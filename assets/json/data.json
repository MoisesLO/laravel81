[
  {
    "titulo": "Empezando",
    "subtitulo": "",
    "items": [
      {
        "titulo": "1.1 Instalación",
        "contenido": "<section>\n  <h1>Instalación</h1>\n  <ul>\n    <li>Instalación\n      <ul>\n        <li>Requisitos del servidor</li>\n        <li>Instalación de Laravel</li>\n        <li>Configuración</li>\n      </ul></li>\n    <li>Configuración del servidor web\n      <ul>\n        <li>Configuración de directorio</li>\n        <li>URL bonitas</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2 id=\"installation\">Instalación</h2>\n  <p></p>\n  <h3 id=\"server-requirements\">Requisitos del servidor</h3>\n  <p>El marco de Laravel tiene algunos requisitos del sistema. La máquina virtual de Laravel Homestead satisface todos estos requisitos , por lo que se recomienda encarecidamente que utilice Homestead como su entorno de desarrollo local de Laravel.</p>\n  <p>Sin embargo, si no está utilizando Homestead, deberá asegurarse de que su servidor cumpla con los siguientes requisitos:</p>\n  <div class=\"content-list\">\n    <ul>\n      <li>PHP&gt; = 7.3</li>\n      <li>Extensión PHP BCMath</li>\n      <li>Extensión PHP Ctype</li>\n      <li>Extensión PHP Fileinfo</li>\n      <li>Extensión PHP JSON</li>\n      <li>Extensión PHP Mbstring</li>\n      <li>Extensión PHP OpenSSL</li>\n      <li>Extensión PHP PDO</li>\n      <li>Extensión PHP Tokenizer</li>\n      <li>Extensión PHP XML</li>\n    </ul>\n  </div>\n  <p></p>\n  <h3 id=\"installing-laravel\">Instalación de Laravel</h3>\n  <p>Laravel utiliza Composer para administrar sus dependencias. Por lo tanto, antes de usar Laravel, asegúrese de tener Composer instalado en su máquina.</p>\n  <h4>A través del instalador de Laravel</h4>\n  <p>Primero, descargue el instalador de Laravel usando Composer:</p>\n  <pre><code>composer global require laravel/installer</code></pre>\n  <p>Asegúrate de colocar el directorio bin del proveedor de todo el sistema de Composer en tu <code>$PATH</code>para que tu sistema pueda localizar el ejecutable de laravel. Este directorio existe en diferentes ubicaciones según su sistema operativo; sin embargo, algunas ubicaciones comunes incluyen:</p>\n  <div class=\"content-list\">\n    <ul>\n      <li>Mac OS: <code>$HOME/.composer/vendor/bin</code></li>\n      <li>Ventanas: <code>%USERPROFILE%\\AppData\\Roaming\\Composer\\vendor\\bin</code></li>\n      <li>Distribuciones GNU / Linux: o<code>$HOME/.config/composer/vendor/bin</code><code>$HOME/.composer/vendor/bin</code></li>\n    </ul>\n  </div>\n  <p>También puede encontrar la ruta de instalación global del compositor ejecutando y mirando hacia arriba desde la primera línea.<code>composer global about</code></p>\n  <p>Una vez instalado, el comando creará una nueva instalación de Laravel en el directorio que especifique. Por ejemplo, creará un directorio llamado que contiene una nueva instalación de Laravel con todas las dependencias de Laravel ya instaladas:<code>laravel new</code><code>laravel new blog</code><code>blog</code></p>\n  <pre><code>laravel new blog</code></pre>\n  <blockquote>\n    <div class=\"callout\"><div class=\"icon purple\"><img src=\"/img/callouts/lightbulb.min.svg\"></div><p class=\"content\">¿Quiere crear un proyecto de Laravel con inicio de sesión, registro y más funciones ya creadas para usted? Echa un vistazo a Laravel Jetstream .</p></div>\n  </blockquote>\n  <h4>A través de Composer Create-Project</h4>\n  <p>Alternativamente, también puede instalar Laravel emitiendo el comando Composer en su terminal:<code>create-project</code></p>\n  <pre><code>composer create-project --prefer-dist laravel/laravel blog</code></pre>\n  <h4>Servidor de desarrollo local</h4>\n  <p>Si tiene PHP instalado localmente y le gustaría usar el servidor de desarrollo integrado de PHP para servir su aplicación, puede usar el <code>serve</code>comando Artisan. Este comando iniciará un servidor de desarrollo en :<code>http://localhost:8000</code></p>\n  <pre><code>php artisan serve</code></pre>\n  <p>Hay opciones de desarrollo local más sólidas disponibles a través de Homestead y Valet .</p>\n  <p></p>\n  <h3 id=\"configuration\">Configuración</h3>\n  <h4>Directorio público</h4>\n  <p>Después de instalar Laravel, debe configurar el documento / raíz web de su servidor web para que sea el <code>public</code>directorio. El en este directorio sirve como el controlador frontal para todas las solicitudes HTTP que ingresan a su aplicación.<code>index.php</code></p>\n  <h4>Archivos de configuración</h4>\n  <p>Todos los archivos de configuración para el marco de Laravel se almacenan en el <code>config</code>directorio. Cada opción está documentada, así que siéntase libre de revisar los archivos y familiarizarse con las opciones disponibles.</p>\n  <h4>Permisos de directorio</h4>\n  <p>Después de instalar Laravel, es posible que deba configurar algunos permisos. Su servidor web debe poder escribir en los directorios dentro de los directorios <code>storage</code>y los directorios o Laravel no se ejecutará. Si está utilizando la máquina virtual de Homestead , estos permisos ya deberían estar configurados.<code>bootstrap/cache</code></p>\n  <h4>Clave de aplicación</h4>\n  <p>Lo siguiente que debe hacer después de instalar Laravel es configurar la clave de su aplicación en una cadena aleatoria. Si instaló Laravel a través de Composer o el instalador de Laravel, esta clave ya se ha configurado para usted mediante el comando.<code>php artisan key:generate</code></p>\n  <p>Normalmente, esta cadena debe tener 32 caracteres. La clave se puede establecer en el <code>.env</code>archivo de entorno. Si no ha copiado el archivo en un archivo nuevo llamado , debe hacerlo ahora. <strong>Si no se establece la clave de la aplicación, sus sesiones de usuario y otros datos cifrados no estarán seguros.</strong><code>.env.example</code><code>.env</code><strong></strong></p>\n  <h4>Configuración adicional</h4>\n  <p>Laravel no necesita casi ninguna otra configuración lista para usar. ¡Eres libre de comenzar a desarrollar! Sin embargo, es posible que desee revisar el archivo y su documentación. Contiene varias opciones como y que quizás desee cambiar de acuerdo con su aplicación.<code>config/app.php</code><code>timezone</code><code>locale</code></p>\n  <p>Es posible que también desee configurar algunos componentes adicionales de Laravel, como:</p>\n  <div>\n    <ul>\n      <li>Cache</li>\n      <li>Base de datos</li>\n      <li>Sesión</li>\n    </ul>\n  </div>\n  <p></p>\n  <h2 id=\"web-server-configuration\">Configuración del servidor web</h2>\n  <p></p>\n  <h3 id=\"directory-configuration\">Configuración de directorio</h3>\n  <p>Laravel siempre debe servirse desde la raíz del \"directorio web\" configurado para su servidor web. No debe intentar servir una aplicación de Laravel desde un subdirectorio del \"directorio web\". Intentar hacerlo podría exponer archivos confidenciales presentes dentro de su aplicación.</p>\n  <p></p>\n  <h3 id=\"pretty-urls\">URL bonitas</h3>\n  <h4>apache</h4>\n  <p>Laravel incluye un archivo que se usa para proporcionar URL sin el controlador frontal en la ruta. Antes de servir Laravel con Apache, asegúrese de habilitar el módulo para que el servidor respete el archivo.<code>public/.htaccess</code><code>index.php</code><code>mod_rewrite</code><code>.htaccess</code></p>\n  <p>Si el <code>.htaccess</code>archivo que viene con Laravel no funciona con su instalación de Apache, pruebe esta alternativa:</p>\n  <pre><code>Options +FollowSymLinks -Indexes<font>\nRewriteEngine On<font>\n<font>\nRewriteCond %{HTTP:Authorization} .\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]<font>\n<font>\nRewriteCond %{REQUEST_FILENAME} !-d<font>\nRewriteCond %{REQUEST_FILENAME} !-f<font>\nRewriteRule ^ index.php [L]</code></pre>\n  <h4>Nginx</h4>\n  <p>Si está utilizando Nginx, la siguiente directiva en la configuración de su sitio dirigirá todas las solicitudes al controlador frontal:<code>index.php</code></p>\n  <pre><code>location / {\n    try_files $uri $uri/ /index.php?$query_string;\n}</code></pre>\n  <p>Al usar Homestead o Valet , se configurarán automáticamente URL bonitas.</p>\n</section>"
      },
      {
        "titulo": "1.2 Configuración",
        "contenido": "<section>\n  <h1>Configuración</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Configuración del entorno\n      <ul>\n        <li>Tipos de variables de entorno</li>\n        <li>Recuperando la configuración del entorno</li>\n        <li>Determinar el entorno actual</li>\n        <li>Ocultar variables de entorno de las páginas de depuración</li>\n      </ul></li>\n    <li>Acceder a los valores de configuración</li>\n    <li>Almacenamiento en caché de configuración</li>\n    <li>Modo de mantenimiento</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Todos los archivos de configuración para el marco de Laravel se almacenan en el <code>config</code>directorio. Cada opción está documentada, así que siéntase libre de revisar los archivos y familiarizarse con las opciones disponibles.</p>\n  <p></p>\n  <h2>Configuración del entorno</h2>\n  <p>A menudo, es útil tener diferentes valores de configuración según el entorno donde se ejecuta la aplicación. Por ejemplo, es posible que desee utilizar localmente un controlador de caché diferente al que utiliza en su servidor de producción.</p>\n  <p>Para que esto sea muy sencillo, Laravel utiliza la biblioteca PHP DotEnv de Vance Lucas. En una nueva instalación de Laravel, el directorio raíz de su aplicación contendrá un archivo. Si instala Laravel a través de Composer, este archivo se copiará automáticamente . De lo contrario, debe copiar el archivo manualmente.<code>.env.example</code><code>.env</code></p>\n  <p>Su <code>.env</code>archivo no debe estar comprometido con el control de código fuente de su aplicación, ya que cada desarrollador / servidor que use su aplicación podría requerir una configuración de entorno diferente. Además, esto sería un riesgo de seguridad en caso de que un intruso obtenga acceso a su repositorio de control de fuente, ya que cualquier credencial confidencial quedaría expuesta.</p>\n  <p>Si está desarrollando con un equipo, es posible que desee continuar incluyendo un archivo con su aplicación. Al colocar valores de marcador de posición en el archivo de configuración de ejemplo, otros desarrolladores de su equipo pueden ver claramente qué variables de entorno son necesarias para ejecutar su aplicación. También puede crear un archivo. Este archivo anulará el archivo al ejecutar pruebas PHPUnit o ejecutar comandos Artisan con la opción.<code>.env.example</code><code>.env.testing</code><code>.env</code><code>--env=testing</code></p>\n  <blockquote>\n    <p>Cualquier variable de su <code>.env</code>archivo puede ser anulada por variables de entorno externas, como variables de entorno a nivel de servidor o de sistema.</p>\n  </blockquote>\n  <p></p>\n  <h3>Tipos de variables de entorno</h3>\n  <p>Todas las variables de sus <code>.env</code>archivos se analizan como cadenas, por lo que se han creado algunos valores reservados para permitirle devolver una gama más amplia de tipos de la función:<code>env()</code></p>\n  <table>\n    <thead>\n    <tr>\n      <th><code>.env</code> Valor</th>\n      <th><code>env()</code> Valor</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td>cierto</td>\n      <td>(bool) cierto</td>\n    </tr>\n    <tr>\n      <td>(cierto)</td>\n      <td>(bool) cierto</td>\n    </tr>\n    <tr>\n      <td>falso</td>\n      <td>(bool) falso</td>\n    </tr>\n    <tr>\n      <td>(falso)</td>\n      <td>(bool) falso</td>\n    </tr>\n    <tr>\n      <td>vacío</td>\n      <td>(cuerda) ''</td>\n    </tr>\n    <tr>\n      <td>(vacío)</td>\n      <td>(cuerda) ''</td>\n    </tr>\n    <tr>\n      <td>nulo</td>\n      <td>(nulo) nulo</td>\n    </tr>\n    <tr>\n      <td>(nulo)</td>\n      <td>(nulo) nulo</td>\n    </tr>\n    </tbody>\n  </table>\n  <p>Si necesita definir una variable de entorno con un valor que contenga espacios, puede hacerlo encerrando el valor entre comillas dobles.</p>\n  <pre><code>APP_NAME=\"My Application\"</code></pre>\n  <p></p>\n  <h3>Recuperando la configuración del entorno</h3>\n  <p>Todas las variables enumeradas en este archivo se cargarán en <code>$_ENV</code>PHP super-global cuando su aplicación reciba una solicitud. Sin embargo, puede usar el <code>env</code>asistente para recuperar valores de estas variables en sus archivos de configuración. De hecho, si revisa los archivos de configuración de Laravel, notará que varias de las opciones ya usan este ayudante:</p>\n  <pre><code>'debug' =&gt; env('APP_DEBUG', false),</code></pre>\n  <p>El segundo valor pasado a la <code>env</code>función es el \"valor predeterminado\". Este valor se utilizará si no existe una variable de entorno para la clave dada.</p>\n  <p></p>\n  <h3>Determinar el entorno actual</h3>\n  <p>El entorno actual de la aplicación se determina mediante la <code>APP_ENV</code>variable de su <code>.env</code>archivo. Puede acceder a este valor a través del <code>environment</code>método en la <code>App</code> fachada :</p>\n  <pre><code>$environment = App::environment();</code></pre>\n  <p>También puede pasar argumentos al <code>environment</code>método para verificar si el entorno coincide con un valor dado. El método devolverá <code>true</code>si el entorno coincide con alguno de los valores dados:</p>\n  <pre><code>if (App::environment('local')) {\n    // The environment is local\n}\n\nif (App::environment(['local', 'staging'])) {\n    // The environment is either local OR staging...\n}</code></pre>\n  <blockquote>\n    <p>La detección del entorno de la aplicación actual se puede anular mediante una <code>APP_ENV</code>variable de entorno a nivel de servidor . Esto puede ser útil cuando necesita compartir la misma aplicación para diferentes configuraciones de entorno, por lo que puede configurar un host determinado para que coincida con un entorno determinado en las configuraciones de su servidor.</p>\n  </blockquote>\n  <p></p>\n  <h3>Ocultar variables de entorno de las páginas de depuración</h3>\n  <p>Cuando no se detecta una excepción y la <code>APP_DEBUG</code>variable de entorno sí <code>true</code>, la página de depuración mostrará todas las variables de entorno y su contenido. En algunos casos, es posible que desee ocultar ciertas variables. Puede hacer esto actualizando la <code>debug_hide</code>opción en su archivo de configuración.<code>config/app.php</code></p>\n  <p>Algunas variables están disponibles tanto en las variables de entorno como en los datos del servidor / solicitud. Por lo tanto, es posible que deba ocultarlos para ambos <code>$_ENV</code>y <code>$_SERVER</code>:</p>\n  <pre><code>return [\n\n    // ...\n\n    'debug_hide' =&gt; [\n        '_ENV' =&gt; [\n            'APP_KEY',\n            'DB_PASSWORD',\n        ],\n\n        '_SERVER' =&gt; [\n            'APP_KEY',\n            'DB_PASSWORD',\n        ],\n\n        '_POST' =&gt; [\n            'password',\n        ],\n    ],\n];</code></pre>\n  <p></p>\n  <h2>Acceder a los valores de configuración</h2>\n  <p>Puede acceder fácilmente a sus valores de configuración utilizando la <code>config</code>función de ayuda global desde cualquier lugar de su aplicación. Se puede acceder a los valores de configuración utilizando la sintaxis de \"punto\", que incluye el nombre del archivo y la opción a la que desea acceder. También se puede especificar un valor predeterminado y se devolverá si la opción de configuración no existe:</p>\n  <pre><code>$value = config('app.timezone');\n\n// Retrieve a default value if the configuration value does not exist...\n$value = config('app.timezone', 'Asia/Seoul');</code></pre>\n  <p>Para establecer valores de configuración en tiempo de ejecución, pase una matriz al <code>config</code>asistente:</p>\n  <pre><code>config(['app.timezone' =&gt; 'America/Chicago']);</code></pre>\n  <p></p>\n  <h2>Almacenamiento en caché de configuración</h2>\n  <p>Para aumentar la velocidad de su aplicación, debe almacenar en caché todos sus archivos de configuración en un solo archivo usando el comando Artisan. Esto combinará todas las opciones de configuración para su aplicación en un solo archivo que será cargado rápidamente por el marco.<code>config:cache</code></p>\n  <p>Por lo general, debe ejecutar el comando como parte de su rutina de implementación de producción. El comando no debe ejecutarse durante el desarrollo local, ya que las opciones de configuración con frecuencia deberán cambiarse durante el curso del desarrollo de su aplicación.<code>php artisan config:cache</code></p>\n  <blockquote>\n    <p>Si ejecuta el comando durante su proceso de implementación, debe asegurarse de que solo está llamando a la función desde sus archivos de configuración. Una vez que la configuración se haya almacenado en caché, el archivo no se cargará y todas las llamadas a la función volverán .<code>config:cache</code><code>env</code><code>.env</code><code>env</code><code>null</code></p>\n  </blockquote>\n  <p></p>\n  <h2>Modo de mantenimiento</h2>\n  <p>Cuando su aplicación está en modo de mantenimiento, se mostrará una vista personalizada para todas las solicitudes en su aplicación. Esto facilita la \"desactivación\" de la aplicación mientras se actualiza o cuando se realiza el mantenimiento. Se incluye una verificación del modo de mantenimiento en la pila de middleware predeterminada para su aplicación. Si la aplicación está en modo de mantenimiento, se <code>MaintenanceModeException</code>lanzará un código de estado de 503.</p>\n  <p>Para habilitar el modo de mantenimiento, ejecute el <code>down</code>comando Artisan:</p>\n  <pre><code>php artisan down</code></pre>\n  <p>También puede proporcionar una <code>retry</code>opción al <code>down</code>comando, que se establecerá como el valor del encabezado HTTP:<code>Retry-After</code></p>\n  <pre><code>php artisan down --retry=60</code></pre>\n  <h4>Omitir el modo de mantenimiento</h4>\n  <p>Incluso en el modo de mantenimiento, puede usar la <code>secret</code>opción para especificar un token de omisión del modo de mantenimiento:</p>\n  <pre><code>php artisan down --secret=\"1630542a-246b-4b66-afa1-dd72a4c43515\"</code></pre>\n  <p>Después de colocar la aplicación en modo de mantenimiento, puede navegar a la URL de la aplicación que coincide con este token y Laravel emitirá una cookie de omisión del modo de mantenimiento a su navegador:</p>\n  <pre><code>https://example.com/1630542a-246b-4b66-afa1-dd72a4c43515</code></pre>\n  <p>Al acceder a esta ruta oculta, será redirigido a la <code>/</code>ruta de la aplicación. Una vez que la cookie haya sido enviada a su navegador, podrá navegar por la aplicación normalmente como si no estuviera en modo de mantenimiento.</p>\n  <h4>Renderizado previo de la vista del modo de mantenimiento</h4>\n  <p>Si utiliza el <code>php artisan down</code>comando durante la implementación, sus usuarios aún pueden encontrar errores ocasionalmente si acceden a la aplicación mientras se actualizan las dependencias de Composer u otros componentes de la infraestructura. Esto ocurre porque una parte importante del marco de Laravel debe iniciarse para determinar que su aplicación está en modo de mantenimiento y representar la vista del modo de mantenimiento utilizando el motor de plantillas.</p>\n  <p>Por esta razón, Laravel le permite pre-renderizar una vista en modo de mantenimiento que será devuelta al comienzo del ciclo de solicitud. Esta vista se representa antes de que se haya cargado cualquiera de las dependencias de su aplicación. Puede pre-renderizar una plantilla de su elección usando la opción <code>down</code>del comando <code>render</code>:</p>\n  <pre><code>php artisan down --render=\"errors::503\"</code></pre>\n  <h4>Redirigir solicitudes de modo de mantenimiento</h4>\n  <p>Mientras está en modo de mantenimiento, Laravel mostrará la vista del modo de mantenimiento para todas las URL de la aplicación a las que el usuario intenta acceder. Si lo desea, puede indicar a Laravel que redirija todas las solicitudes a una URL específica. Esto se puede lograr usando la <code>redirect</code>opción. Por ejemplo, es posible que desee redirigir todas las solicitudes al <code>/</code>URI:</p>\n  <pre><code>php artisan down --redirect=/</code></pre>\n  <h4>Desactivación del modo de mantenimiento</h4>\n  <p>Para deshabilitar el modo de mantenimiento, use el <code>up</code>comando:</p>\n  <pre><code>php artisan up</code></pre>\n  <blockquote>\n    <p>Puede personalizar la plantilla de modo de mantenimiento predeterminada definiendo su propia plantilla en .<code>resources/views/errors/503.blade.php</code></p>\n  </blockquote>\n  <h4>Modo de mantenimiento y colas</h4>\n  <p>Mientras su aplicación esté en modo de mantenimiento, no se manejarán trabajos en cola . Los trabajos continuarán manejándose normalmente una vez que la aplicación esté fuera del modo de mantenimiento.</p>\n  <h4>Alternativas al modo de mantenimiento</h4>\n  <p>Dado que el modo de mantenimiento requiere que su aplicación tenga varios segundos de tiempo de inactividad, considere alternativas como Envoyer para lograr una implementación sin tiempo de inactividad con Laravel.</p>\n</section>"
      },
      {
        "titulo": "1.3 Estructura de directorios",
        "contenido": "<section>\n  <h1>Estructura de directorios</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>El directorio raíz\n      <ul>\n        <li>El <code>app</code>directorio</li>\n        <li>El <code>bootstrap</code>directorio</li>\n        <li>El <code>config</code>directorio</li>\n        <li>El <code>database</code>directorio</li>\n        <li>El <code>public</code>directorio</li>\n        <li>El <code>resources</code>directorio</li>\n        <li>El <code>routes</code>directorio</li>\n        <li>El <code>storage</code>directorio</li>\n        <li>El <code>tests</code>directorio</li>\n        <li>El <code>vendor</code>directorio</li>\n      </ul></li>\n    <li>El directorio de aplicaciones\n      <ul>\n        <li>El <code>Broadcasting</code>directorio</li>\n        <li>El <code>Console</code>directorio</li>\n        <li>El <code>Events</code>directorio</li>\n        <li>El <code>Exceptions</code>directorio</li>\n        <li>El <code>Http</code>directorio</li>\n        <li>El <code>Jobs</code>directorio</li>\n        <li>El <code>Listeners</code>directorio</li>\n        <li>El <code>Mail</code>directorio</li>\n        <li>El <code>Models</code>directorio</li>\n        <li>El <code>Notifications</code>directorio</li>\n        <li>El <code>Policies</code>directorio</li>\n        <li>El <code>Providers</code>directorio</li>\n        <li>El <code>Rules</code>directorio</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>La estructura predeterminada de la aplicación Laravel está destinada a proporcionar un excelente punto de partida para aplicaciones grandes y pequeñas. Pero eres libre de organizar tu aplicación como quieras. Laravel casi no impone restricciones sobre dónde se encuentra una clase determinada, siempre que Composer pueda cargar automáticamente la clase.</p>\n  <p></p>\n  <h2>El directorio raíz</h2>\n  <p></p>\n  <h4>El directorio de aplicaciones</h4>\n  <p>El <code>app</code>directorio contiene el código central de su aplicación. Exploraremos este directorio con más detalle pronto; sin embargo, casi todas las clases de su aplicación estarán en este directorio.</p>\n  <p></p>\n  <h4>El directorio de Bootstrap</h4>\n  <p>El <code>bootstrap</code>directorio contiene el archivo que inicia el marco. Este directorio también alberga un directorio que contiene archivos generados por el marco para la optimización del rendimiento, como los archivos de caché de rutas y servicios.<code>app.php</code><code>cache</code></p>\n  <p></p>\n  <h4>El directorio de configuración</h4>\n  <p>El <code>config</code>directorio, como su nombre lo indica, contiene todos los archivos de configuración de su aplicación. Es una gran idea leer todos estos archivos y familiarizarse con todas las opciones disponibles.</p>\n  <p></p>\n  <h4>El directorio de la base de datos</h4>\n  <p>El <code>database</code>directorio contiene sus migraciones de base de datos, fábricas de modelos y semillas. Si lo desea, también puede utilizar este directorio para almacenar una base de datos SQLite.</p>\n  <p></p>\n  <h4>El directorio público</h4>\n  <p>El <code>public</code>directorio contiene el archivo, que es el punto de entrada para todas las solicitudes que ingresan a su aplicación y configura la carga automática. Este directorio también alberga sus activos, como imágenes, JavaScript y CSS.<code>index.php</code></p>\n  <p></p>\n  <h4>El directorio de recursos</h4>\n  <p>El <code>resources</code>directorio contiene sus vistas, así como sus activos sin procesar y no compilados, como LESS, SASS o JavaScript. Este directorio también aloja todos sus archivos de idioma.</p>\n  <p></p>\n  <h4>El directorio de rutas</h4>\n  <p>El <code>routes</code>directorio contiene todas las definiciones de ruta para su aplicación. Por defecto, varios archivos de ruta se incluyen con laravel: , , y .<code>web.php</code><code>api.php</code><code>console.php</code><code>channels.php</code></p>\n  <p>El archivo contiene rutas que coloca en el grupo de middleware, que proporciona el estado de la sesión, la protección CSRF y el cifrado de cookies. Si su aplicación no ofrece una API RESTful sin estado, es muy probable que todas sus rutas estén definidas en el archivo.<code>web.php</code><code>RouteServiceProvider</code><code>web</code><code>web.php</code></p>\n  <p>El archivo contiene rutas que coloca en el grupo de middleware, lo que proporciona limitación de velocidad. Estas rutas están destinadas a ser sin estado, por lo que las solicitudes que ingresan a la aplicación a través de estas rutas deben autenticarse mediante tokens y no tendrán acceso al estado de la sesión.<code>api.php</code><code>RouteServiceProvider</code><code>api</code></p>\n  <p>El archivo es donde puede definir todos sus comandos de consola basados \u200B\u200Ben Closure. Cada cierre está vinculado a una instancia de comando que permite un enfoque simple para interactuar con los métodos de E / S de cada comando. Aunque este archivo no define rutas HTTP, define puntos de entrada (rutas) basados \u200B\u200Ben consola en su aplicación.<code>console.php</code></p>\n  <p>El archivo es donde puede registrar todos los canales de transmisión de eventos que admite su aplicación.<code>channels.php</code></p>\n  <p></p>\n  <h4>El directorio de almacenamiento</h4>\n  <p>El <code>storage</code>directorio contiene sus plantillas Blade compiladas, sesiones basadas en archivos, cachés de archivos y otros archivos generados por el marco. Este directorio es segregada en <code>app</code>, <code>framework</code>y <code>logs</code>directorios. El <code>app</code>directorio puede usarse para almacenar cualquier archivo generado por su aplicación. El <code>framework</code>directorio se utiliza para almacenar cachés y archivos generados por el framework. Finalmente, el <code>logs</code>directorio contiene los archivos de registro de su aplicación.</p>\n  <p>El directorio se puede utilizar para almacenar archivos generados por el usuario, como los avatares de perfil, que deberían ser de acceso público. Debe crear un enlace simbólico en el que apunte a este directorio. Puede crear el enlace usando el comando.<code>storage/app/public</code><code>public/storage</code><code>php artisan storage:link</code></p>\n  <p></p>\n  <h4>El directorio de pruebas</h4>\n  <p>El <code>tests</code>directorio contiene sus pruebas automatizadas. Se proporciona un ejemplo de prueba PHPUnit lista para usar . Cada clase de prueba debe tener el sufijo de la palabra <code>Test</code>. Puede ejecutar sus pruebas usando los comandos <code>phpunit</code>o .<code>php vendor/bin/phpunit</code></p>\n  <p></p>\n  <h4>El directorio de proveedores</h4>\n  <p>El <code>vendor</code>directorio contiene sus dependencias de Composer .</p>\n  <p></p>\n  <h2>El directorio de aplicaciones</h2>\n  <p>La mayor parte de su aplicación se encuentra en el <code>app</code>directorio. De forma predeterminada, este directorio tiene un espacio de nombres debajo <code>App</code>y Composer lo carga automáticamente utilizando el estándar de carga automática PSR-4 .</p>\n  <p>El <code>app</code>directorio contiene una variedad de directorios adicionales, tales como <code>Console</code>, <code>Http</code>, y <code>Providers</code>. Piense en los directorios <code>Console</code>y <code>Http</code>como una API en el núcleo de su aplicación. El protocolo HTTP y la CLI son mecanismos para interactuar con su aplicación, pero en realidad no contienen lógica de la aplicación. En otras palabras, son dos formas de enviar comandos a su aplicación. El <code>Console</code>directorio contiene todos sus comandos Artisan, mientras que el <code>Http</code>directorio contiene sus controladores, middleware y solicitudes.</p>\n  <p>Una variedad de otros directorios se generarán dentro del <code>app</code>directorio a medida que use los <code>make</code>comandos Artisan para generar clases. Entonces, por ejemplo, el directorio no existirá hasta que ejecute el comando Artisan para generar una clase de trabajo.<code>app/Jobs</code><code>make:job</code></p>\n  <blockquote>\n    <p><code>app</code>Artisan puede generar muchas de las clases en el directorio mediante comandos. Para revisar los comandos disponibles, ejecute el comando en su terminal.<code>php artisan list make</code></p>\n  </blockquote>\n  <p></p>\n  <h4>El directorio de radiodifusión</h4>\n  <p>El <code>Broadcasting</code>directorio contiene todas las clases de canales de transmisión para su aplicación. Estas clases se generan usando el comando. Este directorio no existe de forma predeterminada, pero se creará cuando cree su primer canal. Para obtener más información sobre los canales, consulte la documentación sobre la transmisión de eventos .<code>make:channel</code></p>\n  <p></p>\n  <h4>El directorio de la consola</h4>\n  <p>El <code>Console</code>directorio contiene todos los comandos Artisan personalizados para su aplicación. Estos comandos se pueden generar usando el comando. Este directorio también aloja el kernel de su consola, que es donde se registran sus comandos Artisan personalizados y se definen sus tareas programadas .<code>make:command</code></p>\n  <p></p>\n  <h4>El directorio de eventos</h4>\n  <p>Este directorio no existe de forma predeterminada, pero lo crearán los comandos y Artisan. El directorio alberga clases de eventos . Los eventos pueden usarse para alertar a otras partes de su aplicación de que se ha producido una acción determinada, lo que proporciona una gran flexibilidad y desacoplamiento.<code>event:generate</code><code>make:event</code><code>Events</code></p>\n  <p></p>\n  <h4>El directorio de excepciones</h4>\n  <p>El <code>Exceptions</code>directorio contiene el controlador de excepciones de su aplicación y también es un buen lugar para colocar cualquier excepción lanzada por su aplicación. Si desea personalizar cómo se registran o representan sus excepciones, debe modificar la <code>Handler</code>clase en este directorio.</p>\n  <p></p>\n  <h4>El directorio Http</h4>\n  <p>El <code>Http</code>directorio contiene sus controladores, middleware y solicitudes de formulario. Casi toda la lógica para manejar las solicitudes que ingresan a su aplicación se colocará en este directorio.</p>\n  <p></p>\n  <h4>El directorio de trabajos</h4>\n  <p>Este directorio no existe de forma predeterminada, pero se creará automáticamente si ejecuta el comando Artisan. El directorio contiene los trabajos que se pueden poner en cola para su aplicación. Su aplicación puede poner los trabajos en cola o ejecutarse sincrónicamente dentro del ciclo de vida de la solicitud actual. Los trabajos que se ejecutan sincrónicamente durante la solicitud actual a veces se denominan \"comandos\", ya que son una implementación del patrón de comando .<code>make:job</code><code>Jobs</code></p>\n  <p></p>\n  <h4>El directorio de oyentes</h4>\n  <p>Este directorio no existe de forma predeterminada, pero se creará automáticamente si ejecuta los comandos o Artisan. El directorio contiene las clases que manejan sus eventos . Los oyentes de eventos reciben una instancia de evento y realizan la lógica en respuesta al evento que se dispara. Por ejemplo, un evento puede ser manejado por un oyente.<code>event:generate</code><code>make:listener</code><code>Listeners</code><code>UserRegistered</code><code>SendWelcomeEmail</code></p>\n  <p></p>\n  <h4>El directorio de correo</h4>\n  <p>Este directorio no existe de forma predeterminada, pero se creará automáticamente si ejecuta el comando Artisan. El directorio contiene todas sus clases que representan los correos electrónicos enviados por su aplicación. Los objetos de correo le permiten encapsular toda la lógica de crear un correo electrónico en una sola clase simple que se puede enviar mediante el método.<code>make:mail</code><code>Mail</code><code>Mail::send</code></p>\n  <p></p>\n  <h4>El directorio de modelos</h4>\n  <p>El <code>Models</code>directorio contiene todas sus clases de modelo Eloquent. El ORM Eloquent incluido con Laravel proporciona una implementación de ActiveRecord hermosa y simple para trabajar con su base de datos. Cada tabla de la base de datos tiene un \"Modelo\" correspondiente que se utiliza para interactuar con esa tabla. Los modelos le permiten consultar datos en sus tablas, así como insertar nuevos registros en la tabla.</p>\n  <p></p>\n  <h4>El directorio de notificaciones</h4>\n  <p>Este directorio no existe de forma predeterminada, pero se creará automáticamente si ejecuta el comando Artisan. El directorio contiene todas las notificaciones \"transaccionales\" que envía su aplicación, como notificaciones simples sobre eventos que suceden dentro de su aplicación. La notificación de Laravel presenta resúmenes de envío de notificaciones a través de una variedad de controladores como correo electrónico, Slack, SMS o almacenados en una base de datos.<code>make:notification</code><code>Notifications</code></p>\n  <p></p>\n  <h4>El directorio de políticas</h4>\n  <p>Este directorio no existe de forma predeterminada, pero se creará automáticamente si ejecuta el comando Artisan. El directorio contiene las clases de políticas de autorización para su aplicación. Las políticas se utilizan para determinar si un usuario puede realizar una acción determinada contra un recurso. Para obtener más información, consulte la documentación de autorización .<code>make:policy</code><code>Policies</code></p>\n  <p></p>\n  <h4>El directorio de proveedores</h4>\n  <p>El <code>Providers</code>directorio contiene todos los proveedores de servicios para su aplicación. Los proveedores de servicios inician su aplicación vinculando servicios en el contenedor de servicios, registrando eventos o realizando cualquier otra tarea para preparar su aplicación para las solicitudes entrantes.</p>\n  <p>En una nueva aplicación de Laravel, este directorio ya contendrá varios proveedores. Puede agregar sus propios proveedores a este directorio según sea necesario.</p>\n  <p></p>\n  <h4>El directorio de reglas</h4>\n  <p>Este directorio no existe de forma predeterminada, pero se creará automáticamente si ejecuta el comando Artisan. El directorio contiene los objetos de regla de validación personalizados para su aplicación. Las reglas se utilizan para encapsular una lógica de validación complicada en un objeto simple. Para obtener más información, consulte la documentación de validación .<code>make:rule</code><code>Rules</code></p>\n</section>"
      },
      {
        "titulo": "1.4 Despliegue",
        "contenido": "<section>\n  <h1>Despliegue</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Configuración del servidor\n      <ul>\n        <li>Nginx</li>\n      </ul></li>\n    <li>Mejoramiento\n      <ul>\n        <li>Optimización del cargador automático</li>\n        <li>Optimización de la carga de configuración</li>\n        <li>Optimización de la carga de ruta</li>\n        <li>Optimización de la carga de vistas</li>\n      </ul></li>\n    <li>Implementar con Forge / Vapor</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Cuando esté listo para implementar su aplicación Laravel en producción, hay algunas cosas importantes que puede hacer para asegurarse de que su aplicación se esté ejecutando de la manera más eficiente posible. En este documento, cubriremos algunos puntos de partida excelentes para asegurarnos de que su aplicación Laravel se implemente correctamente.</p>\n  <p></p>\n  <h2>Configuración del servidor</h2>\n  <p></p>\n  <h3>Nginx</h3>\n  <p>Si está implementando su aplicación en un servidor que ejecuta Nginx, puede usar el siguiente archivo de configuración como punto de partida para configurar su servidor web. Lo más probable es que este archivo deba personalizarse según la configuración de su servidor. Si desea ayuda para administrar su servidor, considere usar un servicio como Laravel Forge :</p>\n  <pre><code>server {\n    listen 80;\n    server_name example.com;\n    root /srv/example.com/public;\n\n    add_header X-Frame-Options \"SAMEORIGIN\";\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header X-Content-Type-Options \"nosniff\";\n\n    index index.php;\n\n    charset utf-8;\n\n    location / {\n        try_files $uri $uri/ /index.php?$query_string;\n    }\n\n    location = /favicon.ico { access_log off; log_not_found off; }\n    location = /robots.txt  { access_log off; log_not_found off; }\n\n    error_page 404 /index.php;\n\n    location ~ \\.php$ {\n        fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;\n        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;\n        include fastcgi_params;\n    }\n\n    location ~ /\\.(?!well-known).* {\n        deny all;\n    }\n}</code></pre>\n  <p></p>\n  <h2>Mejoramiento</h2>\n  <p></p>\n  <h3>Optimización del cargador automático</h3>\n  <p>Al implementar en producción, asegúrese de que está optimizando el mapa del cargador automático de clases de Composer para que Composer pueda encontrar rápidamente el archivo adecuado para cargar para una clase determinada:</p>\n  <pre><code>composer install --optimize-autoloader --no-dev</code></pre>\n  <blockquote>\n    <p>Además de optimizar el autocargador, siempre debe asegurarse de incluir un archivo en el repositorio de control de código fuente de su proyecto. Las dependencias de su proyecto se pueden instalar mucho más rápido cuando hay un archivo presente.<code>composer.lock</code><code>composer.lock</code></p>\n  </blockquote>\n  <p></p>\n  <h3>Optimización de la carga de configuración</h3>\n  <p>Al implementar su aplicación en producción, debe asegurarse de ejecutar el comando Artisan durante su proceso de implementación:<code>config:cache</code></p>\n  <pre><code>php artisan config:cache</code></pre>\n  <p>Este comando combinará todos los archivos de configuración de Laravel en un solo archivo en caché, lo que reduce en gran medida la cantidad de viajes que el marco debe hacer al sistema de archivos al cargar sus valores de configuración.</p>\n  <blockquote>\n    <p>Si ejecuta el comando durante su proceso de implementación, debe asegurarse de que solo está llamando a la función desde sus archivos de configuración. Una vez que la configuración se haya almacenado en caché, el archivo no se cargará y todas las llamadas a la función volverán .<code>config:cache</code><code>env</code><code>.env</code><code>env</code><code>null</code></p>\n  </blockquote>\n  <p></p>\n  <h3>Optimización de la carga de ruta</h3>\n  <p>Si está creando una aplicación grande con muchas rutas, debe asegurarse de ejecutar el comando Artisan durante su proceso de implementación:<code>route:cache</code></p>\n  <pre><code>php artisan route:cache</code></pre>\n  <p>Este comando reduce todos sus registros de ruta en una única llamada de método dentro de un archivo en caché, mejorando el rendimiento del registro de ruta al registrar cientos de rutas.</p>\n  <p></p>\n  <h3>Optimización de la carga de v1istas</h3>\n  <p>Al implementar su aplicación en producción, debe asegurarse de ejecutar el comando Artisan durante su proceso de implementación:<code>view:cache</code></p>\n  <pre><code>php artisan view:cache</code></pre>\n  <p>Este comando precompila todas sus vistas de Blade para que no se compilen bajo demanda, mejorando el rendimiento de cada solicitud que devuelve una vista.</p>\n  <p></p>\n  <h2>Implementar con Forge / Vapor</h2>\n  <p>Si no está listo para administrar la configuración de su propio servidor o no se siente cómodo configurando todos los servicios necesarios para ejecutar una aplicación Laravel robusta, Laravel Forge es una alternativa maravillosa.</p>\n  <p>Laravel Forge puede crear servidores en varios proveedores de infraestructura como DigitalOcean, Linode, AWS y más. Además, Forge instala y administra todas las herramientas necesarias para crear aplicaciones robustas de Laravel, como Nginx, MySQL, Redis, Memcached, Beanstalk y más.</p>\n  <h4>Vapor de Laravel</h4>\n  <p>Si desea una plataforma de implementación de escalado automático totalmente sin servidor ajustada para Laravel, consulte Laravel Vapor . Laravel Vapor es una plataforma de implementación sin servidor para Laravel, impulsada por AWS. Lanza tu infraestructura Laravel en Vapor y enamórate de la simplicidad escalable de la tecnología sin servidor. Laravel Vapor está ajustado por los creadores de Laravel para que funcione a la perfección con el marco para que pueda seguir escribiendo sus aplicaciones de Laravel exactamente como está acostumbrado.</p>\n</section>"
      }
    ]
  },
  {
    "titulo": "Arquitectura de laravel",
    "subtitulo": "",
    "items": [
      {
        "titulo": "2.1 Solicitar ciclo de vida",
        "contenido": "<section>\n  <h1>Solicitar ciclo de vida</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Resumen del ciclo de vida</li>\n    <li>Centrarse en los proveedores de servicios</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Cuando usa cualquier herramienta en el \"mundo real\", se siente más seguro si comprende cómo funciona esa herramienta. El desarrollo de aplicaciones no es diferente. Cuando comprenda cómo funcionan sus herramientas de desarrollo, se sentirá más cómodo y seguro al usarlas.</p>\n  <p>El objetivo de este documento es brindarle una buena descripción general de alto nivel de cómo funciona el marco de Laravel. Al conocer mejor el marco general, todo se siente menos \"mágico\" y tendrá más confianza en la construcción de sus aplicaciones. Si no comprende todos los términos de inmediato, ¡no se desanime! Solo intente obtener una comprensión básica de lo que está sucediendo, y su conocimiento crecerá a medida que explore otras secciones de la documentación.</p>\n  <p></p>\n  <h2>Resumen del ciclo de vida</h2>\n  <h3>Primeras cosas</h3>\n  <p>El punto de entrada para todas las solicitudes a una aplicación de Laravel es el archivo. Todas las solicitudes son dirigidas a este archivo por la configuración de su servidor web (Apache / Nginx). El archivo no contiene mucho código. Más bien, es un punto de partida para cargar el resto del marco.<code>public/index.php</code><code>index.php</code></p>\n  <p>El archivo carga la definición de autocargador generada por Composer y luego recupera una instancia de la aplicación Laravel del script. La primera acción realizada por Laravel es crear una instancia del contenedor de la aplicación / servicio .<code>index.php</code><code>bootstrap/app.php</code></p>\n  <h3>Núcleos HTTP / Consola</h3>\n  <p>A continuación, la solicitud entrante se envía al kernel HTTP o al kernel de la consola, según el tipo de solicitud que ingresa a la aplicación. Estos dos núcleos sirven como la ubicación central por donde fluyen todas las solicitudes. Por ahora, centrémonos en el kernel HTTP, que se encuentra en .<code>app/Http/Kernel.php</code></p>\n  <p>El kernel HTTP extiende la clase, que define una matriz que se ejecutará antes de que se ejecute la solicitud. Estos bootstrappers configuran el manejo de errores, configuran el registro, detectan el entorno de la aplicación y realizan otras tareas que deben realizarse antes de que la solicitud se maneje realmente.<code>Illuminate\\Foundation\\Http\\Kernel</code><code>bootstrappers</code></p>\n  <p>El kernel HTTP también define una lista de middleware HTTP por el que deben pasar todas las solicitudes antes de ser manejadas por la aplicación. Estos middleware manejan la lectura y escritura de la sesión HTTP , determinando si la aplicación está en modo de mantenimiento, verificando el token CSRF y más.</p>\n  <p>La firma del método para el <code>handle</code>método del kernel HTTP es bastante simple: recibe un <code>Request</code>y devuelve un <code>Response</code>. Piense en el Kernel como una gran caja negra que representa toda su aplicación. Aliméntelo con solicitudes HTTP y devolverá respuestas HTTP.</p>\n  <h4>Proveedores de servicio</h4>\n  <p>Una de las acciones de arranque del kernel más importantes es cargar los proveedores de servicios para su aplicación. Todos los proveedores de servicios para la aplicación están configurados en la matriz del archivo de configuración . Primero, se llamará al método a todos los proveedores, luego, una vez que todos los proveedores se hayan registrado, se llamará al método.<code>config/app.php</code><code>providers</code><code>register</code><code>boot</code></p>\n  <p>Los proveedores de servicios son responsables de arrancar todos los componentes del marco, como la base de datos, la cola, la validación y los componentes de enrutamiento. Dado que arrancan y configuran todas las funciones que ofrece el marco, los proveedores de servicios son el aspecto más importante de todo el proceso de arranque de Laravel.</p>\n  <h4>Solicitud de envío</h4>\n  <p>Una vez que se haya iniciado la aplicación y se hayan registrado todos los proveedores de servicios, <code>Request</code>se entregarán al enrutador para su envío. El enrutador enviará la solicitud a una ruta o controlador, así como ejecutará cualquier middleware específico de ruta.</p>\n  <p></p>\n  <h2>Centrarse en los proveedores de servicios</h2>\n  <p>Los proveedores de servicios son realmente la clave para iniciar una aplicación Laravel. Se crea la instancia de la aplicación, se registran los proveedores de servicios y se entrega la solicitud a la aplicación de arranque. ¡Es realmente así de simple!</p>\n  <p>Tener un conocimiento firme de cómo se construye y arranca una aplicación de Laravel a través de proveedores de servicios es muy valioso. Los proveedores de servicios predeterminados de su aplicación se almacenan en el directorio.<code>app/Providers</code></p>\n  <p>De forma predeterminada, <code>AppServiceProvider</code>está bastante vacío. Este proveedor es un gran lugar para agregar los enlaces de contenedores de servicio y arranque de su propia aplicación. Para aplicaciones grandes, es posible que desee crear varios proveedores de servicios, cada uno con un tipo de arranque más granular.</p>\n</section>"
      },
      {
        "titulo": "2.2 Contenedor de servicio",
        "contenido": "<section>\n  <h1>Contenedor de servicio</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Unión\n      <ul>\n        <li>Conceptos básicos de encuadernación</li>\n        <li>Vinculación de interfaces a implementaciones</li>\n        <li>Enlace contextual</li>\n        <li>Primitivas vinculantes</li>\n        <li>Vinculación de Variadics con tipo</li>\n        <li>Etiquetado</li>\n        <li>Ampliación de enlaces</li>\n      </ul></li>\n    <li>Resolviendo\n      <ul>\n        <li>El método Make</li>\n        <li>Inyección automática</li>\n      </ul></li>\n    <li>Eventos de contenedores</li>\n    <li>PSR-11</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>El contenedor de servicios de Laravel es una herramienta poderosa para administrar las dependencias de clases y realizar la inyección de dependencias. La inyección de dependencia es una frase elegante que esencialmente significa esto: las dependencias de clase se \"inyectan\" en la clase a través del constructor o, en algunos casos, los métodos \"setter\".</p>\n  <p>Veamos un ejemplo simple:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Http\\Controllers;\n\n    use App\\Http\\Controllers\\Controller;\n    use App\\Repositories\\UserRepository;\n    use App\\Models\\User;\n\n    class UserController extends Controller\n    {\n    /**\n    * The user repository implementation.\n    *\n    * @var UserRepository\n    */\n    protected $users;\n\n    /**\n    * Create a new controller instance.\n    *\n    * @param  UserRepository  $users\n    * @return void\n    */\n    public function __construct(UserRepository $users)\n    {\n    $this-&gt;users = $users;\n    }\n\n    /**\n    * Show the profile for the given user.\n    *\n    * @param  int  $id\n    * @return Response\n    */\n    public function show($id)\n    {\n    $user = $this-&gt;users-&gt;find($id);\n\n    return view('user.profile', ['user' =&gt; $user]);\n    }\n    }</code></pre>\n  <p>En este ejemplo, las <code>UserController</code>necesidades de recuperar usuarios de una fuente de datos. Entonces, <strong>inyectaremos</strong> un servicio que pueda recuperar usuarios. En este contexto, lo <code>UserRepository</code>más probable es que utilice Eloquent para recuperar información del usuario de la base de datos. Sin embargo, dado que se inyecta el repositorio, podemos intercambiarlo fácilmente con otra implementación. También podemos \"simular\" fácilmente, o crear una implementación ficticia del <code>UserRepository</code>cuando probamos nuestra aplicación.</p>\n  <p>Una comprensión profunda del contenedor de servicios de Laravel es esencial para crear una aplicación grande y poderosa, así como para contribuir al núcleo de Laravel en sí.</p>\n  <p></p>\n  <h2>Unión</h2>\n  <p></p>\n  <h3>Conceptos básicos de encuadernación</h3>\n  <p>Casi todos los enlaces de contenedores de servicios se registrarán en los proveedores de servicios , por lo que la mayoría de estos ejemplos demostrarán el uso del contenedor en ese contexto.</p>\n  <blockquote>\n    <p>No es necesario vincular clases en el contenedor si no dependen de ninguna interfaz. No es necesario que el contenedor reciba instrucciones sobre cómo construir estos objetos, ya que puede resolverlos automáticamente mediante la reflexión.</p>\n  </blockquote>\n  <h4>Encuadernaciones simples</h4>\n  <p>Dentro de un proveedor de servicios, siempre tiene acceso al contenedor a través de la propiedad. Podemos registrar un enlace usando el método, pasando el nombre de la clase o interfaz que deseamos registrar junto con un que devuelve una instancia de la clase:<code>$this-&gt;app</code><code>bind</code><code>Closure</code></p>\n  <pre><code>$this-&gt;app-&gt;bind('HelpSpot\\API', function ($app) {\n    return new \\HelpSpot\\API($app-&gt;make('HttpClient'));\n    });</code></pre>\n  <p>Tenga en cuenta que recibimos el contenedor en sí como un argumento para el resolutor. Luego, podemos usar el contenedor para resolver las subdependencias del objeto que estamos construyendo.</p>\n  <h4>Unión de un singleton</h4>\n  <p>El <code>singleton</code>método vincula una clase o interfaz en el contenedor que solo debe resolverse una vez. Una vez que se resuelve un enlace singleton, la misma instancia de objeto se devolverá en llamadas posteriores al contenedor:</p>\n  <pre><code>$this-&gt;app-&gt;singleton('HelpSpot\\API', function ($app) {\n    return new \\HelpSpot\\API($app-&gt;make('HttpClient'));\n    });</code></pre>\n  <h4>Instancias vinculantes</h4>\n  <p>También puede vincular una instancia de objeto existente en el contenedor utilizando el <code>instance</code>método. La instancia dada siempre se devolverá en llamadas posteriores al contenedor:</p>\n  <pre><code>$api = new \\HelpSpot\\API(new HttpClient);\n\n    $this-&gt;app-&gt;instance('HelpSpot\\API', $api);</code></pre>\n  <p></p>\n  <h3>Vinculación de interfaces a implementaciones</h3>\n  <p>Una característica muy poderosa del contenedor de servicios es su capacidad para vincular una interfaz a una implementación determinada. Por ejemplo, supongamos que tenemos una <code>EventPusher</code>interfaz y una <code>RedisEventPusher</code>implementación. Una vez que hemos codificado nuestra <code>RedisEventPusher</code>implementación de esta interfaz, podemos registrarla con el contenedor de servicios así:</p>\n  <pre><code>$this-&gt;app-&gt;bind(\n    'App\\Contracts\\EventPusher',\n    'App\\Services\\RedisEventPusher'\n    );</code></pre>\n  <p>Esta declaración le dice al contenedor que debe inyectar el <code>RedisEventPusher</code>cuando una clase necesita una implementación de <code>EventPusher</code>. Ahora podemos escribir sugerencias en la <code>EventPusher</code>interfaz en un constructor, o en cualquier otra ubicación donde el contenedor de servicios inyecta las dependencias:</p>\n  <pre><code>use App\\Contracts\\EventPusher;\n\n    /**\n    * Create a new class instance.\n    *\n    * @param  EventPusher  $pusher\n    * @return void\n    */\n    public function __construct(EventPusher $pusher)\n    {\n    $this-&gt;pusher = $pusher;\n    }</code></pre>\n  <p></p>\n  <h3>Enlace contextual</h3>\n  <p>A veces, puede tener dos clases que utilizan la misma interfaz, pero desea inyectar diferentes implementaciones en cada clase. Por ejemplo, dos controladores pueden depender de diferentes implementaciones del contrato . Laravel proporciona una interfaz sencilla y fluida para definir este comportamiento:<code>Illuminate\\Contracts\\Filesystem\\Filesystem</code> </p>\n  <pre><code>use App\\Http\\Controllers\\PhotoController;\n    use App\\Http\\Controllers\\UploadController;\n    use App\\Http\\Controllers\\VideoController;\n    use Illuminate\\Contracts\\Filesystem\\Filesystem;\n    use Illuminate\\Support\\Facades\\Storage;\n\n    $this-&gt;app-&gt;when(PhotoController::class)\n    -&gt;needs(Filesystem::class)\n    -&gt;give(function () {\n    return Storage::disk('local');\n    });\n\n    $this-&gt;app-&gt;when([VideoController::class, UploadController::class])\n    -&gt;needs(Filesystem::class)\n    -&gt;give(function () {\n    return Storage::disk('s3');\n    });</code></pre>\n  <p></p>\n  <h3>Primitivas vinculantes</h3>\n  <p>A veces, puede tener una clase que recibe algunas clases inyectadas, pero también necesita un valor primitivo inyectado, como un número entero. Puede usar fácilmente el enlace contextual para inyectar cualquier valor que su clase pueda necesitar:</p>\n  <pre><code>$this-&gt;app-&gt;when('App\\Http\\Controllers\\UserController')\n    -&gt;needs('$variableName')\n    -&gt;give($value);</code></pre>\n  <p>A veces, una clase puede depender de una serie de instancias etiquetadas. Con el <code>giveTagged</code>método, puede inyectar fácilmente todos los enlaces de contenedor con esa etiqueta:</p>\n  <pre><code>$this-&gt;app-&gt;when(ReportAggregator::class)\n    -&gt;needs('$reports')\n    -&gt;giveTagged('reports');</code></pre>\n  <p></p>\n  <h3>Vinculación de Variadics con tipo</h3>\n  <p>Ocasionalmente, puede tener una clase que recibe una matriz de objetos con tipo usando un argumento de constructor variadic:</p>\n  <pre><code>class Firewall\n    {\n    protected $logger;\n    protected $filters;\n\n    public function __construct(Logger $logger, Filter ...$filters)\n    {\n    $this-&gt;logger = $logger;\n    $this-&gt;filters = $filters;\n    }\n    }</code></pre>\n  <p>Al usar el enlace contextual, puede resolver esta dependencia proporcionando al <code>give</code>método un cierre que devuelve una matriz de <code>Filter</code>instancias resueltas :</p>\n  <pre><code>$this-&gt;app-&gt;when(Firewall::class)\n    -&gt;needs(Filter::class)\n    -&gt;give(function ($app) {\n    return [\n    $app-&gt;make(NullFilter::class),\n    $app-&gt;make(ProfanityFilter::class),\n    $app-&gt;make(TooLongFilter::class),\n    ];\n    });</code></pre>\n  <p>Para mayor comodidad, también puede proporcionar una matriz de nombres de clases para que el contenedor los resuelva siempre que <code>Firewall</code>necesite <code>Filter</code>instancias:</p>\n  <pre><code>$this-&gt;app-&gt;when(Firewall::class)\n    -&gt;needs(Filter::class)\n    -&gt;give([\n    NullFilter::class,\n    ProfanityFilter::class,\n    TooLongFilter::class,\n    ]);</code></pre>\n  <h4>Dependencias de etiquetas variables</h4>\n  <p>A veces, una clase puede tener una dependencia variada que se insinúa como una clase determinada ( ). Con los métodos y , puede inyectar fácilmente todos los enlaces de contenedor con esa etiqueta para la dependencia dada:<code>Report ...$reports</code><code>needs</code><code>giveTagged</code></p>\n  <pre><code>$this-&gt;app-&gt;when(ReportAggregator::class)\n    -&gt;needs(Report::class)\n    -&gt;giveTagged('reports');</code></pre>\n  <p></p>\n  <h3>Etiquetado</h3>\n  <p>De vez en cuando, es posible que deba resolver todas las \"categorías\" de vinculación. Por ejemplo, tal vez esté creando un agregador de informes que reciba una serie de muchas <code>Report</code>implementaciones de interfaz diferentes . Después de registrar las <code>Report</code>implementaciones, puede asignarles una etiqueta usando el <code>tag</code>método:</p>\n  <pre><code>$this-&gt;app-&gt;bind('SpeedReport', function () {\n    //\n    });\n\n    $this-&gt;app-&gt;bind('MemoryReport', function () {\n    //\n    });\n\n    $this-&gt;app-&gt;tag(['SpeedReport', 'MemoryReport'], 'reports');</code></pre>\n  <p>Una vez que se hayan etiquetado los servicios, puede resolverlos fácilmente a través del <code>tagged</code>método:</p>\n  <pre><code>$this-&gt;app-&gt;bind('ReportAggregator', function ($app) {\n    return new ReportAggregator($app-&gt;tagged('reports'));\n    });</code></pre>\n  <p></p>\n  <h3>Ampliación de enlaces</h3>\n  <p>El <code>extend</code>método permite la modificación de servicios resueltos. Por ejemplo, cuando se resuelve un servicio, puede ejecutar código adicional para decorar o configurar el servicio. El <code>extend</code>método acepta un Closure, que debería devolver el servicio modificado, como único argumento. El cierre recibe el servicio que se está resolviendo y la instancia del contenedor:</p>\n  <pre><code>$this-&gt;app-&gt;extend(Service::class, function ($service, $app) {\n    return new DecoratedService($service);\n    });</code></pre>\n  <p></p>\n  <h2>Resolviendo</h2>\n  <p></p>\n  <h4>El <code>make</code>método</h4>\n  <p>Puede usar el <code>make</code>método para resolver una instancia de clase fuera del contenedor. El <code>make</code>método acepta el nombre de la clase o interfaz que desea resolver:</p>\n  <pre><code>$api = $this-&gt;app-&gt;make('HelpSpot\\API');</code></pre>\n  <p>Si se encuentra en una ubicación de su código que no tiene acceso a la <code>$app</code>variable, puede usar el <code>resolve</code>asistente global :</p>\n  <pre><code>$api = resolve('HelpSpot\\API');</code></pre>\n  <p>Si algunas de las dependencias de su clase no se pueden resolver a través del contenedor, puede inyectarlas pasándolas como una matriz asociativa en el <code>makeWith</code>método:</p>\n  <pre><code>$api = $this-&gt;app-&gt;makeWith('HelpSpot\\API', ['id' =&gt; 1]);</code></pre>\n  <p></p>\n  <h4>Inyección automática</h4>\n  <p>Alternativamente, y lo que es más importante, puede \"escribir sugerencias\" sobre la dependencia en el constructor de una clase que resuelve el contenedor, incluidos controladores , detectores de eventos , middleware y más. Además, puede escribir sugerencias de dependencias en el <code>handle</code>método de trabajos en cola . En la práctica, así es como el contenedor debería resolver la mayoría de sus objetos.</p>\n  <p>Por ejemplo, puede escribir una sugerencia de un repositorio definido por su aplicación en el constructor de un controlador. El repositorio se resolverá e inyectará automáticamente en la clase:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Http\\Controllers;\n\n    use App\\Models\\Users\\Repository as UserRepository;\n\n    class UserController extends Controller\n    {\n    /**\n    * The user repository instance.\n    */\n    protected $users;\n\n    /**\n    * Create a new controller instance.\n    *\n    * @param  UserRepository  $users\n    * @return void\n    */\n    public function __construct(UserRepository $users)\n    {\n    $this-&gt;users = $users;\n    }\n\n    /**\n    * Show the user with the given ID.\n    *\n    * @param  int  $id\n    * @return Response\n    */\n    public function show($id)\n    {\n    //\n    }\n    }</code></pre>\n  <p></p>\n  <h2>Eventos de contenedores</h2>\n  <p>El contenedor de servicios dispara un evento cada vez que resuelve un objeto. Puede escuchar este evento usando el <code>resolving</code>método:</p>\n  <pre><code>$this-&gt;app-&gt;resolving(function ($object, $app) {\n    // Called when container resolves object of any type...\n    });\n\n    $this-&gt;app-&gt;resolving(\\HelpSpot\\API::class, function ($api, $app) {\n    // Called when container resolves objects of type \"HelpSpot\\API\"...\n    });</code></pre>\n  <p>Como puede ver, el objeto que se está resolviendo se pasará a la devolución de llamada, lo que le permitirá establecer propiedades adicionales en el objeto antes de que se le entregue a su consumidor.</p>\n  <p></p>\n  <h2>PSR-11</h2>\n  <p>El contenedor de servicios de Laravel implementa la interfaz PSR-11 . Por lo tanto, puede escribir sugerencias en la interfaz del contenedor PSR-11 para obtener una instancia del contenedor Laravel:</p>\n  <pre><code>use Psr\\Container\\ContainerInterface;\n\n    Route::get('/', function (ContainerInterface $container) {\n    $service = $container-&gt;get('Service');\n\n    //\n    });</code></pre>\n  <p>Se lanza una excepción si el identificador dado no se puede resolver. La excepción será una instancia de si el identificador nunca estuvo vinculado. Si el identificador estaba vinculado pero no se pudo resolver, se lanzará una instancia de .<code>Psr\\Container\\NotFoundExceptionInterface</code><code>Psr\\Container\\ContainerExceptionInterface</code></p>\n</section>"
      },
      {
        "titulo": "2.3 Proveedores de servicio",
        "contenido": "<section>\n  <h1>Proveedores de servicio</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Proveedores de servicios de redacción\n      <ul>\n        <li>El método de registro</li>\n        <li>El método de arranque</li>\n      </ul></li>\n    <li>Registro de proveedores</li>\n    <li>Proveedores diferidos</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Los proveedores de servicios son el lugar central de todas las aplicaciones de arranque de Laravel. Su propia aplicación, así como todos los servicios principales de Laravel, se ejecutan a través de proveedores de servicios.</p>\n  <p>Pero, ¿qué queremos decir con \"bootstrapped\"? En general, nos referimos al <strong>registro de</strong> cosas, incluido el registro de enlaces de contenedores de servicios, detectores de eventos, middleware e incluso rutas. Los proveedores de servicios son el lugar central para configurar su aplicación.</p>\n  <p>Si abre el archivo incluido con Laravel, verá una matriz. Estas son todas las clases de proveedores de servicios que se cargarán para su aplicación. Tenga en cuenta que muchos de estos son proveedores \"diferidos\", lo que significa que no se cargarán en cada solicitud, sino solo cuando los servicios que brindan sean realmente necesarios.<code>config/app.php</code><code>providers</code></p>\n  <p>En esta descripción general, aprenderá a escribir sus propios proveedores de servicios y a registrarlos con su aplicación Laravel.</p>\n  <p></p>\n  <h2>Proveedores de servicios de redacción</h2>\n  <p>Todos los proveedores de servicios amplían la clase. La mayoría de los proveedores de servicios contienen un método y un . Dentro del método, <strong>solo</strong> debe <strong>vincular cosas en el </strong><strong>contenedor de servicios</strong> . Nunca debe intentar registrar ningún detector de eventos, rutas o cualquier otra función dentro del método.<code>Illuminate\\Support\\ServiceProvider</code><code>register</code><code>boot</code><code>register</code><strong></strong><code>register</code></p>\n  <p>Artisan CLI puede generar un nuevo proveedor mediante el comando:<code>make:provider</code></p>\n  <pre><code>php artisan make:provider RiakServiceProvider</code></pre>\n  <p></p>\n  <h3>El método de registro</h3>\n  <p>Como se mencionó anteriormente, dentro del <code>register</code>método, solo debe vincular cosas en el contenedor de servicios . Nunca debe intentar registrar ningún detector de eventos, rutas o cualquier otra función dentro del <code>register</code>método. De lo contrario, puede utilizar accidentalmente un servicio proporcionado por un proveedor de servicios que aún no se ha cargado.</p>\n  <p>Echemos un vistazo a un proveedor de servicios básicos. Dentro de cualquiera de los métodos de su proveedor de servicios, siempre tiene acceso a la <code>$app</code>propiedad que proporciona acceso al contenedor de servicios:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Providers;\n\n    use Illuminate\\Support\\ServiceProvider;\n    use Riak\\Connection;\n\n    class RiakServiceProvider extends ServiceProvider\n    {\n    /**\n    * Register any application services.\n    *\n    * @return void\n    */\n    public function register()\n    {\n    $this-&gt;app-&gt;singleton(Connection::class, function ($app) {\n    return new Connection(config('riak'));\n    });\n    }\n    }</code></pre>\n  <p>Este proveedor de servicios solo define un <code>register</code>método y usa ese método para definir una implementación de en el contenedor de servicios. Si no comprende cómo funciona el contenedor de servicios, consulte su documentación .<code>Riak\\Connection</code></p>\n  <h4>Las propiedades <code>bindings</code>y<code>singletons</code></h4>\n  <p>Si su proveedor de servicios registra muchos enlaces simples, es posible que desee utilizar las propiedades <code>bindings</code>y <code>singletons</code>en lugar de registrar manualmente cada enlace de contenedor. Cuando el proveedor de servicios es cargado por el marco, automáticamente verificará estas propiedades y registrará sus enlaces:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Providers;\n\n    use App\\Contracts\\DowntimeNotifier;\n    use App\\Contracts\\ServerProvider;\n    use App\\Services\\DigitalOceanServerProvider;\n    use App\\Services\\PingdomDowntimeNotifier;\n    use App\\Services\\ServerToolsProvider;\n    use Illuminate\\Support\\ServiceProvider;\n\n    class AppServiceProvider extends ServiceProvider\n    {\n    /**\n    * All of the container bindings that should be registered.\n    *\n    * @var array\n    */\n    public $bindings = [\n    ServerProvider::class =&gt; DigitalOceanServerProvider::class,\n    ];\n\n    /**\n    * All of the container singletons that should be registered.\n    *\n    * @var array\n    */\n    public $singletons = [\n    DowntimeNotifier::class =&gt; PingdomDowntimeNotifier::class,\n    ServerProvider::class =&gt; ServerToolsProvider::class,\n    ];\n    }</code></pre>\n  <p></p>\n  <h3>El método de arranque</h3>\n  <p>Entonces, ¿qué pasa si necesitamos registrar un compositor de vistas dentro de nuestro proveedor de servicios? Esto debe hacerse dentro del <code>boot</code>método. <strong>Este método se llama después de que se hayan registrado todos los demás proveedores de servicios</strong> , lo que significa que tiene acceso a todos los demás servicios que han sido registrados por el marco:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Providers;\n\n    use Illuminate\\Support\\ServiceProvider;\n\n    class ComposerServiceProvider extends ServiceProvider\n    {\n    /**\n    * Bootstrap any application services.\n    *\n    * @return void\n    */\n    public function boot()\n    {\n    view()-&gt;composer('view', function () {\n    //\n    });\n    }\n    }</code></pre>\n  <h4>Inyección de dependencia del método de arranque</h4>\n  <p>Puede escribir dependencias de sugerencia para el <code>boot</code>método de su proveedor de servicios . El contenedor de servicios inyectará automáticamente las dependencias que necesite:</p>\n  <pre><code>use Illuminate\\Contracts\\Routing\\ResponseFactory;\n\n    public function boot(ResponseFactory $response)\n    {\n    $response-&gt;macro('caps', function ($value) {\n    //\n    });\n    }</code></pre>\n  <p></p>\n  <h2>Registro de proveedores</h2>\n  <p>Todos los proveedores de servicios están registrados en el archivo de configuración. Este archivo contiene una matriz donde puede enumerar los nombres de clase de sus proveedores de servicios. De forma predeterminada, un conjunto de proveedores de servicios centrales de Laravel se enumeran en esta matriz. Estos proveedores arrancan los componentes centrales de Laravel, como el mailer, la cola, la caché y otros.<code>config/app.php</code><code>providers</code></p>\n  <p>Para registrar su proveedor, agréguelo a la matriz:</p>\n  <pre><code>'providers' =&gt; [\n    // Other Service Providers\n\n    App\\Providers\\ComposerServiceProvider::class,\n    ],</code></pre>\n  <p></p>\n  <h2>Proveedores diferidos</h2>\n  <p>Si su proveedor <strong>solo</strong> está registrando vinculaciones en el contenedor de servicios , puede optar por aplazar su registro hasta que una de las vinculaciones registradas sea realmente necesaria. Aplazar la carga de dicho proveedor mejorará el rendimiento de su aplicación, ya que no se carga desde el sistema de archivos en cada solicitud.</p>\n  <p>Laravel compila y almacena una lista de todos los servicios proporcionados por proveedores de servicios diferidos, junto con el nombre de su clase de proveedor de servicios. Entonces, solo cuando intentas resolver uno de estos servicios, Laravel carga el proveedor de servicios.</p>\n  <p>Para aplazar la carga de un proveedor, implemente la interfaz y defina un método. El método debe devolver los enlaces del contenedor de servicios registrados por el proveedor:<code>\\Illuminate\\Contracts\\Support\\DeferrableProvider</code><code>provides</code><code>provides</code></p>\n  <pre><code>&lt;?php\n\n    namespace App\\Providers;\n\n    use Illuminate\\Contracts\\Support\\DeferrableProvider;\n    use Illuminate\\Support\\ServiceProvider;\n    use Riak\\Connection;\n\n    class RiakServiceProvider extends ServiceProvider implements DeferrableProvider\n    {\n    /**\n    * Register any application services.\n    *\n    * @return void\n    */\n    public function register()\n    {\n    $this-&gt;app-&gt;singleton(Connection::class, function ($app) {\n    return new Connection($app['config']['riak']);\n    });\n    }\n\n    /**\n    * Get the services provided by the provider.\n    *\n    * @return array\n    */\n    public function provides()\n    {\n    return [Connection::class];\n    }\n    }</code></pre>\n</section>"
      },
      {
        "titulo": "2.4 Fachadas",
        "contenido": "<section>\n  <h1>Fachadas</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Cuándo usar fachadas\n      <ul>\n        <li>Fachadas vs. Inyección de dependencia</li>\n        <li>Fachadas vs. Funciones auxiliares</li>\n      </ul></li>\n    <li>Cómo funcionan las fachadas</li>\n    <li>Fachadas en tiempo real</li>\n    <li>Referencia de clase de fachada</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Las fachadas proporcionan una interfaz \"estática\" a las clases que están disponibles en el contenedor de servicios de la aplicación . Laravel se envía con muchas fachadas que brindan acceso a casi todas las características de Laravel. Las fachadas de Laravel sirven como \"proxies estáticos\" para las clases subyacentes en el contenedor de servicios, proporcionando el beneficio de una sintaxis concisa y expresiva al tiempo que mantienen más capacidad de prueba y flexibilidad que los métodos estáticos tradicionales.</p>\n  <p>Todas las fachadas de Laravel están definidas en el espacio de nombres. Entonces, podemos acceder fácilmente a una fachada como esta:<code>Illuminate\\Support\\Facades</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Cache;\n\n    Route::get('/cache', function () {\n    return Cache::get('key');\n    });</code></pre>\n  <p>A lo largo de la documentación de Laravel, muchos de los ejemplos usarán fachadas para demostrar varias características del marco.</p>\n  <p></p>\n  <h2>Cuándo usar fachadas</h2>\n  <p>Las fachadas tienen muchos beneficios. Proporcionan una sintaxis concisa y memorable que le permite usar las funciones de Laravel sin recordar nombres de clase largos que deben inyectarse o configurarse manualmente. Además, debido a su uso exclusivo de los métodos dinámicos de PHP, son fáciles de probar.</p>\n  <p>Sin embargo, se debe tener cierto cuidado al usar fachadas. El peligro principal de las fachadas es el deslizamiento del alcance de clase. Dado que las fachadas son tan fáciles de usar y no requieren inyección, puede ser fácil dejar que sus clases continúen creciendo y usar muchas fachadas en una sola clase. Al usar la inyección de dependencia, este potencial se mitiga con la retroalimentación visual que un constructor grande le brinda de que su clase está creciendo demasiado. Por lo tanto, cuando use fachadas, preste especial atención al tamaño de su clase para que su alcance de responsabilidad sea limitado.</p>\n  <blockquote>\n    <p>Al construir un paquete de terceros que interactúa con Laravel, es mejor inyectar contratos de Laravel en lugar de usar fachadas. Dado que los paquetes se crean fuera de Laravel, no tendrá acceso a los ayudantes de prueba de fachada de Laravel.</p>\n  </blockquote>\n  <p></p>\n  <h3>Fachadas vs. Inyección de dependencia</h3>\n  <p>Uno de los principales beneficios de la inyección de dependencia es la capacidad de intercambiar implementaciones de la clase inyectada. Esto es útil durante las pruebas, ya que puede inyectar un simulacro o un código auxiliar y afirmar que se llamaron varios métodos en el código auxiliar.</p>\n  <p>Normalmente, no sería posible simular o eliminar un método de clase verdaderamente estático. Sin embargo, dado que las fachadas utilizan métodos dinámicos para llamar a métodos proxy a objetos resueltos desde el contenedor de servicios, en realidad podemos probar las fachadas como probaríamos una instancia de clase inyectada. Por ejemplo, dada la siguiente ruta:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Cache;\n\n    Route::get('/cache', function () {\n    return Cache::get('key');\n    });</code></pre>\n  <p>Podemos escribir la siguiente prueba para verificar que el método fue llamado con el argumento que esperábamos:<code>Cache::get</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Cache;\n\n    /**\n    * A basic functional test example.\n    *\n    * @return void\n    */\n    public function testBasicExample()\n    {\n    Cache::shouldReceive('get')\n    -&gt;with('key')\n    -&gt;andReturn('value');\n\n    $this-&gt;visit('/cache')\n    -&gt;see('value');\n    }</code></pre>\n  <p></p>\n  <h3>Fachadas vs. Funciones auxiliares</h3>\n  <p>Además de las fachadas, Laravel incluye una variedad de funciones de \"ayuda\" que pueden realizar tareas comunes como generar vistas, disparar eventos, despachar trabajos o enviar respuestas HTTP. Muchas de estas funciones auxiliares realizan la misma función que una fachada correspondiente. Por ejemplo, esta llamada de fachada y llamada de ayuda son equivalentes:</p>\n  <pre><code>return View::make('profile');\n\n    return view('profile');</code></pre>\n  <p>No hay absolutamente ninguna diferencia práctica entre las fachadas y las funciones auxiliares. Al usar funciones auxiliares, aún puede probarlas exactamente como lo haría con la fachada correspondiente. Por ejemplo, dada la siguiente ruta:</p>\n  <pre><code>Route::get('/cache', function () {\n    return cache('key');\n    });</code></pre>\n  <p>Bajo el capó, el <code>cache</code>ayudante llamará al <code>get</code>método en la clase subyacente a la <code>Cache</code>fachada. Entonces, aunque estamos usando la función auxiliar, podemos escribir la siguiente prueba para verificar que el método fue llamado con el argumento que esperábamos:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Cache;\n\n    /**\n    * A basic functional test example.\n    *\n    * @return void\n    */\n    public function testBasicExample()\n    {\n    Cache::shouldReceive('get')\n    -&gt;with('key')\n    -&gt;andReturn('value');\n\n    $this-&gt;visit('/cache')\n    -&gt;see('value');\n    }</code></pre>\n  <p></p>\n  <h2>Cómo funcionan las fachadas</h2>\n  <p>En una aplicación de Laravel, una fachada es una clase que proporciona acceso a un objeto desde el contenedor. La maquinaria que hace que esto funcione está en la <code>Facade</code>clase. Las fachadas de Laravel y las fachadas personalizadas que cree ampliarán la clase base .<code>Illuminate\\Support\\Facades\\Facade</code></p>\n  <p>La <code>Facade</code>clase base hace uso del método mágico para diferir las llamadas desde su fachada a un objeto resuelto desde el contenedor. En el siguiente ejemplo, se realiza una llamada al sistema de caché de Laravel. Al mirar este código, se podría suponer que se está llamando al método estático en la clase:<code>__callStatic()</code><code>get</code><code>Cache</code></p>\n  <pre><code>&lt;?php\n\n    namespace App\\Http\\Controllers;\n\n    use App\\Http\\Controllers\\Controller;\n    use Illuminate\\Support\\Facades\\Cache;\n\n    class UserController extends Controller\n    {\n    /**\n    * Show the profile for the given user.\n    *\n    * @param  int  $id\n    * @return Response\n    */\n    public function showProfile($id)\n    {\n    $user = Cache::get('user:'.$id);\n\n    return view('profile', ['user' =&gt; $user]);\n    }\n    }</code></pre>\n  <p>Observe que cerca de la parte superior del archivo estamos \"importando\" la <code>Cache</code>fachada. Esta fachada sirve como un proxy para acceder a la implementación subyacente de la interfaz. Cualquier llamada que hagamos usando la fachada se pasará a la instancia subyacente del servicio de caché de Laravel.<code>Illuminate\\Contracts\\Cache\\Factory</code></p>\n  <p>Si miramos esa clase, verá que no hay un método estático :<code>Illuminate\\Support\\Facades\\Cache</code><code>get</code></p>\n  <pre><code>class Cache extends Facade\n    {\n    /**\n    * Get the registered name of the component.\n    *\n    * @return string\n    */\n    protected static function getFacadeAccessor() { return 'cache'; }\n    }</code></pre>\n  <p>En cambio, la <code>Cache</code>fachada extiende la <code>Facade</code>clase base y define el método . El trabajo de este método es devolver el nombre de un enlace de contenedor de servicios. Cuando un usuario hace referencia a cualquier método estático en la fachada, Laravel resuelve el enlace desde el contenedor de servicios y ejecuta el método solicitado (en este caso ) contra ese objeto.<code>getFacadeAccessor()</code><code>Cache</code><code>cache</code><code>get</code></p>\n  <p></p>\n  <h2>Fachadas en tiempo real</h2>\n  <p>Al utilizar fachadas en tiempo real, puede tratar cualquier clase de su aplicación como si fuera una fachada. Para ilustrar cómo se puede utilizar esto, examinemos una alternativa. Por ejemplo, supongamos que nuestro <code>Podcast</code>modelo tiene un <code>publish</code>método. Sin embargo, para publicar el podcast, necesitamos inyectar una <code>Publisher</code>instancia:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Models;\n\n    use App\\Contracts\\Publisher;\n    use Illuminate\\Database\\Eloquent\\Model;\n\n    class Podcast extends Model\n    {\n    /**\n    * Publish the podcast.\n    *\n    * @param  Publisher  $publisher\n    * @return void\n    */\n    public function publish(Publisher $publisher)\n    {\n    $this-&gt;update(['publishing' =&gt; now()]);\n\n    $publisher-&gt;publish($this);\n    }\n    }</code></pre>\n  <p>Inyectar una implementación de editor en el método nos permite probar fácilmente el método de forma aislada, ya que podemos burlarnos del editor inyectado. Sin embargo, nos obliga a pasar siempre una instancia de editor cada vez que llamamos al <code>publish</code>método. Al usar fachadas en tiempo real, podemos mantener la misma capacidad de prueba sin tener que pasar explícitamente una <code>Publisher</code>instancia. Para generar una fachada en tiempo real, anteponga el espacio de nombres de la clase importada con <code>Facades</code>:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Models;\n\n    use Facades\\App\\Contracts\\Publisher;\n    use Illuminate\\Database\\Eloquent\\Model;\n\n    class Podcast extends Model\n    {\n    /**\n    * Publish the podcast.\n    *\n    * @return void\n    */\n    public function publish()\n    {\n    $this-&gt;update(['publishing' =&gt; now()]);\n\n    Publisher::publish($this);\n    }\n    }</code></pre>\n  <p>Cuando se utiliza la fachada en tiempo real, la implementación del editor se resolverá fuera del contenedor de servicios utilizando la parte de la interfaz o el nombre de clase que aparece después del <code>Facades</code>prefijo. Al realizar pruebas, podemos usar los ayudantes de prueba de fachada incorporados de Laravel para simular esta llamada al método:</p>\n  <pre><code>&lt;?php\n\n    namespace Tests\\Feature;\n\n    use App\\Models\\Podcast;\n    use Facades\\App\\Contracts\\Publisher;\n    use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n    use Tests\\TestCase;\n\n    class PodcastTest extends TestCase\n    {\n    use RefreshDatabase;\n\n    /**\n    * A test example.\n    *\n    * @return void\n    */\n    public function test_podcast_can_be_published()\n    {\n    $podcast = factory(Podcast::class)-&gt;create();\n\n    Publisher::shouldReceive('publish')-&gt;once()-&gt;with($podcast);\n\n    $podcast-&gt;publish();\n    }\n    }</code></pre>\n</section>"
      },
      {
        "titulo": "2.5 Contratos",
        "contenido": "<section>\n  <h1>Contratos</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Contratos vs. Fachadas</li>\n      </ul></li>\n    <li>Cuándo utilizar contratos\n      <ul>\n        <li>Bajo acoplamiento</li>\n        <li>Sencillez</li>\n      </ul></li>\n    <li>Cómo utilizar los contratos</li>\n    <li>Referencia de contrato</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Los contratos de Laravel son un conjunto de interfaces que definen los servicios centrales proporcionados por el marco. Por ejemplo, un contrato define los métodos necesarios para poner en cola los trabajos, mientras que el contrato define los métodos necesarios para enviar correo electrónico.<code>Illuminate\\Contracts\\Queue\\Queue</code><code>Illuminate\\Contracts\\Mail\\Mailer</code></p>\n  <p>Cada contrato tiene una implementación correspondiente proporcionada por el marco. Por ejemplo, Laravel proporciona una implementación de cola con una variedad de controladores y una implementación de correo que funciona con SwiftMailer .</p>\n  <p>Todos los contratos de Laravel viven en su propio repositorio de GitHub . Esto proporciona un punto de referencia rápido para todos los contratos disponibles, así como un paquete único desacoplado que pueden utilizar los desarrolladores de paquetes.</p>\n  <p></p>\n  <h3>Contratos vs. Fachadas</h3>\n  <p>Las fachadas y las funciones auxiliares de Laravel proporcionan una forma sencilla de utilizar los servicios de Laravel sin necesidad de escribir sugerencias y resolver contratos fuera del contenedor de servicios. En la mayoría de los casos, cada fachada tiene un contrato equivalente.</p>\n  <p>A diferencia de las fachadas, que no requieren que las requiera en el constructor de su clase, los contratos le permiten definir dependencias explícitas para sus clases. Algunos desarrolladores prefieren definir explícitamente sus dependencias de esta manera y, por lo tanto, prefieren utilizar contratos, mientras que otros desarrolladores disfrutan de la comodidad de las fachadas.</p>\n  <blockquote>\n    <p>La mayoría de las aplicaciones estarán bien independientemente de si prefiere fachadas o contratos. Sin embargo, si está creando un paquete, debería considerar seriamente el uso de contratos, ya que serán más fáciles de probar en el contexto de un paquete.</p>\n  </blockquote>\n  <p></p>\n  <h2>Cuándo utilizar contratos</h2>\n  <p>Como se discutió en otra parte, gran parte de la decisión de usar contratos o fachadas dependerá del gusto personal y de los gustos de su equipo de desarrollo. Tanto los contratos como las fachadas se pueden utilizar para crear aplicaciones Laravel sólidas y bien probadas. Mientras mantenga enfocadas las responsabilidades de su clase, notará muy pocas diferencias prácticas entre el uso de contratos y fachadas.</p>\n  <p>Sin embargo, es posible que aún tenga varias preguntas sobre los contratos. Por ejemplo, ¿por qué utilizar interfaces? ¿No es más complicado usar interfaces? Destilemos las razones para usar interfaces en los siguientes encabezados: acoplamiento flexible y simplicidad.</p>\n  <p></p>\n  <h3>Bajo acoplamiento</h3>\n  <p>Primero, revisemos un código que está estrechamente acoplado a una implementación de caché. Considera lo siguiente:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Orders;\n\n    class Repository\n    {\n    /**\n    * The cache instance.\n    */\n    protected $cache;\n\n    /**\n    * Create a new repository instance.\n    *\n    * @param  \\SomePackage\\Cache\\Memcached  $cache\n    * @return void\n    */\n    public function __construct(\\SomePackage\\Cache\\Memcached $cache)\n    {\n    $this-&gt;cache = $cache;\n    }\n\n    /**\n    * Retrieve an Order by ID.\n    *\n    * @param  int  $id\n    * @return Order\n    */\n    public function find($id)\n    {\n    if ($this-&gt;cache-&gt;has($id)) {\n    //\n    }\n    }\n    }</code></pre>\n  <p>En esta clase, el código está estrechamente acoplado a una implementación de caché determinada. Está estrechamente acoplado porque dependemos de una clase de caché concreta de un proveedor de paquetes. Si la API de ese paquete cambia, nuestro código también debe cambiar.</p>\n  <p>Asimismo, si queremos reemplazar nuestra tecnología de caché subyacente (Memcached) por otra tecnología (Redis), nuevamente tendremos que modificar nuestro repositorio. Nuestro repositorio no debería tener tanto conocimiento sobre quién les proporciona datos o cómo los proporcionan.</p>\n  <p><strong>En lugar de este enfoque, podemos mejorar nuestro código dependiendo de una interfaz simple e independiente del proveedor:</strong></p>\n  <pre><code>&lt;?php\n\n    namespace App\\Orders;\n\n    use Illuminate\\Contracts\\Cache\\Repository as Cache;\n\n    class Repository\n    {\n    /**\n    * The cache instance.\n    */\n    protected $cache;\n\n    /**\n    * Create a new repository instance.\n    *\n    * @param  Cache  $cache\n    * @return void\n    */\n    public function __construct(Cache $cache)\n    {\n    $this-&gt;cache = $cache;\n    }\n    }</code></pre>\n  <p>Ahora el código no está asociado a ningún proveedor específico, ni siquiera a Laravel. Dado que el paquete de contratos no contiene implementación ni dependencias, puede escribir fácilmente una implementación alternativa de cualquier contrato dado, lo que le permite reemplazar su implementación de caché sin modificar ninguno de los códigos que consumen caché.</p>\n  <p></p>\n  <h3>Sencillez</h3>\n  <p>Cuando todos los servicios de Laravel están claramente definidos dentro de interfaces simples, es muy fácil determinar la funcionalidad ofrecida por un servicio dado. <strong>Los contratos sirven como documentación sucinta de las características del marco.</strong></p>\n  <p>Además, cuando depende de interfaces simples, su código es más fácil de entender y mantener. En lugar de rastrear qué métodos están disponibles para usted dentro de una clase grande y complicada, puede consultar una interfaz simple y limpia.</p>\n  <p></p>\n  <h2>Cómo utilizar los contratos</h2>\n  <p>Entonces, ¿cómo se consigue la implementación de un contrato? De hecho, es bastante simple.</p>\n  <p>Muchos tipos de clases en Laravel se resuelven a través del contenedor de servicios , incluidos controladores, detectores de eventos, middleware, trabajos en cola e incluso cierres de rutas. Entonces, para obtener una implementación de un contrato, puede simplemente \"escribir una sugerencia\" en la interfaz en el constructor de la clase que se está resolviendo.</p>\n  <p>Por ejemplo, eche un vistazo a este detector de eventos:</p>\n  <pre><code>&lt;?php\n\n    namespace App\\Listeners;\n\n    use App\\Events\\OrderWasPlaced;\n    use App\\Models\\User;\n    use Illuminate\\Contracts\\Redis\\Factory;\n\n    class CacheOrderInformation\n    {\n    /**\n    * The Redis factory implementation.\n    */\n    protected $redis;\n\n    /**\n    * Create a new event handler instance.\n    *\n    * @param  Factory  $redis\n    * @return void\n    */\n    public function __construct(Factory $redis)\n    {\n    $this-&gt;redis = $redis;\n    }\n\n    /**\n    * Handle the event.\n    *\n    * @param  OrderWasPlaced  $event\n    * @return void\n    */\n    public function handle(OrderWasPlaced $event)\n    {\n    //\n    }\n    }</code></pre>\n  <p>Cuando se resuelve el detector de eventos, el contenedor de servicios leerá las sugerencias de tipo en el constructor de la clase e inyectará el valor apropiado. Para obtener más información sobre cómo registrar cosas en el contenedor de servicios, consulte su documentación .</p>\n</section>"
      }
    ]
  },
  {
    "titulo": "Conceptos Basicos",
    "subtitulo": "",
    "items": [
      {
        "titulo": "3.1 Enrutamiento",
        "contenido": "<section>\n  <h1>Enrutamiento</h1>\n  <ul>\n    <li>Enrutamiento básico\n      <ul>\n        <li>Redirigir rutas</li>\n        <li>Ver rutas</li>\n      </ul></li>\n    <li>Parámetros de ruta\n      <ul>\n        <li>Parámetros requeridos</li>\n        <li>Parámetros opcionales</li>\n        <li>Restricciones de expresiones regulares</li>\n      </ul></li>\n    <li>Rutas nombradas</li>\n    <li>Grupos de ruta\n      <ul>\n        <li>Middleware</li>\n        <li>Enrutamiento de subdominio</li>\n        <li>Prefijos de ruta</li>\n        <li>Prefijos de nombre de ruta</li>\n      </ul></li>\n    <li>Enlace de modelo de ruta\n      <ul>\n        <li>Enlace implícito</li>\n        <li>Enlace explícito</li>\n      </ul></li>\n    <li>Rutas de respaldo</li>\n    <li>Limitación de tasa\n      <ul>\n        <li>Definición de limitadores de velocidad</li>\n        <li>Colocación de limitadores de velocidad en rutas</li>\n      </ul></li>\n    <li>Método de formulario suplantación</li>\n    <li>Accediendo a la ruta actual</li>\n    <li>Uso compartido de recursos de origen cruzado (CORS)</li>\n  </ul>\n  <p></p>\n  <h2>Enrutamiento básico</h2>\n  <p>Las rutas de Laravel más básicas aceptan una URI y una <code>Closure</code>, proporcionando un método muy simple y expresivo para definir rutas:</p>\n  <pre><code>Route::get('foo', function () {\n    return 'Hello World';\n});</code></pre>\n  <h4>Los archivos de ruta predeterminados</h4>\n  <p>Todas las rutas de Laravel se definen en sus archivos de ruta, que se encuentran en el <code>routes</code>directorio. Estos archivos son cargados automáticamente por el marco. El archivo define rutas que son para su interfaz web. A estas rutas se les asigna el grupo de middleware, que proporciona características como el estado de la sesión y la protección CSRF. Las rutas en no tienen estado y se les asigna el grupo de middleware.<code>routes/web.php</code><code>web</code><code>routes/api.php</code><code>api</code></p>\n  <p>Para la mayoría de las aplicaciones, comenzará por definir rutas en su archivo. Se puede acceder a las rutas definidas en ingresando la URL de la ruta definida en su navegador. Por ejemplo, puede acceder a la siguiente ruta navegando a en su navegador:<code>routes/web.php</code><code>routes/web.php</code><code>http://your-app.test/user</code></p>\n  <pre><code>use App\\Http\\Controllers\\UserController;\n\nRoute::get('/user', [UserController::class, 'index']);</code></pre>\n  <p>Las rutas definidas en el archivo están anidadas dentro de un grupo de rutas por . Dentro de este grupo, el prefijo URI se aplica automáticamente, por lo que no es necesario aplicarlo manualmente a todas las rutas del archivo. Puede modificar el prefijo y otras opciones del grupo de rutas modificando su clase.<code>routes/api.php</code><code>RouteServiceProvider</code><code>/api</code><code>RouteServiceProvider</code></p>\n  <h4>Métodos de enrutador disponibles</h4>\n  <p>El enrutador le permite registrar rutas que responden a cualquier verbo HTTP:</p>\n  <pre><code>Route::get($uri, $callback);\nRoute::post($uri, $callback);\nRoute::put($uri, $callback);\nRoute::patch($uri, $callback);\nRoute::delete($uri, $callback);\nRoute::options($uri, $callback);</code></pre>\n  <p>A veces, es posible que deba registrar una ruta que responda a varios verbos HTTP. Puede hacerlo utilizando el <code>match</code>método. O incluso puede registrar una ruta que responda a todos los verbos HTTP usando el <code>any</code>método:</p>\n  <pre><code>Route::match(['get', 'post'], '/', function () {\n    //\n});\n\nRoute::any('/', function () {\n    //\n});</code></pre>\n  <h4>Protección CSRF</h4>\n  <p>Cualquier formularios HTML que apuntan a <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, o <code>DELETE</code>rutas que se definen en el <code>web</code>archivo de rutas deben incluir un campo token CSRF. De lo contrario, la solicitud será rechazada. Puede leer más sobre la protección CSRF en la documentación de CSRF :</p>\n  <pre><code>&lt;form method=\"POST\" action=\"/profile\"&gt;\n    @csrf\n    ...\n&lt;/form&gt;</code></pre>\n  <p></p>\n  <h3>Redirigir rutas</h3>\n  <p>Si está definiendo una ruta que redirige a otro URI, puede usar el método. Este método proporciona un atajo conveniente para que no tenga que definir una ruta completa o un controlador para realizar una redirección simple:<code>Route::redirect</code></p>\n  <pre><code>Route::redirect('/here', '/there');</code></pre>\n  <p>De forma predeterminada, devuelve un código de estado. Puede personalizar el código de estado utilizando el tercer parámetro opcional:<code>Route::redirect</code><code>302</code></p>\n  <pre><code>Route::redirect('/here', '/there', 301);</code></pre>\n  <p>Puede utilizar el método para devolver un código de estado:<code>Route::permanentRedirect</code><code>301</code></p>\n  <pre><code>Route::permanentRedirect('/here', '/there');</code></pre>\n  <p></p>\n  <h3>Ver rutas</h3>\n  <p>Si su ruta solo necesita devolver una vista, puede usar el método. Al igual que el método, este método proporciona un atajo simple para que no tenga que definir una ruta completa o un controlador. El método acepta un URI como primer argumento y un nombre de vista como segundo argumento. Además, puede proporcionar una matriz de datos para pasar a la vista como un tercer argumento opcional:<code>Route::view</code><code>redirect</code><code>view</code></p>\n  <pre><code>Route::view('/welcome', 'welcome');\n\nRoute::view('/welcome', 'welcome', ['name' =&gt; 'Taylor']);</code></pre>\n  <p></p>\n  <h2>Parámetros de ruta</h2>\n  <p></p>\n  <h3>Parámetros requeridos</h3>\n  <p>A veces, necesitará capturar segmentos del URI dentro de su ruta. Por ejemplo, es posible que deba capturar la identificación de un usuario de la URL. Puede hacerlo definiendo los parámetros de ruta:</p>\n  <pre><code>Route::get('user/{id}', function ($id) {\n    return 'User '.$id;\n});</code></pre>\n  <p>Puede definir tantos parámetros de ruta como requiera su ruta:</p>\n  <pre><code>Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {\n    //\n});</code></pre>\n  <p>Los parámetros de ruta siempre están entre llaves y deben consistir en caracteres alfabéticos y no pueden contener un carácter. En lugar de usar el carácter, use un guión bajo ( ). Los parámetros de ruta se inyectan en las devoluciones de llamada / controladores de ruta según su orden; los nombres de los argumentos de devolución de llamada / controlador no importan.<code>{}</code><code>-</code><code>-</code><code>_</code></p>\n  <p></p>\n  <h3>Parámetros opcionales</h3>\n  <p>Ocasionalmente, es posible que deba especificar un parámetro de ruta, pero haga que la presencia de ese parámetro de ruta sea opcional. Puede hacerlo colocando una <code>?</code>marca después del nombre del parámetro. Asegúrese de darle a la variable correspondiente de la ruta un valor predeterminado:</p>\n  <pre><code>Route::get('user/{name?}', function ($name = null) {\n    return $name;\n});\n\nRoute::get('user/{name?}', function ($name = 'John') {\n    return $name;\n});</code></pre>\n  <p></p>\n  <h3>Restricciones de expresiones regulares</h3>\n  <p>Puede restringir el formato de los parámetros de su ruta utilizando el <code>where</code>método en una instancia de ruta. El <code>where</code>método acepta el nombre del parámetro y una expresión regular que define cómo se debe restringir el parámetro:</p>\n  <pre><code>Route::get('user/{name}', function ($name) {\n    //\n})-&gt;where('name', '[A-Za-z]+');\n\nRoute::get('user/{id}', function ($id) {\n    //\n})-&gt;where('id', '[0-9]+');\n\nRoute::get('user/{id}/{name}', function ($id, $name) {\n    //\n})-&gt;where(['id' =&gt; '[0-9]+', 'name' =&gt; '[a-z]+']);</code></pre>\n  <p></p>\n  <h4>Restricciones globales</h4>\n  <p>Si desea que un parámetro de ruta esté siempre limitado por una expresión regular determinada, puede usar el <code>pattern</code>método. Debe definir estos patrones en el <code>boot</code>método de su <code>RouteServiceProvider</code>:</p>\n  <pre><code>/**\n * Define your route model bindings, pattern filters, etc.\n *\n * @return void\n */\npublic function boot()\n{\n    Route::pattern('id', '[0-9]+');\n}</code></pre>\n  <p>Una vez que se ha definido el patrón, se aplica automáticamente a todas las rutas usando ese nombre de parámetro:</p>\n  <pre><code>Route::get('user/{id}', function ($id) {\n    // Only executed if {id} is numeric...\n});</code></pre>\n  <p></p>\n  <h4>Barras diagonales codificadas</h4>\n  <p>El componente de enrutamiento de Laravel permite todos los caracteres excepto <code>/</code>. Debe permitir explícitamente <code>/</code>ser parte de su marcador de posición utilizando una <code>where</code>expresión regular de condición:</p>\n  <pre><code>Route::get('search/{search}', function ($search) {\n    return $search;\n})-&gt;where('search', '.*');</code></pre>\n  <blockquote>\n    <p> Las barras diagonales codificadas solo se admiten dentro del último segmento de ruta.</p>\n  </blockquote>\n  <p></p>\n  <h2>Rutas nombradas</h2>\n  <p>Las rutas con nombre permiten la generación conveniente de URL o redireccionamientos para rutas específicas. Puede especificar un nombre para una ruta encadenando el <code>name</code>método en la definición de la ruta:</p>\n  <pre><code>Route::get('user/profile', function () {\n    //\n})-&gt;name('profile');</code></pre>\n  <p>También puede especificar nombres de ruta para las acciones del controlador:</p>\n  <pre><code>Route::get('user/profile', [UserProfileController::class, 'show'])-&gt;name('profile');</code></pre>\n  <blockquote>\n    <p> Los nombres de las rutas siempre deben ser únicos.</p>\n  </blockquote>\n  <h4>Generación de URL para rutas con nombre</h4>\n  <p>Una vez que haya asignado un nombre a una ruta determinada, puede usar el nombre de la ruta al generar URL o redireccionamientos a través de la <code>route</code>función global :</p>\n  <pre><code>// Generating URLs...\n$url = route('profile');\n\n// Generating Redirects...\nreturn redirect()-&gt;route('profile');</code></pre>\n  <p>Si la ruta nombrada define parámetros, puede pasar los parámetros como segundo argumento a la <code>route</code>función. Los parámetros dados se insertarán automáticamente en la URL en sus posiciones correctas:</p>\n  <pre><code>Route::get('user/{id}/profile', function ($id) {\n    //\n})-&gt;name('profile');\n\n$url = route('profile', ['id' =&gt; 1]);</code></pre>\n  <p>Si pasa parámetros adicionales en la matriz, esos pares clave / valor se agregarán automáticamente a la cadena de consulta de la URL generada:</p>\n  <pre><code>Route::get('user/{id}/profile', function ($id) {\n    //\n})-&gt;name('profile');\n\n$url = route('profile', ['id' =&gt; 1, 'photos' =&gt; 'yes']);\n\n// /user/1/profile?photos=yes</code></pre>\n  <blockquote>\n    <p>A veces, es posible que desee especificar valores predeterminados para toda la solicitud para los parámetros de URL, como la configuración regional actual. Para lograr esto, puede utilizar el método .<code>URL::defaults</code></p>\n  </blockquote>\n  <h4>Inspección de la ruta actual</h4>\n  <p>Si desea determinar si la solicitud actual fue enrutada a una ruta con nombre dada, puede usar el <code>named</code>método en una instancia de Ruta. Por ejemplo, puede verificar el nombre de la ruta actual desde un middleware de ruta:</p>\n  <pre><code>/**\n * Handle an incoming request.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @param  \\Closure  $next\n * @return mixed\n */\npublic function handle($request, Closure $next)\n{\n    if ($request-&gt;route()-&gt;named('profile')) {\n        //\n    }\n\n    return $next($request);\n}</code></pre>\n  <p></p>\n  <h2>Grupos de ruta</h2>\n  <p>Los grupos de rutas le permiten compartir atributos de ruta, como middleware, en una gran cantidad de rutas sin necesidad de definir esos atributos en cada ruta individual. Los atributos compartidos se especifican en un formato de matriz como primer parámetro del método.<code>Route::group</code></p>\n  <p>Los grupos anidados intentan \"fusionar\" de forma inteligente los atributos con su grupo principal. El middleware y las <code>where</code>condiciones se combinan mientras se agregan nombres y prefijos. Los delimitadores de espacio de nombres y las barras inclinadas en los prefijos de URI se agregan automáticamente cuando corresponde.</p>\n  <p></p>\n  <h3>Middleware</h3>\n  <p>Para asignar middleware a todas las rutas dentro de un grupo, puede usar el <code>middleware</code>método antes de definir el grupo. El middleware se ejecuta en el orden en el que se enumeran en la matriz:</p>\n  <pre><code>Route::middleware(['first', 'second'])-&gt;group(function () {\n    Route::get('/', function () {\n        // Uses first &amp; second middleware...\n    });\n\n    Route::get('user/profile', function () {\n        // Uses first &amp; second middleware...\n    });\n});</code></pre>\n  <p></p>\n  <h3>Enrutamiento de subdominio</h3>\n  <p>Los grupos de rutas también se pueden utilizar para manejar el enrutamiento de subdominios. A los subdominios se les pueden asignar parámetros de ruta al igual que los URI de ruta, lo que le permite capturar una parte del subdominio para usar en su ruta o controlador. El subdominio se puede especificar llamando al <code>domain</code>método antes de definir el grupo:</p>\n  <pre><code>Route::domain('{account}.myapp.com')-&gt;group(function () {\n    Route::get('user/{id}', function ($account, $id) {\n        //\n    });\n});</code></pre>\n  <blockquote>\n    <p>Para asegurarse de que las rutas de su subdominio sean accesibles, debe registrar las rutas del subdominio antes de registrar las rutas del dominio raíz. Esto evitará que las rutas del dominio raíz sobrescriban las rutas del subdominio que tienen la misma ruta URI.</p>\n  </blockquote>\n  <p></p>\n  <h3>Prefijos de ruta</h3>\n  <p>El <code>prefix</code>método puede usarse para prefijar cada ruta en el grupo con un URI dado. Por ejemplo, es posible que desee anteponer todos los URI de ruta dentro del grupo con <code>admin</code>:</p>\n  <pre><code>Route::prefix('admin')-&gt;group(function () {\n    Route::get('users', function () {\n        // Matches The \"/admin/users\" URL\n    });\n});</code></pre>\n  <p></p>\n  <h3>Prefijos de nombre de ruta</h3>\n  <p>El <code>name</code>método puede usarse para prefijar cada nombre de ruta en el grupo con una cadena dada. Por ejemplo, es posible que desee anteponer todos los nombres de las rutas agrupadas con <code>admin</code>. La cadena dada tiene el prefijo del nombre de la ruta exactamente como se especifica, por lo que nos aseguraremos de proporcionar el <code>.</code>carácter final en el prefijo:</p>\n  <pre><code>Route::name('admin.')-&gt;group(function () {\n    Route::get('users', function () {\n        // Route assigned name \"admin.users\"...\n    })-&gt;name('users');\n});</code></pre>\n  <p></p>\n  <h2>Enlace de modelo de ruta</h2>\n  <p>Al inyectar un ID de modelo a una ruta o acción de controlador, a menudo consultará para recuperar el modelo que corresponde a ese ID. El enlace del modelo de ruta de Laravel proporciona una forma conveniente de inyectar automáticamente las instancias del modelo directamente en sus rutas. Por ejemplo, en lugar de inyectar la ID de un usuario, puede inyectar toda la <code>User</code>instancia del modelo que coincida con la ID dada.</p>\n  <p></p>\n  <h3>Enlace implícito</h3>\n  <p>Laravel resuelve automáticamente los modelos Eloquent definidos en rutas o acciones de controlador cuyos nombres de variables con sugerencias de tipo coinciden con un nombre de segmento de ruta. Por ejemplo:</p>\n  <pre><code>Route::get('api/users/{user}', function (App\\Models\\User $user) {\n    return $user-&gt;email;\n});</code></pre>\n  <p>Dado que la <code>$user</code>variable está insinuada como modelo Eloquent y el nombre de la variable coincide con el segmento de URI, Laravel inyectará automáticamente la instancia del modelo que tiene una ID que coincide con el valor correspondiente de la URI de solicitud. Si no se encuentra una instancia de modelo coincidente en la base de datos, se generará automáticamente una respuesta HTTP 404.<code>App\\Models\\User</code><code>{user}</code></p>\n  <h4>Personalizando la clave</h4>\n  <p>A veces, es posible que desee resolver modelos de Eloquent utilizando una columna que no sea <code>id</code>. Para hacerlo, puede especificar la columna en la definición del parámetro de ruta:</p>\n  <pre><code>Route::get('api/posts/{post:slug}', function (App\\Models\\Post $post) {\n    return $post;\n});</code></pre>\n  <p></p>\n  <h4>Teclas personalizadas y alcance</h4>\n  <p>A veces, cuando se vinculan implícitamente varios modelos Eloquent en una definición de ruta única, es posible que desee establecer el alcance del segundo modelo Eloquent de manera que deba ser un hijo del primer modelo Eloquent. Por ejemplo, considere esta situación que recupera una publicación de blog por slug para un usuario específico:</p>\n  <pre><code>use App\\Models\\Post;\nuse App\\Models\\User;\n\nRoute::get('api/users/{user}/posts/{post:slug}', function (User $user, Post $post) {\n    return $post;\n});</code></pre>\n  <p>Cuando se usa un enlace implícito con clave personalizada como un parámetro de ruta anidado, Laravel buscará automáticamente el alcance de la consulta para recuperar el modelo anidado por su padre usando convenciones para adivinar el nombre de la relación en el padre. En este caso, se asumirá que el <code>User</code>modelo tiene una relación denominada <code>posts</code>(el plural del nombre del parámetro de ruta) que se puede utilizar para recuperar el <code>Post</code>modelo.</p>\n  <h4>Personalización del nombre de clave predeterminado</h4>\n  <p>Si desea que el enlace de modelos use una columna de base de datos predeterminada que no sea <code>id</code>cuando recupera una clase de modelo determinada, puede anular el <code>getRouteKeyName</code>método en el modelo Eloquent:</p>\n  <pre><code>/**\n * Get the route key for the model.\n *\n * @return string\n */\npublic function getRouteKeyName()\n{\n    return 'slug';\n}</code></pre>\n  <p></p>\n  <h3>Enlace explícito</h3>\n  <p>Para registrar un enlace explícito, use el <code>model</code>método del enrutador para especificar la clase para un parámetro dado. Debes definir tus enlaces de modelo explícitos al comienzo del <code>boot</code>método de tu <code>RouteServiceProvider</code>clase:</p>\n  <pre><code>/**\n * Define your route model bindings, pattern filters, etc.\n *\n * @return void\n */\npublic function boot()\n{\n    Route::model('user', App\\Models\\User::class);\n\n    // ...\n}</code></pre>\n  <p>A continuación, defina una ruta que contenga un parámetro:<code>{user}</code></p>\n  <pre><code>Route::get('profile/{user}', function (App\\Models\\User $user) {\n    //\n});</code></pre>\n  <p>Dado que hemos vinculado todos los parámetros al modelo, se inyectará una instancia en la ruta. Entonces, por ejemplo, una solicitud inyectará la instancia de la base de datos que tiene un ID de .<code>{user}</code><code>App\\Models\\User</code><code>User</code><code>profile/1</code><code>User</code><code>1</code></p>\n  <p>Si no se encuentra una instancia de modelo coincidente en la base de datos, se generará automáticamente una respuesta HTTP 404.</p>\n  <h4>Personalización de la lógica de resolución</h4>\n  <p>Si desea utilizar su propia lógica de resolución, puede utilizar el método. El que pase al método recibirá el valor del segmento de URI y debe devolver la instancia de la clase que debe inyectarse en la ruta:<code>Route::bind</code><code>Closure</code><code>bind</code></p>\n  <pre><code>/**\n * Define your route model bindings, pattern filters, etc.\n *\n * @return void\n */\npublic function boot()\n{\n    Route::bind('user', function ($value) {\n        return App\\Models\\User::where('name', $value)-&gt;firstOrFail();\n    });\n\n    // ...\n}</code></pre>\n  <p>Alternativamente, puede anular el <code>resolveRouteBinding</code>método en su modelo Eloquent. Este método recibirá el valor del segmento de URI y debería devolver la instancia de la clase que debería inyectarse en la ruta:</p>\n  <pre><code>/**\n * Retrieve the model for a bound value.\n *\n * @param  mixed  $value\n * @param  string|null  $field\n * @return \\Illuminate\\Database\\Eloquent\\Model|null\n */\npublic function resolveRouteBinding($value, $field = null)\n{\n    return $this-&gt;where('name', $value)-&gt;firstOrFail();\n}</code></pre>\n  <p></p>\n  <h2>Rutas de respaldo</h2>\n  <p>Con el método, puede definir una ruta que se ejecutará cuando ninguna otra ruta coincida con la solicitud entrante. Por lo general, las solicitudes no manejadas generarán automáticamente una página \"404\" a través del controlador de excepciones de su aplicación. Sin embargo, dado que puede definir la ruta dentro de su archivo, todo el middleware del grupo de middleware se aplicará a la ruta. Puede agregar middleware adicional a esta ruta según sea necesario:<code>Route::fallback</code><code>fallback</code><code>routes/web.php</code><code>web</code></p>\n  <pre><code>Route::fallback(function () {\n    //\n});</code></pre>\n  <blockquote>\n    <p> La ruta alternativa siempre debe ser la última ruta registrada por su aplicación.</p>\n  </blockquote>\n  <p></p>\n  <h2>Limitación de tasa</h2>\n  <p></p>\n  <h3>Definición de limitadores de velocidad</h3>\n  <p>Laravel incluye servicios de limitación de velocidad potentes y personalizables que puede utilizar para restringir la cantidad de tráfico para una ruta o grupo de rutas determinado. Para comenzar, debe definir configuraciones de limitador de velocidad que satisfagan las necesidades de su aplicación. Normalmente, esto se puede hacer en el archivo de su aplicación <code>RouteServiceProvider</code>.</p>\n  <p>Los limitadores de velocidad se definen utilizando el método <code>RateLimiter</code>de fachada <code>for</code>. El <code>for</code>método acepta un nombre de limitador de velocidad y un cierre que devuelve la configuración de límite que debe aplicarse a las rutas a las que se asigna este limitador de velocidad:</p>\n  <pre><code>use Illuminate\\Cache\\RateLimiting\\Limit;\nuse Illuminate\\Support\\Facades\\RateLimiter;\n\nRateLimiter::for('global', function (Request $request) {\n    return Limit::perMinute(1000);\n});</code></pre>\n  <p>Si la solicitud entrante excede el límite de velocidad especificado, Laravel devolverá automáticamente una respuesta con un código de estado HTTP 429. Si desea definir su propia respuesta que debe ser devuelta por un límite de tasa, puede usar el <code>response</code>método:</p>\n  <pre><code>RateLimiter::for('global', function (Request $request) {\n    return Limit::perMinute(1000)-&gt;response(function () {\n        return response('Custom response...', 429);\n    });\n});</code></pre>\n  <p>Dado que las devoluciones de llamada del limitador de tasa reciben la instancia de solicitud HTTP entrante, puede crear el límite de tasa apropiado de forma dinámica en función de la solicitud entrante o del usuario autenticado:</p>\n  <pre><code>RateLimiter::for('uploads', function (Request $request) {\n    return $request-&gt;user()-&gt;vipCustomer()\n                ? Limit::none()\n                : Limit::perMinute(100);\n});</code></pre>\n  <h4>Límites de velocidad de segmentación</h4>\n  <p>A veces, es posible que desee segmentar los límites de tasas por algún valor arbitrario. Por ejemplo, es posible que desee permitir que los usuarios accedan a una ruta determinada 100 veces por minuto por dirección IP. Para lograr esto, puede usar el <code>by</code>método al construir su límite de tasa:</p>\n  <pre><code>RateLimiter::for('uploads', function (Request $request) {\n    return $request-&gt;user()-&gt;vipCustomer()\n                ? Limit::none()\n                : Limit::perMinute(100)-&gt;by($request-&gt;ip());\n});</code></pre>\n  <h4>Límites de frecuencia múltiple</h4>\n  <p>Si es necesario, puede devolver una serie de límites de velocidad para una configuración de limitador de velocidad determinada. Cada límite de velocidad se evaluará para la ruta según el orden en que se colocan dentro de la matriz:</p>\n  <pre><code>RateLimiter::for('login', function (Request $request) {\n    return [\n        Limit::perMinute(500),\n        Limit::perMinute(3)-&gt;by($request-&gt;input('email')),\n    ];\n});</code></pre>\n  <p></p>\n  <h3>Colocación de limitadores de velocidad en rutas</h3>\n  <p>Se pueden adjuntar limitadores de velocidad a rutas o grupos de rutas mediante el <code>throttle</code> middleware . El middleware del acelerador acepta el nombre del limitador de velocidad que desea asignar a la ruta:</p>\n  <pre><code>Route::middleware(['throttle:uploads'])-&gt;group(function () {\n    Route::post('/audio', function () {\n        //\n    });\n\n    Route::post('/video', function () {\n        //\n    });\n});</code></pre>\n  <p></p>\n  <h2>Método de formulario suplantación</h2>\n  <p>HTML formas no son compatibles <code>PUT</code>, <code>PATCH</code>o <code>DELETE</code>acciones. Por lo tanto, en la definición <code>PUT</code>, <code>PATCH</code>o <code>DELETE</code>rutas que se llama desde un formulario HTML, tendrá que añadir un escondido <code>_method</code>campo al formulario. El valor enviado con el <code>_method</code>campo se utilizará como método de solicitud HTTP:</p>\n  <pre><code>&lt;form action=\"/foo/bar\" method=\"POST\"&gt;\n    &lt;input type=\"hidden\" name=\"_method\" value=\"PUT\"&gt;\n    &lt;input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\"&gt;\n&lt;/form&gt;</code></pre>\n  <p>Puede utilizar la <code>@method</code>directiva Blade para generar la <code>_method</code>entrada:</p>\n  <pre><code>&lt;form action=\"/foo/bar\" method=\"POST\"&gt;\n    @method('PUT')\n    @csrf\n&lt;/form&gt;</code></pre>\n  <p></p>\n  <h2>Accediendo a la ruta actual</h2>\n  <p>Es posible utilizar los <code>current</code>, <code>currentRouteName</code>y <code>currentRouteAction</code>métodos en la <code>Route</code>fachada de acceso a la información sobre el manejo de la solicitud entrante ruta:</p>\n  <pre><code>$route = Route::current();\n\n$name = Route::currentRouteName();\n\n$action = Route::currentRouteAction();</code></pre>\n  <p>Consulte la documentación de la API para conocer la clase subyacente de la fachada de la ruta y la instancia de la ruta para revisar todos los métodos accesibles.</p>\n  <p></p>\n  <h2>Uso compartido de recursos de origen cruzado (CORS)</h2>\n  <p>Laravel puede responder automáticamente a las solicitudes CORS OPTIONS con los valores que usted configure. Todas las configuraciones de CORS pueden configurarse en su <code>cors</code>archivo de configuración y las solicitudes de OPCIONES serán manejadas automáticamente por el <code>HandleCors</code>middleware que se incluye por defecto en su pila global de middleware.</p>\n  <blockquote>\n    <p>Para obtener más información sobre CORS y los encabezados CORS, consulte la documentación web de MDN sobre CORS .</p>\n  </blockquote>\n</section>"
      },
      {
        "titulo": "3.2 Middleware",
        "contenido": "<section>\n\n\n  <h1>Middleware</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Definición de middleware</li>\n    <li>Registro de middleware\n      <ul>\n        <li>Middleware global</li>\n        <li>Asignación de middleware a rutas</li>\n        <li>Grupos de middleware</li>\n        <li>Clasificación de middleware</li>\n      </ul></li>\n    <li>Parámetros de middleware</li>\n    <li>Middleware terminable</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>El middleware proporciona un mecanismo conveniente para filtrar las solicitudes HTTP que ingresan a su aplicación. Por ejemplo, Laravel incluye un middleware que verifica que el usuario de su aplicación esté autenticado. Si el usuario no está autenticado, el middleware redirigirá al usuario a la pantalla de inicio de sesión. Sin embargo, si el usuario está autenticado, el middleware permitirá que la solicitud continúe en la aplicación.</p>\n  <p>Se puede escribir middleware adicional para realizar una variedad de tareas además de la autenticación. Un middleware CORS podría ser responsable de agregar los encabezados adecuados a todas las respuestas que salen de su aplicación. Un middleware de registro puede registrar todas las solicitudes entrantes en su aplicación.</p>\n  <p>Hay varios middleware incluidos en el marco de Laravel, incluido el middleware para la autenticación y la protección CSRF. Todos estos middleware se encuentran en el directorio.<code>app/Http/Middleware</code></p>\n  <p></p>\n  <h2>Definición de middleware</h2>\n  <p>Para crear un nuevo middleware, use el comando Artisan:<code>make:middleware</code></p>\n  <pre><code>php artisan make:middleware CheckAge</code></pre>\n  <p>Este comando colocará una nueva <code>CheckAge</code>clase dentro de su directorio. En este middleware, solo permitiremos el acceso a la ruta si el suministro es mayor que 200. De lo contrario, redirigiremos a los usuarios de nuevo al URI:<code>app/Http/Middleware</code><code>age</code><code>home</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass CheckAge\n{\n    /**\n     * Handle an incoming request.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Closure  $next\n     * @return mixed\n     */\n    public function handle($request, Closure $next)\n    {\n        if ($request-&gt;age &lt;= 200) {\n            return redirect('home');\n        }\n\n        return $next($request);\n    }\n}</code></pre>\n  <p>Como puede ver, si el valor dado <code>age</code>es menor o igual que <code>200</code>, el middleware devolverá una redirección HTTP al cliente; de lo contrario, la solicitud se pasará a la aplicación. Para pasar la solicitud más profundamente en la aplicación (permitiendo que el middleware \"pase\"), llame a la <code>$next</code>devolución de llamada con <code>$request</code>.</p>\n  <p>Es mejor imaginarse el middleware como una serie de \"capas\" que las solicitudes HTTP deben atravesar antes de que lleguen a su aplicación. Cada capa puede examinar la solicitud e incluso rechazarla por completo.</p>\n  <blockquote>\n    <p>Todo el middleware se resuelve a través del contenedor de servicios , por lo que puede indicar cualquier dependencia que necesite dentro del constructor de un middleware.</p>\n  </blockquote>\n  <h4>Middleware antes y después</h4>\n  <p>La ejecución de un middleware antes o después de una solicitud depende del propio middleware. Por ejemplo, el siguiente middleware realizaría alguna tarea <strong>antes</strong> de que la aplicación maneje la solicitud:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass BeforeMiddleware\n{\n    public function handle($request, Closure $next)\n    {\n        // Perform action\n\n        return $next($request);\n    }\n}</code></pre>\n  <p>Sin embargo, este middleware realizaría su tarea <strong>después</strong> de que la aplicación maneje la solicitud:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass AfterMiddleware\n{\n    public function handle($request, Closure $next)\n    {\n        $response = $next($request);\n\n        // Perform action\n\n        return $response;\n    }\n}</code></pre>\n  <p></p>\n  <h2>Registro de middleware</h2>\n  <p></p>\n  <h3>Middleware global</h3>\n  <p>Si desea que se ejecute un middleware durante cada solicitud HTTP a su aplicación, enumere la clase de middleware en la <code>$middleware</code>propiedad de su clase.<code>app/Http/Kernel.php</code></p>\n  <p></p>\n  <h3>Asignación de middleware a rutas</h3>\n  <p>Si desea asignar middleware a rutas específicas, primero debe asignar al middleware una clave en su archivo. De forma predeterminada, la propiedad de esta clase contiene entradas para el middleware incluido con Laravel. Para agregar el suyo, añádalo a esta lista y asígnele una clave de su elección:<code>app/Http/Kernel.php</code><code>$routeMiddleware</code></p>\n  <pre><code>// Within App\\Http\\Kernel Class...\n\nprotected $routeMiddleware = [\n    'auth' =&gt; \\App\\Http\\Middleware\\Authenticate::class,\n    'auth.basic' =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\n    'bindings' =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n    'cache.headers' =&gt; \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class,\n    'can' =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class,\n    'guest' =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\n    'signed' =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,\n    'throttle' =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\n    'verified' =&gt; \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,\n];</code></pre>\n  <p>Una vez que se ha definido el middleware en el kernel HTTP, puede usar el <code>middleware</code>método para asignar middleware a una ruta:</p>\n  <pre><code>Route::get('admin/profile', function () {\n    //\n})-&gt;middleware('auth');</code></pre>\n  <p>También puede asignar varios middleware a la ruta:</p>\n  <pre><code>Route::get('/', function () {\n    //\n})-&gt;middleware('first', 'second');</code></pre>\n  <p>Al asignar middleware, también puede pasar el nombre de clase completo:</p>\n  <pre><code>use App\\Http\\Middleware\\CheckAge;\n\nRoute::get('admin/profile', function () {\n    //\n})-&gt;middleware(CheckAge::class);</code></pre>\n  <p>Al asignar middleware a un grupo de rutas, es posible que ocasionalmente necesite evitar que el middleware se aplique a una ruta individual dentro del grupo. Puede lograr esto usando el <code>withoutMiddleware</code>método:</p>\n  <pre><code>use App\\Http\\Middleware\\CheckAge;\n\nRoute::middleware([CheckAge::class])-&gt;group(function () {\n    Route::get('/', function () {\n        //\n    });\n\n    Route::get('admin/profile', function () {\n        //\n    })-&gt;withoutMiddleware([CheckAge::class]);\n});</code></pre>\n  <p>El <code>withoutMiddleware</code>método solo puede eliminar el middleware de ruta y no se aplica al middleware global .</p>\n  <p></p>\n  <h3>Grupos de middleware</h3>\n  <p>A veces, es posible que desee agrupar varios middleware en una sola tecla para facilitar su asignación a las rutas. Puede hacer esto usando la <code>$middlewareGroups</code>propiedad de su kernel HTTP.</p>\n  <p>Fuera de la caja, viene con laravel <code>web</code>y <code>api</code>grupos de middleware que contienen middleware común es posible que desee aplicar a la interfaz de usuario web y la API de rutas:</p>\n  <pre><code>/**\n * The application's route middleware groups.\n *\n * @var array\n */\nprotected $middlewareGroups = [\n    'web' =&gt; [\n        \\App\\Http\\Middleware\\EncryptCookies::class,\n        \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class,\n        \\Illuminate\\Session\\Middleware\\StartSession::class,\n        \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\n        \\App\\Http\\Middleware\\VerifyCsrfToken::class,\n        \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n    ],\n\n    'api' =&gt; [\n        'throttle:60,1',\n        'auth:api',\n    ],\n];</code></pre>\n  <p>Los grupos de middleware se pueden asignar a rutas y acciones de controlador utilizando la misma sintaxis que el middleware individual. Nuevamente, los grupos de middleware hacen que sea más conveniente asignar muchos middleware a una ruta a la vez:</p>\n  <pre><code>Route::get('/', function () {\n    //\n})-&gt;middleware('web');\n\nRoute::group(['middleware' =&gt; ['web']], function () {\n    //\n});\n\nRoute::middleware(['web', 'subscribed'])-&gt;group(function () {\n    //\n});</code></pre>\n  <blockquote>\n    <p>Fuera de la caja, el <code>web</code>grupo de middleware se aplica automáticamente a su archivo mediante .<code>routes/web.php</code><code>RouteServiceProvider</code></p>\n  </blockquote>\n  <p></p>\n  <h3>Clasificación de middleware</h3>\n  <p>En raras ocasiones, es posible que necesite que su middleware se ejecute en un orden específico, pero no tenga control sobre su orden cuando se asignan a la ruta. En este caso, puede especificar su prioridad de middleware utilizando la <code>$middlewarePriority</code>propiedad de su archivo:<code>app/Http/Kernel.php</code></p>\n  <pre><code>/**\n * The priority-sorted list of middleware.\n *\n * This forces non-global middleware to always be in the given order.\n *\n * @var array\n */\nprotected $middlewarePriority = [\n    \\Illuminate\\Session\\Middleware\\StartSession::class,\n    \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\n    \\Illuminate\\Contracts\\Auth\\Middleware\\AuthenticatesRequests::class,\n    \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\n    \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,\n    \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n    \\Illuminate\\Auth\\Middleware\\Authorize::class,\n];</code></pre>\n  <p></p>\n  <h2>Parámetros de middleware</h2>\n  <p>El middleware también puede recibir parámetros adicionales. Por ejemplo, si su aplicación necesita verificar que el usuario autenticado tiene un \"rol\" determinado antes de realizar una acción determinada, puede crear un <code>CheckRole</code>middleware que reciba un nombre de rol como argumento adicional.</p>\n  <p>Los parámetros de middleware adicionales se pasarán al middleware después del <code>$next</code>argumento:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass CheckRole\n{\n    /**\n     * Handle the incoming request.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Closure  $next\n     * @param  string  $role\n     * @return mixed\n     */\n    public function handle($request, Closure $next, $role)\n    {\n        if (! $request-&gt;user()-&gt;hasRole($role)) {\n            // Redirect...\n        }\n\n        return $next($request);\n    }\n\n}</code></pre>\n  <p>Los parámetros del middleware se pueden especificar al definir la ruta separando el nombre y los parámetros del middleware con un <code>:</code>. Los parámetros múltiples deben estar delimitados por comas:</p>\n  <pre><code>Route::put('post/{id}', function ($id) {\n    //\n})-&gt;middleware('role:editor');</code></pre>\n  <p></p>\n  <h2>Middleware terminable</h2>\n  <p>A veces, es posible que un middleware deba realizar algún trabajo después de que se haya enviado la respuesta HTTP al navegador. Si define un <code>terminate</code>método en su middleware y su servidor web está utilizando FastCGI, el <code>terminate</code>método se llamará automáticamente después de que se envíe la respuesta al navegador:</p>\n  <pre><code>&lt;?php\n\nnamespace Illuminate\\Session\\Middleware;\n\nuse Closure;\n\nclass StartSession\n{\n    public function handle($request, Closure $next)\n    {\n        return $next($request);\n    }\n\n    public function terminate($request, $response)\n    {\n        // Store the session data...\n    }\n}</code></pre>\n  <p>El <code>terminate</code>método debe recibir tanto la solicitud como la respuesta. Una vez que haya definido un middleware terminable, debe agregarlo a la lista de ruta o middleware global en el archivo.<code>app/Http/Kernel.php</code></p>\n  <p>Al llamar al <code>terminate</code>método en su middleware, Laravel resolverá una nueva instancia del middleware desde el contenedor de servicios . Si desea utilizar la misma instancia de middleware cuando se llama a los métodos <code>handle</code>y <code>terminate</code>, registre el middleware con el contenedor utilizando el <code>singleton</code>método del contenedor . Por lo general, esto debe hacerse en el <code>register</code>método de su :<code>AppServiceProvider.php</code></p>\n  <pre><code>use App\\Http\\Middleware\\TerminableMiddleware;\n\n/**\n * Register any application services.\n *\n * @return void\n */\npublic function register()\n{\n    $this-&gt;app-&gt;singleton(TerminableMiddleware::class);\n}</code></pre>\n</section>"
      },
      {
        "titulo": "3.3 Protección CSRF",
        "contenido": "<section>\n  <h1>Protección CSRF</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Excluyendo URI</li>\n    <li>Token X-CSRF</li>\n    <li>Token X-XSRF</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel facilita la protección de su aplicación de los ataques de falsificación de solicitudes entre sitios (CSRF). Las falsificaciones de solicitudes entre sitios son un tipo de exploit malicioso mediante el cual se ejecutan comandos no autorizados en nombre de un usuario autenticado.</p>\n  <p>Laravel genera automáticamente un \"token\" CSRF para cada sesión de usuario activa administrada por la aplicación. Este token se utiliza para verificar que el usuario autenticado es el que realmente realiza las solicitudes a la aplicación.</p>\n  <p>Siempre que defina un formulario HTML en su aplicación, debe incluir un campo de token CSRF oculto en el formulario para que el middleware de protección CSRF pueda validar la solicitud. Puede utilizar la <code>@csrf</code>directiva Blade para generar el campo token:</p>\n  <pre><code>&lt;form method=\"POST\" action=\"/profile\"&gt;\n    @csrf\n    ...\n&lt;/form&gt;</code></pre>\n  <p>El <code>VerifyCsrfToken</code> middleware , que se incluye en el <code>web</code>grupo de middleware, verificará automáticamente que el token en la entrada de la solicitud coincide con el token almacenado en la sesión.</p>\n  <h4>Tokens CSRF y JavaScript</h4>\n  <p>Al crear aplicaciones basadas en JavaScript, es conveniente que su biblioteca HTTP de JavaScript adjunte automáticamente el token CSRF a cada solicitud saliente. De forma predeterminada, la biblioteca HTTP de Axios proporcionada en el archivo envía automáticamente un encabezado utilizando el valor de la cookie cifrada . Si no está utilizando esta biblioteca, deberá configurar manualmente este comportamiento para su aplicación.<code>resources/js/bootstrap.js</code><code>X-XSRF-TOKEN</code><code>XSRF-TOKEN</code></p>\n  <p></p>\n  <h2>Excluir URI de la protección CSRF</h2>\n  <p>A veces, es posible que desee excluir un conjunto de URI de la protección CSRF. Por ejemplo, si está utilizando Stripe para procesar pagos y está utilizando su sistema de webhook, deberá excluir la ruta del controlador de webhook de Stripe de la protección CSRF, ya que Stripe no sabrá qué token CSRF enviar a sus rutas.</p>\n  <p>Normalmente, debería colocar este tipo de rutas fuera del <code>web</code>grupo de middleware que se <code>RouteServiceProvider</code>aplica a todas las rutas del archivo. Sin embargo, también puede excluir las rutas agregando sus URI a la propiedad del middleware:<code>routes/web.php</code><code>$except</code><code>VerifyCsrfToken</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware;\n\nclass VerifyCsrfToken extends Middleware\n{\n    /**\n     * The URIs that should be excluded from CSRF verification.\n     *\n     * @var array\n     */\n    protected $except = [\n        'stripe/*',\n        'http://example.com/foo/bar',\n        'http://example.com/foo/*',\n    ];\n}</code></pre>\n  <blockquote>\n    <p>El middleware CSRF se desactiva automáticamente al ejecutar pruebas .</p>\n  </blockquote>\n  <p></p>\n  <h2>X-CSRF-TOKEN</h2>\n  <p>Además de comprobar el token CSRF como parámetro POST, el <code>VerifyCsrfToken</code>middleware también comprobará el encabezado de la solicitud. Podría, por ejemplo, almacenar el token en una etiqueta HTML :<code>X-CSRF-TOKEN</code><code>meta</code></p>\n  <pre><code>&lt;meta name=\"csrf-token\" content=\"{{ csrf_token() }}\"&gt;</code></pre>\n  <p>Luego, una vez que haya creado la <code>meta</code>etiqueta, puede indicar a una biblioteca como jQuery que agregue automáticamente el token a todos los encabezados de solicitud. Esto proporciona una protección CSRF simple y conveniente para sus aplicaciones basadas en AJAX:</p>\n  <pre><code>$.ajaxSetup({\n    headers: {\n        'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')\n    }\n});</code></pre>\n  <p></p>\n  <h2>X-XSRF-TOKEN</h2>\n  <p>Laravel almacena el token CSRF actual en una cookie cifrada que se incluye con cada respuesta generada por el marco. Puede utilizar el valor de la cookie para configurar el encabezado de la solicitud.<code>XSRF-TOKEN</code><code>X-XSRF-TOKEN</code></p>\n  <p>Esta cookie se envía principalmente para su conveniencia, ya que algunos marcos y bibliotecas de JavaScript, como Angular y Axios, colocan automáticamente su valor en el encabezado de las solicitudes del mismo origen.<code>X-XSRF-TOKEN</code></p>\n  <blockquote>\n    <p>De forma predeterminada, el archivo incluye la biblioteca HTTP de Axios, que se lo enviará automáticamente.<code>resources/js/bootstrap.js</code></p>\n  </blockquote>\n</section>"
      },
      {
        "titulo": "3.4 Controladores",
        "contenido": "<section>\n  <h1>Controladores</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Controladores básicos\n      <ul>\n        <li>Definición de controladores</li>\n        <li>Controladores de acción simple</li>\n      </ul></li>\n    <li>Middleware del controlador</li>\n    <li>Controladores de recursos\n      <ul>\n        <li>Rutas de recursos parciales</li>\n        <li>Recursos anidados</li>\n        <li>Nombrar rutas de recursos</li>\n        <li>Nombrar parámetros de ruta de recursos</li>\n        <li>Rutas de recursos de alcance</li>\n        <li>Localización de URI de recursos</li>\n        <li>Complementando controladores de recursos</li>\n      </ul></li>\n    <li>Inyección de dependencia y controladores</li>\n    <li>Caché de ruta</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>En lugar de definir toda su lógica de manejo de solicitudes como cierres en archivos de ruta, es posible que desee organizar este comportamiento utilizando clases de controlador. Los controladores pueden agrupar la lógica de manejo de solicitudes relacionadas en una sola clase. Los controladores se almacenan en el directorio.<code>app/Http/Controllers</code></p>\n  <p></p>\n  <h2>Controladores básicos</h2>\n  <p></p>\n  <h3>Definición de controladores</h3>\n  <p>A continuación se muestra un ejemplo de una clase de controlador básica. Tenga en cuenta que el controlador extiende la clase de controlador base incluida con Laravel. La clase base proporciona algunos métodos convenientes, como el <code>middleware</code>método, que se puede utilizar para adjuntar middleware a las acciones del controlador:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\User;\n\nclass UserController extends Controller\n{\n    /**\n     * Show the profile for the given user.\n     *\n     * @param  int  $id\n     * @return View\n     */\n    public function show($id)\n    {\n        return view('user.profile', ['user' =&gt; User::findOrFail($id)]);\n    }\n}</code></pre>\n  <p>Puede definir una ruta a esta acción del controlador así:</p>\n  <pre><code>use App\\Http\\Controllers\\UserController;\n\nRoute::get('user/{id}', [UserController::class, 'show']);</code></pre>\n  <p>Ahora, cuando una solicitud coincide con el URI de ruta especificado, se ejecutará el <code>show</code>método de la <code>UserController</code>clase. Los parámetros de la ruta también se pasarán al método.</p>\n  <blockquote>\n    <p>No es <strong>necesario</strong> que los controladores amplíen una clase base. Sin embargo, usted no tendrá acceso a características prácticas tales como los <code>middleware</code>, <code>validate</code>y <code>dispatch</code>métodos.</p>\n  </blockquote>\n  <p></p>\n  <h3>Controladores de acción simple</h3>\n  <p>Si desea definir un controlador que solo maneja una sola acción, puede colocar un único <code>__invoke</code>método en el controlador:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\User;\n\nclass ShowProfile extends Controller\n{\n    /**\n     * Show the profile for the given user.\n     *\n     * @param  int  $id\n     * @return View\n     */\n    public function __invoke($id)\n    {\n        return view('user.profile', ['user' =&gt; User::findOrFail($id)]);\n    }\n}</code></pre>\n  <p>Al registrar rutas para controladores de acción única, no es necesario especificar un método:</p>\n  <pre><code>use App\\Http\\Controllers\\ShowProfile;\n\nRoute::get('user/{id}', ShowProfile::class);</code></pre>\n  <p>Puede generar un controlador invocable utilizando la <code>--invokable</code>opción del comando Artisan:<code>make:controller</code></p>\n  <pre><code>php artisan make:controller ShowProfile --invokable</code></pre>\n  <blockquote>\n    <p>Los stubs del controlador se pueden personalizar mediante la publicación de stub</p>\n  </blockquote>\n  <p></p>\n  <h2>Middleware del controlador</h2>\n  <p>Se puede asignar middleware a las rutas del controlador en sus archivos de ruta:</p>\n  <pre><code>Route::get('profile', [UserController::class, 'show'])-&gt;middleware('auth');</code></pre>\n  <p>Sin embargo, es más conveniente especificar middleware dentro del constructor de su controlador. Usando el <code>middleware</code>método del constructor de su controlador, puede asignar fácilmente middleware a la acción del controlador. Incluso puede restringir el middleware a solo ciertos métodos en la clase de controlador:</p>\n  <pre><code>class UserController extends Controller\n{\n    /**\n     * Instantiate a new controller instance.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        $this-&gt;middleware('auth');\n\n        $this-&gt;middleware('log')-&gt;only('index');\n\n        $this-&gt;middleware('subscribed')-&gt;except('store');\n    }\n}</code></pre>\n  <p>Los controladores también le permiten registrar middleware mediante un cierre. Esto proporciona una forma conveniente de definir un middleware para un solo controlador sin definir una clase de middleware completa:</p>\n  <pre><code>$this-&gt;middleware(function ($request, $next) {\n    // ...\n\n    return $next($request);\n});</code></pre>\n  <blockquote>\n    <p>Puede asignar middleware a un subconjunto de acciones del controlador; sin embargo, puede indicar que su controlador está creciendo demasiado. En su lugar, considere dividir su controlador en varios controladores más pequeños.</p>\n  </blockquote>\n  <p></p>\n  <h2>Controladores de recursos</h2>\n  <p>El enrutamiento de recursos de Laravel asigna las típicas rutas \"CRUD\" a un controlador con una sola línea de código. Por ejemplo, es posible que desee crear un controlador que maneje todas las solicitudes HTTP de \"fotos\" almacenadas por su aplicación. Usando el comando Artisan, podemos crear rápidamente dicho controlador:<code>make:controller</code></p>\n  <pre><code>php artisan make:controller PhotoController --resource</code></pre>\n  <p>Este comando generará un controlador en . El controlador contendrá un método para cada una de las operaciones de recursos disponibles.<code>app/Http/Controllers/PhotoController.php</code></p>\n  <p>A continuación, puede registrar una ruta ingeniosa al controlador:</p>\n  <pre><code>Route::resource('photos', PhotoController::class);</code></pre>\n  <p>Esta declaración de ruta única crea múltiples rutas para manejar una variedad de acciones en el recurso. El controlador generado ya tendrá métodos stubped para cada una de estas acciones, incluidas notas que le informan de los verbos HTTP y URI que manejan.</p>\n  <p>Puede registrar muchos controladores de recursos a la vez pasando una matriz al <code>resources</code>método:</p>\n  <pre><code>Route::resources([\n    'photos' =&gt; PhotoController::class,\n    'posts' =&gt; PostController::class,\n]);</code></pre>\n  <h4>Acciones manejadas por el controlador de recursos</h4>\n  <table>\n    <thead>\n    <tr>\n      <th>Verbo</th>\n      <th>URI</th>\n      <th>Acción</th>\n      <th>Nombre de ruta</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td>OBTENER</td>\n      <td><code>/photos</code></td>\n      <td>índice</td>\n      <td>photos.index</td>\n    </tr>\n    <tr>\n      <td>OBTENER</td>\n      <td><code>/photos/create</code></td>\n      <td>crear</td>\n      <td>fotos.crear</td>\n    </tr>\n    <tr>\n      <td>ENVIAR</td>\n      <td><code>/photos</code></td>\n      <td>Tienda</td>\n      <td>photos.store</td>\n    </tr>\n    <tr>\n      <td>OBTENER</td>\n      <td><code>/photos/{photo}</code></td>\n      <td>espectáculo</td>\n      <td>fotos.show</td>\n    </tr>\n    <tr>\n      <td>OBTENER</td>\n      <td><code>/photos/{photo}/edit</code></td>\n      <td>editar</td>\n      <td>photos.editar</td>\n    </tr>\n    <tr>\n      <td>PONER / PATCH</td>\n      <td><code>/photos/{photo}</code></td>\n      <td>actualizar</td>\n      <td>photos.update</td>\n    </tr>\n    <tr>\n      <td>ELIMINAR</td>\n      <td><code>/photos/{photo}</code></td>\n      <td>destruir</td>\n      <td>fotos.destruir</td>\n    </tr>\n    </tbody>\n  </table>\n  <h4>Especificar el modelo de recursos</h4>\n  <p>Si está utilizando la vinculación del modelo de ruta y le gustaría que los métodos del controlador de recursos escribieran una sugerencia de una instancia de modelo, puede usar la <code>--model</code>opción al generar el controlador:</p>\n  <pre><code>php artisan make:controller PhotoController --resource --model=Photo</code></pre>\n  <p></p>\n  <h3>Rutas de recursos parciales</h3>\n  <p>Al declarar una ruta de recursos, puede especificar un subconjunto de acciones que el controlador debe manejar en lugar del conjunto completo de acciones predeterminadas:</p>\n  <pre><code>Route::resource('photos', PhotoController::class)-&gt;only([\n    'index', 'show'\n]);\n\nRoute::resource('photos', PhotoController::class)-&gt;except([\n    'create', 'store', 'update', 'destroy'\n]);</code></pre>\n  <h4>Rutas de recursos de API</h4>\n  <p>Al declarar rutas de recursos que serán consumidas por las API, normalmente querrá excluir rutas que presenten plantillas HTML como <code>create</code>y <code>edit</code>. Por conveniencia, puede utilizar el <code>apiResource</code>método para excluir automáticamente estas dos rutas:</p>\n  <pre><code>Route::apiResource('photos', PhotoController::class);</code></pre>\n  <p>Puede registrar muchos controladores de recursos API a la vez pasando una matriz al <code>apiResources</code>método:</p>\n  <pre><code>Route::apiResources([\n    'photos' =&gt; PhotoController::class,\n    'posts' =&gt; PostController::class,\n]);</code></pre>\n  <p>Para generar rápidamente un controlador de recursos de API que no incluya los métodos <code>create</code>o <code>edit</code>, use el <code>--api</code>conmutador al ejecutar el comando:<code>make:controller</code></p>\n  <pre><code>php artisan make:controller API/PhotoController --api</code></pre>\n  <p></p>\n  <h3>Recursos anidados</h3>\n  <p>A veces, es posible que deba definir rutas a un recurso anidado. Por ejemplo, un recurso de fotografía puede tener varios comentarios que se pueden adjuntar a la fotografía. Para anidar los controladores de recursos, use la notación \"punto\" en su declaración de ruta:</p>\n  <pre><code>Route::resource('photos.comments', PhotoCommentController::class);</code></pre>\n  <p>Esta ruta registrará un recurso anidado al que se puede acceder con URI como los siguientes:</p>\n  <pre><code>/photos/{photo}/comments/{comment}</code></pre>\n  <h4>Alcance de los recursos anidados</h4>\n  <p>La función de enlace de modelo implícito de Laravel puede abarcar automáticamente enlaces anidados de modo que se confirme que el modelo hijo resuelto pertenece al modelo padre. Al usar el <code>scoped</code>método al definir su recurso anidado, puede habilitar el alcance automático e indicar a Laravel qué campo debe recuperar el recurso secundario:</p>\n  <pre><code>Route::resource('photos.comments', PhotoCommentController::class)-&gt;scoped([\n    'comment' =&gt; 'slug',\n]);</code></pre>\n  <p>Esta ruta registrará un recurso anidado con ámbito al que se puede acceder con URI como los siguientes:</p>\n  <pre><code>/photos/{photo}/comments/{comment:slug}</code></pre>\n  <h4>Anidamiento poco profundo</h4>\n  <p>A menudo, no es del todo necesario tener los identificadores principal y secundario dentro de un URI, ya que el identificador secundario ya es un identificador único. Cuando utilice un identificador único, como las claves primarias de incremento automático para identificar sus modelos en segmentos de URI, puede optar por utilizar \"anidación superficial\":</p>\n  <pre><code>Route::resource('photos.comments', CommentController::class)-&gt;shallow();</code></pre>\n  <p>La definición de ruta anterior definirá las siguientes rutas:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Verbo</th>\n      <th>URI</th>\n      <th>Acción</th>\n      <th>Nombre de ruta</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td>OBTENER</td>\n      <td><code>/photos/{photo}/comments</code></td>\n      <td>índice</td>\n      <td>photos.comments.index</td>\n    </tr>\n    <tr>\n      <td>OBTENER</td>\n      <td><code>/photos/{photo}/comments/create</code></td>\n      <td>crear</td>\n      <td>photos.comments.create</td>\n    </tr>\n    <tr>\n      <td>ENVIAR</td>\n      <td><code>/photos/{photo}/comments</code></td>\n      <td>Tienda</td>\n      <td>photos.comments.store</td>\n    </tr>\n    <tr>\n      <td>OBTENER</td>\n      <td><code>/comments/{comment}</code></td>\n      <td>espectáculo</td>\n      <td>comentarios mostrar</td>\n    </tr>\n    <tr>\n      <td>OBTENER</td>\n      <td><code>/comments/{comment}/edit</code></td>\n      <td>editar</td>\n      <td>comentarios.editar</td>\n    </tr>\n    <tr>\n      <td>PONER / PATCH</td>\n      <td><code>/comments/{comment}</code></td>\n      <td>actualizar</td>\n      <td>comentarios.update</td>\n    </tr>\n    <tr>\n      <td>ELIMINAR</td>\n      <td><code>/comments/{comment}</code></td>\n      <td>destruir</td>\n      <td>comentarios.destruir</td>\n    </tr>\n    </tbody>\n  </table>\n  <p></p>\n  <h3>Nombrar rutas de recursos</h3>\n  <p>De forma predeterminada, todas las acciones del controlador de recursos tienen un nombre de ruta; sin embargo, puede anular estos nombres pasando una <code>names</code>matriz con sus opciones:</p>\n  <pre><code>Route::resource('photos', PhotoController::class)-&gt;names([\n    'create' =&gt; 'photos.build'\n]);</code></pre>\n  <p></p>\n  <h3>Nombrar parámetros de ruta de recursos</h3>\n  <p>De forma predeterminada, creará los parámetros de ruta para sus rutas de recursos en función de la versión \"singularizada\" del nombre del recurso. Puede anular esto fácilmente por recurso utilizando el método. La matriz que se pasa al método debe ser una matriz asociativa de nombres de recursos y nombres de parámetros:<code>Route::resource</code><code>parameters</code><code>parameters</code></p>\n  <pre><code>Route::resource('users', AdminUserController::class)-&gt;parameters([\n    'users' =&gt; 'admin_user'\n]);</code></pre>\n  <p>El ejemplo anterior genera los siguientes URI para la <code>show</code>ruta del recurso :</p>\n  <pre><code>/users/{admin_user}</code></pre>\n  <p></p>\n  <h3>Rutas de recursos de alcance</h3>\n  <p>A veces, al vincular implícitamente múltiples modelos Eloquent en definiciones de ruta de recursos, es posible que desee establecer el alcance del segundo modelo Eloquent de manera que deba ser un hijo del primer modelo Eloquent. Por ejemplo, considere esta situación que recupera una publicación de blog por slug para un usuario específico:</p>\n  <pre><code>use App\\Http\\Controllers\\PostsController;\n\nRoute::resource('users.posts', PostsController::class)-&gt;scoped();</code></pre>\n  <p>Puede anular las claves de ruta del modelo predeterminadas pasando una matriz al <code>scoped</code>método:</p>\n  <pre><code>use App\\Http\\Controllers\\PostsController;\n\nRoute::resource('users.posts', PostsController::class)-&gt;scoped([\n    'post' =&gt; 'slug',\n]);</code></pre>\n  <p>Cuando se usa un enlace implícito con clave personalizada como un parámetro de ruta anidado, Laravel buscará automáticamente el alcance de la consulta para recuperar el modelo anidado por su padre usando convenciones para adivinar el nombre de la relación en el padre. En este caso, se asumirá que el <code>User</code>modelo tiene una relación denominada <code>posts</code>(el plural del nombre del parámetro de ruta) que se puede utilizar para recuperar el <code>Post</code>modelo.</p>\n  <p></p>\n  <h3>Localización de URI de recursos</h3>\n  <p>De forma predeterminada, creará URI de recursos utilizando verbos en inglés. Si necesita localizar los verbos de acción y , puede usar el método. Esto se puede hacer con el método de su :<code>Route::resource</code><code>create</code><code>edit</code><code>Route::resourceVerbs</code><code>boot</code><code>AppServiceProvider</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Route;\n\n/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    Route::resourceVerbs([\n        'create' =&gt; 'crear',\n        'edit' =&gt; 'editar',\n    ]);\n}</code></pre>\n  <p>Una vez que se han personalizado los verbos, un registro de ruta de recursos como , producirá los siguientes URI:<code>Route::resource('fotos', 'PhotoController')</code></p>\n  <pre><code>/fotos/crear\n\n/fotos/{foto}/editar</code></pre>\n  <p></p>\n  <h3>Complementando controladores de recursos</h3>\n  <p>Si necesita agregar rutas adicionales a un controlador de recursos más allá del conjunto predeterminado de rutas de recursos, debe definir esas rutas antes de su llamada a ; de lo contrario, las rutas definidas por el método pueden tener precedencia involuntaria sobre sus rutas complementarias:<code>Route::resource</code><code>resource</code></p>\n  <pre><code>Route::get('photos/popular', [PhotoController::class, 'popular']);\n\nRoute::resource('photos', PhotoController::class);</code></pre>\n  <blockquote>\n    <p>Recuerde mantener sus controladores enfocados. Si encuentra que necesita métodos de forma rutinaria fuera del conjunto típico de acciones de recursos, considere dividir su controlador en dos controladores más pequeños.</p>\n  </blockquote>\n  <p></p>\n  <h2>Inyección de dependencia y controladores</h2>\n  <h4>Inyección de constructor</h4>\n  <p>El contenedor de servicios de Laravel se utiliza para resolver todos los controladores de Laravel. Como resultado, puede escribir sugerencias sobre cualquier dependencia que su controlador pueda necesitar en su constructor. Las dependencias declaradas se resolverán e inyectarán automáticamente en la instancia del controlador:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Repositories\\UserRepository;\n\nclass UserController extends Controller\n{\n    /**\n     * The user repository instance.\n     */\n    protected $users;\n\n    /**\n     * Create a new controller instance.\n     *\n     * @param  UserRepository  $users\n     * @return void\n     */\n    public function __construct(UserRepository $users)\n    {\n        $this-&gt;users = $users;\n    }\n}</code></pre>\n  <p>También puede escribir sugerencias sobre cualquier contrato de Laravel . Si el contenedor puede resolverlo, puede escribir una sugerencia. Dependiendo de su aplicación, inyectar sus dependencias en su controlador puede proporcionar una mejor capacidad de prueba.</p>\n  <h4>Método de inyección</h4>\n  <p>Además de la inyección del constructor, también puede escribir dependencias de sugerencia en los métodos de su controlador. Un caso de uso común para la inyección de métodos es inyectar la instancia en los métodos de su controlador:<code>Illuminate\\Http\\Request</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass UserController extends Controller\n{\n    /**\n     * Store a new user.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        $name = $request-&gt;name;\n\n        //\n    }\n}</code></pre>\n  <p>Si su método de controlador también espera la entrada de un parámetro de ruta, enumere los argumentos de su ruta después de sus otras dependencias. Por ejemplo, si su ruta se define así:</p>\n  <pre><code>Route::put('user/{id}', [UserController::class, 'update']);</code></pre>\n  <p>Aún puede escribir sugerencias y acceder a su parámetro definiendo su método de controlador de la siguiente manera:<code>Illuminate\\Http\\Request</code><code>id</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass UserController extends Controller\n{\n    /**\n     * Update the given user.\n     *\n     * @param  Request  $request\n     * @param  string  $id\n     * @return Response\n     */\n    public function update(Request $request, $id)\n    {\n        //\n    }\n}</code></pre>\n  <p></p>\n  <h2>Caché de ruta</h2>\n  <p>Si su aplicación utiliza exclusivamente rutas basadas en controladores, debe aprovechar la caché de rutas de Laravel. El uso de la memoria caché de rutas disminuirá drásticamente la cantidad de tiempo que lleva registrar todas las rutas de su aplicación. En algunos casos, el registro de su ruta puede ser hasta 100 veces más rápido. Para generar un caché de ruta, simplemente ejecute el comando Artisan:<code>route:cache</code></p>\n  <pre><code>php artisan route:cache</code></pre>\n  <p>Después de ejecutar este comando, su archivo de rutas en caché se cargará en cada solicitud. Recuerde, si agrega rutas nuevas, deberá generar una memoria caché de ruta nueva. Debido a esto, solo debe ejecutar el comando durante la implementación de su proyecto.<code>route:cache</code></p>\n  <p>Puede usar el comando para borrar el caché de ruta:<code>route:clear</code></p>\n  <pre><code>php artisan route:clear</code></pre>\n</section>"
      },
      {
        "titulo": "3.5 Peticiones",
        "contenido": "<section>\n  <h1>Solicitudes HTTP</h1>\n  <ul>\n    <li>Accediendo a la solicitud\n      <ul>\n        <li>Ruta de solicitud y método</li>\n        <li>Solicitudes PSR-7</li>\n      </ul></li>\n    <li>Recorte y normalización de entrada</li>\n    <li>Recuperando entrada\n      <ul>\n        <li>Entrada antigua</li>\n        <li>Galletas</li>\n      </ul></li>\n    <li>Archivos\n      <ul>\n        <li>Recuperando archivos cargados</li>\n        <li>Almacenamiento de archivos cargados</li>\n      </ul></li>\n    <li>Configurar servidores proxy de confianza</li>\n  </ul>\n  <p></p>\n  <h2>Accediendo a la solicitud</h2>\n  <p>Para obtener una instancia de la solicitud HTTP actual a través de la inyección de dependencias, debe escribir la clase en su método de controlador. El contenedor de servicios inyectará automáticamente la instancia de solicitud entrante :<code>Illuminate\\Http\\Request</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass UserController extends Controller\n{\n    /**\n     * Store a new user.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        $name = $request-&gt;input('name');\n\n        //\n    }\n}</code></pre>\n  <h4>Inyección de dependencia y parámetros de ruta</h4>\n  <p>Si su método de controlador también espera la entrada de un parámetro de ruta, debe enumerar sus parámetros de ruta después de sus otras dependencias. Por ejemplo, si su ruta se define así:</p>\n  <pre><code>use App\\Http\\Controllers\\UserController;\n\nRoute::put('user/{id}', [UserController::class, 'update']);</code></pre>\n  <p>Aún puede escribir-hint y acceder a su parámetro de ruta definiendo su método de controlador de la siguiente manera:<code>Illuminate\\Http\\Request</code><code>id</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass UserController extends Controller\n{\n    /**\n     * Update the specified user.\n     *\n     * @param  Request  $request\n     * @param  string  $id\n     * @return Response\n     */\n    public function update(Request $request, $id)\n    {\n        //\n    }\n}</code></pre>\n  <h4>Acceder a la solicitud a través de cierres de ruta</h4>\n  <p>También puede escribir sugerencias a la clase en un cierre de ruta. El contenedor de servicios inyectará automáticamente la solicitud entrante en el cierre cuando se ejecute:<code>Illuminate\\Http\\Request</code></p>\n  <pre><code>use Illuminate\\Http\\Request;\n\nRoute::get('/', function (Request $request) {\n    //\n});</code></pre>\n  <p></p>\n  <h3>Ruta de solicitud y método</h3>\n  <p>La instancia proporciona una variedad de métodos para examinar la solicitud HTTP para su aplicación y extiende la clase. Discutiremos algunos de los métodos más importantes a continuación.<code>Illuminate\\Http\\Request</code><code>Symfony\\Component\\HttpFoundation\\Request</code></p>\n  <h4>Recuperando la ruta de solicitud</h4>\n  <p>El <code>path</code>método devuelve la información de la ruta de la solicitud. Entonces, si la solicitud entrante está dirigida a , el método devolverá :<code>http://domain.com/foo/bar</code><code>path</code><code>foo/bar</code></p>\n  <pre><code>$uri = $request-&gt;path();</code></pre>\n  <p>El <code>is</code>método le permite verificar que la ruta de la solicitud entrante coincide con un patrón determinado. Puede utilizar el <code>*</code>carácter como comodín cuando utilice este método:</p>\n  <pre><code>if ($request-&gt;is('admin/*')) {\n    //\n}</code></pre>\n  <h4>Recuperando la URL de la solicitud</h4>\n  <p>Para recuperar la URL completa de la solicitud entrante, puede utilizar los métodos <code>url</code>o <code>fullUrl</code>. El <code>url</code>método devolverá la URL sin la cadena de consulta, mientras que el <code>fullUrl</code>método incluye la cadena de consulta:</p>\n  <pre><code>// Without Query String...\n$url = $request-&gt;url();\n\n// With Query String...\n$url = $request-&gt;fullUrl();</code></pre>\n  <h4>Recuperando el método de solicitud</h4>\n  <p>El <code>method</code>método devolverá el verbo HTTP para la solicitud. Puede usar el <code>isMethod</code>método para verificar que el verbo HTTP coincide con una cadena determinada:</p>\n  <pre><code>$method = $request-&gt;method();\n\nif ($request-&gt;isMethod('post')) {\n    //\n}</code></pre>\n  <p></p>\n  <h3>Solicitudes PSR-7</h3>\n  <p>El estándar PSR-7 especifica interfaces para mensajes HTTP, incluidas solicitudes y respuestas. Si desea obtener una instancia de una solicitud PSR-7 en lugar de una solicitud de Laravel, primero deberá instalar algunas bibliotecas. Laravel usa el componente <em>Symfony HTTP Message Bridge</em> para convertir las solicitudes y respuestas típicas de Laravel en implementaciones compatibles con PSR-7:</p>\n  <pre><code>composer require symfony/psr-http-message-bridge\ncomposer require nyholm/psr7</code></pre>\n  <p>Una vez que haya instalado estas bibliotecas, puede obtener una solicitud PSR-7 al indicar el tipo de la interfaz de solicitud en su método de cierre de ruta o controlador:</p>\n  <pre><code>use Psr\\Http\\Message\\ServerRequestInterface;\n\nRoute::get('/', function (ServerRequestInterface $request) {\n    //\n});</code></pre>\n  <blockquote>\n    <p> Si devuelve una instancia de respuesta de PSR-7 desde una ruta o controlador, se convertirá automáticamente de nuevo en una instancia de respuesta de Laravel y se mostrará en el marco.</p>\n  </blockquote>\n  <p></p>\n  <h2>Recorte y normalización de entrada</h2>\n  <p>De forma predeterminada, Laravel incluye el middleware <code>TrimStrings</code>y <code>ConvertEmptyStringsToNull</code>en la pila de middleware global de su aplicación. Estos middleware se enumeran en la pila por clase. Este middleware recortará automáticamente todos los campos de cadena entrantes en la solicitud, así como también convertirá cualquier campo de cadena vacío a . Esto le permite no tener que preocuparse por estos problemas de normalización en sus rutas y controladores.<code>App\\Http\\Kernel</code><code>null</code></p>\n  <p>Si desea deshabilitar este comportamiento, puede eliminar los dos middleware de la pila de middleware de su aplicación eliminándolos de la <code>$middleware</code>propiedad de su clase.<code>App\\Http\\Kernel</code></p>\n  <p></p>\n  <h2>Recuperando entrada</h2>\n  <h4>Recuperar todos los datos de entrada</h4>\n  <p>También puede recuperar todos los datos de entrada <code>array</code>usando el <code>all</code>método:</p>\n  <pre><code>$input = $request-&gt;all();</code></pre>\n  <h4>Recuperar un valor de entrada</h4>\n  <p>Usando algunos métodos simples, puede acceder a toda la entrada del usuario desde su instancia sin preocuparse por qué verbo HTTP se usó para la solicitud. Independientemente del verbo HTTP, el método se puede utilizar para recuperar la entrada del usuario:<code>Illuminate\\Http\\Request</code><code>input</code></p>\n  <pre><code>$name = $request-&gt;input('name');</code></pre>\n  <p>Puede pasar un valor predeterminado como segundo argumento del <code>input</code>método. Este valor se devolverá si el valor de entrada solicitado no está presente en la solicitud:</p>\n  <pre><code>$name = $request-&gt;input('name', 'Sally');</code></pre>\n  <p>Cuando trabaje con formularios que contienen entradas de matriz, utilice la notación \"punto\" para acceder a las matrices:</p>\n  <pre><code>$name = $request-&gt;input('products.0.name');\n\n$names = $request-&gt;input('products.*.name');</code></pre>\n  <p>Puede llamar al <code>input</code>método sin ningún argumento para recuperar todos los valores de entrada como una matriz asociativa:</p>\n  <pre><code>$input = $request-&gt;input();</code></pre>\n  <h4>Recuperar entrada de la cadena de consulta</h4>\n  <p>Si bien el <code>input</code>método recupera valores de toda la carga útil de la solicitud (incluida la cadena de consulta), el <code>query</code>método solo recuperará valores de la cadena de consulta:</p>\n  <pre><code>$name = $request-&gt;query('name');</code></pre>\n  <p>Si los datos del valor de la cadena de consulta solicitada no están presentes, se devolverá el segundo argumento de este método:</p>\n  <pre><code>$name = $request-&gt;query('name', 'Helen');</code></pre>\n  <p>Puede llamar al <code>query</code>método sin ningún argumento para recuperar todos los valores de la cadena de consulta como una matriz asociativa:</p>\n  <pre><code>$query = $request-&gt;query();</code></pre>\n  <h4>Recuperar entrada a través de propiedades dinámicas</h4>\n  <p>También puede acceder a la entrada del usuario utilizando propiedades dinámicas en la instancia. Por ejemplo, si uno de los formularios de su aplicación contiene un campo, puede acceder al valor del campo así:<code>Illuminate\\Http\\Request</code><code>name</code></p>\n  <pre><code>$name = $request-&gt;name;</code></pre>\n  <p>Cuando se utilizan propiedades dinámicas, Laravel primero buscará el valor del parámetro en la carga útil de la solicitud. Si no está presente, Laravel buscará el campo en los parámetros de ruta.</p>\n  <h4>Recuperar valores de entrada JSON</h4>\n  <p>Al enviar solicitudes JSON a su aplicación, puede acceder a los datos JSON a través del <code>input</code>método siempre que el encabezado de la solicitud esté configurado correctamente en . Incluso puede usar la sintaxis de \"puntos\" para profundizar en las matrices JSON:<code>Content-Type</code><code>application/json</code></p>\n  <pre><code>$name = $request-&gt;input('user.name');</code></pre>\n  <h4>Recuperar valores de entrada booleanos</h4>\n  <p>Al tratar con elementos HTML como casillas de verificación, su aplicación puede recibir valores \"verdaderos\" que en realidad son cadenas. Por ejemplo, \"verdadero\" o \"activado\". Por conveniencia, puede utilizar el <code>boolean</code>método para recuperar estos valores como booleanos. El <code>boolean</code>método devuelve <code>true</code>1, \"1\", verdadero, \"verdadero\", \"activado\" y \"sí\". Todos los demás valores devolverán <code>false</code>:</p>\n  <pre><code>$archived = $request-&gt;boolean('archived');</code></pre>\n  <h4>Recuperar una parte de los datos de entrada</h4>\n  <p>Si necesita recuperar un subconjunto de los datos de entrada, puede utilizar los métodos <code>only</code>y <code>except</code>. Ambos métodos aceptan una <code>array</code>lista de argumentos única o dinámica:</p>\n  <pre><code>$input = $request-&gt;only(['username', 'password']);\n\n$input = $request-&gt;only('username', 'password');\n\n$input = $request-&gt;except(['credit_card']);\n\n$input = $request-&gt;except('credit_card');</code></pre>\n  <blockquote>\n    <p>El <code>only</code>método devuelve todos los pares clave / valor que solicita; sin embargo, no devolverá pares clave / valor que no estén presentes en la solicitud.</p>\n  </blockquote>\n  <h4>Determinar si un valor de entrada está presente</h4>\n  <p>Debe utilizar el <code>has</code>método para determinar si hay un valor presente en la solicitud. El <code>has</code>método devuelve <code>true</code>si el valor está presente en la solicitud:</p>\n  <pre><code>if ($request-&gt;has('name')) {\n    //\n}</code></pre>\n  <p>Cuando se le da una matriz, el <code>has</code>método determinará si todos los valores especificados están presentes:</p>\n  <pre><code>if ($request-&gt;has(['name', 'email'])) {\n    //\n}</code></pre>\n  <p>El <code>hasAny</code>método devuelve <code>true</code>si alguno de los valores especificados está presente:</p>\n  <pre><code>if ($request-&gt;hasAny(['name', 'email'])) {\n    //\n}</code></pre>\n  <p>Si desea determinar si un valor está presente en la solicitud y no está vacío, puede usar el <code>filled</code>método:</p>\n  <pre><code>if ($request-&gt;filled('name')) {\n    //\n}</code></pre>\n  <p>Para determinar si una clave determinada está ausente de la solicitud, puede utilizar el <code>missing</code>método:</p>\n  <pre><code>if ($request-&gt;missing('name')) {\n    //\n}</code></pre>\n  <p></p>\n  <h3>Entrada antigua</h3>\n  <p>Laravel le permite mantener la entrada de una solicitud durante la siguiente solicitud. Esta función es particularmente útil para rellenar formularios después de detectar errores de validación. Sin embargo, si está utilizando las funciones de validación incluidas en Laravel , es poco probable que necesite utilizar estos métodos manualmente, ya que algunas de las funciones de validación integradas de Laravel los llamarán automáticamente.</p>\n  <h4>Entrada intermitente a la sesión</h4>\n  <p>El <code>flash</code>método de la clase mostrará la entrada actual a la sesión para que esté disponible durante la próxima solicitud del usuario a la aplicación:<code>Illuminate\\Http\\Request</code></p>\n  <pre><code>$request-&gt;flash();</code></pre>\n  <p>También puede utilizar los métodos <code>flashOnly</code>y <code>flashExcept</code>para actualizar un subconjunto de los datos de la solicitud a la sesión. Estos métodos son útiles para mantener la información confidencial, como contraseñas, fuera de la sesión:</p>\n  <pre><code>$request-&gt;flashOnly(['username', 'email']);\n\n$request-&gt;flashExcept('password');</code></pre>\n  <h4>Entrada intermitente y luego redireccionamiento</h4>\n  <p>Dado que a menudo querrá flashear la entrada a la sesión y luego redirigir a la página anterior, puede encadenar fácilmente el flasheo de entrada en una redirección usando el <code>withInput</code>método:</p>\n  <pre><code>return redirect('form')-&gt;withInput();\n\nreturn redirect('form')-&gt;withInput(\n    $request-&gt;except('password')\n);</code></pre>\n  <h4>Recuperando entrada antigua</h4>\n  <p>Para recuperar la entrada flasheada de la solicitud anterior, use el <code>old</code>método en la <code>Request</code>instancia. El <code>old</code>método extraerá los datos de entrada previamente mostrados de la sesión :</p>\n  <pre><code>$username = $request-&gt;old('username');</code></pre>\n  <p>Laravel también proporciona un <code>old</code>ayudante global . Si está mostrando una entrada antigua dentro de una plantilla Blade , es más conveniente usar el <code>old</code>asistente. Si no existe una entrada anterior para el campo dado, <code>null</code>se devolverá:</p>\n  <pre><code>&lt;input type=\"text\" name=\"username\" value=\"{{ old('username') }}\"&gt;</code></pre>\n  <p></p>\n  <h3>Galletas</h3>\n  <h4>Recuperación de cookies de solicitudes</h4>\n  <p>Todas las cookies creadas por el marco de Laravel están encriptadas y firmadas con un código de autenticación, lo que significa que se considerarán inválidas si el cliente las ha cambiado. Para recuperar un valor de cookie de la solicitud, use el <code>cookie</code>método en una instancia:<code>Illuminate\\Http\\Request</code></p>\n  <pre><code>$value = $request-&gt;cookie('name');</code></pre>\n  <p>Alternativamente, puede utilizar la <code>Cookie</code>fachada para acceder a los valores de las cookies:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Cookie;\n\n$value = Cookie::get('name');</code></pre>\n  <h4>Adjuntar cookies a las respuestas</h4>\n  <p>Puede adjuntar una cookie a una instancia saliente utilizando el método. Debe pasar el nombre, el valor y la cantidad de minutos que la cookie debe considerarse válida para este método:<code>Illuminate\\Http\\Response</code><code>cookie</code></p>\n  <pre><code>return response('Hello World')-&gt;cookie(\n    'name', 'value', $minutes\n);</code></pre>\n  <p>El <code>cookie</code>método también acepta algunos argumentos más que se utilizan con menos frecuencia. Generalmente, estos argumentos tienen el mismo propósito y significado que los argumentos que se le darían al método setcookie nativo de PHP :</p>\n  <pre><code>return response('Hello World')-&gt;cookie(\n    'name', 'value', $minutes, $path, $domain, $secure, $httpOnly\n);</code></pre>\n  <p>Alternativamente, puede usar la <code>Cookie</code>fachada para \"poner en cola\" las cookies para adjuntarlas a la respuesta saliente de su aplicación. El <code>queue</code>método acepta una <code>Cookie</code>instancia o los argumentos necesarios para crear una <code>Cookie</code>instancia. Estas cookies se adjuntarán a la respuesta saliente antes de que se envíe al navegador:</p>\n  <pre><code>Cookie::queue(Cookie::make('name', 'value', $minutes));\n\nCookie::queue('name', 'value', $minutes);</code></pre>\n  <h4>Generación de instancias de cookies</h4>\n  <p>Si desea generar una instancia que se pueda dar a una instancia de respuesta en un momento posterior, puede usar el asistente global . Esta cookie no se enviará de vuelta al cliente a menos que esté adjunta a una instancia de respuesta:<code>Symfony\\Component\\HttpFoundation\\Cookie</code><code>cookie</code></p>\n  <pre><code>$cookie = cookie('name', 'value', $minutes);\n\nreturn response('Hello World')-&gt;cookie($cookie);</code></pre>\n  <h4>Caducar las cookies antes de tiempo</h4>\n  <p>Puede eliminar una cookie caducándola mediante el <code>forget</code>método de la <code>Cookie</code>fachada:</p>\n  <pre><code>Cookie::queue(Cookie::forget('name'));</code></pre>\n  <p>Alternativamente, puede adjuntar la cookie caducada a una instancia de respuesta:</p>\n  <pre><code>$cookie = Cookie::forget('name');\n\nreturn response('Hello World')-&gt;withCookie($cookie);</code></pre>\n  <p></p>\n  <h2>Archivos</h2>\n  <p></p>\n  <h3>Recuperando archivos cargados</h3>\n  <p>Puede acceder a los archivos cargados desde una instancia usando el método o usando propiedades dinámicas. El método devuelve una instancia de la clase, que extiende la clase PHP y proporciona una variedad de métodos para interactuar con el archivo:<code>Illuminate\\Http\\Request</code><code>file</code><code>file</code><code>Illuminate\\Http\\UploadedFile</code><code>SplFileInfo</code></p>\n  <pre><code>$file = $request-&gt;file('photo');\n\n$file = $request-&gt;photo;</code></pre>\n  <p>Puede determinar si un archivo está presente en la solicitud utilizando el <code>hasFile</code>método:</p>\n  <pre><code>if ($request-&gt;hasFile('photo')) {\n    //\n}</code></pre>\n  <h4>Validación de cargas exitosas</h4>\n  <p>Además de verificar si el archivo está presente, puede verificar que no hubo problemas para cargar el archivo a través del <code>isValid</code>método:</p>\n  <pre><code>if ($request-&gt;file('photo')-&gt;isValid()) {\n    //\n}</code></pre>\n  <h4>Rutas de archivo y extensiones</h4>\n  <p>La <code>UploadedFile</code>clase también contiene métodos para acceder a la ruta completa del archivo y su extensión. El <code>extension</code>método intentará adivinar la extensión del archivo basándose en su contenido. Esta extensión puede ser diferente de la extensión proporcionada por el cliente:</p>\n  <pre><code>$path = $request-&gt;photo-&gt;path();\n\n$extension = $request-&gt;photo-&gt;extension();</code></pre>\n  <h4>Otros métodos de archivo</h4>\n  <p>Hay una variedad de otros métodos disponibles en <code>UploadedFile</code>casos. Consulte la documentación de la API de la clase para obtener más información sobre estos métodos.</p>\n  <p></p>\n  <h3>Almacenamiento de archivos cargados</h3>\n  <p>Para almacenar un archivo cargado, normalmente utilizará uno de sus sistemas de archivos configurados . La <code>UploadedFile</code>clase tiene un <code>store</code>método que moverá un archivo cargado a uno de sus discos, que puede ser una ubicación en su sistema de archivos local o incluso una ubicación de almacenamiento en la nube como Amazon S3.</p>\n  <p>El <code>store</code>método acepta la ruta donde se debe almacenar el archivo en relación con el directorio raíz configurado del sistema de archivos. Esta ruta no debe contener un nombre de archivo, ya que se generará automáticamente un ID único para que sirva como nombre de archivo.</p>\n  <p>El <code>store</code>método también acepta un segundo argumento opcional para el nombre del disco que debe usarse para almacenar el archivo. El método devolverá la ruta del archivo relativa a la raíz del disco:</p>\n  <pre><code>$path = $request-&gt;photo-&gt;store('images');\n\n$path = $request-&gt;photo-&gt;store('images', 's3');</code></pre>\n  <p>Si no desea que se genere un nombre de archivo automáticamente, puede usar el <code>storeAs</code>método, que acepta la ruta, el nombre del archivo y el nombre del disco como argumentos:</p>\n  <pre><code>$path = $request-&gt;photo-&gt;storeAs('images', 'filename.jpg');\n\n$path = $request-&gt;photo-&gt;storeAs('images', 'filename.jpg', 's3');</code></pre>\n  <p></p>\n  <h2>Configurar servidores proxy de confianza</h2>\n  <p>Al ejecutar sus aplicaciones detrás de un equilibrador de carga que cancela los certificados TLS / SSL, puede notar que su aplicación a veces no genera enlaces HTTPS. Por lo general, esto se debe a que su aplicación está reenviando tráfico desde su balanceador de carga en el puerto 80 y no sabe que debe generar enlaces seguros.</p>\n  <p>Para resolver esto, puede utilizar el middleware que se incluye en su aplicación Laravel, que le permite personalizar rápidamente los equilibradores de carga o proxies en los que su aplicación debería confiar. Sus proxies de confianza deben aparecer como una matriz en la propiedad de este middleware. Además de configurar los proxies confiables, puede configurar el proxy que debería ser de confianza:<code>App\\Http\\Middleware\\TrustProxies</code><code>$proxies</code><code>$headers</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Fideloper\\Proxy\\TrustProxies as Middleware;\nuse Illuminate\\Http\\Request;\n\nclass TrustProxies extends Middleware\n{\n    /**\n     * The trusted proxies for this application.\n     *\n     * @var string|array\n     */\n    protected $proxies = [\n        '192.168.1.1',\n        '192.168.1.2',\n    ];\n\n    /**\n     * The headers that should be used to detect proxies.\n     *\n     * @var int\n     */\n    protected $headers = Request::HEADER_X_FORWARDED_ALL;\n}</code></pre>\n  <blockquote>\n    <p>Si utiliza AWS Elastic Load Balancing, su <code>$headers</code>valor debería ser . Para obtener más información sobre las constantes que se pueden utilizar en la propiedad, consulte la documentación de Symfony sobre la confianza en proxies .<code>Request::HEADER_X_FORWARDED_AWS_ELB</code><code>$headers</code></p>\n  </blockquote>\n  <h4>Confiar en todos los proxies</h4>\n  <p>Si está utilizando Amazon AWS u otro proveedor de equilibradores de carga \"en la nube\", es posible que no conozca las direcciones IP de sus equilibradores reales. En este caso, puede utilizar <code>*</code>para confiar en todos los proxies:</p>\n  <pre><code>/**\n * The trusted proxies for this application.\n *\n * @var string|array\n */\nprotected $proxies = '*';</code></pre>\n</section>"
      },
      {
        "titulo": "3.6 Respuestas",
        "contenido": "<section>\n  <h1>Respuestas HTTP</h1>\n  <ul>\n    <li>Crear respuestas\n      <ul>\n        <li>Adjuntar encabezados a las respuestas</li>\n        <li>Adjuntar cookies a las respuestas</li>\n        <li>Cookies y cifrado</li>\n      </ul></li>\n    <li>Redireccionamientos\n      <ul>\n        <li>Redirigir a rutas con nombre</li>\n        <li>Redirigir a acciones del controlador</li>\n        <li>Redirigir a dominios externos</li>\n        <li>Redirigir con datos de sesión flasheados</li>\n      </ul></li>\n    <li>Otros tipos de respuesta\n      <ul>\n        <li>Ver respuestas</li>\n        <li>Respuestas JSON</li>\n        <li>Descargas de archivos</li>\n        <li>Respuestas de archivo</li>\n      </ul></li>\n    <li>Macros de respuesta</li>\n  </ul>\n  <p></p>\n  <h2>Crear respuestas</h2>\n  <h4>Cadenas y matrices</h4>\n  <p>Todas las rutas y controladores deben devolver una respuesta para ser enviada al navegador del usuario. Laravel proporciona varias formas diferentes de devolver respuestas. La respuesta más básica es devolver una cadena de una ruta o controlador. El marco convertirá automáticamente la cadena en una respuesta HTTP completa:</p>\n  <pre><code>Route::get('/', function () {\n    return 'Hello World';\n});</code></pre>\n  <p>Además de devolver cadenas de sus rutas y controladores, también puede devolver matrices. El marco convertirá automáticamente la matriz en una respuesta JSON:</p>\n  <pre><code>Route::get('/', function () {\n    return [1, 2, 3];\n});</code></pre>\n  <blockquote>\n    <p>¿Sabías que también puedes devolver colecciones Eloquent desde tus rutas o controladores? Se convertirán automáticamente a JSON. ¡Dale un tiro!</p>\n  </blockquote>\n  <h4>Objetos de respuesta</h4>\n  <p>Por lo general, no solo devolverá cadenas o matrices simples de sus acciones de ruta. En su lugar, devolverá instancias o vistas completas .<code>Illuminate\\Http\\Response</code></p>\n  <p>Devolver una <code>Response</code>instancia completa le permite personalizar el código de estado HTTP y los encabezados de la respuesta. Una <code>Response</code>instancia hereda de la clase, que proporciona una variedad de métodos para crear respuestas HTTP:<code>Symfony\\Component\\HttpFoundation\\Response</code></p>\n  <pre><code>Route::get('home', function () {\n    return response('Hello World', 200)\n                  -&gt;header('Content-Type', 'text/plain');\n});</code></pre>\n  <p></p>\n  <h4>Adjuntar encabezados a las respuestas</h4>\n  <p>Tenga en cuenta que la mayoría de los métodos de respuesta son encadenables, lo que permite la construcción fluida de instancias de respuesta. Por ejemplo, puede usar el <code>header</code>método para agregar una serie de encabezados a la respuesta antes de devolverla al usuario:</p>\n  <pre><code>return response($content)\n            -&gt;header('Content-Type', $type)\n            -&gt;header('X-Header-One', 'Header Value')\n            -&gt;header('X-Header-Two', 'Header Value');</code></pre>\n  <p>O puede usar el <code>withHeaders</code>método para especificar una matriz de encabezados que se agregarán a la respuesta:</p>\n  <pre><code>return response($content)\n            -&gt;withHeaders([\n                'Content-Type' =&gt; $type,\n                'X-Header-One' =&gt; 'Header Value',\n                'X-Header-Two' =&gt; 'Header Value',\n            ]);</code></pre>\n  <h4>Middleware de control de caché</h4>\n  <p>Laravel incluye un middleware, que puede usarse para configurar rápidamente el encabezado de un grupo de rutas. Si se especifica en la lista de directivas, un hash MD5 del contenido de la respuesta se establecerá automáticamente como el identificador ETag:<code>cache.headers</code><code>Cache-Control</code><code>etag</code></p>\n  <pre><code>Route::middleware('cache.headers:public;max_age=2628000;etag')-&gt;group(function () {\n    Route::get('privacy', function () {\n        // ...\n    });\n\n    Route::get('terms', function () {\n        // ...\n    });\n});</code></pre>\n  <p></p>\n  <h4>Adjuntar cookies a las respuestas</h4>\n  <p>El <code>cookie</code>método en instancias de respuesta le permite adjuntar cookies fácilmente a la respuesta. Por ejemplo, puede usar el <code>cookie</code>método para generar una cookie y adjuntarla con fluidez a la instancia de respuesta de la siguiente manera:</p>\n  <pre><code>return response($content)\n                -&gt;header('Content-Type', $type)\n                -&gt;cookie('name', 'value', $minutes);</code></pre>\n  <p>El <code>cookie</code>método también acepta algunos argumentos más que se utilizan con menos frecuencia. Generalmente, estos argumentos tienen el mismo propósito y significado que los argumentos que se le darían al método setcookie nativo de PHP :</p>\n  <pre><code>-&gt;cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly)</code></pre>\n  <p>Alternativamente, puede usar la <code>Cookie</code>fachada para \"poner en cola\" las cookies para adjuntarlas a la respuesta saliente de su aplicación. El <code>queue</code>método acepta una <code>Cookie</code>instancia o los argumentos necesarios para crear una <code>Cookie</code>instancia. Estas cookies se adjuntarán a la respuesta saliente antes de que se envíe al navegador:</p>\n  <pre><code>Cookie::queue(Cookie::make('name', 'value', $minutes));\n\nCookie::queue('name', 'value', $minutes);</code></pre>\n  <p></p>\n  <h4>Cookies y cifrado</h4>\n  <p>De forma predeterminada, todas las cookies generadas por Laravel están encriptadas y firmadas para que el cliente no pueda modificarlas ni leerlas. Si desea deshabilitar el cifrado para un subconjunto de cookies generadas por su aplicación, puede usar la <code>$except</code>propiedad del middleware, que se encuentra en el directorio:<code>App\\Http\\Middleware\\EncryptCookies</code><code>app/Http/Middleware</code></p>\n  <pre><code>/**\n * The names of the cookies that should not be encrypted.\n *\n * @var array\n */\nprotected $except = [\n    'cookie_name',\n];</code></pre>\n  <p></p>\n  <h2>Redireccionamientos</h2>\n  <p>Las respuestas de redireccionamiento son instancias de la clase y contienen los encabezados adecuados necesarios para redirigir al usuario a otra URL. Hay varias formas de generar una instancia. El método más simple es usar el ayudante global :<code>Illuminate\\Http\\RedirectResponse</code><code>RedirectResponse</code><code>redirect</code></p>\n  <pre><code>Route::get('dashboard', function () {\n    return redirect('home/dashboard');\n});</code></pre>\n  <p>A veces, es posible que desee redirigir al usuario a su ubicación anterior, como cuando un formulario enviado no es válido. Puede hacerlo utilizando la <code>back</code>función auxiliar global . Dado que esta función utiliza la sesión , asegúrese de que la ruta que llama a la <code>back</code>función esté utilizando el <code>web</code>grupo de middleware o tenga aplicado todo el middleware de la sesión:</p>\n  <pre><code>Route::post('user/profile', function () {\n    // Validate the request...\n\n    return back()-&gt;withInput();\n});</code></pre>\n  <p></p>\n  <h3>Redirigir a rutas con nombre</h3>\n  <p>Cuando llama al <code>redirect</code>asistente sin parámetros, se devuelve una instancia de , lo que le permite llamar a cualquier método en la instancia. Por ejemplo, para generar una ruta con nombre, puede usar el método:<code>Illuminate\\Routing\\Redirector</code><code>Redirector</code><code>RedirectResponse</code><code>route</code></p>\n  <pre><code>return redirect()-&gt;route('login');</code></pre>\n  <p>Si su ruta tiene parámetros, puede pasarlos como el segundo argumento del <code>route</code>método:</p>\n  <pre><code>// For a route with the following URI: profile/{id}\n\nreturn redirect()-&gt;route('profile', ['id' =&gt; 1]);</code></pre>\n  <h4>Completando parámetros a través de modelos elocuentes</h4>\n  <p>Si está redirigiendo a una ruta con un parámetro \"ID\" que se está poblando de un modelo Eloquent, puede pasar el modelo en sí. La identificación se extraerá automáticamente:</p>\n  <pre><code>// For a route with the following URI: profile/{id}\n\nreturn redirect()-&gt;route('profile', [$user]);</code></pre>\n  <p>Si desea personalizar el valor que se coloca en el parámetro de ruta, puede especificar la columna en la definición del parámetro de ruta ( ) o puede anular el método en su modelo Eloquent:<code>profile/{id:slug}</code><code>getRouteKey</code></p>\n  <pre><code>/**\n * Get the value of the model's route key.\n *\n * @return mixed\n */\npublic function getRouteKey()\n{\n    return $this-&gt;slug;\n}</code></pre>\n  <p></p>\n  <h3>Redirigir a acciones del controlador</h3>\n  <p>También puede generar redireccionamientos a las acciones del controlador . Para hacerlo, pase el controlador y el nombre de la acción al <code>action</code>método:</p>\n  <pre><code>use App\\Http\\Controllers\\HomeController;\n\nreturn redirect()-&gt;action([HomeController::class, 'index']);</code></pre>\n  <p>Si la ruta de su controlador requiere parámetros, puede pasarlos como el segundo argumento del <code>action</code>método:</p>\n  <pre><code>return redirect()-&gt;action(\n    [UserController::class, 'profile'], ['id' =&gt; 1]\n);</code></pre>\n  <p></p>\n  <h3>Redirigir a dominios externos</h3>\n  <p>A veces, es posible que deba redirigir a un dominio fuera de su aplicación. Puede hacerlo llamando al <code>away</code>método, que crea una <code>RedirectResponse</code>URL sin codificación, validación o verificación adicional:</p>\n  <pre><code>return redirect()-&gt;away('https://www.google.com');</code></pre>\n  <p></p>\n  <h3>Redirigir con datos de sesión flasheados</h3>\n  <p>La redirección a una nueva URL y la actualización de datos a la sesión generalmente se realizan al mismo tiempo. Normalmente, esto se hace después de realizar con éxito una acción cuando muestra un mensaje de éxito en la sesión. Para mayor comodidad, puede crear una <code>RedirectResponse</code>instancia y actualizar datos a la sesión en una única cadena de métodos fluida:</p>\n  <pre><code>Route::post('user/profile', function () {\n    // Update the user's profile...\n\n    return redirect('dashboard')-&gt;with('status', 'Profile updated!');\n});</code></pre>\n  <p>Una vez que se redirige al usuario, puede mostrar el mensaje parpadeante de la sesión . Por ejemplo, usando la sintaxis Blade :</p>\n  <pre><code>@if (session('status'))\n    &lt;div class=\"alert alert-success\"&gt;\n        {{ session('status') }}\n    &lt;/div&gt;\n@endif</code></pre>\n  <p></p>\n  <h2>Otros tipos de respuesta</h2>\n  <p>El <code>response</code>ayudante se puede utilizar para generar otros tipos de instancias de respuesta. Cuando <code>response</code>se llama al ayudante sin argumentos, se devuelve una implementación del contrato . Este contrato proporciona varios métodos útiles para generar respuestas.<code>Illuminate\\Contracts\\Routing\\ResponseFactory</code> </p>\n  <p></p>\n  <h3>Ver respuestas</h3>\n  <p>Si necesita controlar el estado y los encabezados de la respuesta, pero también necesita devolver una vista como contenido de la respuesta, debe usar el <code>view</code>método:</p>\n  <pre><code>return response()\n            -&gt;view('hello', $data, 200)\n            -&gt;header('Content-Type', $type);</code></pre>\n  <p>Por supuesto, si no necesita pasar un código de estado HTTP personalizado o encabezados personalizados, debe usar la <code>view</code>función de ayuda global .</p>\n  <p></p>\n  <h3>Respuestas JSON</h3>\n  <p>El <code>json</code>método establecerá automáticamente el encabezado en , además de convertir la matriz dada a JSON usando la función PHP:<code>Content-Type</code><code>application/json</code><code>json_encode</code></p>\n  <pre><code>return response()-&gt;json([\n    'name' =&gt; 'Abigail',\n    'state' =&gt; 'CA',\n]);</code></pre>\n  <p>Si desea crear una respuesta JSONP, puede usar el <code>json</code>método en combinación con el <code>withCallback</code>método:</p>\n  <pre><code>return response()\n            -&gt;json(['name' =&gt; 'Abigail', 'state' =&gt; 'CA'])\n            -&gt;withCallback($request-&gt;input('callback'));</code></pre>\n  <p></p>\n  <h3>Descargas de archivos</h3>\n  <p>El <code>download</code>método puede usarse para generar una respuesta que obligue al navegador del usuario a descargar el archivo en la ruta dada. El <code>download</code>método acepta un nombre de archivo como segundo argumento del método, que determinará el nombre de archivo que verá el usuario que lo descarga. Finalmente, puede pasar una matriz de encabezados HTTP como tercer argumento del método:</p>\n  <pre><code>return response()-&gt;download($pathToFile);\n\nreturn response()-&gt;download($pathToFile, $name, $headers);\n\nreturn response()-&gt;download($pathToFile)-&gt;deleteFileAfterSend();</code></pre>\n  <blockquote>\n    <p> Symfony HttpFoundation, que administra las descargas de archivos, requiere que el archivo que se descarga tenga un nombre de archivo ASCII.</p>\n  </blockquote>\n  <h4>Descargas transmitidas</h4>\n  <p>A veces, es posible que desee convertir la respuesta de cadena de una operación determinada en una respuesta descargable sin tener que escribir el contenido de la operación en el disco. Puede utilizar el <code>streamDownload</code>método en este escenario. Este método acepta una devolución de llamada, un nombre de archivo y una matriz opcional de encabezados como argumentos:</p>\n  <pre><code>return response()-&gt;streamDownload(function () {\n    echo GitHub::api('repo')\n                -&gt;contents()\n                -&gt;readme('laravel', 'laravel')['contents'];\n}, 'laravel-readme.md');</code></pre>\n  <p></p>\n  <h3>Respuestas de archivo</h3>\n  <p>El <code>file</code>método se puede utilizar para mostrar un archivo, como una imagen o PDF, directamente en el navegador del usuario en lugar de iniciar una descarga. Este método acepta la ruta al archivo como primer argumento y una matriz de encabezados como segundo argumento:</p>\n  <pre><code>return response()-&gt;file($pathToFile);\n\nreturn response()-&gt;file($pathToFile, $headers);</code></pre>\n  <p></p>\n  <h2>Macros de respuesta</h2>\n  <p>Si desea definir una respuesta personalizada que pueda reutilizar en una variedad de sus rutas y controladores, puede usar el <code>macro</code>método en la <code>Response</code>fachada. Por ejemplo, del <code>boot</code> método de un proveedor de servicios :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\Response;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass ResponseMacroServiceProvider extends ServiceProvider\n{\n    /**\n     * Register the application's response macros.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Response::macro('caps', function ($value) {\n            return Response::make(strtoupper($value));\n        });\n    }\n}</code></pre>\n  <p>La <code>macro</code>función acepta un nombre como primer argumento y un cierre como segundo. El cierre de la macro se ejecutará cuando se llame al nombre de la macro desde una <code>ResponseFactory</code>implementación o el <code>response</code>ayudante:</p>\n  <pre><code>return response()-&gt;caps('foo');</code></pre>\n</section>"
      },
      {
        "titulo": "3.7 Puntos de vista",
        "contenido": "<section>\n  <h1>Puntos de vista</h1>\n  <ul>\n    <li>Creando Vistas</li>\n    <li>Pasar datos a vistas\n      <ul>\n        <li>Compartir datos con todas las vistas</li>\n      </ul></li>\n    <li>Ver compositores</li>\n    <li>Optimización de vistas</li>\n  </ul>\n  <p></p>\n  <h2>Creando Vistas</h2>\n  <blockquote>\n    <p>¿Busca más información sobre cómo escribir plantillas Blade? Consulte la documentación completa de Blade para comenzar.</p>\n  </blockquote>\n  <p>Las vistas contienen el HTML proporcionado por su aplicación y separan la lógica de su controlador / aplicación de su lógica de presentación. Las vistas se almacenan en el directorio. Una vista simple podría verse así:<code>resources/views</code></p>\n  <pre><code>&lt;!-- View stored in resources/views/greeting.blade.php --&gt;\n\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello, {{ $name }}&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n  <p>Dado que esta vista se almacena en , podemos devolverla usando el ayudante global así:<code>resources/views/greeting.blade.php</code><code>view</code></p>\n  <pre><code>Route::get('/', function () {\n    return view('greeting', ['name' =&gt; 'James']);\n});</code></pre>\n  <p>Como puede ver, el primer argumento pasado al <code>view</code>ayudante corresponde al nombre del archivo de vista en el directorio. El segundo argumento es una matriz de datos que deben estar disponibles para la vista. En este caso, estamos pasando la variable, que se muestra en la vista utilizando la sintaxis Blade .<code>resources/views</code><code>name</code></p>\n  <p>Las vistas también pueden estar anidadas en subdirectorios del directorio. La notación de \"puntos\" se puede utilizar para hacer referencia a vistas anidadas. Por ejemplo, si su vista está almacenada en , puede hacer referencia a ella así:<code>resources/views</code><code>resources/views/admin/profile.blade.php</code></p>\n  <pre><code>return view('admin.profile', $data);</code></pre>\n  <blockquote>\n    <p>Los nombres de directorio de vista no deben contener el <code>.</code>carácter.</p>\n  </blockquote>\n  <h4>Determinar si existe una vista</h4>\n  <p>Si necesita determinar si existe una vista, puede usar la <code>View</code>fachada. El <code>exists</code>método regresará <code>true</code>si la vista existe:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\View;\n\nif (View::exists('emails.customer')) {\n    //\n}</code></pre>\n  <h4>Creación de la primera vista disponible</h4>\n  <p>Con el <code>first</code>método, puede crear la primera vista que existe en una matriz de vistas determinada. Esto es útil si su aplicación o paquete permite personalizar o sobrescribir vistas:</p>\n  <pre><code>return view()-&gt;first(['custom.admin', 'admin'], $data);</code></pre>\n  <p>También puede llamar a este método a través de la <code>View</code> fachada :</p>\n  <pre><code>use Illuminate\\Support\\Facades\\View;\n\nreturn View::first(['custom.admin', 'admin'], $data);</code></pre>\n  <p></p>\n  <h2>Pasar datos a vistas</h2>\n  <p>Como vio en los ejemplos anteriores, puede pasar una matriz de datos a las vistas:</p>\n  <pre><code>return view('greetings', ['name' =&gt; 'Victoria']);</code></pre>\n  <p>Al pasar información de esta manera, los datos deben ser una matriz con pares clave / valor. Dentro de su vista, puede acceder a cada valor utilizando su clave correspondiente, como . Como alternativa a pasar una matriz completa de datos a la función auxiliar, puede usar el método para agregar datos individuales a la vista:<code>&lt;?php echo $key; ?&gt;</code><code>view</code><code>with</code></p>\n  <pre><code>return view('greeting')-&gt;with('name', 'Victoria');</code></pre>\n  <p></p>\n  <h4>Compartir datos con todas las vistas</h4>\n  <p>De vez en cuando, es posible que deba compartir una parte de los datos con todas las vistas que genera su aplicación. Puede hacerlo utilizando el <code>share</code>método de la fachada de vista . Por lo general, debe realizar llamadas a <code>share</code>dentro del <code>boot</code>método de un proveedor de servicios . Puede agregarlos al <code>AppServiceProvider</code>o generar un proveedor de servicios separado para alojarlos:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\View;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        View::share('key', 'value');\n    }\n}</code></pre>\n  <p></p>\n  <h2>Ver compositores</h2>\n  <p>Los compositores de vistas son devoluciones de llamada o métodos de clase que se llaman cuando se representa una vista. Si tiene datos que desea vincular a una vista cada vez que se renderiza esa vista, un compositor de vistas puede ayudarlo a organizar esa lógica en una sola ubicación.</p>\n  <p>Para este ejemplo, registremos los compositores de vistas dentro de un proveedor de servicios . Usaremos la <code>View</code>fachada para acceder a la implementación del contrato subyacente . Recuerde, Laravel no incluye un directorio predeterminado para los compositores de vistas. Eres libre de organizarlos como quieras. Por ejemplo, podría crear un directorio:<code>Illuminate\\Contracts\\View\\Factory</code><code>app/Http/View/Composers</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass ViewServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        // Using class based composers...\n        View::composer(\n            'profile', 'App\\Http\\View\\Composers\\ProfileComposer'\n        );\n\n        // Using Closure based composers...\n        View::composer('dashboard', function ($view) {\n            //\n        });\n    }\n}</code></pre>\n  <blockquote>\n    <p>Recuerde, si crea un nuevo proveedor de servicios para que contenga los registros de su compositor de vistas, deberá agregar el proveedor de servicios a la <code>providers</code>matriz en el archivo de configuración.<code>config/app.php</code></p>\n  </blockquote>\n  <p>Ahora que hemos registrado el compositor, el <code>ProfileComposer@compose</code>método se ejecutará cada vez que se <code>profile</code>renderice la vista. Entonces, definamos la clase de compositor:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\View\\Composers;\n\nuse App\\Repositories\\UserRepository;\nuse Illuminate\\View\\View;\n\nclass ProfileComposer\n{\n    /**\n     * The user repository implementation.\n     *\n     * @var UserRepository\n     */\n    protected $users;\n\n    /**\n     * Create a new profile composer.\n     *\n     * @param  UserRepository  $users\n     * @return void\n     */\n    public function __construct(UserRepository $users)\n    {\n        // Dependencies automatically resolved by service container...\n        $this-&gt;users = $users;\n    }\n\n    /**\n     * Bind data to the view.\n     *\n     * @param  View  $view\n     * @return void\n     */\n    public function compose(View $view)\n    {\n        $view-&gt;with('count', $this-&gt;users-&gt;count());\n    }\n}</code></pre>\n  <p>Justo antes de renderizar la vista, <code>compose</code>se llama al método del compositor con la instancia. Puede utilizar el método para vincular datos a la vista.<code>Illuminate\\View\\View</code><code>with</code></p>\n  <blockquote>\n    <p>Todos los compositores de vistas se resuelven a través del contenedor de servicios , por lo que puede indicar cualquier dependencia que necesite dentro del constructor de un compositor.</p>\n  </blockquote>\n  <h4>Adjuntar un compositor a varias vistas</h4>\n  <p>Puede adjuntar un compositor de vistas a varias vistas a la vez pasando una matriz de vistas como primer argumento del <code>composer</code>método:</p>\n  <pre><code>View::composer(\n    ['profile', 'dashboard'],\n    'App\\Http\\View\\Composers\\MyViewComposer'\n);</code></pre>\n  <p>El <code>composer</code>método también acepta el <code>*</code>carácter como comodín, lo que le permite adjuntar un compositor a todas las vistas:</p>\n  <pre><code>View::composer('*', function ($view) {\n    //\n});</code></pre>\n  <h4>Ver creadores</h4>\n  <p>Los <strong>creadores de</strong> vistas son muy similares a los compositores de vistas; sin embargo, se ejecutan inmediatamente después de crear una instancia de la vista en lugar de esperar hasta que la vista esté a punto de renderizarse. Para registrar un creador de vistas, use el <code>creator</code>método:</p>\n  <pre><code>View::creator('profile', 'App\\Http\\View\\Creators\\ProfileCreator');</code></pre>\n  <p></p>\n  <h2>Optimización de vistas</h2>\n  <p>De forma predeterminada, las vistas se compilan a pedido. Cuando se ejecuta una solicitud que muestra una vista, Laravel determinará si existe una versión compilada de la vista. Si el archivo existe, Laravel determinará si la vista no compilada se ha modificado más recientemente que la vista compilada. Si la vista compilada no existe o la vista no compilada ha sido modificada, Laravel recompilará la vista.</p>\n  <p>La compilación de vistas durante la solicitud impacta negativamente en el rendimiento, por lo que Laravel proporciona el comando Artisan para precompilar todas las vistas utilizadas por su aplicación. Para un mayor rendimiento, es posible que desee ejecutar este comando como parte de su proceso de implementación:<code>view:cache</code></p>\n  <pre><code>php artisan view:cache</code></pre>\n  <p>Puede usar el comando para borrar el caché de vista:<code>view:clear</code></p>\n  <pre><code>php artisan view:clear</code></pre>\n</section>"
      },
      {
        "titulo": "3.8 Generación de URL",
        "contenido": "<section>\n  <h1>Generación de URL</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Los basicos\n      <ul>\n        <li>Generación de URL básicas</li>\n        <li>Accediendo a la URL actual</li>\n      </ul></li>\n    <li>URL para rutas con nombre\n      <ul>\n        <li>URL firmadas</li>\n      </ul></li>\n    <li>URL para acciones del controlador</li>\n    <li>Valores predeterminados</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel proporciona varios ayudantes para ayudarlo a generar URL para su aplicación. Estos son principalmente útiles al crear enlaces en sus plantillas y respuestas de API, o al generar respuestas de redireccionamiento a otra parte de su aplicación.</p>\n  <p></p>\n  <h2>Los basicos</h2>\n  <p></p>\n  <h3>Generación de URL básicas</h3>\n  <p>El <code>url</code>ayudante se puede utilizar para generar URL arbitrarias para su aplicación. La URL generada utilizará automáticamente el esquema (HTTP o HTTPS) y el host de la solicitud actual:</p>\n  <pre><code>$post = App\\Models\\Post::find(1);\n\necho url(\"/posts/{$post-&gt;id}\");\n\n// http://example.com/posts/1</code></pre>\n  <p></p>\n  <h3>Accediendo a la URL actual</h3>\n  <p>Si no se proporciona una ruta al <code>url</code>asistente, se devuelve una instancia, lo que le permite acceder a información sobre la URL actual:<code>Illuminate\\Routing\\UrlGenerator</code></p>\n  <pre><code>// Get the current URL without the query string...\necho url()-&gt;current();\n\n// Get the current URL including the query string...\necho url()-&gt;full();\n\n// Get the full URL for the previous request...\necho url()-&gt;previous();</code></pre>\n  <p>También se puede acceder a cada uno de estos métodos a través de la <code>URL</code> fachada :</p>\n  <pre><code>use Illuminate\\Support\\Facades\\URL;\n\necho URL::current();</code></pre>\n  <p></p>\n  <h2>URL para rutas con nombre</h2>\n  <p>El <code>route</code>ayudante se puede utilizar para generar URL a rutas con nombre. Las rutas con nombre le permiten generar URL sin estar acopladas a la URL real definida en la ruta. Por lo tanto, si cambia la URL de la ruta, no es necesario realizar cambios en sus <code>route</code>llamadas a funciones. Por ejemplo, imagina que tu aplicación contiene una ruta definida como la siguiente:</p>\n  <pre><code>Route::get('/post/{post}', function () {\n    //\n})-&gt;name('post.show');</code></pre>\n  <p>Para generar una URL a esta ruta, puede usar el <code>route</code>ayudante así:</p>\n  <pre><code>echo route('post.show', ['post' =&gt; 1]);\n\n// http://example.com/post/1</code></pre>\n  <p>A menudo, generará URL utilizando la clave principal de los modelos Eloquent . Por esta razón, puede pasar modelos Eloquent como valores de parámetro. El <code>route</code>ayudante extraerá automáticamente la clave principal del modelo:</p>\n  <pre><code>echo route('post.show', ['post' =&gt; $post]);</code></pre>\n  <p>El <code>route</code>ayudante también se puede utilizar para generar URL para rutas con múltiples parámetros:</p>\n  <pre><code>Route::get('/post/{post}/comment/{comment}', function () {\n    //\n})-&gt;name('comment.show');\n\necho route('comment.show', ['post' =&gt; 1, 'comment' =&gt; 3]);\n\n// http://example.com/post/1/comment/3</code></pre>\n  <p></p>\n  <h3>URL firmadas</h3>\n  <p>Laravel te permite crear fácilmente URL \"firmadas\" para rutas con nombre. Estas URL tienen un hash de \"firma\" adjunto a la cadena de consulta que permite a Laravel verificar que la URL no se ha modificado desde que se creó. Las URL firmadas son especialmente útiles para las rutas que son de acceso público pero necesitan una capa de protección contra la manipulación de URL.</p>\n  <p>Por ejemplo, puede utilizar URL firmadas para implementar un enlace público de \"cancelación de suscripción\" que se envía por correo electrónico a sus clientes. Para crear una URL firmada a una ruta con nombre, use el <code>signedRoute</code>método de la <code>URL</code>fachada:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\URL;\n\nreturn URL::signedRoute('unsubscribe', ['user' =&gt; 1]);</code></pre>\n  <p>Si desea generar una URL de ruta firmada temporal que expire, puede usar el <code>temporarySignedRoute</code>método:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\URL;\n\nreturn URL::temporarySignedRoute(\n    'unsubscribe', now()-&gt;addMinutes(30), ['user' =&gt; 1]\n);</code></pre>\n  <h4>Validación de solicitudes de ruta firmadas</h4>\n  <p>Para verificar que una solicitud entrante tiene una firma válida, debe llamar al <code>hasValidSignature</code>método en la entrante <code>Request</code>:</p>\n  <pre><code>use Illuminate\\Http\\Request;\n\nRoute::get('/unsubscribe/{user}', function (Request $request) {\n    if (! $request-&gt;hasValidSignature()) {\n        abort(401);\n    }\n\n    // ...\n})-&gt;name('unsubscribe');</code></pre>\n  <p>Alternativamente, puede asignar el middleware a la ruta. Si aún no está presente, debe asignar a este middleware una clave en la matriz de su kernel HTTP :<code>Illuminate\\Routing\\Middleware\\ValidateSignature</code><code>routeMiddleware</code></p>\n  <pre><code>/**\n * The application's route middleware.\n *\n * These middleware may be assigned to groups or used individually.\n *\n * @var array\n */\nprotected $routeMiddleware = [\n    'signed' =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,\n];</code></pre>\n  <p>Una vez que haya registrado el middleware en su kernel, puede adjuntarlo a una ruta. Si la solicitud entrante no tiene una firma válida, el middleware devolverá automáticamente una <code>403</code>respuesta de error:</p>\n  <pre><code>Route::post('/unsubscribe/{user}', function (Request $request) {\n    // ...\n})-&gt;name('unsubscribe')-&gt;middleware('signed');</code></pre>\n  <p></p>\n  <h2>URL para acciones del controlador</h2>\n  <p>La <code>action</code>función genera una URL para la acción del controlador dada:</p>\n  <pre><code>use App\\Http\\Controllers\\HomeController;\n\n$url = action([HomeController::class, 'index']);</code></pre>\n  <p>Si el método del controlador acepta parámetros de ruta, puede pasarlos como segundo argumento a la función:</p>\n  <pre><code>$url = action([UserController::class, 'profile'], ['id' =&gt; 1]);</code></pre>\n  <p></p>\n  <h2>Valores predeterminados</h2>\n  <p>Para algunas aplicaciones, es posible que desee especificar valores predeterminados para toda la solicitud para ciertos parámetros de URL. Por ejemplo, imagina que muchas de tus rutas definen un parámetro:<code>{locale}</code></p>\n  <pre><code>Route::get('/{locale}/posts', function () {\n    //\n})-&gt;name('post.index');</code></pre>\n  <p>Es engorroso pasar siempre <code>locale</code>cada vez que llama al <code>route</code>ayudante. Por lo tanto, puede usar el método para definir un valor predeterminado para este parámetro que siempre se aplicará durante la solicitud actual. Es posible que desee llamar a este método desde un middleware de ruta para que tenga acceso a la solicitud actual:<code>URL::defaults</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Support\\Facades\\URL;\n\nclass SetDefaultLocaleForUrls\n{\n    public function handle($request, Closure $next)\n    {\n        URL::defaults(['locale' =&gt; $request-&gt;user()-&gt;locale]);\n\n        return $next($request);\n    }\n}</code></pre>\n  <p>Una vez que se ha establecido el valor predeterminado para el <code>locale</code>parámetro, ya no es necesario que pase su valor al generar URL a través del <code>route</code>asistente.</p>\n  <h4>Valores predeterminados de URL y prioridad de middleware</h4>\n  <p>Establecer valores predeterminados de URL puede interferir con el manejo de Laravel de los enlaces de modelos implícitos. Por lo tanto, debe priorizar su middleware que establece los valores predeterminados de URL para que se ejecuten antes que el propio <code>SubstituteBindings</code>middleware de Laravel . Puede lograr esto asegurándose de que su middleware ocurra antes que el <code>SubstituteBindings</code>middleware dentro de la <code>$middlewarePriority</code>propiedad del kernel HTTP de su aplicación.</p>\n  <p>La <code>$middlewarePriority</code>propiedad está definida en la clase base . Puede copiar su definición de esa clase y sobrescribirla en el kernel HTTP de su aplicación para modificarla:<code>Illuminate\\Foundation\\Http\\Kernel</code></p>\n  <pre><code>/**\n * The priority-sorted list of middleware.\n *\n * This forces non-global middleware to always be in the given order.\n *\n * @var array\n */\nprotected $middlewarePriority = [\n    // ...\n     \\App\\Http\\MiddlewareSetDefaultLocaleForUrls::class,\n     \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n     // ...\n];</code></pre>\n</section>"
      },
      {
        "titulo": "3.9 Sesión",
        "contenido": "<section>\n  <h1>Sesión HTTP</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Configuración</li>\n        <li>Requisitos previos del controlador</li>\n      </ul></li>\n    <li>Usando la sesión\n      <ul>\n        <li>Recuperando datos</li>\n        <li>Almacenamiento de datos</li>\n        <li>Datos flash</li>\n        <li>Eliminar datos</li>\n        <li>Regenerando el ID de sesión</li>\n      </ul></li>\n    <li>Bloqueo de sesiones</li>\n    <li>Agregar controladores de sesión personalizados\n      <ul>\n        <li>Implementación del controlador</li>\n        <li>Registro del conductor</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Dado que las aplicaciones controladas por HTTP no tienen estado, las sesiones proporcionan una forma de almacenar información sobre el usuario en varias solicitudes. Laravel se envía con una variedad de backends de sesión a los que se accede a través de una API unificada y expresiva. Se incluye soporte para backends populares como Memcached , Redis y bases de datos.</p>\n  <p></p>\n  <h3>Configuración</h3>\n  <p>El archivo de configuración de la sesión se almacena en . Asegúrese de revisar las opciones disponibles para usted en este archivo. De forma predeterminada, Laravel está configurado para usar el controlador de sesión, que funcionará bien para muchas aplicaciones.<code>config/session.php</code><code>file</code></p>\n  <p>La <code>driver</code>opción de configuración de la sesión define dónde se almacenarán los datos de la sesión para cada solicitud. Laravel se envía con varios controladores geniales listos para usar:</p>\n  \n    <ul>\n      <li><code>file</code>- las sesiones se almacenan en .<code>storage/framework/sessions</code></li>\n      <li><code>cookie</code> - las sesiones se almacenan en cookies seguras y cifradas.</li>\n      <li><code>database</code> - las sesiones se almacenan en una base de datos relacional.</li>\n      <li><code>memcached</code>/ <code>redis</code>- las sesiones se almacenan en uno de estos almacenes rápidos basados \u200B\u200Ben caché.</li>\n      <li><code>array</code> - las sesiones se almacenan en una matriz PHP y no se conservarán.</li>\n    </ul>\n  \n  <blockquote>\n    <p>El controlador de matriz se utiliza durante las pruebas y evita que los datos almacenados en la sesión se conserven.</p>\n  </blockquote>\n  <p></p>\n  <h3>Requisitos previos del controlador</h3>\n  <h4>Base de datos</h4>\n  <p>Cuando utilice el <code>database</code>controlador de sesión, deberá crear una tabla que contenga los elementos de la sesión. A continuación se muestra una <code>Schema</code>declaración de ejemplo para la tabla:</p>\n  <pre><code>Schema::create('sessions', function ($table) {\n    $table-&gt;string('id')-&gt;unique();\n    $table-&gt;foreignId('user_id')-&gt;nullable();\n    $table-&gt;string('ip_address', 45)-&gt;nullable();\n    $table-&gt;text('user_agent')-&gt;nullable();\n    $table-&gt;text('payload');\n    $table-&gt;integer('last_activity');\n});</code></pre>\n  <p>Puede utilizar el comando Artisan para generar esta migración:<code>session:table</code></p>\n  <pre><code>php artisan session:table\n\nphp artisan migrate</code></pre>\n  <h4>Redis</h4>\n  <p>Antes de usar las sesiones de Redis con Laravel, deberá instalar la extensión PHP PhpRedis a través de PECL o instalar el paquete (~ 1.0) a través de Composer. Para obtener más información sobre la configuración de Redis, consulte su página de documentación de Laravel .<code>predis/predis</code></p>\n  <blockquote>\n    <p>En el <code>session</code>archivo de configuración, la <code>connection</code>opción puede usarse para especificar qué conexión Redis usa la sesión.</p>\n  </blockquote>\n  <p></p>\n  <h2>Usando la sesión</h2>\n  <p></p>\n  <h3>Recuperando datos</h3>\n  <p>Hay dos formas principales de trabajar con datos de sesión en Laravel: el <code>session</code>asistente global y a través de una <code>Request</code>instancia. Primero, veamos cómo acceder a la sesión a través de una <code>Request</code>instancia, que se puede insinuar en un método de controlador. Recuerde, las dependencias del método del controlador se inyectan automáticamente a través del contenedor de servicios de Laravel :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\n\nclass UserController extends Controller\n{\n    /**\n     * Show the profile for the given user.\n     *\n     * @param  Request  $request\n     * @param  int  $id\n     * @return Response\n     */\n    public function show(Request $request, $id)\n    {\n        $value = $request-&gt;session()-&gt;get('key');\n\n        //\n    }\n}</code></pre>\n  <p>Cuando recupera un elemento de la sesión, también puede pasar un valor predeterminado como segundo argumento del <code>get</code>método. Este valor predeterminado se devolverá si la clave especificada no existe en la sesión. Si pasa un <code>Closure</code>como valor predeterminado al <code>get</code>método y la clave solicitada no existe, <code>Closure</code>se ejecutará y se devolverá su resultado:</p>\n  <pre><code>$value = $request-&gt;session()-&gt;get('key', 'default');\n\n$value = $request-&gt;session()-&gt;get('key', function () {\n    return 'default';\n});</code></pre>\n  <h4>El asistente de sesión global</h4>\n  <p>También puede utilizar la <code>session</code>función PHP global para recuperar y almacenar datos en la sesión. Cuando <code>session</code>se llama al ayudante con un solo argumento de cadena, devolverá el valor de esa clave de sesión. Cuando se llama al ayudante con una matriz de pares clave / valor, esos valores se almacenarán en la sesión:</p>\n  <pre><code>Route::get('home', function () {\n    // Retrieve a piece of data from the session...\n    $value = session('key');\n\n    // Specifying a default value...\n    $value = session('key', 'default');\n\n    // Store a piece of data in the session...\n    session(['key' =&gt; 'value']);\n});</code></pre>\n  <blockquote>\n    <p>Hay poca diferencia práctica entre usar la sesión a través de una instancia de solicitud HTTP y usar el <code>session</code>asistente global . Ambos métodos se pueden probar a través del <code>assertSessionHas</code>método que está disponible en todos sus casos de prueba.</p>\n  </blockquote>\n  <h4>Recuperar todos los datos de la sesión</h4>\n  <p>Si desea recuperar todos los datos de la sesión, puede utilizar el <code>all</code>método:</p>\n  <pre><code>$data = $request-&gt;session()-&gt;all();</code></pre>\n  <h4>Determinar si existe un elemento en la sesión</h4>\n  <p>Para determinar si un elemento está presente en la sesión, puede usar el <code>has</code>método. El <code>has</code>método regresa <code>true</code>si el artículo está presente y no <code>null</code>:</p>\n  <pre><code>if ($request-&gt;session()-&gt;has('users')) {\n    //\n}</code></pre>\n  <p>Para determinar si un elemento está presente en la sesión, incluso si su valor lo es <code>null</code>, puede utilizar el <code>exists</code>método. El <code>exists</code>método devuelve <code>true</code>si el artículo está presente:</p>\n  <pre><code>if ($request-&gt;session()-&gt;exists('users')) {\n    //\n}</code></pre>\n  <p></p>\n  <h3>Almacenamiento de datos</h3>\n  <p>Para almacenar datos en la sesión, normalmente utilizará el <code>put</code>método o el <code>session</code>asistente:</p>\n  <pre><code>// Via a request instance...\n$request-&gt;session()-&gt;put('key', 'value');\n\n// Via the global helper...\nsession(['key' =&gt; 'value']);</code></pre>\n  <h4>Empujar a matriz de valores de sesión</h4>\n  <p>El <code>push</code>método puede usarse para insertar un nuevo valor en un valor de sesión que es una matriz. Por ejemplo, si la clave contiene una matriz de nombres de equipos, puede insertar un nuevo valor en la matriz de la siguiente manera:<code>user.teams</code></p>\n  <pre><code>$request-&gt;session()-&gt;push('user.teams', 'developers');</code></pre>\n  <h4>Recuperar y eliminar un elemento</h4>\n  <p>El <code>pull</code>método recuperará y eliminará un elemento de la sesión en una sola declaración:</p>\n  <pre><code>$value = $request-&gt;session()-&gt;pull('key', 'default');</code></pre>\n  <p></p>\n  <h3>Datos flash</h3>\n  <p>A veces, es posible que desee almacenar elementos en la sesión solo para la próxima solicitud. Puede hacerlo utilizando el <code>flash</code>método. Los datos almacenados en la sesión que utiliza este método estarán disponibles inmediatamente y durante la siguiente solicitud HTTP. Después de la solicitud HTTP posterior, se eliminarán los datos actualizados. Los datos flash son útiles principalmente para mensajes de estado de corta duración:</p>\n  <pre><code>$request-&gt;session()-&gt;flash('status', 'Task was successful!');</code></pre>\n  <p>Si necesita mantener sus datos flash para varias solicitudes, puede usar el <code>reflash</code>método, que conservará todos los datos flash para una solicitud adicional. Si solo necesita mantener datos flash específicos, puede usar el <code>keep</code>método:</p>\n  <pre><code>$request-&gt;session()-&gt;reflash();\n\n$request-&gt;session()-&gt;keep(['username', 'email']);</code></pre>\n  <p></p>\n  <h3>Eliminar datos</h3>\n  <p>El <code>forget</code>método eliminará una parte de los datos de la sesión. Si desea eliminar todos los datos de la sesión, puede utilizar el <code>flush</code>método:</p>\n  <pre><code>// Forget a single key...\n$request-&gt;session()-&gt;forget('key');\n\n// Forget multiple keys...\n$request-&gt;session()-&gt;forget(['key1', 'key2']);\n\n$request-&gt;session()-&gt;flush();</code></pre>\n  <p></p>\n  <h3>Regenerando el ID de sesión</h3>\n  <p>La regeneración del ID de sesión se realiza a menudo para evitar que usuarios malintencionados aprovechen un ataque de fijación de sesión en su aplicación.</p>\n  <p>Laravel regenera automáticamente la ID de sesión durante la autenticación si está utilizando Laravel Jetstream ; sin embargo, si necesita volver a generar manualmente el ID de sesión, puede utilizar el <code>regenerate</code>método.</p>\n  <pre><code>$request-&gt;session()-&gt;regenerate();</code></pre>\n  <p></p>\n  <h2>Bloqueo de sesiones</h2>\n  <blockquote>\n    <p>Para utilizar el bloqueo de sesión, su aplicación debe utilizar un controlador de caché que admita bloqueos atómicos . Actualmente, los conductores de caché incluyen las <code>memcached</code>, <code>dynamodb</code>, <code>redis</code>, y <code>database</code>los conductores. Además, no puede utilizar el <code>cookie</code>controlador de sesión.</p>\n  </blockquote>\n  <p>De forma predeterminada, Laravel permite que las solicitudes que usan la misma sesión se ejecuten simultáneamente. Entonces, por ejemplo, si usa una biblioteca HTTP de JavaScript para realizar dos solicitudes HTTP a su aplicación, ambas se ejecutarán al mismo tiempo. Para muchas aplicaciones, esto no es un problema; sin embargo, la pérdida de datos de la sesión puede ocurrir en un pequeño subconjunto de aplicaciones que realizan solicitudes simultáneas a dos puntos finales de aplicaciones diferentes que escriben datos en la sesión.</p>\n  <p>Para mitigar esto, Laravel proporciona una funcionalidad que le permite limitar las solicitudes simultáneas para una sesión determinada. Para comenzar, simplemente puede encadenar el <code>block</code>método a la definición de su ruta. En este ejemplo, una solicitud entrante al <code>/profile</code>punto final adquiriría un bloqueo de sesión. Mientras se mantiene este bloqueo, cualquier solicitud entrante a los puntos finales <code>/profile</code>o <code>/order</code>que comparten el mismo ID de sesión esperará a que la primera solicitud termine de ejecutarse antes de continuar con su ejecución:</p>\n  <pre><code>Route::post('/profile', function () {\n    //\n})-&gt;block($lockSeconds = 10, $waitSeconds = 10)\n\nRoute::post('/order', function () {\n    //\n})-&gt;block($lockSeconds = 10, $waitSeconds = 10)</code></pre>\n  <p>El <code>block</code>método acepta dos argumentos opcionales. El primer argumento aceptado por el <code>block</code>método es el número máximo de segundos que debe mantenerse el bloqueo de la sesión antes de que se libere. Por supuesto, si la solicitud termina de ejecutarse antes de este tiempo, el bloqueo se liberará antes.</p>\n  <p>El segundo argumento aceptado por el <code>block</code>método es la cantidad de segundos que debe esperar una solicitud mientras intenta obtener un bloqueo de sesión. Se lanzará A si la solicitud no puede obtener un bloqueo de sesión dentro del número de segundos especificado.<code>Illuminate\\Contracts\\Cache\\LockTimeoutException</code></p>\n  <p>Si no se pasa ninguno de estos argumentos, el bloqueo se obtendrá durante un máximo de 10 segundos y las solicitudes esperarán un máximo de 10 segundos mientras intentan obtener un bloqueo:</p>\n  <pre><code>Route::post('/profile', function () {\n    //\n})-&gt;block()</code></pre>\n  <p></p>\n  <h2>Agregar controladores de sesión personalizados</h2>\n  <p></p>\n  <h4>Implementación del controlador</h4>\n  <p>Su controlador de sesión personalizado debe implementar <code>SessionHandlerInterface</code>. Esta interfaz contiene solo algunos métodos simples que debemos implementar. Una implementación de MongoDB cortada se parece a esto:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Extensions;\n\nclass MongoSessionHandler implements \\SessionHandlerInterface\n{\n    public function open($savePath, $sessionName) {}\n    public function close() {}\n    public function read($sessionId) {}\n    public function write($sessionId, $data) {}\n    public function destroy($sessionId) {}\n    public function gc($lifetime) {}\n}</code></pre>\n  <blockquote>\n    <p>Laravel no incluye un directorio que contenga tus extensiones. Puede colocarlos en cualquier lugar que desee. En este ejemplo, hemos creado un <code>Extensions</code>directorio para albergar el <code>MongoSessionHandler</code>.</p>\n  </blockquote>\n  <p>Dado que el propósito de estos métodos no es fácilmente comprensible, cubramos rápidamente lo que hace cada uno de los métodos:</p>\n  \n    <ul>\n      <li>El <code>open</code>método se utilizaría normalmente en sistemas de almacenamiento de sesiones basados \u200B\u200Ben archivos. Dado que Laravel se envía con un <code>file</code>controlador de sesión, casi nunca necesitará poner nada en este método. Puede dejarlo como un talón vacío. Es un hecho del diseño deficiente de la interfaz (que discutiremos más adelante) que PHP requiere que implementemos este método.</li>\n      <li>El <code>close</code>método, al igual que el <code>open</code>método, generalmente también puede ignorarse. Para la mayoría de los conductores, no es necesario.</li>\n      <li>El <code>read</code>método debe devolver la versión de cadena de los datos de sesión asociados con el dado <code>$sessionId</code>. No es necesario realizar ninguna serialización u otra codificación al recuperar o almacenar datos de sesión en su controlador, ya que Laravel realizará la serialización por usted.</li>\n      <li>El <code>write</code>método debe escribir la <code>$data</code>cadena dada asociada con el <code>$sessionId</code>en algún sistema de almacenamiento persistente, como MongoDB, Dynamo, etc. Nuevamente, no debe realizar ninguna serialización - Laravel ya lo habrá manejado por usted.</li>\n      <li>El <code>destroy</code>método debe eliminar los datos asociados con el <code>$sessionId</code>del almacenamiento persistente.</li>\n      <li>El <code>gc</code>método debe destruir todos los datos de la sesión que sean más antiguos que los indicados <code>$lifetime</code>, que es una marca de tiempo de UNIX. Para sistemas que caducan automáticamente como Memcached y Redis, este método puede dejarse vacío.</li>\n    </ul>\n  \n  <p></p>\n  <h4>Registro del conductor</h4>\n  <p>Una vez que se haya implementado su controlador, estará listo para registrarlo con el marco. Para agregar controladores adicionales al backend de la sesión de Laravel, puede usar el <code>extend</code>método en la <code>Session</code> fachada . Debe llamar al <code>extend</code>método desde el <code>boot</code>método de un proveedor de servicios . Puede hacer esto desde el <code>AppServiceProvider</code>proveedor existente o crear uno completamente nuevo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse App\\Extensions\\MongoSessionHandler;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass SessionServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Session::extend('mongo', function ($app) {\n            // Return implementation of SessionHandlerInterface...\n            return new MongoSessionHandler;\n        });\n    }\n}</code></pre>\n  <p>Una vez que se haya registrado el controlador de sesión, puede utilizar el <code>mongo</code>controlador en su archivo de configuración.<code>config/session.php</code></p>\n</section>"
      },
      {
        "titulo": "3.10 Validación",
        "contenido": "<section>\n  <h1>Validación</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Inicio rápido de validación\n      <ul>\n        <li>Definiendo las rutas</li>\n        <li>Creando el controlador</li>\n        <li>Escribir la lógica de validación</li>\n        <li>Visualización de los errores de validación</li>\n        <li>Una nota sobre los campos opcionales</li>\n      </ul></li>\n    <li>Validación de solicitud de formulario\n      <ul>\n        <li>Crear solicitudes de formulario</li>\n        <li>Autorización de solicitudes de formulario</li>\n        <li>Personalización de los mensajes de error</li>\n        <li>Personalización de los atributos de validación</li>\n        <li>Preparar la entrada para la validación</li>\n      </ul></li>\n    <li>Creación manual de validadores\n      <ul>\n        <li>Redirección automática</li>\n        <li>Bolsas de error con nombre</li>\n        <li>Después del gancho de validación</li>\n      </ul></li>\n    <li>Trabajar con mensajes de error\n      <ul>\n        <li>Mensajes de error personalizados</li>\n      </ul></li>\n    <li>Reglas de validación disponibles</li>\n    <li>Agregar reglas condicionalmente</li>\n    <li>Validación de matrices</li>\n    <li>Reglas de validación personalizadas\n      <ul>\n        <li>Usar objetos de regla</li>\n        <li>Usando cierres</li>\n        <li>Usar extensiones</li>\n        <li>Extensiones implícitas</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel proporciona varios enfoques diferentes para validar los datos entrantes de su aplicación. De forma predeterminada, la clase de controlador base de Laravel usa un <code>ValidatesRequests</code>rasgo que proporciona un método conveniente para validar las solicitudes HTTP entrantes con una variedad de poderosas reglas de validación.</p>\n  <p></p>\n  <h2>Inicio rápido de validación</h2>\n  <p>Para conocer las potentes funciones de validación de Laravel, veamos un ejemplo completo de cómo validar un formulario y mostrar los mensajes de error al usuario.</p>\n  <p></p>\n  <h3>Definiendo las rutas</h3>\n  <p>Primero, supongamos que tenemos las siguientes rutas definidas en nuestro archivo:<code>routes/web.php</code></p>\n  <pre><code>use App\\Http\\Controllers\\PostController;\n\nRoute::get('post/create', [PostController::class, 'create']);\n\nRoute::post('post', [PostController::class, 'store']);</code></pre>\n  <p>La <code>GET</code>ruta mostrará un formulario para que el usuario cree una nueva publicación de blog, mientras que la <code>POST</code>ruta almacenará la nueva publicación de blog en la base de datos.</p>\n  <p></p>\n  <h3>Creando el controlador</h3>\n  <p>A continuación, echemos un vistazo a un controlador simple que maneja estas rutas. Dejaremos el <code>store</code>método vacío por ahora:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\n\nclass PostController extends Controller\n{\n    /**\n     * Show the form to create a new blog post.\n     *\n     * @return Response\n     */\n    public function create()\n    {\n        return view('post.create');\n    }\n\n    /**\n     * Store a new blog post.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        // Validate and store the blog post...\n    }\n}</code></pre>\n  <p></p>\n  <h3>Escribir la lógica de validación</h3>\n  <p>Ahora estamos listos para completar nuestro <code>store</code>método con la lógica para validar la nueva publicación del blog. Para hacer esto, usaremos el <code>validate</code>método proporcionado por el objeto. Si pasan las reglas de validación, su código seguirá ejecutándose normalmente; sin embargo, si la validación falla, se lanzará una excepción y la respuesta de error adecuada se enviará automáticamente al usuario. En el caso de una solicitud HTTP tradicional, se generará una respuesta de redireccionamiento, mientras que se enviará una respuesta JSON para las solicitudes AJAX.<code>Illuminate\\Http\\Request</code></p>\n  <p>Para comprender mejor el <code>validate</code>método, regresemos al <code>store</code>método:</p>\n  <pre><code>/**\n * Store a new blog post.\n *\n * @param  Request  $request\n * @return Response\n */\npublic function store(Request $request)\n{\n    $validatedData = $request-&gt;validate([\n        'title' =&gt; 'required|unique:posts|max:255',\n        'body' =&gt; 'required',\n    ]);\n\n    // The blog post is valid...\n}</code></pre>\n  <p>Como puede ver, pasamos las reglas de validación deseadas al <code>validate</code>método. Nuevamente, si la validación falla, se generará automáticamente la respuesta adecuada. Si la validación pasa, nuestro controlador continuará ejecutándose normalmente.</p>\n  <p>Alternativamente, las reglas de validación se pueden especificar como matrices de reglas en lugar de una sola <code>|</code>cadena delimitada:</p>\n  <pre><code>$validatedData = $request-&gt;validate([\n    'title' =&gt; ['required', 'unique:posts', 'max:255'],\n    'body' =&gt; ['required'],\n]);</code></pre>\n  <p>Puede usar el <code>validateWithBag</code>método para validar una solicitud y almacenar cualquier mensaje de error dentro de una bolsa de error con nombre :</p>\n  <pre><code>$validatedData = $request-&gt;validateWithBag('post', [\n    'title' =&gt; ['required', 'unique:posts', 'max:255'],\n    'body' =&gt; ['required'],\n]);</code></pre>\n  <h4>Detención ante la primera falla de validación</h4>\n  <p>A veces, es posible que desee dejar de ejecutar reglas de validación en un atributo después del primer error de validación. Para hacerlo, asigne la <code>bail</code>regla al atributo:</p>\n  <pre><code>$request-&gt;validate([\n    'title' =&gt; 'bail|required|unique:posts|max:255',\n    'body' =&gt; 'required',\n]);</code></pre>\n  <p>En este ejemplo, si la <code>unique</code>regla del <code>title</code>atributo falla, <code>max</code>no se verificará la regla. Las reglas se validarán en el orden en que se asignan.</p>\n  <h4>Una nota sobre los atributos anidados</h4>\n  <p>Si su solicitud HTTP contiene parámetros \"anidados\", puede especificarlos en sus reglas de validación usando la sintaxis de \"punto\":</p>\n  <pre><code>$request-&gt;validate([\n    'title' =&gt; 'required|unique:posts|max:255',\n    'author.name' =&gt; 'required',\n    'author.description' =&gt; 'required',\n]);</code></pre>\n  <p></p>\n  <h3>Visualización de los errores de validación</h3>\n  <p>Entonces, ¿qué pasa si los parámetros de la solicitud entrante no pasan las reglas de validación dadas? Como se mencionó anteriormente, Laravel redirigirá automáticamente al usuario a su ubicación anterior. Además, todos los errores de validación se mostrarán automáticamente a la sesión .</p>\n  <p>Nuevamente, observe que no tuvimos que vincular explícitamente los mensajes de error a la vista en nuestra <code>GET</code>ruta. Esto se debe a que Laravel buscará errores en los datos de la sesión y los vinculará automáticamente a la vista si están disponibles. La <code>$errors</code>variable será una instancia de . Para obtener más información sobre cómo trabajar con este objeto, consulte su documentación .<code>Illuminate\\Support\\MessageBag</code></p>\n  <blockquote>\n    <p>La <code>$errors</code>variable está vinculada a la vista por el middleware, que es proporcionado por el grupo de middleware. <strong>Cuando se aplica este middleware, una </strong><strong>variable siempre estará disponible en sus vistas</strong> , lo que le permitirá asumir convenientemente que la variable siempre está definida y se puede utilizar de forma segura.<code>Illuminate\\View\\Middleware\\ShareErrorsFromSession</code><code>web</code><strong><code>$errors</code></strong><code>$errors</code></p>\n  </blockquote>\n  <p>Entonces, en nuestro ejemplo, el usuario será redirigido al <code>create</code>método de nuestro controlador cuando falla la validación, lo que nos permite mostrar los mensajes de error en la vista:</p>\n  <pre><code>&lt;!-- /resources/views/post/create.blade.php --&gt;\n\n&lt;h1&gt;Create Post&lt;/h1&gt;\n\n@if ($errors-&gt;any())\n    &lt;div class=\"alert alert-danger\"&gt;\n        &lt;ul&gt;\n            @foreach ($errors-&gt;all() as $error)\n                &lt;li&gt;{{ $error }}&lt;/li&gt;\n            @endforeach\n        &lt;/ul&gt;\n    &lt;/div&gt;\n@endif\n\n&lt;!-- Create Post Form --&gt;</code></pre>\n  <h4>La <code>@error</code>directiva</h4>\n  <p>También puede utilizar la directiva <code>@error</code> Blade para comprobar rápidamente si existen mensajes de error de validación para un atributo determinado. Dentro de una <code>@error</code>directiva, puede hacer eco de la <code>$message</code>variable para mostrar el mensaje de error:</p>\n  <pre><code>&lt;!-- /resources/views/post/create.blade.php --&gt;\n\n&lt;label for=\"title\"&gt;Post Title&lt;/label&gt;\n\n&lt;input id=\"title\" type=\"text\" class=\"@error('title') is-invalid @enderror\"&gt;\n\n@error('title')\n    &lt;div class=\"alert alert-danger\"&gt;{{ $message }}&lt;/div&gt;\n@enderror</code></pre>\n  <p></p>\n  <h3>Una nota sobre los campos opcionales</h3>\n  <p>De forma predeterminada, Laravel incluye el middleware <code>TrimStrings</code>y <code>ConvertEmptyStringsToNull</code>en la pila de middleware global de su aplicación. Estos middleware se enumeran en la pila por clase. Debido a esto, a menudo necesitará marcar sus campos de solicitud \"opcionales\" como si no quisiera que el validador considere los valores como no válidos. Por ejemplo:<code>App\\Http\\Kernel</code><code>nullable</code><code>null</code></p>\n  <pre><code>$request-&gt;validate([\n    'title' =&gt; 'required|unique:posts|max:255',\n    'body' =&gt; 'required',\n    'publish_at' =&gt; 'nullable|date',\n]);</code></pre>\n  <p>En este ejemplo, estamos especificando que el <code>publish_at</code>campo puede ser <code>null</code>o una representación de fecha válida. Si el <code>nullable</code>modificador no se agrega a la definición de la regla, el validador consideraría <code>null</code>una fecha no válida.</p>\n  <p></p>\n  <h4 id=\"quick-ajax-requests-and-validation\">Solicitudes y validación de AJAX</h4>\n  <p>En este ejemplo, usamos un formulario tradicional para enviar datos a la aplicación. Sin embargo, muchas aplicaciones utilizan solicitudes AJAX. Cuando se usa el <code>validate</code>método durante una solicitud AJAX, Laravel no generará una respuesta de redireccionamiento. En cambio, Laravel genera una respuesta JSON que contiene todos los errores de validación. Esta respuesta JSON se enviará con un código de estado HTTP 422.</p>\n  <p></p>\n  <h2>Validación de solicitud de formulario</h2>\n  <p></p>\n  <h3>Crear solicitudes de formulario</h3>\n  <p>Para escenarios de validación más complejos, es posible que desee crear una \"solicitud de formulario\". Las solicitudes de formulario son clases de solicitud personalizadas que contienen lógica de validación. Para crear una clase de solicitud de formulario, use el comando de la CLI de Artisan:<code>make:request</code></p>\n  <pre><code>php artisan make:request StoreBlogPost</code></pre>\n  <p>La clase generada se colocará en el directorio. Si este directorio no existe, se creará cuando ejecute el comando. Agreguemos algunas reglas de validación al método:<code>app/Http/Requests</code><code>make:request</code><code>rules</code></p>\n  <pre><code>/**\n * Get the validation rules that apply to the request.\n *\n * @return array\n */\npublic function rules()\n{\n    return [\n        'title' =&gt; 'required|unique:posts|max:255',\n        'body' =&gt; 'required',\n    ];\n}</code></pre>\n  <blockquote>\n    <p>Puede escribir sugerencias sobre las dependencias que necesite dentro de la <code>rules</code>firma del método. Se resolverán automáticamente a través del contenedor de servicios de Laravel .</p>\n  </blockquote>\n  <p>Entonces, ¿cómo se evalúan las reglas de validación? Todo lo que necesita hacer es escribir la solicitud en el método de su controlador. La solicitud de formulario entrante se valida antes de que se llame al método del controlador, lo que significa que no es necesario saturar su controlador con ninguna lógica de validación:</p>\n  <pre><code>/**\n * Store the incoming blog post.\n *\n * @param  StoreBlogPost  $request\n * @return Response\n */\npublic function store(StoreBlogPost $request)\n{\n    // The incoming request is valid...\n\n    // Retrieve the validated input data...\n    $validated = $request-&gt;validated();\n}</code></pre>\n  <p>Si la validación falla, se generará una respuesta de redireccionamiento para enviar al usuario de regreso a su ubicación anterior. Los errores también se mostrarán en la sesión para que estén disponibles para su visualización. Si la solicitud era una solicitud AJAX, se devolverá al usuario una respuesta HTTP con un código de estado 422, incluida una representación JSON de los errores de validación.</p>\n  <h4>Adición de enlaces posteriores a solicitudes de formulario</h4>\n  <p>Si desea agregar un gancho \"después\" a una solicitud de formulario, puede usar el <code>withValidator</code>método. Este método recibe el validador completamente construido, lo que le permite llamar a cualquiera de sus métodos antes de que se evalúen las reglas de validación:</p>\n  <pre><code>/**\n * Configure the validator instance.\n *\n * @param  \\Illuminate\\Validation\\Validator  $validator\n * @return void\n */\npublic function withValidator($validator)\n{\n    $validator-&gt;after(function ($validator) {\n        if ($this-&gt;somethingElseIsInvalid()) {\n            $validator-&gt;errors()-&gt;add('field', 'Something is wrong with this field!');\n        }\n    });\n}</code></pre>\n  <p></p>\n  <h3>Autorización de solicitudes de formulario</h3>\n  <p>La clase de solicitud de formulario también contiene un <code>authorize</code>método. Dentro de este método, puede verificar si el usuario autenticado realmente tiene la autoridad para actualizar un recurso determinado. Por ejemplo, puede determinar si un usuario es propietario de un comentario de blog que está intentando actualizar:</p>\n  <pre><code>/**\n * Determine if the user is authorized to make this request.\n *\n * @return bool\n */\npublic function authorize()\n{\n    $comment = Comment::find($this-&gt;route('comment'));\n\n    return $comment &amp;&amp; $this-&gt;user()-&gt;can('update', $comment);\n}</code></pre>\n  <p>Dado que todas las solicitudes de formulario extienden la clase de solicitud base de Laravel, podemos usar el <code>user</code>método para acceder al usuario actualmente autenticado. También tenga en cuenta la llamada al <code>route</code>método en el ejemplo anterior. Este método le otorga acceso a los parámetros de URI definidos en la ruta que se llama, como el parámetro en el ejemplo siguiente:<code>{comment}</code></p>\n  <pre><code>Route::post('comment/{comment}');</code></pre>\n  <p>Si el <code>authorize</code>método regresa <code>false</code>, se devolverá automáticamente una respuesta HTTP con un código de estado 403 y su método de controlador no se ejecutará.</p>\n  <p>Si planea tener una lógica de autorización en otra parte de su aplicación, regrese <code>true</code>del <code>authorize</code>método:</p>\n  <pre><code>/**\n * Determine if the user is authorized to make this request.\n *\n * @return bool\n */\npublic function authorize()\n{\n    return true;\n}</code></pre>\n  <blockquote>\n    <p>Puede escribir sugerencias sobre las dependencias que necesite dentro de la <code>authorize</code>firma del método. Se resolverán automáticamente a través del contenedor de servicios de Laravel .</p>\n  </blockquote>\n  <p></p>\n  <h3>Personalización de los mensajes de error</h3>\n  <p>Puede personalizar los mensajes de error utilizados por la solicitud de formulario anulando el <code>messages</code>método. Este método debe devolver una matriz de pares de atributos / reglas y sus mensajes de error correspondientes:</p>\n  <pre><code>/**\n * Get the error messages for the defined validation rules.\n *\n * @return array\n */\npublic function messages()\n{\n    return [\n        'title.required' =&gt; 'A title is required',\n        'body.required' =&gt; 'A message is required',\n    ];\n}</code></pre>\n  <p></p>\n  <h3>Personalización de los atributos de validación</h3>\n  <p>Si desea que la <code>:attribute</code>parte de su mensaje de validación se reemplace con un nombre de atributo personalizado, puede especificar los nombres personalizados anulando el <code>attributes</code>método. Este método debería devolver una matriz de pares de atributo / nombre:</p>\n  <pre><code>/**\n * Get custom attributes for validator errors.\n *\n * @return array\n */\npublic function attributes()\n{\n    return [\n        'email' =&gt; 'email address',\n    ];\n}</code></pre>\n  <p></p>\n  <h3>Preparar la entrada para la validación</h3>\n  <p>Si necesita desinfectar algún dato de la solicitud antes de aplicar sus reglas de validación, puede usar el <code>prepareForValidation</code>método:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n/**\n * Prepare the data for validation.\n *\n * @return void\n */\nprotected function prepareForValidation()\n{\n    $this-&gt;merge([\n        'slug' =&gt; Str::slug($this-&gt;slug),\n    ]);\n}</code></pre>\n  <p></p>\n  <h2>Creación manual de validadores</h2>\n  <p>Si no desea utilizar el <code>validate</code>método en la solicitud, puede crear una instancia de validación manualmente utilizando la <code>Validator</code> fachada . El <code>make</code>método en la fachada genera una nueva instancia de validación:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Validator;\n\nclass PostController extends Controller\n{\n    /**\n     * Store a new blog post.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        $validator = Validator::make($request-&gt;all(), [\n            'title' =&gt; 'required|unique:posts|max:255',\n            'body' =&gt; 'required',\n        ]);\n\n        if ($validator-&gt;fails()) {\n            return redirect('post/create')\n                        -&gt;withErrors($validator)\n                        -&gt;withInput();\n        }\n\n        // Store the blog post...\n    }\n}</code></pre>\n  <p>El primer argumento que se pasa al <code>make</code>método son los datos en validación. El segundo argumento son las reglas de validación que deben aplicarse a los datos.</p>\n  <p>Después de verificar si la validación de la solicitud falló, puede usar el <code>withErrors</code>método para mostrar los mensajes de error a la sesión. Al usar este método, la <code>$errors</code>variable se compartirá automáticamente con sus vistas después de la redirección, lo que le permitirá mostrarlas fácilmente al usuario. El <code>withErrors</code>método acepta un validador, a <code>MessageBag</code>o PHP <code>array</code>.</p>\n  <p></p>\n  <h3>Redirección automática</h3>\n  <p>Si desea crear una instancia de validador manualmente pero aún así aprovechar la redirección automática que ofrece el <code>validate</code>método de la solicitud , puede llamar al <code>validate</code>método en una instancia de validador existente. Si la validación falla, el usuario será redirigido automáticamente o, en el caso de una solicitud AJAX, se devolverá una respuesta JSON:</p>\n  <pre><code>Validator::make($request-&gt;all(), [\n    'title' =&gt; 'required|unique:posts|max:255',\n    'body' =&gt; 'required',\n])-&gt;validate();</code></pre>\n  <p>Puede utilizar el <code>validateWithBag</code>método para almacenar los mensajes de error en una bolsa de error con nombre si falla la validación:</p>\n  <pre><code>Validator::make($request-&gt;all(), [\n    'title' =&gt; 'required|unique:posts|max:255',\n    'body' =&gt; 'required',\n])-&gt;validateWithBag('post');</code></pre>\n  <p></p>\n  <h3>Bolsas de error con nombre</h3>\n  <p>Si tiene varios formularios en una sola página, es posible que desee nombrar los <code>MessageBag</code>errores, lo que le permitirá recuperar los mensajes de error para un formulario específico. Pase un nombre como segundo argumento a <code>withErrors</code>:</p>\n  <pre><code>return redirect('register')\n            -&gt;withErrors($validator, 'login');</code></pre>\n  <p>Luego puede acceder a la <code>MessageBag</code>instancia nombrada desde la <code>$errors</code>variable:</p>\n  <pre><code>{{ $errors-&gt;login-&gt;first('email') }}</code></pre>\n  <p></p>\n  <h3>Después del gancho de validación</h3>\n  <p>El validador también le permite adjuntar devoluciones de llamada para que se ejecuten después de que se complete la validación. Esto le permite realizar fácilmente más validaciones e incluso agregar más mensajes de error a la colección de mensajes. Para comenzar, use el <code>after</code>método en una instancia de validador:</p>\n  <pre><code>$validator = Validator::make(...);\n\n$validator-&gt;after(function ($validator) {\n    if ($this-&gt;somethingElseIsInvalid()) {\n        $validator-&gt;errors()-&gt;add('field', 'Something is wrong with this field!');\n    }\n});\n\nif ($validator-&gt;fails()) {\n    //\n}</code></pre>\n  <p></p>\n  <h2>Trabajar con mensajes de error</h2>\n  <p>Después de llamar al <code>errors</code>método en una <code>Validator</code>instancia, recibirá una instancia, que tiene una variedad de métodos convenientes para trabajar con mensajes de error. La variable que se pone automáticamente a disposición de todas las vistas también es una instancia de la clase.<code>Illuminate\\Support\\MessageBag</code><code>$errors</code><code>MessageBag</code></p>\n  <h4>Recuperando el primer mensaje de error para un campo</h4>\n  <p>Para recuperar el primer mensaje de error de un campo determinado, utilice el <code>first</code>método:</p>\n  <pre><code>$errors = $validator-&gt;errors();\n\necho $errors-&gt;first('email');</code></pre>\n  <h4>Recuperar todos los mensajes de error de un campo</h4>\n  <p>Si necesita recuperar una matriz de todos los mensajes para un campo determinado, use el <code>get</code>método:</p>\n  <pre><code>foreach ($errors-&gt;get('email') as $message) {\n    //\n}</code></pre>\n  <p>Si está validando un campo de formulario de matriz, puede recuperar todos los mensajes para cada uno de los elementos de la matriz utilizando el <code>*</code>carácter:</p>\n  <pre><code>foreach ($errors-&gt;get('attachments.*') as $message) {\n    //\n}</code></pre>\n  <h4>Recuperación de todos los mensajes de error para todos los campos</h4>\n  <p>Para recuperar una matriz de todos los mensajes para todos los campos, use el <code>all</code>método:</p>\n  <pre><code>foreach ($errors-&gt;all() as $message) {\n    //\n}</code></pre>\n  <h4>Determinar si existen mensajes para un campo</h4>\n  <p>El <code>has</code>método se puede utilizar para determinar si existe algún mensaje de error para un campo determinado:</p>\n  <pre><code>if ($errors-&gt;has('email')) {\n    //\n}</code></pre>\n  <p></p>\n  <h3>Mensajes de error personalizados</h3>\n  <p>Si es necesario, puede utilizar mensajes de error personalizados para la validación en lugar de los valores predeterminados. Hay varias formas de especificar mensajes personalizados. Primero, puede pasar los mensajes personalizados como tercer argumento del método:<code>Validator::make</code></p>\n  <pre><code>$messages = [\n    'required' =&gt; 'The :attribute field is required.',\n];\n\n$validator = Validator::make($input, $rules, $messages);</code></pre>\n  <p>En este ejemplo, el <code>:attribute</code>marcador de posición será reemplazado por el nombre real del campo bajo validación. También puede utilizar otros marcadores de posición en los mensajes de validación. Por ejemplo:</p>\n  <pre><code>$messages = [\n    'same' =&gt; 'The :attribute and :other must match.',\n    'size' =&gt; 'The :attribute must be exactly :size.',\n    'between' =&gt; 'The :attribute value :input is not between :min - :max.',\n    'in' =&gt; 'The :attribute must be one of the following types: :values',\n];</code></pre>\n  <h4>Especificar un mensaje personalizado para un atributo dado</h4>\n  <p>A veces, es posible que desee especificar un mensaje de error personalizado solo para un campo específico. Puede hacerlo utilizando la notación de \"puntos\". Primero especifique el nombre del atributo, seguido de la regla:</p>\n  <pre><code>$messages = [\n    'email.required' =&gt; 'We need to know your e-mail address!',\n];</code></pre>\n  <p></p>\n  <h4 id=\"localization\">Especificación de mensajes personalizados en archivos de idioma</h4>\n  <p>En la mayoría de los casos, probablemente especificará sus mensajes personalizados en un archivo de idioma en lugar de pasarlos directamente al archivo <code>Validator</code>. Para hacerlo, agregue sus mensajes a la <code>custom</code>matriz en el archivo de idioma.<code>resources/lang/xx/validation.php</code></p>\n  <pre><code>'custom' =&gt; [\n    'email' =&gt; [\n        'required' =&gt; 'We need to know your e-mail address!',\n    ],\n],</code></pre>\n  <h4>Especificar valores de atributos personalizados</h4>\n  <p>Si desea que la <code>:attribute</code>parte de su mensaje de validación sea reemplazada por un nombre de atributo personalizado, puede especificar el nombre personalizado en la <code>attributes</code>matriz de su archivo de idioma:<code>resources/lang/xx/validation.php</code></p>\n  <pre><code>'attributes' =&gt; [\n    'email' =&gt; 'email address',\n],</code></pre>\n  <p>También puede pasar los atributos personalizados como el cuarto argumento del método:<code>Validator::make</code></p>\n  <pre><code>$customAttributes = [\n    'email' =&gt; 'email address',\n];\n\n$validator = Validator::make($input, $rules, $messages, $customAttributes);</code></pre>\n  <h4>Especificar valores personalizados en archivos de idioma</h4>\n  <p>A veces, es posible que necesite que la <code>:value</code>parte de su mensaje de validación se reemplace con una representación personalizada del valor. Por ejemplo, considere la siguiente regla que especifica que se requiere un número de tarjeta de crédito si <code>payment_type</code>tiene un valor de <code>cc</code>:</p>\n  <pre><code>$request-&gt;validate([\n    'credit_card_number' =&gt; 'required_if:payment_type,cc'\n]);</code></pre>\n  <p>Si esta regla de validación falla, producirá el siguiente mensaje de error:</p>\n  <pre><code>The credit card number field is required when payment type is cc.</code></pre>\n  <p>En lugar de mostrarse <code>cc</code>como el valor del tipo de pago, puede especificar una representación de valor personalizado en su <code>validation</code>archivo de idioma definiendo una <code>values</code>matriz:</p>\n  <pre><code>'values' =&gt; [\n    'payment_type' =&gt; [\n        'cc' =&gt; 'credit card'\n    ],\n],</code></pre>\n  <p>Ahora, si la regla de validación falla, producirá el siguiente mensaje:</p>\n  <pre><code>The credit card number field is required when payment type is credit card.</code></pre>\n  <p></p>\n  <h2>Reglas de validación disponibles</h2>\n  <p>A continuación se muestra una lista de todas las reglas de validación disponibles y su función:</p>\n  <style>\n    .collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    .collection-method-list a {\n        display: block;\n    }\n</style>\n  \n    <p>Aceptado\n      URL activa\n      Después de (fecha)\n      Después o igual (fecha)\n      Alfa\n      Alpha Dash\n      Alfanumérico\n      Formación\n      Fianza\n      Antes (fecha)\n      Antes o igual (fecha)\n      Entre\n      Booleano\n      Confirmado\n      Fecha\n      La fecha es igual a\n      Formato de fecha\n      Diferente\n      Dígitos\n      Dígitos entre\n      Dimensiones (archivos de imagen)\n      Distinto\n      Email\n      Termina con\n      Excluir si\n      Excluir a menos que\n      Existe (base de datos)\n      Expediente\n      Lleno\n      Mas grande que\n      Mayor que o igual\n      Archivo de imagen)\n      En\n      En matriz\n      Entero\n      Dirección IP\n      JSON\n      Menos que\n      Menor o igual\n      Max\n      Tipos MIME\n      Tipo MIME por extensión de archivo\n      Min\n      No en\n      No Regex\n      Anulable\n      Numérico\n      Contraseña\n      Presente\n      Expresión regular\n      Necesario\n      Requerido si\n      Requerido a menos\n      Requerido con\n      Requerido con todos\n      Requerido sin\n      Requerido sin todo\n      Mismo\n      Talla\n      Algunas veces\n      Comienza con\n      Cuerda\n      Zona horaria\n      Único (base de datos)\n      URL\n      UUID</p>\n  \n  <p></p>\n  <h4 id=\"rule-accepted\">aceptado</h4>\n  <p>El campo bajo de validación debe ser <em>sí</em> , <em>en</em> , <em>1</em> , o <em>verdadera</em> . Esto es útil para validar la aceptación de las \"Condiciones de servicio\".</p>\n  <p></p>\n  <h4 id=\"rule-active-url\">active_url</h4>\n  <p>El campo bajo validación debe tener un registro A o AAAA válido de acuerdo con la <code>dns_get_record</code>función PHP. El nombre de host de la URL proporcionada se extrae mediante la <code>parse_url</code>función PHP antes de pasar a <code>dns_get_record</code>.</p>\n  <p></p>\n  <h4 id=\"rule-after\">después: <em>fecha</em></h4>\n  <p>El campo bajo validación debe ser un valor posterior a una fecha determinada. Las fechas se pasarán a la <code>strtotime</code>función PHP:</p>\n  <pre><code>'start_date' =&gt; 'required|date|after:tomorrow'</code></pre>\n  <p>En lugar de pasar una cadena de fecha para ser evaluada <code>strtotime</code>, puede especificar otro campo para compararlo con la fecha:</p>\n  <pre><code>'finish_date' =&gt; 'required|date|after:start_date'</code></pre>\n  <p></p>\n  <h4 id=\"rule-after-or-equal\">after_or_equal: <em>fecha</em></h4>\n  <p>El campo bajo validación debe ser un valor posterior o igual a la fecha dada. Para obtener más información, consulte la regla posterior .</p>\n  <p></p>\n  <h4 id=\"rule-alpha\">alfa</h4>\n  <p>El campo bajo validación debe ser completamente alfabético.</p>\n  <p></p>\n  <h4 id=\"rule-alpha-dash\">alpha_dash</h4>\n  <p>El campo bajo validación puede tener caracteres alfanuméricos, así como guiones y guiones bajos.</p>\n  <p></p>\n  <h4 id=\"rule-alpha-num\">alpha_num</h4>\n  <p>El campo bajo validación debe ser completamente alfanumérico.</p>\n  <p></p>\n  <h4 id=\"rule-array\">formación</h4>\n  <p>El campo bajo validación debe ser PHP <code>array</code>.</p>\n  <p></p>\n  <h4 id=\"rule-bail\">fianza</h4>\n  <p>Deje de ejecutar reglas de validación después del primer error de validación.</p>\n  <p></p>\n  <h4 id=\"rule-before\">antes: <em>fecha</em></h4>\n  <p>El campo bajo validación debe ser un valor anterior a la fecha indicada. Las fechas se pasarán a la <code>strtotime</code>función PHP . Además, al igual que la <code>after</code>regla, el nombre de otro campo en validación se puede proporcionar como el valor de <code>date</code>.</p>\n  <p></p>\n  <h4 id=\"rule-before-or-equal\">before_or_equal: <em>fecha</em></h4>\n  <p>El campo bajo validación debe ser un valor anterior o igual a la fecha dada. Las fechas se pasarán a la <code>strtotime</code>función PHP . Además, al igual que la <code>after</code>regla, el nombre de otro campo en validación se puede proporcionar como el valor de <code>date</code>.</p>\n  <p></p>\n  <h4 id=\"rule-between\">entre: <em>min</em> , <em>max</em></h4>\n  <p>El campo bajo validación debe tener un tamaño entre el <em>mínimo</em> y el <em>máximo</em> dados . Las cadenas, números, matrices y archivos se evalúan de la misma forma que la <code>size</code>regla.</p>\n  <p></p>\n  <h4 id=\"rule-boolean\">booleano</h4>\n  <p>El campo bajo validación debe poder convertirse en booleano. De entrada aceptados son <code>true</code>, <code>false</code>, <code>1</code>, <code>0</code>, <code>\"1\"</code>, y <code>\"0\"</code>.</p>\n  <p></p>\n  <h4 id=\"rule-confirmed\">confirmado</h4>\n  <p>El campo bajo validación debe tener un campo coincidente de <code>foo_confirmation</code>. Por ejemplo, si el campo bajo validación es <code>password</code>, <code>password_confirmation</code>debe haber un campo coincidente en la entrada.</p>\n  <p></p>\n  <h4 id=\"rule-date\">fecha</h4>\n  <p>El campo bajo validación debe ser una fecha válida y no relativa de acuerdo con la <code>strtotime</code>función PHP.</p>\n  <p></p>\n  <h4 id=\"rule-date-equals\">date_equals: <em>fecha</em></h4>\n  <p>El campo bajo validación debe ser igual a la fecha indicada. Las fechas se pasarán a la <code>strtotime</code>función PHP .</p>\n  <p></p>\n  <h4 id=\"rule-date-format\">date_format: <em>formato</em></h4>\n  <p>El campo bajo validación debe coincidir con el <em>formato</em> dado . Debe usar <strong>uno</strong> <code>date</code> o <code>date_format</code>al validar un campo, no ambos. Esta regla de validación es compatible con todos los formatos compatibles con la clase DateTime de PHP .</p>\n  <p></p>\n  <h4 id=\"rule-different\">diferente: <em>campo</em></h4>\n  <p>El campo bajo validación debe tener un valor diferente al <em>campo</em> .</p>\n  <p></p>\n  <h4 id=\"rule-digits\">dígitos: <em>valor</em></h4>\n  <p>El campo bajo validación debe ser <em>numérico</em> y debe tener una longitud exacta de <em>valor</em> .</p>\n  <p></p>\n  <h4 id=\"rule-digits-between\">digits_between: <em>min</em> , <em>max</em></h4>\n  <p>El campo bajo validación debe ser <em>numérico</em> y debe tener una longitud entre el <em>mínimo</em> y el <em>máximo</em> dados .</p>\n  <p></p>\n  <h4 id=\"rule-dimensions\">dimensiones</h4>\n  <p>El archivo bajo validación debe ser una imagen que cumpla con las restricciones de dimensión especificadas por los parámetros de la regla:</p>\n  <pre><code>'avatar' =&gt; 'dimensions:min_width=100,min_height=200'</code></pre>\n  <p>Las restricciones disponibles son: <em>min_width</em> , <em>max_width</em> , <em>min_height</em> , <em>max_height</em> , <em>width</em> , <em>height</em> , <em>ratio</em> .</p>\n  <p>Una restricción de <em>relación</em> debe representarse como ancho dividido por alto. Esto se puede especificar mediante una declaración como o un flotante como :<code>3/2</code><code>1.5</code></p>\n  <pre><code>'avatar' =&gt; 'dimensions:ratio=3/2'</code></pre>\n  <p>Dado que esta regla requiere varios argumentos, puede usar el método para construir la regla con fluidez:<code>Rule::dimensions</code></p>\n  <pre><code>use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    'avatar' =&gt; [\n        'required',\n        Rule::dimensions()-&gt;maxWidth(1000)-&gt;maxHeight(500)-&gt;ratio(3 / 2),\n    ],\n]);</code></pre>\n  <p></p>\n  <h4 id=\"rule-distinct\">distinto</h4>\n  <p>Cuando se trabaja con matrices, el campo bajo validación no debe tener valores duplicados.</p>\n  <pre><code>'foo.*.id' =&gt; 'distinct'</code></pre>\n  <p></p>\n  <h4 id=\"rule-email\">correo electrónico</h4>\n  <p>El campo bajo validación debe tener el formato de una dirección de correo electrónico. Bajo el capó, esta regla de validación hace uso del paquete para validar la dirección de correo electrónico. De forma predeterminada, se aplica el validador, pero también puede aplicar otros estilos de validación:<code>egulias/email-validator</code><code>RFCValidation</code></p>\n  <pre><code>'email' =&gt; 'email:rfc,dns'</code></pre>\n  <p>El ejemplo anterior aplicará las validaciones <code>RFCValidation</code>y <code>DNSCheckValidation</code>. Aquí hay una lista completa de estilos de validación que puede aplicar:</p>\n  \n    <ul>\n      <li><code>rfc</code>: <code>RFCValidation</code></li>\n      <li><code>strict</code>: <code>NoRFCWarningsValidation</code></li>\n      <li><code>dns</code>: <code>DNSCheckValidation</code></li>\n      <li><code>spoof</code>: <code>SpoofCheckValidation</code></li>\n      <li><code>filter</code>: <code>FilterEmailValidation</code></li>\n    </ul>\n  \n  <p>El <code>filter</code>validador, que usa la <code>filter_var</code>función de PHP bajo el capó, viene con Laravel y es el comportamiento anterior a 5.8 de Laravel. Los validadores <code>dns</code>y <code>spoof</code>requieren la <code>intl</code>extensión PHP .</p>\n  <p></p>\n  <h4 id=\"rule-ends-with\">termina_con: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El campo bajo validación debe terminar con uno de los valores dados.</p>\n  <p></p>\n  <h4 id=\"rule-exclude-if\">exclude_if: otro <em>campo</em> , <em>valor</em></h4>\n  <p>El campo bajo validación se excluirá de los datos de solicitud devueltos por los métodos <code>validate</code>y <code>validated</code>si el campo de <em>otro</em> campo es igual a <em>valor</em> .</p>\n  <p></p>\n  <h4 id=\"rule-exclude-unless\">exclude_unless: otro <em>campo</em> , <em>valor</em></h4>\n  <p>El campo bajo de validación será excluido de los datos de solicitud devueltos por el <code>validate</code>y <code>validated</code>métodos a menos <em>anotherfield</em> campo 's es igual a <em>valor</em> .</p>\n  <p></p>\n  <h4 id=\"rule-exists\">existe: <em>tabla</em> , <em>columna</em></h4>\n  <p>El campo bajo validación debe existir en una tabla de base de datos determinada.</p>\n  <h4>Regla de uso básico de existe</h4>\n  <pre><code>'state' =&gt; 'exists:states'</code></pre>\n  <p>Si <code>column</code>no se especifica la opción, se utilizará el nombre del campo.</p>\n  <h4>Especificar un nombre de columna personalizado</h4>\n  <pre><code>'state' =&gt; 'exists:states,abbreviation'</code></pre>\n  <p>En ocasiones, es posible que deba especificar una conexión de base de datos específica que se utilizará para la <code>exists</code>consulta. Puede lograr esto anteponiendo el nombre de la conexión al nombre de la tabla usando la sintaxis \"punto\":</p>\n  <pre><code>'email' =&gt; 'exists:connection.staff,email'</code></pre>\n  <p>En lugar de especificar el nombre de la tabla directamente, puede especificar el modelo Eloquent que debe usarse para determinar el nombre de la tabla:</p>\n  <pre><code>'user_id' =&gt; 'exists:App\\Models\\User,id'</code></pre>\n  <p>Si desea personalizar la consulta ejecutada por la regla de validación, puede usar la <code>Rule</code>clase para definir la regla con fluidez. En este ejemplo, también especificaremos las reglas de validación como una matriz en lugar de usar el <code>|</code>carácter para delimitarlas:</p>\n  <pre><code>use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    'email' =&gt; [\n        'required',\n        Rule::exists('staff')-&gt;where(function ($query) {\n            $query-&gt;where('account_id', 1);\n        }),\n    ],\n]);</code></pre>\n  <p></p>\n  <h4 id=\"rule-file\">expediente</h4>\n  <p>El campo bajo validación debe ser un archivo cargado correctamente.</p>\n  <p></p>\n  <h4 id=\"rule-filled\">lleno</h4>\n  <p>El campo bajo validación no debe estar vacío cuando está presente.</p>\n  <p></p>\n  <h4 id=\"rule-gt\">gt: <em>campo</em></h4>\n  <p>El campo bajo validación debe ser mayor que el <em>campo</em> dado . Los dos campos deben ser del mismo tipo. Las cadenas, números, matrices y archivos se evalúan utilizando las mismas convenciones que la <code>size</code>regla.</p>\n  <p></p>\n  <h4 id=\"rule-gte\">gte: <em>campo</em></h4>\n  <p>El campo bajo validación debe ser mayor o igual que el <em>campo</em> dado . Los dos campos deben ser del mismo tipo. Las cadenas, números, matrices y archivos se evalúan utilizando las mismas convenciones que la <code>size</code>regla.</p>\n  <p></p>\n  <h4 id=\"rule-image\">imagen</h4>\n  <p>El archivo bajo validación debe ser una imagen (jpeg, png, bmp, gif, svg o webp)</p>\n  <p></p>\n  <h4 id=\"rule-in\">en: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El campo bajo validación debe incluirse en la lista de valores dada. Dado que esta regla a menudo requiere <code>implode</code>una matriz, el método puede usarse para construir la regla con fluidez:<code>Rule::in</code></p>\n  <pre><code>use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    'zones' =&gt; [\n        'required',\n        Rule::in(['first-zone', 'second-zone']),\n    ],\n]);</code></pre>\n  <p></p>\n  <h4 id=\"rule-in-array\">in_array: otro <em>campo</em> . *</h4>\n  <p>El campo bajo de validación debe existir en <em>anotherfield</em> valores 's.</p>\n  <p></p>\n  <h4 id=\"rule-integer\">entero</h4>\n  <p>El campo bajo validación debe ser un número entero.</p>\n  <blockquote>\n    <p> Esta regla de validación no verifica que la entrada sea del tipo de variable \"entero\", solo que la entrada sea una cadena o valor numérico que contenga un entero.</p>\n  </blockquote>\n  <p></p>\n  <h4 id=\"rule-ip\">ip</h4>\n  <p>El campo bajo validación debe ser una dirección IP.</p>\n  <h4>ipv4</h4>\n  <p>El campo bajo validación debe ser una dirección IPv4.</p>\n  <h4>ipv6</h4>\n  <p>El campo bajo validación debe ser una dirección IPv6.</p>\n  <p></p>\n  <h4 id=\"rule-json\">json</h4>\n  <p>El campo bajo validación debe ser una cadena JSON válida.</p>\n  <p></p>\n  <h4 id=\"rule-lt\">lt: <em>campo</em></h4>\n  <p>El campo bajo validación debe ser menor que el <em>campo</em> dado . Los dos campos deben ser del mismo tipo. Las cadenas, números, matrices y archivos se evalúan utilizando las mismas convenciones que la <code>size</code>regla.</p>\n  <p></p>\n  <h4 id=\"rule-lte\">lte: <em>campo</em></h4>\n  <p>El campo bajo validación debe ser menor o igual al <em>campo</em> dado . Los dos campos deben ser del mismo tipo. Las cadenas, números, matrices y archivos se evalúan utilizando las mismas convenciones que la <code>size</code>regla.</p>\n  <p></p>\n  <h4 id=\"rule-max\">max: <em>valor</em></h4>\n  <p>El campo bajo validación debe ser menor o igual a un <em>valor</em> máximo . Las cadenas, números, matrices y archivos se evalúan de la misma forma que la <code>size</code>regla.</p>\n  <p></p>\n  <h4 id=\"rule-mimetypes\">tipos mime: <em>texto / plano</em> , ...</h4>\n  <p>El archivo bajo validación debe coincidir con uno de los tipos MIME dados:</p>\n  <pre><code>'video' =&gt; 'mimetypes:video/avi,video/mpeg,video/quicktime'</code></pre>\n  <p>Para determinar el tipo MIME del archivo cargado, se leerá el contenido del archivo y el marco intentará adivinar el tipo MIME, que puede ser diferente del tipo MIME proporcionado por el cliente.</p>\n  <p></p>\n  <h4 id=\"rule-mimes\">mimos: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El archivo bajo validación debe tener un tipo MIME correspondiente a una de las extensiones listadas.</p>\n  <h4>Uso básico de la regla MIME</h4>\n  <pre><code>'photo' =&gt; 'mimes:jpeg,bmp,png'</code></pre>\n  <p>Aunque solo necesita especificar las extensiones, esta regla en realidad se valida con el tipo MIME del archivo al leer el contenido del archivo y adivinar su tipo MIME.</p>\n  <p>Puede encontrar una lista completa de tipos MIME y sus extensiones correspondientes en la siguiente ubicación: https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types</p>\n  <p></p>\n  <h4 id=\"rule-min\">min: <em>valor</em></h4>\n  <p>El campo bajo validación debe tener un <em>valor</em> mínimo . Las cadenas, números, matrices y archivos se evalúan de la misma forma que la <code>size</code>regla.</p>\n  <p></p>\n  <h4 id=\"rule-not-in\">not_in: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El campo bajo validación no debe incluirse en la lista de valores dada. El método se puede utilizar para construir con fluidez la regla:<code>Rule::notIn</code></p>\n  <pre><code>use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    'toppings' =&gt; [\n        'required',\n        Rule::notIn(['sprinkles', 'cherries']),\n    ],\n]);</code></pre>\n  <p></p>\n  <h4 id=\"rule-not-regex\">not_regex: <em>patrón</em></h4>\n  <p>El campo bajo validación no debe coincidir con la expresión regular dada.</p>\n  <p>Internamente, esta regla usa la <code>preg_match</code>función PHP . El patrón especificado debe obedecer al mismo formato requerido por <code>preg_match</code>y, por lo tanto, también debe incluir delimitadores válidos. Por ejemplo: .<code>'email' =&gt; 'not_regex:/^.+$/i'</code></p>\n  <p><strong>Nota:</strong> Al usar los patrones <code>regex</code>/ <code>not_regex</code>, puede ser necesario especificar reglas en una matriz en lugar de usar delimitadores de barra vertical, especialmente si la expresión regular contiene una barra vertical.</p>\n  <p></p>\n  <h4 id=\"rule-nullable\">anulable</h4>\n  <p>El campo bajo validación puede ser <code>null</code>. Esto es particularmente útil al validar primitivas como cadenas y enteros que pueden contener <code>null</code>valores.</p>\n  <p></p>\n  <h4 id=\"rule-numeric\">numérico</h4>\n  <p>El campo bajo validación debe ser numérico.</p>\n  <p></p>\n  <h4 id=\"rule-password\">contraseña</h4>\n  <p>El campo bajo validación debe coincidir con la contraseña del usuario autenticado. Puede especificar una protección de autenticación utilizando el primer parámetro de la regla:</p>\n  <pre><code>'password' =&gt; 'password:api'</code></pre>\n  <p></p>\n  <h4 id=\"rule-present\">presente</h4>\n  <p>El campo bajo validación debe estar presente en los datos de entrada pero puede estar vacío.</p>\n  <p></p>\n  <h4 id=\"rule-regex\">regex: <em>patrón</em></h4>\n  <p>El campo bajo validación debe coincidir con la expresión regular dada.</p>\n  <p>Internamente, esta regla usa la <code>preg_match</code>función PHP . El patrón especificado debe obedecer al mismo formato requerido por <code>preg_match</code>y, por lo tanto, también debe incluir delimitadores válidos. Por ejemplo: .<code>'email' =&gt; 'regex:/^.+@.+$/i'</code></p>\n  <p><strong>Nota:</strong> Al usar los patrones <code>regex</code>/ <code>not_regex</code>, puede ser necesario especificar reglas en una matriz en lugar de usar delimitadores de barra vertical, especialmente si la expresión regular contiene una barra vertical.</p>\n  <p></p>\n  <h4 id=\"rule-required\">necesario</h4>\n  <p>El campo bajo validación debe estar presente en los datos de entrada y no vacío. Un campo se considera \"vacío\" si se cumple una de las siguientes condiciones:</p>\n  \n    <ul>\n      <li>El valor es <code>null</code>.</li>\n      <li>El valor es una cadena vacía.</li>\n      <li>El valor es una matriz u <code>Countable</code>objeto vacío .</li>\n      <li>El valor es un archivo cargado sin ruta.</li>\n    </ul>\n  \n  <p></p>\n  <h4 id=\"rule-required-if\">required_if: otro <em>campo</em> , <em>valor</em> , ...</h4>\n  <p>El campo bajo validación debe estar presente y no vacío si el campo de <em>otro</em> campo es igual a cualquier <em>valor</em> .</p>\n  <p>Si desea construir una condición más compleja para la <code>required_if</code>regla, puede usar el método. Este método acepta un booleano o un cierre. Cuando pasa un cierre, el cierre debe regresar o indicar si el campo bajo validación es obligatorio:<code>Rule::requiredIf</code><code>true</code><code>false</code></p>\n  <pre><code>use Illuminate\\Validation\\Rule;\n\nValidator::make($request-&gt;all(), [\n    'role_id' =&gt; Rule::requiredIf($request-&gt;user()-&gt;is_admin),\n]);\n\nValidator::make($request-&gt;all(), [\n    'role_id' =&gt; Rule::requiredIf(function () use ($request) {\n        return $request-&gt;user()-&gt;is_admin;\n    }),\n]);</code></pre>\n  <p></p>\n  <h4 id=\"rule-required-unless\">required_unless: otro <em>campo</em> , <em>valor</em> , ...</h4>\n  <p>El campo bajo validación debe estar presente y no vacío a menos que el campo <em>otro</em> campo sea igual a cualquier <em>valor</em> .</p>\n  <p></p>\n  <h4 id=\"rule-required-with\">required_with: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El campo bajo validación debe estar presente y no vacío <em>solo si</em> alguno de los otros campos especificados está presente.</p>\n  <p></p>\n  <h4 id=\"rule-required-with-all\">required_with_all: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El campo bajo validación debe estar presente y no vacío <em>solo si</em> están presentes todos los demás campos especificados.</p>\n  <p></p>\n  <h4 id=\"rule-required-without\">required_without: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El campo bajo validación debe estar presente y no vacío <em>solo cuando</em> alguno de los otros campos especificados no está presente.</p>\n  <p></p>\n  <h4 id=\"rule-required-without-all\">required_without_all: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El campo bajo validación debe estar presente y no vacío <em>solo cuando</em> no están presentes todos los demás campos especificados.</p>\n  <p></p>\n  <h4 id=\"rule-same\">mismo: <em>campo</em></h4>\n  <p>El <em>campo</em> dado debe coincidir con el campo bajo validación.</p>\n  <p></p>\n  <h4 id=\"rule-size\">tamaño: <em>valor</em></h4>\n  <p>El campo bajo validación debe tener un tamaño que coincida con el <em>valor</em> dado . Para datos de cadena, el <em>valor</em> corresponde al número de caracteres. Para datos numéricos, el <em>valor</em> corresponde a un valor entero dado (el atributo también debe tener la regla <code>numeric</code>o <code>integer</code>). Para una matriz, el <em>tamaño</em> corresponde al <code>count</code>de la matriz. Para los archivos, el <em>tamaño</em> corresponde al tamaño del archivo en kilobytes. Veamos algunos ejemplos:</p>\n  <pre><code>// Validate that a string is exactly 12 characters long...\n'title' =&gt; 'size:12';\n\n// Validate that a provided integer equals 10...\n'seats' =&gt; 'integer|size:10';\n\n// Validate that an array has exactly 5 elements...\n'tags' =&gt; 'array|size:5';\n\n// Validate that an uploaded file is exactly 512 kilobytes...\n'image' =&gt; 'file|size:512';</code></pre>\n  <p></p>\n  <h4 id=\"rule-starts-with\">empieza_con: <em>foo</em> , <em>bar</em> , ...</h4>\n  <p>El campo bajo validación debe comenzar con uno de los valores dados.</p>\n  <p></p>\n  <h4 id=\"rule-string\">cuerda</h4>\n  <p>El campo bajo validación debe ser una cadena. Si desea permitir que el campo también lo esté <code>null</code>, debe asignar la <code>nullable</code>regla al campo.</p>\n  <p></p>\n  <h4 id=\"rule-timezone\">zona horaria</h4>\n  <p>El campo bajo validación debe ser un identificador de zona horaria válido de acuerdo con la <code>timezone_identifiers_list</code>función PHP.</p>\n  <p></p>\n  <h4 id=\"rule-unique\">único: <em>tabla</em> , <em>columna</em> , <em>excepto</em> , <em>idColumn</em></h4>\n  <p>El campo bajo validación no debe existir dentro de la tabla de base de datos dada.</p>\n  <p><strong>Especificación de un nombre de columna / tabla personalizado:</strong></p>\n  <p>En lugar de especificar el nombre de la tabla directamente, puede especificar el modelo Eloquent que debe usarse para determinar el nombre de la tabla:</p>\n  <pre><code>'email' =&gt; 'unique:App\\Models\\User,email_address'</code></pre>\n  <p>La <code>column</code>opción se puede utilizar para especificar la columna de base de datos correspondiente al campo. Si <code>column</code>no se especifica la opción, se utilizará el nombre del campo.</p>\n  <pre><code>'email' =&gt; 'unique:users,email_address'</code></pre>\n  <p><strong>Conexión de base de datos personalizada</strong></p>\n  <p>Ocasionalmente, es posible que deba establecer una conexión personalizada para las consultas de la base de datos realizadas por el Validador. Como se vio anteriormente, la configuración como regla de validación utilizará la conexión de base de datos predeterminada para consultar la base de datos. Para anular esto, especifique la conexión y el nombre de la tabla usando la sintaxis de \"punto\":<code>unique:users</code></p>\n  <pre><code>'email' =&gt; 'unique:connection.users,email_address'</code></pre>\n  <p><strong>Forzar una regla única para ignorar una ID determinada:</strong></p>\n  <p>A veces, es posible que desee ignorar una identificación determinada durante la verificación única. Por ejemplo, considere una pantalla de \"perfil de actualización\" que incluye el nombre del usuario, la dirección de correo electrónico y la ubicación. Probablemente desee verificar que la dirección de correo electrónico sea única. Sin embargo, si el usuario solo cambia el campo de nombre y no el campo de correo electrónico, no desea que se genere un error de validación porque el usuario ya es el propietario de la dirección de correo electrónico.</p>\n  <p>Para indicarle al validador que ignore la ID del usuario, usaremos la <code>Rule</code>clase para definir la regla con fluidez. En este ejemplo, también especificaremos las reglas de validación como una matriz en lugar de usar el <code>|</code>carácter para delimitar las reglas:</p>\n  <pre><code>use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    'email' =&gt; [\n        'required',\n        Rule::unique('users')-&gt;ignore($user-&gt;id),\n    ],\n]);</code></pre>\n  <blockquote>\n    <p>Nunca debe pasar ninguna entrada de solicitud controlada por el usuario al <code>ignore</code>método. En su lugar, solo debe pasar una ID única generada por el sistema, como una ID de incremento automático o UUID de una instancia de modelo Eloquent. De lo contrario, su aplicación será vulnerable a un ataque de inyección SQL.</p>\n  </blockquote>\n  <p>En lugar de pasar el valor de la clave del modelo al <code>ignore</code>método, puede pasar toda la instancia del modelo. Laravel extraerá automáticamente la clave del modelo:</p>\n  <pre><code>Rule::unique('users')-&gt;ignore($user)</code></pre>\n  <p>Si su tabla usa un nombre de columna de clave principal diferente a <code>id</code>, puede especificar el nombre de la columna al llamar al <code>ignore</code>método:</p>\n  <pre><code>Rule::unique('users')-&gt;ignore($user-&gt;id, 'user_id')</code></pre>\n  <p>De forma predeterminada, la <code>unique</code>regla comprobará la singularidad de la columna que coincida con el nombre del atributo que se valida. Sin embargo, puede pasar un nombre de columna diferente como segundo argumento del <code>unique</code>método:</p>\n  <pre><code>Rule::unique('users', 'email_address')-&gt;ignore($user-&gt;id),</code></pre>\n  <p><strong>Adición de cláusulas adicionales Where:</strong></p>\n  <p>También puede especificar restricciones de consulta adicionales personalizando la consulta usando el <code>where</code>método. Por ejemplo, agreguemos una restricción que verifique que <code>account_id</code>es <code>1</code>:</p>\n  <pre><code>'email' =&gt; Rule::unique('users')-&gt;where(function ($query) {\n    return $query-&gt;where('account_id', 1);\n})</code></pre>\n  <p></p>\n  <h4 id=\"rule-url\">url</h4>\n  <p>El campo bajo validación debe ser una URL válida.</p>\n  <p></p>\n  <h4 id=\"rule-uuid\">uuid</h4>\n  <p>El campo bajo validación debe ser un RFC 4122 válido (versión 1, 3, 4 o 5) identificador único universal (UUID).</p>\n  <p></p>\n  <h2>Agregar reglas condicionalmente</h2>\n  <h4>Omitir la validación cuando los campos tienen ciertos valores</h4>\n  <p>En ocasiones, es posible que desee no validar un campo determinado si otro campo tiene un valor determinado. Puede lograr esto usando la <code>exclude_if</code>regla de validación. En este ejemplo, las <code>appointment_date</code>y los <code>doctor_name</code>campos no serán validados si el <code>has_appointment</code>campo tiene un valor de <code>false</code>:</p>\n  <pre><code>$v = Validator::make($data, [\n    'has_appointment' =&gt; 'required|bool',\n    'appointment_date' =&gt; 'exclude_if:has_appointment,false|required|date',\n    'doctor_name' =&gt; 'exclude_if:has_appointment,false|required|string',\n]);</code></pre>\n  <p>Alternativamente, puede usar la <code>exclude_unless</code>regla para no validar un campo dado a menos que otro campo tenga un valor dado:</p>\n  <pre><code>$v = Validator::make($data, [\n    'has_appointment' =&gt; 'required|bool',\n    'appointment_date' =&gt; 'exclude_unless:has_appointment,true|required|date',\n    'doctor_name' =&gt; 'exclude_unless:has_appointment,true|required|string',\n]);</code></pre>\n  <h4>Validar cuando está presente</h4>\n  <p>En algunas situaciones, es posible que desee ejecutar comprobaciones de validación en un campo <strong>solo</strong> si ese campo está presente en la matriz de entrada. Para lograr esto rápidamente, agregue la <code>sometimes</code>regla a su lista de reglas:</p>\n  <pre><code>$v = Validator::make($data, [\n    'email' =&gt; 'sometimes|required|email',\n]);</code></pre>\n  <p>En el ejemplo anterior, el <code>email</code>campo solo se validará si está presente en la <code>$data</code>matriz.</p>\n  <blockquote>\n    <p>Si está intentando validar un campo que siempre debería estar presente pero que puede estar vacío, consulte esta nota sobre los campos opcionales</p>\n  </blockquote>\n  <h4>Validación condicional compleja</h4>\n  <p>A veces, es posible que desee agregar reglas de validación basadas en una lógica condicional más compleja. Por ejemplo, es posible que desee solicitar un campo determinado solo si otro campo tiene un valor mayor que 100. O puede que necesite dos campos para tener un valor determinado solo cuando haya otro campo presente. Agregar estas reglas de validación no tiene por qué ser una molestia. Primero, cree una <code>Validator</code>instancia con sus <em>reglas estáticas</em> que nunca cambian:</p>\n  <pre><code>$v = Validator::make($data, [\n    'email' =&gt; 'required|email',\n    'games' =&gt; 'required|numeric',\n]);</code></pre>\n  <p>Supongamos que nuestra aplicación web es para coleccionistas de juegos. Si un coleccionista de juegos se registra en nuestra aplicación y posee más de 100 juegos, queremos que explique por qué posee tantos juegos. Por ejemplo, tal vez dirijan una tienda de reventa de juegos o tal vez simplemente disfruten coleccionando. Para agregar condicionalmente este requisito, podemos usar el <code>sometimes</code>método en la <code>Validator</code>instancia.</p>\n  <pre><code>$v-&gt;sometimes('reason', 'required|max:500', function ($input) {\n    return $input-&gt;games &gt;= 100;\n});</code></pre>\n  <p>El primer argumento que se pasa al <code>sometimes</code>método es el nombre del campo que estamos validando condicionalmente. El segundo argumento son las reglas que queremos agregar. Si el <code>Closure</code>pasado como tercer argumento regresa <code>true</code>, se agregarán las reglas. Este método facilita la creación de validaciones condicionales complejas. Incluso puede agregar validaciones condicionales para varios campos a la vez:</p>\n  <pre><code>$v-&gt;sometimes(['reason', 'cost'], 'required', function ($input) {\n    return $input-&gt;games &gt;= 100;\n});</code></pre>\n  <blockquote>\n    <p>El <code>$input</code>parámetro pasado a su <code>Closure</code>será una instancia de y puede usarse para acceder a su entrada y archivos.<code>Illuminate\\Support\\Fluent</code></p>\n  </blockquote>\n  <p></p>\n  <h2>Validación de matrices</h2>\n  <p>Validar los campos de entrada de formularios basados \u200B\u200Ben matrices no tiene por qué ser una molestia. Puede utilizar \"notación de puntos\" para validar atributos dentro de una matriz. Por ejemplo, si la solicitud HTTP entrante contiene un campo, puede validarlo así:<code>photos[profile]</code></p>\n  <pre><code>$validator = Validator::make($request-&gt;all(), [\n    'photos.profile' =&gt; 'required|image',\n]);</code></pre>\n  <p>También puede validar cada elemento de una matriz. Por ejemplo, para validar que cada correo electrónico en un campo de entrada de matriz dado es único, puede hacer lo siguiente:</p>\n  <pre><code>$validator = Validator::make($request-&gt;all(), [\n    'person.*.email' =&gt; 'email|unique:users',\n    'person.*.first_name' =&gt; 'required_with:person.*.last_name',\n]);</code></pre>\n  <p>Del mismo modo, puede usar el <code>*</code>carácter al especificar sus mensajes de validación en sus archivos de idioma, lo que facilita el uso de un solo mensaje de validación para campos basados \u200B\u200Ben matrices:</p>\n  <pre><code>'custom' =&gt; [\n    'person.*.email' =&gt; [\n        'unique' =&gt; 'Each person must have a unique e-mail address',\n    ]\n],</code></pre>\n  <p></p>\n  <h2>Reglas de validación personalizadas</h2>\n  <p></p>\n  <h3>Usar objetos de regla</h3>\n  <p>Laravel proporciona una variedad de reglas de validación útiles; sin embargo, es posible que desee especificar algunos propios. Un método para registrar reglas de validación personalizadas es utilizar objetos de reglas. Para generar un nuevo objeto de regla, puede utilizar el comando Artisan. Usemos este comando para generar una regla que verifique que una cadena esté en mayúsculas. Laravel colocará la nueva regla en el directorio:<code>make:rule</code><code>app/Rules</code></p>\n  <pre><code>php artisan make:rule Uppercase</code></pre>\n  <p>Una vez creada la regla, estamos listos para definir su comportamiento. Un objeto de regla contiene dos métodos: <code>passes</code>y <code>message</code>. El <code>passes</code>método recibe el valor y el nombre del atributo, y debe devolver <code>true</code>o <code>false</code>dependiendo de si el valor del atributo es válido o no. El <code>message</code>método debe devolver el mensaje de error de validación que debe usarse cuando falla la validación:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\n\nclass Uppercase implements Rule\n{\n    /**\n     * Determine if the validation rule passes.\n     *\n     * @param  string  $attribute\n     * @param  mixed  $value\n     * @return bool\n     */\n    public function passes($attribute, $value)\n    {\n        return strtoupper($value) === $value;\n    }\n\n    /**\n     * Get the validation error message.\n     *\n     * @return string\n     */\n    public function message()\n    {\n        return 'The :attribute must be uppercase.';\n    }\n}</code></pre>\n  <p>Puede llamar al <code>trans</code>ayudante desde su <code>message</code>método si desea devolver un mensaje de error de sus archivos de traducción:</p>\n  <pre><code>/**\n * Get the validation error message.\n *\n * @return string\n */\npublic function message()\n{\n    return trans('validation.uppercase');\n}</code></pre>\n  <p>Una vez que se ha definido la regla, puede adjuntarla a un validador pasando una instancia del objeto de regla con sus otras reglas de validación:</p>\n  <pre><code>use App\\Rules\\Uppercase;\n\n$request-&gt;validate([\n    'name' =&gt; ['required', 'string', new Uppercase],\n]);</code></pre>\n  <p></p>\n  <h3>Usando cierres</h3>\n  <p>Si solo necesita la funcionalidad de una regla personalizada una vez en su aplicación, puede usar un cierre en lugar de un objeto de regla. El cierre recibe el nombre del atributo, el valor del atributo y una <code>$fail</code>devolución de llamada que se debe llamar si falla la validación:</p>\n  <pre><code>$validator = Validator::make($request-&gt;all(), [\n    'title' =&gt; [\n        'required',\n        'max:255',\n        function ($attribute, $value, $fail) {\n            if ($value === 'foo') {\n                $fail($attribute.' is invalid.');\n            }\n        },\n    ],\n]);</code></pre>\n  <p></p>\n  <h3>Usar extensiones</h3>\n  <p>Otro método para registrar reglas de validación personalizadas es usar el <code>extend</code>método en la <code>Validator</code> fachada . Usemos este método dentro de un proveedor de servicios para registrar una regla de validación personalizada:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse Illuminate\\Support\\Facades\\Validator;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Validator::extend('foo', function ($attribute, $value, $parameters, $validator) {\n            return $value == 'foo';\n        });\n    }\n}</code></pre>\n  <p>El cierre del validador personalizado recibe cuatro argumentos: el nombre del <code>$attribute</code>validado, el <code>$value</code>del atributo, una matriz de <code>$parameters</code>pasados \u200B\u200Ba la regla y la <code>Validator</code>instancia.</p>\n  <p>También puede pasar una clase y un método al <code>extend</code>método en lugar de un cierre:</p>\n  <pre><code>Validator::extend('foo', 'FooValidator@validate');</code></pre>\n  <h4>Definición del mensaje de error</h4>\n  <p>También deberá definir un mensaje de error para su regla personalizada. Puede hacerlo utilizando una matriz de mensajes personalizados en línea o agregando una entrada en el archivo de idioma de validación. Este mensaje debe colocarse en el primer nivel de la matriz, no dentro de la <code>custom</code>matriz, que es solo para mensajes de error específicos de atributo:</p>\n  <pre><code>\"foo\" =&gt; \"Your input was invalid!\",\n\n\"accepted\" =&gt; \"The :attribute must be accepted.\",\n\n// The rest of the validation error messages...</code></pre>\n  <p>Al crear una regla de validación personalizada, a veces es posible que deba definir reemplazos de marcadores de posición personalizados para los mensajes de error. Puede hacerlo creando un Validador personalizado como se describe anteriormente y luego haciendo una llamada al <code>replacer</code>método en la <code>Validator</code>fachada. Puede hacer esto dentro del <code>boot</code>método de un proveedor de servicios :</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    Validator::extend(...);\n\n    Validator::replacer('foo', function ($message, $attribute, $rule, $parameters) {\n        return str_replace(...);\n    });\n}</code></pre>\n  <p></p>\n  <h3>Extensiones implícitas</h3>\n  <p>De forma predeterminada, cuando un atributo que se está validando no está presente o contiene una cadena vacía, las reglas de validación normales, incluidas las extensiones personalizadas, no se ejecutan. Por ejemplo, la <code>unique</code>regla no se ejecutará en una cadena vacía:</p>\n  <pre><code>$rules = ['name' =&gt; 'unique:users,name'];\n\n$input = ['name' =&gt; ''];\n\nValidator::make($input, $rules)-&gt;passes(); // true</code></pre>\n  <p>Para que una regla se ejecute incluso cuando un atributo está vacío, la regla debe implicar que el atributo es obligatorio. Para crear una extensión \"implícita\", utilice el método:<code>Validator::extendImplicit()</code></p>\n  <pre><code>Validator::extendImplicit('foo', function ($attribute, $value, $parameters, $validator) {\n    return $value == 'foo';\n});</code></pre>\n  <blockquote>\n    <p>Una extensión \"implícita\" solo <em>implica</em> que el atributo es obligatorio. Depende de usted si realmente invalida un atributo faltante o vacío.</p>\n  </blockquote>\n  <h4>Objetos de regla implícitos</h4>\n  <p>Si desea que un objeto de regla se ejecute cuando un atributo está vacío, debe implementar la interfaz. Esta interfaz sirve como una \"interfaz de marcador\" para el validador; por lo tanto, no contiene ningún método que deba implementar.<code>Illuminate\\Contracts\\Validation\\ImplicitRule</code></p>\n</section>"
      },
      {
        "titulo": "3.11 Manejo de errores",
        "contenido": "<section>\n  <h1>Manejo de errores</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Configuración</li>\n    <li>El controlador de excepciones\n      <ul>\n        <li>Notificación de excepciones</li>\n        <li>Excepciones de representación</li>\n        <li>Excepciones reportables y renderizables</li>\n      </ul></li>\n    <li>Excepciones HTTP\n      <ul>\n        <li>Páginas de error HTTP personalizadas</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Cuando inicia un nuevo proyecto de Laravel, el manejo de errores y excepciones ya está configurado para usted. La clase es donde todas las excepciones desencadenadas por su aplicación se registran y luego se devuelven al usuario. Profundizaremos en esta clase a lo largo de esta documentación.<code>App\\Exceptions\\Handler</code></p>\n  <p></p>\n  <h2>Configuración</h2>\n  <p>La <code>debug</code>opción en su archivo de configuración determina cuánta información sobre un error se muestra realmente al usuario. De forma predeterminada, esta opción está configurada para respetar el valor de la variable de entorno, que se almacena en su archivo.<code>config/app.php</code><code>APP_DEBUG</code><code>.env</code></p>\n  <p>Para el desarrollo local, debe establecer la <code>APP_DEBUG</code>variable de entorno en <code>true</code>. En su entorno de producción, este valor siempre debería ser <code>false</code>. Si el valor se establece <code>true</code>en producción, corre el riesgo de exponer valores de configuración confidenciales a los usuarios finales de su aplicación.</p>\n  <p></p>\n  <h2>El controlador de excepciones</h2>\n  <p></p>\n  <h3>Notificación de excepciones</h3>\n  <p>Todas las excepciones son manejadas por la clase. Esta clase contiene un método en el que puede registrar devoluciones de llamada de reportero y renderizador de excepciones personalizadas. Examinaremos cada uno de estos conceptos en detalle. Los informes de excepciones se utilizan para registrar excepciones o enviarlas a un servicio externo como Flare , Bugsnag o Sentry . De forma predeterminada, las excepciones se registrarán en función de su configuración de registro . Sin embargo, puede registrar las excepciones como desee.<code>App\\Exceptions\\Handler</code><code>register</code></p>\n  <p>Por ejemplo, si necesita informar diferentes tipos de excepciones de diferentes formas, puede utilizar el <code>reportable</code>método para registrar un cierre que debe ejecutarse cuando sea necesario informar una excepción de un tipo determinado. Laravel deducirá qué tipo de excepción informa el Cierre examinando la sugerencia de tipo del Cierre:</p>\n  <pre><code>use App\\Exceptions\\CustomException;\n\n/**\n * Register the exception handling callbacks for the application.\n *\n * @return void\n */\npublic function register()\n{\n    $this-&gt;reportable(function (CustomException $e) {\n        //\n    });\n}</code></pre>\n  <p>Cuando registra una devolución de llamada de informe de excepción personalizada usando el <code>reportable</code>método, Laravel aún registrará la excepción usando la configuración de registro predeterminada para la aplicación. Si desea detener la propagación de la excepción a la pila de registro predeterminada, puede usar el <code>stop</code>método al definir su devolución de llamada de informes:</p>\n  <pre><code>$this-&gt;reportable(function (CustomException $e) {\n    //\n})-&gt;stop();</code></pre>\n  <blockquote>\n    <p>Para personalizar los informes de excepciones para una excepción determinada, también puede considerar el uso de excepciones notificables</p>\n  </blockquote>\n  <h4>Contexto de registro global</h4>\n  <p>Si está disponible, Laravel agrega automáticamente la ID del usuario actual al mensaje de registro de cada excepción como datos contextuales. Puede definir sus propios datos contextuales globales anulando el <code>context</code>método de la clase de su aplicación . Esta información se incluirá en el mensaje de registro de cada excepción escrito por su aplicación:<code>App\\Exceptions\\Handler</code></p>\n  <pre><code>/**\n * Get the default context variables for logging.\n *\n * @return array\n */\nprotected function context()\n{\n    return array_merge(parent::context(), [\n        'foo' =&gt; 'bar',\n    ]);\n}</code></pre>\n  <h4>El <code>report</code>ayudante</h4>\n  <p>A veces, es posible que deba informar una excepción pero continuar manejando la solicitud actual. La <code>report</code>función auxiliar le permite informar rápidamente una excepción utilizando su controlador de excepciones sin generar una página de error:</p>\n  <pre><code>public function isValid($value)\n{\n    try {\n        // Validate the value...\n    } catch (Throwable $e) {\n        report($e);\n\n        return false;\n    }\n}</code></pre>\n  <h4>Ignorar excepciones por tipo</h4>\n  <p>La <code>$dontReport</code>propiedad del controlador de excepciones contiene una matriz de tipos de excepciones que no se registrarán. Por ejemplo, las excepciones resultantes de errores 404, así como otros tipos de errores, no se escriben en sus archivos de registro. Puede agregar otros tipos de excepciones a esta matriz según sea necesario:</p>\n  <pre><code>/**\n * A list of the exception types that should not be reported.\n *\n * @var array\n */\nprotected $dontReport = [\n    \\Illuminate\\Auth\\AuthenticationException::class,\n    \\Illuminate\\Auth\\Access\\AuthorizationException::class,\n    \\Symfony\\Component\\HttpKernel\\Exception\\HttpException::class,\n    \\Illuminate\\Database\\Eloquent\\ModelNotFoundException::class,\n    \\Illuminate\\Validation\\ValidationException::class,\n];</code></pre>\n  <p></p>\n  <h3>Excepciones de representación</h3>\n  <p>De forma predeterminada, el controlador de excepciones de Laravel convertirá las excepciones en una respuesta HTTP por ti. Sin embargo, puede registrar un cierre de renderizado personalizado para excepciones de un tipo determinado. Puede lograr esto mediante el <code>renderable</code>método de su controlador de excepciones. Laravel deducirá qué tipo de excepción presenta el Cierre examinando la sugerencia de tipo del Cierre:</p>\n  <pre><code>use App\\Exceptions\\CustomException;\n\n/**\n * Register the exception handling callbacks for the application.\n *\n * @return void\n */\npublic function register()\n{\n    $this-&gt;renderable(function (CustomException $e, $request) {\n        return response()-&gt;view('errors.custom', [], 500);\n    });\n}</code></pre>\n  <p></p>\n  <h3>Excepciones reportables y renderizables</h3>\n  <p>En lugar de comprobar el tipo de excepciones en los métodos <code>report</code>y del controlador de excepciones <code>render</code>, puede definir métodos <code>report</code>y <code>render</code>directamente en su excepción personalizada. Cuando existan estos métodos, el marco los llamará automáticamente:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Exceptions;\n\nuse Exception;\n\nclass RenderException extends Exception\n{\n    /**\n     * Report the exception.\n     *\n     * @return void\n     */\n    public function report()\n    {\n        //\n    }\n\n    /**\n     * Render the exception into an HTTP response.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function render($request)\n    {\n        return response(...);\n    }\n}</code></pre>\n  <p>Si tu excepción contiene una lógica de informes personalizada que solo ocurre cuando se cumplen ciertas condiciones, es posible que debas indicarle a Laravel que informe la excepción utilizando la configuración predeterminada de manejo de excepciones. Para lograr esto, puede regresar <code>false</code>del <code>report</code>método de la excepción :</p>\n  <pre><code>/**\n * Report the exception.\n *\n * @return bool|void\n */\npublic function report()\n{\n    // Determine if the exception needs custom reporting...\n\n    return false;\n}</code></pre>\n  <blockquote>\n    <p>Puede escribir sugerencias sobre las dependencias necesarias del <code>report</code>método y el contenedor de servicios de Laravel las inyectará automáticamente en el método .</p>\n  </blockquote>\n  <p></p>\n  <h2>Excepciones HTTP</h2>\n  <p>Algunas excepciones describen códigos de error HTTP del servidor. Por ejemplo, esto puede ser un error de \"página no encontrada\" (404), un \"error no autorizado\" (401) o incluso un error 500 generado por el desarrollador. Para generar dicha respuesta desde cualquier lugar de su aplicación, puede utilizar el <code>abort</code>asistente:</p>\n  <pre><code>abort(404);</code></pre>\n  <p></p>\n  <h3>Páginas de error HTTP personalizadas</h3>\n  <p>Laravel facilita la visualización de páginas de error personalizadas para varios códigos de estado HTTP. Por ejemplo, si desea personalizar la página de error para los códigos de estado HTTP 404, cree un archivo . Este archivo se publicará en todos los errores 404 generados por su aplicación. Las vistas dentro de este directorio deben tener un nombre que coincida con el código de estado HTTP al que corresponden. La instancia generada por la función se pasará a la vista como una variable:<code>resources/views/errors/404.blade.php</code><code>HttpException</code><code>abort</code><code>$exception</code></p>\n  <pre><code>&lt;h2&gt;{{ $exception-&gt;getMessage() }}&lt;/h2&gt;</code></pre>\n  <p>Puede publicar las plantillas de página de error de Laravel usando el comando Artisan. Una vez publicadas las plantillas, puedes personalizarlas a tu gusto:<code>vendor:publish</code></p>\n  <pre><code>php artisan vendor:publish --tag=laravel-errors</code></pre>\n</section>"
      },
      {
        "titulo": "3.12 Inicio sesión",
        "contenido": "<section>\n  <h1>Inicio sesión</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Configuración\n      <ul>\n        <li>Construcción de pilas de troncos</li>\n      </ul></li>\n    <li>Escribir mensajes de registro\n      <ul>\n        <li>Escribir en canales específicos</li>\n      </ul></li>\n    <li>Personalización avanzada del canal Monolog\n      <ul>\n        <li>Personalización de Monolog para canales</li>\n        <li>Creación de canales de controlador de Monolog</li>\n        <li>Creación de canales a través de Factories</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Para ayudarlo a aprender más sobre lo que está sucediendo dentro de su aplicación, Laravel brinda servicios de registro robustos que le permiten registrar mensajes en archivos, el registro de errores del sistema e incluso en Slack para notificar a todo su equipo.</p>\n  <p>Debajo del capó, Laravel utiliza la biblioteca Monolog , que brinda soporte para una variedad de poderosos controladores de registro. Laravel hace que sea muy fácil configurar estos controladores, lo que le permite mezclarlos y combinarlos para personalizar el manejo de registros de su aplicación.</p>\n  <p></p>\n  <h2>Configuración</h2>\n  <p>Toda la configuración del sistema de registro de su aplicación se encuentra en el archivo de configuración. Este archivo le permite configurar los canales de registro de su aplicación, así que asegúrese de revisar cada uno de los canales disponibles y sus opciones. Revisaremos algunas opciones comunes a continuación.<code>config/logging.php</code></p>\n  <p>De forma predeterminada, Laravel usará el <code>stack</code>canal al registrar mensajes. El <code>stack</code>canal se utiliza para agregar varios canales de registro en un solo canal. Para obtener más información sobre cómo construir pilas, consulte la documentación a continuación .</p>\n  <h4>Configurar el nombre del canal</h4>\n  <p>De forma predeterminada, se crea una instancia de Monolog con un \"nombre de canal\" que coincide con el entorno actual, como <code>production</code>o <code>local</code>. Para cambiar este valor, agregue una <code>name</code>opción a la configuración de su canal:</p>\n  <pre><code>'stack' =&gt; [\n    'driver' =&gt; 'stack',\n    'name' =&gt; 'channel-name',\n    'channels' =&gt; ['single', 'slack'],\n],</code></pre>\n  <h4>Controladores de canal disponibles</h4>\n  <table>\n    <thead>\n    <tr>\n      <th>Nombre</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>stack</code></td>\n      <td>Un contenedor para facilitar la creación de canales \"multicanal\"</td>\n    </tr>\n    <tr>\n      <td><code>single</code></td>\n      <td>Un canal de registro basado en un solo archivo o ruta ( <code>StreamHandler</code>)</td>\n    </tr>\n    <tr>\n      <td><code>daily</code></td>\n      <td>Un <code>RotatingFileHandler</code>controlador Monolog basado que gira a diario</td>\n    </tr>\n    <tr>\n      <td><code>slack</code></td>\n      <td>Un <code>SlackWebhookHandler</code>controlador Monolog basado</td>\n    </tr>\n    <tr>\n      <td><code>papertrail</code></td>\n      <td>Un <code>SyslogUdpHandler</code>controlador Monolog basado</td>\n    </tr>\n    <tr>\n      <td><code>syslog</code></td>\n      <td>Un <code>SyslogHandler</code>controlador Monolog basado</td>\n    </tr>\n    <tr>\n      <td><code>errorlog</code></td>\n      <td>Un <code>ErrorLogHandler</code>controlador Monolog basado</td>\n    </tr>\n    <tr>\n      <td><code>monolog</code></td>\n      <td>Un controlador de fábrica de Monolog que puede utilizar cualquier controlador de Monolog compatible</td>\n    </tr>\n    <tr>\n      <td><code>custom</code></td>\n      <td>Un controlador que llama a una fábrica específica para crear un canal.</td>\n    </tr>\n    </tbody>\n  </table>\n  <blockquote>\n    <p>Consulte la documentación sobre personalización avanzada de canales para obtener más información sobre los controladores <code>monolog</code>y <code>custom</code>.</p>\n  </blockquote>\n  <h4>Configuración de los canales individuales y diarios</h4>\n  <p>El <code>single</code>y <code>daily</code>canales tienen tres opciones de configuración opcionales: <code>bubble</code>, <code>permission</code>, y <code>locking</code>.</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Nombre</th>\n      <th>Descripción</th>\n      <th>Defecto</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>bubble</code></td>\n      <td>Indica si los mensajes deben aparecer en otros canales después de ser manejados</td>\n      <td><code>true</code></td>\n    </tr>\n    <tr>\n      <td><code>permission</code></td>\n      <td>Los permisos del archivo de registro</td>\n      <td><code>0644</code></td>\n    </tr>\n    <tr>\n      <td><code>locking</code></td>\n      <td>Intente bloquear el archivo de registro antes de escribir en él</td>\n      <td><code>false</code></td>\n    </tr>\n    </tbody>\n  </table>\n  <h4>Configuración del canal Papertrail</h4>\n  <p>El <code>papertrail</code>canal requiere las opciones de configuración <code>url</code>y <code>port</code>. Puede obtener estos valores de Papertrail .</p>\n  <h4>Configuración del canal Slack</h4>\n  <p>El <code>slack</code>canal requiere una <code>url</code>opción de configuración. Esta URL debe coincidir con la URL de un webhook entrante que haya configurado para su equipo de Slack. De forma predeterminada, Slack solo recibirá registros de <code>critical</code>nivel y superior; sin embargo, puede ajustar esto en su <code>logging</code>archivo de configuración.</p>\n  <p></p>\n  <h3>Construcción de pilas de troncos</h3>\n  <p>Como se mencionó anteriormente, el <code>stack</code>controlador le permite combinar múltiples canales en un solo canal de registro. Para ilustrar cómo usar las pilas de registros, echemos un vistazo a una configuración de ejemplo que puede ver en una aplicación de producción:</p>\n  <pre><code>'channels' =&gt; [\n    'stack' =&gt; [\n        'driver' =&gt; 'stack',\n        'channels' =&gt; ['syslog', 'slack'],\n    ],\n\n    'syslog' =&gt; [\n        'driver' =&gt; 'syslog',\n        'level' =&gt; 'debug',\n    ],\n\n    'slack' =&gt; [\n        'driver' =&gt; 'slack',\n        'url' =&gt; env('LOG_SLACK_WEBHOOK_URL'),\n        'username' =&gt; 'Laravel Log',\n        'emoji' =&gt; ':boom:',\n        'level' =&gt; 'critical',\n    ],\n],</code></pre>\n  <p>Analicemos esta configuración. Primero, observe que nuestro <code>stack</code>canal agrega otros dos canales a través de su <code>channels</code>opción: <code>syslog</code>y <code>slack</code>. Entonces, al registrar mensajes, ambos canales tendrán la oportunidad de registrar el mensaje.</p>\n  <h4>Niveles de registro</h4>\n  <p>Tome nota de la <code>level</code>opción de configuración presente en las configuraciones de canal <code>syslog</code>y <code>slack</code>en el ejemplo anterior. Esta opción determina el \"nivel\" mínimo que debe tener un mensaje para que el canal lo registre. Monolog, que impulsa los servicios de registro de Laravel, ofrece todos los niveles de registro definidos en la especificación RFC 5424 : <strong>emergencia</strong> , <strong>alerta</strong> , <strong>crítico</strong> , <strong>error</strong> , <strong>advertencia</strong> , <strong>aviso</strong> , <strong>información</strong> y <strong>depuración</strong> .</p>\n  <p>Entonces, imagina que registramos un mensaje usando el <code>debug</code>método:</p>\n  <pre><code>Log::debug('An informational message.');</code></pre>\n  <p>Dada nuestra configuración, el <code>syslog</code>canal escribirá el mensaje en el registro del sistema; sin embargo, dado que el mensaje de error no es <code>critical</code>o superior, no se enviará a Slack. Sin embargo, si registramos un <code>emergency</code>mensaje, se enviará tanto al registro del sistema como a Slack, ya que el <code>emergency</code>nivel está por encima de nuestro umbral de nivel mínimo para ambos canales:</p>\n  <pre><code>Log::emergency('The system is down!');</code></pre>\n  <p></p>\n  <h2>Escribir mensajes de registro</h2>\n  <p>Puede escribir información en los registros utilizando la <code>Log</code> fachada . Como se mencionó anteriormente, el registrador proporciona los ocho niveles de registro definidos en la especificación RFC 5424 : <strong>emergencia</strong> , <strong>alerta</strong> , <strong>crítico</strong> , <strong>error</strong> , <strong>advertencia</strong> , <strong>aviso</strong> , <strong>información</strong> y <strong>depuración</strong> :</p>\n  <pre><code>Log::emergency($message);\nLog::alert($message);\nLog::critical($message);\nLog::error($message);\nLog::warning($message);\nLog::notice($message);\nLog::info($message);\nLog::debug($message);</code></pre>\n  <p>Por lo tanto, puede llamar a cualquiera de estos métodos para registrar un mensaje para el nivel correspondiente. De forma predeterminada, el mensaje se escribirá en el canal de registro predeterminado según lo configurado por su archivo de configuración:<code>config/logging.php</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass UserController extends Controller\n{\n    /**\n     * Show the profile for the given user.\n     *\n     * @param  int  $id\n     * @return Response\n     */\n    public function showProfile($id)\n    {\n        Log::info('Showing user profile for user: '.$id);\n\n        return view('user.profile', ['user' =&gt; User::findOrFail($id)]);\n    }\n}</code></pre>\n  <h4>Información contextual</h4>\n  <p>También se puede pasar una serie de datos contextuales a los métodos de registro. Estos datos contextuales serán formateados y mostrados con el mensaje de registro:</p>\n  <pre><code>Log::info('User failed to login.', ['id' =&gt; $user-&gt;id]);</code></pre>\n  <p></p>\n  <h3>Escribir en canales específicos</h3>\n  <p>A veces, es posible que desee registrar un mensaje en un canal que no sea el canal predeterminado de su aplicación. Puede usar el <code>channel</code>método en la <code>Log</code>fachada para recuperar e iniciar sesión en cualquier canal definido en su archivo de configuración:</p>\n  <pre><code>Log::channel('slack')-&gt;info('Something happened!');</code></pre>\n  <p>Si desea crear una pila de registro a pedido que consta de varios canales, puede usar el <code>stack</code>método:</p>\n  <pre><code>Log::stack(['single', 'slack'])-&gt;info('Something happened!');</code></pre>\n  <p></p>\n  <h2>Personalización avanzada del canal Monolog</h2>\n  <p></p>\n  <h3>Personalización de Monolog para canales</h3>\n  <p>A veces, es posible que necesite un control total sobre cómo se configura Monolog para un canal existente. Por ejemplo, es posible que desee configurar una <code>FormatterInterface</code>implementación de Monolog personalizada para los controladores de un canal determinado.</p>\n  <p>Para comenzar, defina una <code>tap</code>matriz en la configuración del canal. La <code>tap</code>matriz debe contener una lista de clases que deben tener la oportunidad de personalizar (o \"aprovechar\") la instancia de Monolog después de su creación:</p>\n  <pre><code>'single' =&gt; [\n    'driver' =&gt; 'single',\n    'tap' =&gt; [App\\Logging\\CustomizeFormatter::class],\n    'path' =&gt; storage_path('logs/laravel.log'),\n    'level' =&gt; 'debug',\n],</code></pre>\n  <p>Una vez que haya configurado la <code>tap</code>opción en su canal, estará listo para definir la clase que personalizará su instancia de Monolog. Esta clase solo necesita un único método:, <code>__invoke</code>que recibe una instancia. La instancia envía todas las llamadas a métodos a la instancia de Monolog subyacente:<code>Illuminate\\Log\\Logger</code><code>Illuminate\\Log\\Logger</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Logging;\n\nuse Monolog\\Formatter\\LineFormatter;\n\nclass CustomizeFormatter\n{\n    /**\n     * Customize the given logger instance.\n     *\n     * @param  \\Illuminate\\Log\\Logger  $logger\n     * @return void\n     */\n    public function __invoke($logger)\n    {\n        foreach ($logger-&gt;getHandlers() as $handler) {\n            $handler-&gt;setFormatter(new LineFormatter(\n                '[%datetime%] %channel%.%level_name%: %message% %context% %extra%'\n            ));\n        }\n    }\n}</code></pre>\n  <blockquote>\n    <p>Todas sus clases de \"tap\" son resueltas por el contenedor de servicios , por lo que cualquier dependencia de constructor que requieran se inyectará automáticamente.</p>\n  </blockquote>\n  <p></p>\n  <h3>Creación de canales de controlador de Monolog</h3>\n  <p>Monolog tiene una variedad de controladores disponibles . En algunos casos, el tipo de registrador que desea crear es simplemente un controlador Monolog con una instancia de un controlador específico. Estos canales se pueden crear utilizando el <code>monolog</code>controlador.</p>\n  <p>Al usar el <code>monolog</code>controlador, la <code>handler</code>opción de configuración se usa para especificar qué controlador se instanciará. Opcionalmente, cualquier parámetro de constructor que necesite el controlador puede especificarse mediante la <code>with</code>opción de configuración:</p>\n  <pre><code>'logentries' =&gt; [\n    'driver'  =&gt; 'monolog',\n    'handler' =&gt; Monolog\\Handler\\SyslogUdpHandler::class,\n    'with' =&gt; [\n        'host' =&gt; 'my.logentries.internal.datahubhost.company.com',\n        'port' =&gt; '10000',\n    ],\n],</code></pre>\n  <h4>Formateadores de monólogos</h4>\n  <p>Al utilizar el <code>monolog</code>controlador, Monolog <code>LineFormatter</code>se utilizará como formateador predeterminado. Sin embargo, puede personalizar el tipo de formateador que se pasa al controlador mediante las opciones de configuración <code>formatter</code>y <code>formatter_with</code>:</p>\n  <pre><code>'browser' =&gt; [\n    'driver' =&gt; 'monolog',\n    'handler' =&gt; Monolog\\Handler\\BrowserConsoleHandler::class,\n    'formatter' =&gt; Monolog\\Formatter\\HtmlFormatter::class,\n    'formatter_with' =&gt; [\n        'dateFormat' =&gt; 'Y-m-d',\n    ],\n],</code></pre>\n  <p>Si está utilizando un controlador Monolog que es capaz de proporcionar su propio formateador, puede establecer el valor de la <code>formatter</code>opción de configuración en <code>default</code>:</p>\n  <pre><code>'newrelic' =&gt; [\n    'driver' =&gt; 'monolog',\n    'handler' =&gt; Monolog\\Handler\\NewRelicHandler::class,\n    'formatter' =&gt; 'default',\n],</code></pre>\n  <p></p>\n  <h3>Creación de canales a través de Factories</h3>\n  <p>Si desea definir un canal completamente personalizado en el que tenga control total sobre la creación de instancias y la configuración de Monolog, puede especificar un <code>custom</code>tipo de controlador en su archivo de configuración. Su configuración debe incluir una opción para apuntar a la clase de fábrica que se invocará para crear la instancia de Monolog:<code>config/logging.php</code><code>via</code></p>\n  <pre><code>'channels' =&gt; [\n    'custom' =&gt; [\n        'driver' =&gt; 'custom',\n        'via' =&gt; App\\Logging\\CreateCustomLogger::class,\n    ],\n],</code></pre>\n  <p>Una vez que haya configurado el <code>custom</code>canal, estará listo para definir la clase que creará su instancia de Monolog. Esta clase solo necesita un único método:, <code>__invoke</code>que debería devolver la instancia de Monolog:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Logging;\n\nuse Monolog\\Logger;\n\nclass CreateCustomLogger\n{\n    /**\n     * Create a custom Monolog instance.\n     *\n     * @param  array  $config\n     * @return \\Monolog\\Logger\n     */\n    public function __invoke(array $config)\n    {\n        return new Logger(...);\n    }\n}</code></pre>\n</section>"
      }
    ]
  },
  {
    "titulo": "FrontEnd",
    "subtitulo": "",
    "items": [
      {
        "titulo": "4.1 Plantillas Blade",
        "contenido": "<section>\n  <h1>Plantillas Blade</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Herencia de plantilla\n      <ul>\n        <li>Definición de un diseño</li>\n        <li>Extender un diseño</li>\n      </ul></li>\n    <li>Visualización de datos\n      <ul>\n        <li>Frameworks Blade y JavaScript</li>\n      </ul></li>\n    <li>Estructuras de Control\n      <ul>\n        <li>Si declaraciones</li>\n        <li>Cambiar declaraciones</li>\n        <li>Bucles</li>\n        <li>La variable de bucle</li>\n        <li>Comentarios</li>\n        <li>PHP</li>\n        <li>La <code>@once</code>directiva</li>\n      </ul></li>\n    <li>Formularios\n      <ul>\n        <li>Campo CSRF</li>\n        <li>Campo de método</li>\n        <li>Errores de validación</li>\n      </ul></li>\n    <li>Componentes\n      <ul>\n        <li>Visualización de componentes</li>\n        <li>Pasar datos a componentes</li>\n        <li>Administrar atributos</li>\n        <li>Ranuras</li>\n        <li>Vistas de componentes integradas</li>\n        <li>Componentes anónimos</li>\n        <li>Componentes dinámicos</li>\n      </ul></li>\n    <li>Incluyendo subvistas\n      <ul>\n        <li>Representación de vistas para colecciones</li>\n      </ul></li>\n    <li>Pilas</li>\n    <li>Inyección de servicio</li>\n    <li>Hoja extensible\n      <ul>\n        <li>Declaraciones If personalizadas</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Blade es el motor de plantillas simple pero potente que se proporciona con Laravel. A diferencia de otros motores de plantillas PHP populares, Blade no le impide usar código PHP simple en sus vistas. De hecho, todas las vistas de Blade se compilan en código PHP simple y se almacenan en caché hasta que se modifican, lo que significa que Blade agrega esencialmente cero gastos generales a su aplicación. Los archivos de vista Blade usan la extensión de archivo y generalmente se almacenan en el directorio.<code>.blade.php</code><code>resources/views</code></p>\n  <p></p>\n  <h2>Herencia de plantilla</h2>\n  <p></p>\n  <h3>Definición de un diseño</h3>\n  <p>Dos de los principales beneficios de utilizar Blade son <em>la herencia de plantillas</em> y las <em>secciones</em> . Para empezar, echemos un vistazo a un ejemplo sencillo. Primero, examinaremos un diseño de página \"maestro\". Dado que la mayoría de las aplicaciones web mantienen el mismo diseño general en varias páginas, es conveniente definir este diseño como una sola vista Blade:</p>\n  <pre><code>&lt;!-- Stored in resources/views/layouts/app.blade.php --&gt;\n\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;App Name - @yield('title')&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        @section('sidebar')\n            This is the master sidebar.\n        @show\n\n        &lt;div class=\"container\"&gt;\n            @yield('content')\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n  <p>Como puede ver, este archivo contiene un marcado HTML típico. Sin embargo, tome nota de las directivas <code>@section</code>y . La directiva, como su nombre lo indica, define una sección de contenido, mientras que la directiva se usa para mostrar el contenido de una sección determinada.<code>@yield</code><code>@section</code><code>@yield</code></p>\n  <p>Ahora que hemos definido un diseño para nuestra aplicación, definamos una página secundaria que herede el diseño.</p>\n  <p></p>\n  <h3>Extender un diseño</h3>\n  <p>Al definir una vista secundaria, use la directiva Blade para especificar qué diseño debe \"heredar\" la vista secundaria. Las vistas que extienden un diseño Blade pueden inyectar contenido en las secciones del diseño mediante directivas. Recuerde, como se ve en el ejemplo anterior, el contenido de estas secciones se mostrará en el diseño usando :<code>@extends</code><code>@section</code><code>@yield</code></p>\n  <pre><code>&lt;!-- Stored in resources/views/child.blade.php --&gt;\n\n@extends('layouts.app')\n\n@section('title', 'Page Title')\n\n@section('sidebar')\n    @parent\n\n    &lt;p&gt;This is appended to the master sidebar.&lt;/p&gt;\n@endsection\n\n@section('content')\n    &lt;p&gt;This is my body content.&lt;/p&gt;\n@endsection</code></pre>\n  <p>En este ejemplo, la <code>sidebar</code>sección utiliza la directiva para agregar (en lugar de sobrescribir) contenido a la barra lateral del diseño. La directiva será reemplazada por el contenido del diseño cuando se renderice la vista.<code>@parent</code><code>@parent</code></p>\n  <blockquote>\n    <p>Al contrario que en el ejemplo anterior, esta <code>sidebar</code>sección termina con en <code>@endsection</code>lugar de <code>@show</code>. La <code>@endsection</code>directiva solo definirá una sección mientras <code>@show</code>que definirá e <strong>inmediatamente cederá</strong> la sección.</p>\n  </blockquote>\n  <p>La directiva también acepta un valor predeterminado como segundo parámetro. Este valor se representará si la sección que se obtiene no está definida:<code>@yield</code></p>\n  <pre><code>@yield('content', View::make('view.name'))</code></pre>\n  <p>Las vistas de la hoja se pueden devolver desde las rutas utilizando el <code>view</code>ayudante global :</p>\n  <pre><code>Route::get('blade', function () {\n    return view('child');\n});</code></pre>\n  <p></p>\n  <h2>Visualización de datos</h2>\n  <p>Puede mostrar los datos transmitidos a sus vistas de Blade envolviendo la variable entre llaves. Por ejemplo, dada la siguiente ruta:</p>\n  <pre><code>Route::get('greeting', function () {\n    return view('welcome', ['name' =&gt; 'Samantha']);\n});</code></pre>\n  <p>Puede mostrar el contenido de la <code>name</code>variable así:</p>\n  <pre><code>Hello, {{ $name }}.</code></pre>\n  <blockquote>\n    <p>Las declaraciones Blade se envían automáticamente a través de la función de PHP para evitar ataques XSS.<code>{{ }}</code><code>htmlspecialchars</code></p>\n  </blockquote>\n  <p>No está limitado a mostrar el contenido de las variables pasadas a la vista. También puede repetir los resultados de cualquier función PHP. De hecho, puede poner cualquier código PHP que desee dentro de una declaración de eco de Blade:</p>\n  <pre><code>The current UNIX timestamp is {{ time() }}.</code></pre>\n  <h4>Visualización de datos sin escape</h4>\n  <p>De forma predeterminada, las declaraciones de Blade se envían automáticamente a través de la función de PHP para evitar ataques XSS. Si no desea que se escapen sus datos, puede utilizar la siguiente sintaxis:<code>{{ }}</code><code>htmlspecialchars</code></p>\n  <pre><code>Hello, {!! $name !!}.</code></pre>\n  <blockquote>\n    <p>Tenga mucho cuidado al hacer eco de contenido proporcionado por los usuarios de su aplicación. Utilice siempre la sintaxis de doble llave de escape para evitar ataques XSS al mostrar datos proporcionados por el usuario.</p>\n  </blockquote>\n  <h4>Representación de JSON</h4>\n  <p>A veces, puede pasar una matriz a su vista con la intención de representarla como JSON para inicializar una variable de JavaScript. Por ejemplo:</p>\n  <pre><code>&lt;script&gt;\n    var app = &lt;?php echo json_encode($array); ?&gt;;\n&lt;/script&gt;</code></pre>\n  <p>Sin embargo, en lugar de llamar manualmente <code>json_encode</code>, puede usar la <code>@json</code>directiva Blade. La <code>@json</code>directiva acepta los mismos argumentos que la <code>json_encode</code>función de PHP :</p>\n  <pre><code>&lt;script&gt;\n    var app = @json($array);\n\n    var app = @json($array, JSON_PRETTY_PRINT);\n&lt;/script&gt;</code></pre>\n  <blockquote>\n    <p>Solo debe usar la <code>@json</code>directiva para representar las variables existentes como JSON. La plantilla Blade se basa en expresiones regulares y los intentos de pasar una expresión compleja a la directiva pueden provocar fallos inesperados.</p>\n  </blockquote>\n  <h4>Codificación de entidad HTML</h4>\n  <p>De forma predeterminada, Blade (y el <code>e</code>ayudante de Laravel ) codificarán dos veces las entidades HTML. Si desea deshabilitar la codificación doble, llame al método desde el método de su :<code>Blade::withoutDoubleEncoding</code><code>boot</code><code>AppServiceProvider</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\Blade;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Blade::withoutDoubleEncoding();\n    }\n}</code></pre>\n  <p></p>\n  <h3>Frameworks Blade y JavaScript</h3>\n  <p>Dado que muchos marcos de JavaScript también usan llaves \"rizadas\" para indicar que una expresión determinada debe mostrarse en el navegador, puede usar el <code>@</code>símbolo para informar al motor de renderizado Blade que una expresión debe permanecer intacta. Por ejemplo:</p>\n  <pre><code>&lt;h1&gt;Laravel&lt;/h1&gt;\n\nHello, @{{ name }}.</code></pre>\n  <p>En este ejemplo, <code>@</code>Blade eliminará el símbolo; sin embargo, la expresión permanecerá intacta por el motor Blade, lo que permitirá que su marco JavaScript la represente.<code>{{ name }}</code></p>\n  <p>El <code>@</code>símbolo también se puede usar para escapar de las directivas Blade:</p>\n  <pre><code>{{-- Blade --}}\n@@json()\n\n&lt;!-- HTML output --&gt;\n@json()</code></pre>\n  <h4>La <code>@verbatim</code>directiva</h4>\n  <p>Si muestra variables de JavaScript en una gran parte de su plantilla, puede envolver el HTML en la <code>@verbatim</code>directiva para que no tenga que anteponer cada declaración de eco de Blade con un <code>@</code>símbolo:</p>\n  <pre><code>@verbatim\n    &lt;div class=\"container\"&gt;\n        Hello, {{ name }}.\n    &lt;/div&gt;\n@endverbatim</code></pre>\n  <p></p>\n  <h2>Estructuras de Control</h2>\n  <p>Además de la herencia de la plantilla y la visualización de datos, Blade también proporciona accesos directos convenientes para estructuras de control PHP comunes, como declaraciones condicionales y bucles. Estos atajos proporcionan una forma muy clara y concisa de trabajar con las estructuras de control de PHP, sin dejar de ser familiares para sus contrapartes de PHP.</p>\n  <p></p>\n  <h3>Si declaraciones</h3>\n  <p>Es posible construir <code>if</code>declaraciones utilizando los , , , y directivas. Estas directivas funcionan de manera idéntica a sus contrapartes de PHP:<code>@if</code><code>@elseif</code><code>@else</code><code>@endif</code></p>\n  <pre><code>@if (count($records) === 1)\n    I have one record!\n@elseif (count($records) &gt; 1)\n    I have multiple records!\n@else\n    I don't have any records!\n@endif</code></pre>\n  <p>Para mayor comodidad, Blade también proporciona una <code>@unless</code>directiva:</p>\n  <pre><code>@unless (Auth::check())\n    You are not signed in.\n@endunless</code></pre>\n  <p>Además de las directivas condicionales ya discutidas, las directivas y pueden usarse como accesos directos convenientes para sus respectivas funciones PHP:<code>@isset</code><code>@empty</code></p>\n  <pre><code>@isset($records)\n    // $records is defined and is not null...\n@endisset\n\n@empty($records)\n    // $records is \"empty\"...\n@endempty</code></pre>\n  <h4>Directivas de autenticación</h4>\n  <p>Las directivas <code>@auth</code>y <code>@guest</code>se pueden usar para determinar rápidamente si el usuario actual está autenticado o es un invitado:</p>\n  <pre><code>@auth\n    // The user is authenticated...\n@endauth\n\n@guest\n    // The user is not authenticated...\n@endguest</code></pre>\n  <p>Si es necesario, puede especificar la protección de autenticación que se debe verificar al usar las directivas <code>@auth</code>y <code>@guest</code>:</p>\n  <pre><code>@auth('admin')\n    // The user is authenticated...\n@endauth\n\n@guest('admin')\n    // The user is not authenticated...\n@endguest</code></pre>\n  <h4>Directivas de sección</h4>\n  <p>Puede verificar si una sección tiene contenido usando la <code>@hasSection</code>directiva:</p>\n  <pre><code>@hasSection('navigation')\n    &lt;div class=\"pull-right\"&gt;\n        @yield('navigation')\n    &lt;/div&gt;\n\n    &lt;div class=\"clearfix\"&gt;&lt;/div&gt;\n@endif</code></pre>\n  <p>Puede utilizar la <code>sectionMissing</code>directiva para determinar si una sección no tiene contenido:</p>\n  <pre><code>@sectionMissing('navigation')\n    &lt;div class=\"pull-right\"&gt;\n        @include('default-navigation')\n    &lt;/div&gt;\n@endif</code></pre>\n  <h4>Directivas medioambientales</h4>\n  <p>Puede verificar si la aplicación se está ejecutando en el entorno de producción utilizando la <code>@production</code>directiva:</p>\n  <pre><code>@production\n    // Production specific content...\n@endproduction</code></pre>\n  <p>O puede determinar si la aplicación se está ejecutando en un entorno específico usando la <code>@env</code>directiva:</p>\n  <pre><code>@env('staging')\n    // The application is running in \"staging\"...\n@endenv\n\n@env(['staging', 'production'])\n    // The application is running in \"staging\" or \"production\"...\n@endenv</code></pre>\n  <p></p>\n  <h3>Cambiar declaraciones</h3>\n  <p>Sentencias switch se pueden construir usando los , , , y directivas:<code>@switch</code><code>@case</code><code>@break</code><code>@default</code><code>@endswitch</code></p>\n  <pre><code>@switch($i)\n    @case(1)\n        First case...\n        @break\n\n    @case(2)\n        Second case...\n        @break\n\n    @default\n        Default case...\n@endswitch</code></pre>\n  <p></p>\n  <h3>Bucles</h3>\n  <p>Además de las declaraciones condicionales, Blade proporciona directivas simples para trabajar con estructuras de bucle de PHP. Nuevamente, cada una de estas directivas funciona de manera idéntica a sus contrapartes de PHP:</p>\n  <pre><code>@for ($i = 0; $i &lt; 10; $i++)\n    The current value is {{ $i }}\n@endfor\n\n@foreach ($users as $user)\n    &lt;p&gt;This is user {{ $user-&gt;id }}&lt;/p&gt;\n@endforeach\n\n@forelse ($users as $user)\n    &lt;li&gt;{{ $user-&gt;name }}&lt;/li&gt;\n@empty\n    &lt;p&gt;No users&lt;/p&gt;\n@endforelse\n\n@while (true)\n    &lt;p&gt;I'm looping forever.&lt;/p&gt;\n@endwhile</code></pre>\n  <blockquote>\n    <p>Al realizar un bucle, puede utilizar la variable de bucle para obtener información valiosa sobre el bucle, como si se encuentra en la primera o la última iteración del bucle.</p>\n  </blockquote>\n  <p>Al usar bucles, también puede finalizar el bucle u omitir la iteración actual:</p>\n  <pre><code>@foreach ($users as $user)\n    @if ($user-&gt;type == 1)\n        @continue\n    @endif\n\n    &lt;li&gt;{{ $user-&gt;name }}&lt;/li&gt;\n\n    @if ($user-&gt;number == 5)\n        @break\n    @endif\n@endforeach</code></pre>\n  <p>También puede incluir la condición con la declaración directiva en una línea:</p>\n  <pre><code>@foreach ($users as $user)\n    @continue($user-&gt;type == 1)\n\n    &lt;li&gt;{{ $user-&gt;name }}&lt;/li&gt;\n\n    @break($user-&gt;number == 5)\n@endforeach</code></pre>\n  <p></p>\n  <h3>La variable de bucle</h3>\n  <p>Al hacer un bucle, <code>$loop</code>habrá una variable disponible dentro de su bucle. Esta variable proporciona acceso a algunos bits de información útiles, como el índice del ciclo actual y si esta es la primera o la última iteración a través del ciclo:</p>\n  <pre><code>@foreach ($users as $user)\n    @if ($loop-&gt;first)\n        This is the first iteration.\n    @endif\n\n    @if ($loop-&gt;last)\n        This is the last iteration.\n    @endif\n\n    &lt;p&gt;This is user {{ $user-&gt;id }}&lt;/p&gt;\n@endforeach</code></pre>\n  <p>Si está en un bucle anidado, puede acceder a la <code>$loop</code>variable del bucle principal a través de la <code>parent</code>propiedad:</p>\n  <pre><code>@foreach ($users as $user)\n    @foreach ($user-&gt;posts as $post)\n        @if ($loop-&gt;parent-&gt;first)\n            This is first iteration of the parent loop.\n        @endif\n    @endforeach\n@endforeach</code></pre>\n  <p>La <code>$loop</code>variable también contiene una variedad de otras propiedades útiles:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Propiedad</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$loop-&gt;index</code></td>\n      <td>El índice de la iteración del ciclo actual (comienza en 0).</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;iteration</code></td>\n      <td>La iteración del ciclo actual (comienza en 1).</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;remaining</code></td>\n      <td>Las iteraciones que quedan en el ciclo.</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;count</code></td>\n      <td>El número total de elementos de la matriz que se iteran.</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;first</code></td>\n      <td>Si esta es la primera iteración a través del ciclo.</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;last</code></td>\n      <td>Si esta es la última iteración del ciclo.</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;even</code></td>\n      <td>Si se trata de una iteración uniforme a través del ciclo.</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;odd</code></td>\n      <td>Si se trata de una iteración extraña a través del ciclo.</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;depth</code></td>\n      <td>El nivel de anidamiento del bucle actual.</td>\n    </tr>\n    <tr>\n      <td><code>$loop-&gt;parent</code></td>\n      <td>Cuando está en un bucle anidado, la variable del bucle principal.</td>\n    </tr>\n    </tbody>\n  </table>\n  <p></p>\n  <h3>Comentarios</h3>\n  <p>Blade también le permite definir comentarios en sus vistas. Sin embargo, a diferencia de los comentarios HTML, los comentarios Blade no se incluyen en el HTML devuelto por su aplicación:</p>\n  <pre><code>{{-- This comment will not be present in the rendered HTML --}}</code></pre>\n  <p></p>\n  <h3>PHP</h3>\n  <p>En algunas situaciones, es útil incrustar código PHP en sus vistas. Puede usar la <code>@php</code>directiva Blade para ejecutar un bloque de PHP simple dentro de su plantilla:</p>\n  <pre><code>@php\n    //\n@endphp</code></pre>\n  <blockquote>\n    <p> Si bien Blade ofrece esta función, usarla con frecuencia puede ser una señal de que tiene demasiada lógica incrustada en su plantilla.</p>\n  </blockquote>\n  <p></p>\n  <h3>La <code>@once</code>directiva</h3>\n  <p>La <code>@once</code>directiva le permite definir una parte de la plantilla que solo se evaluará una vez por ciclo de representación. Esto puede ser útil para insertar una parte determinada de JavaScript en el encabezado de la página utilizando pilas . Por ejemplo, si está renderizando un componente determinado dentro de un bucle, es posible que desee enviar JavaScript al encabezado solo la primera vez que se renderiza el componente:</p>\n  <pre><code>@once\n    @push('scripts')\n        &lt;script&gt;\n            // Your custom JavaScript...\n        &lt;/script&gt;\n    @endpush\n@endonce</code></pre>\n  <p></p>\n  <h2>Formularios</h2>\n  <p></p>\n  <h3>Campo CSRF</h3>\n  <p>Siempre que defina un formulario HTML en su aplicación, debe incluir un campo de token CSRF oculto en el formulario para que el middleware de protección CSRF pueda validar la solicitud. Puede utilizar la <code>@csrf</code>directiva Blade para generar el campo token:</p>\n  <pre><code>&lt;form method=\"POST\" action=\"/profile\"&gt;\n    @csrf\n\n    ...\n&lt;/form&gt;</code></pre>\n  <p></p>\n  <h3>Campo de método</h3>\n  <p>Since HTML forms can't make <code>PUT</code>, <code>PATCH</code>, or <code>DELETE</code> requests, you will need to add a hidden <code>_method</code> field to spoof these HTTP verbs. The <code>@method</code> Blade directive can create this field for you:</p>\n  <pre><code>&lt;form action=\"/foo/bar\" method=\"POST\"&gt;\n    @method('PUT')\n\n    ...\n&lt;/form&gt;</code></pre>\n  <p></p>\n  <h3>Validation Errors</h3>\n  <p>The <code>@error</code> directive may be used to quickly check if validation error messages exist for a given attribute. Within an <code>@error</code> directive, you may echo the <code>$message</code> variable to display the error message:</p>\n  <pre><code>&lt;!-- /resources/views/post/create.blade.php --&gt;\n\n&lt;label for=\"title\"&gt;Post Title&lt;/label&gt;\n\n&lt;input id=\"title\" type=\"text\" class=\"@error('title') is-invalid @enderror\"&gt;\n\n@error('title')\n    &lt;div class=\"alert alert-danger\"&gt;{{ $message }}&lt;/div&gt;\n@enderror</code></pre>\n  <p>You may pass the name of a specific error bag as the second parameter to the <code>@error</code> directive to retrieve validation error messages on pages containing multiple forms:</p>\n  <pre><code>&lt;!-- /resources/views/auth.blade.php --&gt;\n\n&lt;label for=\"email\"&gt;Email address&lt;/label&gt;\n\n&lt;input id=\"email\" type=\"email\" class=\"@error('email', 'login') is-invalid @enderror\"&gt;\n\n@error('email', 'login')\n    &lt;div class=\"alert alert-danger\"&gt;{{ $message }}&lt;/div&gt;\n@enderror</code></pre>\n  <p></p>\n  <h2>Components</h2>\n  <p>Components and slots provide similar benefits to sections and layouts; however, some may find the mental model of components and slots easier to understand. There are two approaches to writing components: class based components and anonymous components.</p>\n  <p>To create a class based component, you may use the <code>make:component</code> Artisan command. To illustrate how to use components, we will create a simple <code>Alert</code> component. The <code>make:component</code> command will place the component in the <code>App\\View\\Components</code> directory:</p>\n  <pre><code>php artisan make:component Alert</code></pre>\n  <p>The <code>make:component</code> command will also create a view template for the component. The view will be placed in the <code>resources/views/components</code> directory.</p>\n  <h4>Manually Registering Package Components</h4>\n  <p>When writing components for your own application, components are automatically discovered within the <code>app/View/Components</code> directory and <code>resources/views/components</code> directory.</p>\n  <p>Sin embargo, si está creando un paquete que utiliza componentes Blade, deberá registrar manualmente su clase de componente y su alias de etiqueta HTML. Por lo general, debe registrar sus componentes en el <code>boot</code>método del proveedor de servicios de su paquete:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Blade;\n\n/**\n * Bootstrap your package's services.\n */\npublic function boot()\n{\n    Blade::component('package-alert', AlertComponent::class);\n}</code></pre>\n  <p>Una vez que su componente ha sido registrado, puede ser renderizado usando su alias de etiqueta:</p>\n  <pre><code>&lt;x-package-alert/&gt;</code></pre>\n  <p>Alternativamente, puede usar el <code>componentNamespace</code>método para autocargar clases de componentes por convención. Por ejemplo, un <code>Nightshade</code>paquete puede tener <code>Calendar</code>y <code>ColorPicker</code>componentes que residen dentro del espacio de nombres:<code>Package\\Views\\Components</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Blade;\n\n/**\n * Bootstrap your package's services.\n */\npublic function boot()\n{\n    Blade::componentNamespace('Nightshade\\\\Views\\\\Components', 'nightshade');\n}</code></pre>\n  <p>Esto permitirá el uso de los componentes del paquete por el espacio de nombres de su proveedor utilizando la sintaxis:<code>package-name::</code></p>\n  <pre><code>&lt;x-nightshade::calendar /&gt;\n&lt;x-nightshade::color-picker /&gt;</code></pre>\n  <p>Blade will automatically detect the class that's linked to this component by pascal-casing the component name. Subdirectories are also supported using \"dot\" notation.</p>\n  <p></p>\n  <h3>Displaying Components</h3>\n  <p>To display a component, you may use a Blade component tag within one of your Blade templates. Blade component tags start with the string <code>x-</code> followed by the kebab case name of the component class:</p>\n  <pre><code>&lt;x-alert/&gt;\n\n&lt;x-user-profile/&gt;</code></pre>\n  <p>If the component class is nested deeper within the <code>App\\View\\Components</code> directory, you may use the <code>.</code> character to indicate directory nesting. For example, if we assume a component is located at <code>App\\View\\Components\\Inputs\\Button.php</code>, we may render it like so:</p>\n  <pre><code>&lt;x-inputs.button/&gt;</code></pre>\n  <p></p>\n  <h3>Passing Data To Components</h3>\n  <p>Puede pasar datos a los componentes Blade utilizando atributos HTML. Los valores primitivos codificados de forma rígida se pueden pasar al componente utilizando atributos HTML simples. Las expresiones y variables de PHP deben pasarse al componente a través de atributos que usan el <code>:</code>carácter como prefijo:</p>\n  <pre><code>&lt;x-alert type=\"error\" :message=\"$message\"/&gt;</code></pre>\n  <p>Debe definir los datos requeridos del componente en su constructor de clases. Todas las propiedades públicas de un componente se pondrán automáticamente a disposición de la vista del componente. No es necesario pasar los datos a la vista desde el <code>render</code>método del componente :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass Alert extends Component\n{\n    /**\n     * The alert type.\n     *\n     * @var string\n     */\n    public $type;\n\n    /**\n     * The alert message.\n     *\n     * @var string\n     */\n    public $message;\n\n    /**\n     * Create the component instance.\n     *\n     * @param  string  $type\n     * @param  string  $message\n     * @return void\n     */\n    public function __construct($type, $message)\n    {\n        $this-&gt;type = $type;\n        $this-&gt;message = $message;\n    }\n\n    /**\n     * Get the view / contents that represent the component.\n     *\n     * @return \\Illuminate\\View\\View|\\Closure|string\n     */\n    public function render()\n    {\n        return view('components.alert');\n    }\n}</code></pre>\n  <p>Cuando se procesa su componente, puede mostrar el contenido de las variables públicas de su componente haciendo eco de las variables por nombre:</p>\n  <pre><code>&lt;div class=\"alert alert-{{ $type }}\"&gt;\n    {{ $message }}\n&lt;/div&gt;</code></pre>\n  <h4>Caja</h4>\n  <p>Los argumentos del constructor de componentes deben especificarse usando <code>camelCase</code>, mientras que deben usarse al hacer referencia a los nombres de los argumentos en sus atributos HTML. Por ejemplo, dado el siguiente constructor de componentes:<code>kebab-case</code></p>\n  <pre><code>/**\n * Create the component instance.\n *\n * @param  string  $alertType\n * @return void\n */\npublic function __construct($alertType)\n{\n    $this-&gt;alertType = $alertType;\n}</code></pre>\n  <p>El <code>$alertType</code>argumento se puede proporcionar así:</p>\n  <pre><code>&lt;x-alert alert-type=\"danger\" /&gt;</code></pre>\n  <h4>Métodos de componentes</h4>\n  <p>Además de que las variables públicas estén disponibles para la plantilla de su componente, también se puede ejecutar cualquier método público en el componente. Por ejemplo, imagina un componente que tiene un <code>isSelected</code>método:</p>\n  <pre><code>/**\n * Determine if the given option is the current selected option.\n *\n * @param  string  $option\n * @return bool\n */\npublic function isSelected($option)\n{\n    return $option === $this-&gt;selected;\n}</code></pre>\n  <p>Puede ejecutar este método desde su plantilla de componente invocando la variable que coincida con el nombre del método:</p>\n  <pre><code>&lt;option {{ $isSelected($value) ? 'selected=\"selected\"' : '' }} value=\"{{ $value }}\"&gt;\n    {{ $label }}\n&lt;/option&gt;</code></pre>\n  <h4>Uso de atributos y espacios dentro de la clase</h4>\n  <p>Blade components also allow you to access the component name, attributes, and slot inside the class's render method. However, in order to access this data, you should return a Closure from your component's <code>render</code> method. The Closure will receive a <code>$data</code> array as its only argument:</p>\n  <pre><code>/**\n * Get the view / contents that represent the component.\n *\n * @return \\Illuminate\\View\\View|\\Closure|string\n */\npublic function render()\n{\n    return function (array $data) {\n        // $data['componentName'];\n        // $data['attributes'];\n        // $data['slot'];\n\n        return '&lt;div&gt;Component content&lt;/div&gt;';\n    };\n}</code></pre>\n  <p>The <code>componentName</code> is equal to the name used in the HTML tag after the <code>x-</code> prefix. So <code>&lt;x-alert /&gt;</code>'s <code>componentName</code> will be <code>alert</code>. The <code>attributes</code> element will contain all of the attributes that were present on the HTML tag. The <code>slot</code> element is a <code>Illuminate\\Support\\HtmlString</code> instance with the contents of the slot from the component.</p>\n  <h4>Additional Dependencies</h4>\n  <p>If your component requires dependencies from Laravel's service container, you may list them before any of the component's data attributes and they will automatically be injected by the container:</p>\n  <pre><code>use App\\Services\\AlertCreator\n\n/**\n * Create the component instance.\n *\n * @param  \\App\\Services\\AlertCreator  $creator\n * @param  string  $type\n * @param  string  $message\n * @return void\n */\npublic function __construct(AlertCreator $creator, $type, $message)\n{\n    $this-&gt;creator = $creator;\n    $this-&gt;type = $type;\n    $this-&gt;message = $message;\n}</code></pre>\n  <p></p>\n  <h3>Managing Attributes</h3>\n  <p>We've already examined how to pass data attributes to a component; however, sometimes you may need to specify additional HTML attributes, such as <code>class</code>, that are not part of the data required for a component to function. Typically, you want to pass these additional attributes down to the root element of the component template. For example, imagine we want to render an <code>alert</code> component like so:</p>\n  <pre><code>&lt;x-alert type=\"error\" :message=\"$message\" class=\"mt-4\"/&gt;</code></pre>\n  <p>All of the attributes that are not part of the component's constructor will automatically be added to the component's \"attribute bag\". This attribute bag is automatically made available to the component via the <code>$attributes</code> variable. All of the attributes may be rendered within the component by echoing this variable:</p>\n  <pre><code>&lt;div {{ $attributes }}&gt;\n    &lt;!-- Component Content --&gt;\n&lt;/div&gt;</code></pre>\n  <blockquote>\n    <p> Using directives such as <code>@env</code> directly on a component is not supported at this time.</p>\n  </blockquote>\n  <h4>Default / Merged Attributes</h4>\n  <p>Sometimes you may need to specify default values for attributes or merge additional values into some of the component's attributes. To accomplish this, you may use the attribute bag's <code>merge</code> method:</p>\n  <pre><code>&lt;div {{ $attributes-&gt;merge(['class' =&gt; 'alert alert-'.$type]) }}&gt;\n    {{ $message }}\n&lt;/div&gt;</code></pre>\n  <p>If we assume this component is utilized like so:</p>\n  <pre><code>&lt;x-alert type=\"error\" :message=\"$message\" class=\"mb-4\"/&gt;</code></pre>\n  <p>The final, rendered HTML of the component will appear like the following:</p>\n  <pre><code>&lt;div class=\"alert alert-error mb-4\"&gt;\n    &lt;!-- Contents of the $message variable --&gt;\n&lt;/div&gt;</code></pre>\n  <h4>Filtering Attributes</h4>\n  <p>Puede filtrar atributos usando el <code>filter</code>método. Este método acepta un cierre que debería regresar <code>true</code>si desea retener el atributo en la bolsa de atributos:</p>\n  <pre><code>{{ $attributes-&gt;filter(fn ($value, $key) =&gt; $key == 'foo') }}</code></pre>\n  <p>Por conveniencia, puede utilizar el <code>whereStartsWith</code>método para recuperar todos los atributos cuyas claves comienzan con una cadena determinada:</p>\n  <pre><code>{{ $attributes-&gt;whereStartsWith('wire:model') }}</code></pre>\n  <p>Con el <code>first</code>método, puede representar el primer atributo en una bolsa de atributos determinada:</p>\n  <pre><code>{{ $attributes-&gt;whereStartsWith('wire:model')-&gt;first() }}</code></pre>\n  <p></p>\n  <h3>Ranuras</h3>\n  <p>A menudo, necesitará pasar contenido adicional a su componente a través de \"ranuras\". Imaginemos que un <code>alert</code>componente que creamos tiene el siguiente marcado:</p>\n  <pre><code>&lt;!-- /resources/views/components/alert.blade.php --&gt;\n\n&lt;div class=\"alert alert-danger\"&gt;\n    {{ $slot }}\n&lt;/div&gt;</code></pre>\n  <p>Podemos pasar contenido al <code>slot</code>inyectando contenido en el componente:</p>\n  <pre><code>&lt;x-alert&gt;\n    &lt;strong&gt;Whoops!&lt;/strong&gt; Something went wrong!\n&lt;/x-alert&gt;</code></pre>\n  <p>A veces, un componente puede necesitar renderizar varias ranuras diferentes en diferentes ubicaciones dentro del componente. Modifiquemos nuestro componente de alerta para permitir la inyección de un \"título\":</p>\n  <pre><code>&lt;!-- /resources/views/components/alert.blade.php --&gt;\n\n&lt;span class=\"alert-title\"&gt;{{ $title }}&lt;/span&gt;\n\n&lt;div class=\"alert alert-danger\"&gt;\n    {{ $slot }}\n&lt;/div&gt;</code></pre>\n  <p>Puede definir el contenido de la ranura nombrada usando la etiqueta. Cualquier contenido que no esté dentro de una etiqueta se pasará al componente en la variable:<code>x-slot</code><code>x-slot</code><code>$slot</code></p>\n  <pre><code>&lt;x-alert&gt;\n    &lt;x-slot name=\"title\"&gt;\n        Server Error\n    &lt;/x-slot&gt;\n\n    &lt;strong&gt;Whoops!&lt;/strong&gt; Something went wrong!\n&lt;/x-alert&gt;</code></pre>\n  <h4>Ranuras con ámbito</h4>\n  <p>Si ha utilizado un marco de JavaScript como Vue, es posible que esté familiarizado con las \"ranuras con alcance\", que le permiten acceder a datos o métodos desde el componente dentro de su ranura. Puede lograr un comportamiento similar en Laravel definiendo métodos públicos o propiedades en su componente y accediendo al componente dentro de su ranura a través de la <code>$component</code>variable:</p>\n  <pre><code>&lt;x-alert&gt;\n    &lt;x-slot name=\"title\"&gt;\n        {{ $component-&gt;formatAlert('Server Error') }}\n    &lt;/x-slot&gt;\n\n    &lt;strong&gt;Whoops!&lt;/strong&gt; Something went wrong!\n&lt;/x-alert&gt;</code></pre>\n  <p></p>\n  <h3>Vistas de componentes integradas</h3>\n  <p>Para componentes muy pequeños, puede resultar complicado administrar tanto la clase de componente como la plantilla de vista del componente. Por esta razón, puede devolver el marcado del componente directamente desde el <code>render</code>método:</p>\n  <pre><code>/**\n * Get the view / contents that represent the component.\n *\n * @return \\Illuminate\\View\\View|\\Closure|string\n */\npublic function render()\n{\n    return &lt;&lt;&lt;'blade'\n        &lt;div class=\"alert alert-danger\"&gt;\n            {{ $slot }}\n        &lt;/div&gt;\n    blade;\n}</code></pre>\n  <h4>Generación de componentes de vista en línea</h4>\n  <p>Para crear un componente que represente una vista en línea, puede usar la <code>inline</code>opción al ejecutar el comando:<code>make:component</code></p>\n  <pre><code>php artisan make:component Alert --inline</code></pre>\n  <p></p>\n  <h3>Componentes anónimos</h3>\n  <p>Al igual que los componentes en línea, los componentes anónimos proporcionan un mecanismo para administrar un componente a través de un solo archivo. Sin embargo, los componentes anónimos utilizan un archivo de vista única y no tienen una clase asociada. Para definir un componente anónimo, solo necesita colocar una plantilla Blade dentro de su directorio. Por ejemplo, suponiendo que haya definido un componente en :<code>resources/views/components</code><code>resources/views/components/alert.blade.php</code></p>\n  <pre><code>&lt;x-alert/&gt;</code></pre>\n  <p>Puede usar el <code>.</code>carácter para indicar si un componente está anidado más profundamente dentro del <code>components</code>directorio. Por ejemplo, asumiendo que el componente está definido en , puede representarlo así:<code>resources/views/components/inputs/button.blade.php</code></p>\n  <pre><code>&lt;x-inputs.button/&gt;</code></pre>\n  <h4>Propiedades / atributos de datos</h4>\n  <p>Dado que los componentes anónimos no tienen ninguna clase asociada, es posible que se pregunte cómo puede diferenciar qué datos deben pasarse al componente como variables y qué atributos deben colocarse en la bolsa de atributos del componente .</p>\n  <p>Puede especificar qué atributos deben considerarse variables de datos utilizando la <code>@props</code>directiva en la parte superior de la plantilla Blade de su componente. Todos los demás atributos del componente estarán disponibles a través de la bolsa de atributos del componente. Si desea darle a una variable de datos un valor predeterminado, puede especificar el nombre de la variable como clave de matriz y el valor predeterminado como valor de matriz:</p>\n  <pre><code>&lt;!-- /resources/views/components/alert.blade.php --&gt;\n\n@props(['type' =&gt; 'info', 'message'])\n\n&lt;div {{ $attributes-&gt;merge(['class' =&gt; 'alert alert-'.$type]) }}&gt;\n    {{ $message }}\n&lt;/div&gt;</code></pre>\n  <p></p>\n  <h3>Componentes dinámicos</h3>\n  <p>A veces es posible que necesite renderizar un componente pero no saber qué componente debe renderizarse hasta el tiempo de ejecución. En esta situación, puede usar el componente integrado de Laravel para renderizar el componente en función de un valor de tiempo de ejecución o una variable:<code>dynamic-component</code></p>\n  <pre><code>&lt;x-dynamic-component :component=\"$componentName\" class=\"mt-4\" /&gt;</code></pre>\n  <p></p>\n  <h2>Incluyendo subvistas</h2>\n  <p>Blade's <code>@include</code> directive allows you to include a Blade view from within another view. All variables that are available to the parent view will be made available to the included view:</p>\n  <pre><code>&lt;div&gt;\n    @include('shared.errors')\n\n    &lt;form&gt;\n        &lt;!-- Form Contents --&gt;\n    &lt;/form&gt;\n&lt;/div&gt;</code></pre>\n  <p>Even though the included view will inherit all data available in the parent view, you may also pass an array of extra data to the included view:</p>\n  <pre><code>@include('view.name', ['some' =&gt; 'data'])</code></pre>\n  <p>If you attempt to <code>@include</code> a view which does not exist, Laravel will throw an error. If you would like to include a view that may or may not be present, you should use the <code>@includeIf</code> directive:</p>\n  <pre><code>@includeIf('view.name', ['some' =&gt; 'data'])</code></pre>\n  <p>If you would like to <code>@include</code> a view if a given boolean expression evaluates to <code>true</code>, you may use the <code>@includeWhen</code> directive:</p>\n  <pre><code>@includeWhen($boolean, 'view.name', ['some' =&gt; 'data'])</code></pre>\n  <p>If you would like to <code>@include</code> a view if a given boolean expression evaluates to <code>false</code>, you may use the <code>@includeUnless</code> directive:</p>\n  <pre><code>@includeUnless($boolean, 'view.name', ['some' =&gt; 'data'])</code></pre>\n  <p>To include the first view that exists from a given array of views, you may use the <code>includeFirst</code> directive:</p>\n  <pre><code>@includeFirst(['custom.admin', 'admin'], ['some' =&gt; 'data'])</code></pre>\n  <blockquote>\n    <p> You should avoid using the <code>__DIR__</code> and <code>__FILE__</code> constants in your Blade views, since they will refer to the location of the cached, compiled view.</p>\n  </blockquote>\n  <h4>Aliasing Includes</h4>\n  <p>If your Blade includes are stored in a subdirectory, you may wish to alias them for easier access. For example, imagine a Blade include that is stored at <code>resources/views/includes/input.blade.php</code> with the following content:</p>\n  <pre><code>&lt;input type=\"{{ $type ?? 'text' }}\"&gt;</code></pre>\n  <p>You may use the <code>include</code> method to alias the include from <code>includes.input</code> to <code>input</code>. Typically, this should be done in the <code>boot</code> method of your <code>AppServiceProvider</code>:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Blade;\n\nBlade::include('includes.input', 'input');</code></pre>\n  <p>Once the include has been aliased, you may render it using the alias name as the Blade directive:</p>\n  <pre><code>@input(['type' =&gt; 'email'])</code></pre>\n  <p></p>\n  <h3>Rendering Views For Collections</h3>\n  <p>You may combine loops and includes into one line with Blade's <code>@each</code> directive:</p>\n  <pre><code>@each('view.name', $jobs, 'job')</code></pre>\n  <p>The first argument is the view partial to render for each element in the array or collection. The second argument is the array or collection you wish to iterate over, while the third argument is the variable name that will be assigned to the current iteration within the view. So, for example, if you are iterating over an array of <code>jobs</code>, typically you will want to access each job as a <code>job</code> variable within your view partial. The key for the current iteration will be available as the <code>key</code> variable within your view partial.</p>\n  <p>You may also pass a fourth argument to the <code>@each</code> directive. This argument determines the view that will be rendered if the given array is empty.</p>\n  <pre><code>@each('view.name', $jobs, 'job', 'view.empty')</code></pre>\n  <blockquote>\n    <p>Las vistas representadas mediante <code>@each</code>no heredan las variables de la vista principal. Si la vista secundaria requiere estas variables, debe usar y en su lugar.<code>@foreach</code><code>@include</code></p>\n  </blockquote>\n  <p></p>\n  <h2>Pilas</h2>\n  <p>Blade le permite empujar a pilas con nombre que se pueden representar en otro lugar en otra vista o diseño. Esto puede ser particularmente útil para especificar cualquier biblioteca de JavaScript requerida por sus vistas secundarias:</p>\n  <pre><code>@push('scripts')\n    &lt;script src=\"/example.js\"&gt;&lt;/script&gt;\n@endpush</code></pre>\n  <p>Puede empujar a una pila tantas veces como sea necesario. Para representar el contenido completo de la pila, pase el nombre de la pila a la <code>@stack</code>directiva:</p>\n  <pre><code>&lt;head&gt;\n    &lt;!-- Head Contents --&gt;\n\n    @stack('scripts')\n&lt;/head&gt;</code></pre>\n  <p>Si desea anteponer contenido al comienzo de una pila, debe usar la <code>@prepend</code>directiva:</p>\n  <pre><code>@push('scripts')\n    This will be second...\n@endpush\n\n// Later...\n\n@prepend('scripts')\n    This will be first...\n@endprepend</code></pre>\n  <p></p>\n  <h2>Inyección de servicio</h2>\n  <p>La <code>@inject</code>directiva se puede usar para recuperar un servicio del contenedor de servicios de Laravel . El primer argumento que se pasa <code>@inject</code>es el nombre de la variable en la que se colocará el servicio, mientras que el segundo argumento es el nombre de la clase o interfaz del servicio que desea resolver:</p>\n  <pre><code>@inject('metrics', 'App\\Services\\MetricsService')\n\n&lt;div&gt;\n    Monthly Revenue: {{ $metrics-&gt;monthlyRevenue() }}.\n&lt;/div&gt;</code></pre>\n  <p></p>\n  <h2>Hoja extensible</h2>\n  <p>Blade le permite definir sus propias directivas personalizadas utilizando el <code>directive</code>método. Cuando el compilador Blade encuentra la directiva personalizada, llamará a la devolución de llamada proporcionada con la expresión que contiene la directiva.</p>\n  <p>El siguiente ejemplo crea una directiva que formatea un determinado , que debería ser una instancia de :<code>@datetime($var)</code><code>$var</code><code>DateTime</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\Blade;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Blade::directive('datetime', function ($expression) {\n            return \"&lt;?php echo ($expression)-&gt;format('m/d/Y H:i'); ?&gt;\";\n        });\n    }\n}</code></pre>\n  <p>Como puede ver, encadenaremos el <code>format</code>método a cualquier expresión que se pase a la directiva. Entonces, en este ejemplo, el PHP final generado por esta directiva será:</p>\n  <pre><code>&lt;?php echo ($var)-&gt;format('m/d/Y H:i'); ?&gt;</code></pre>\n  <blockquote>\n    <p>Después de actualizar la lógica de una directiva Blade, deberá eliminar todas las vistas Blade almacenadas en caché. Las vistas de Blade almacenadas en caché se pueden eliminar mediante el comando Artisan.<code>view:clear</code></p>\n  </blockquote>\n  <p></p>\n  <h3>Declaraciones If personalizadas</h3>\n  <p>La programación de una directiva personalizada es a veces más compleja de lo necesario al definir declaraciones condicionales personalizadas simples. Por esa razón, Blade proporciona un método que le permite definir rápidamente directivas condicionales personalizadas utilizando Closures. Por ejemplo, definamos un condicional personalizado que verifique el proveedor de la nube de aplicaciones actual. Podemos hacer esto en el método de nuestro :<code>Blade::if</code><code>boot</code><code>AppServiceProvider</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Blade;\n\n/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    Blade::if('cloud', function ($provider) {\n        return config('filesystems.default') === $provider;\n    });\n}</code></pre>\n  <p>Una vez que se ha definido el condicional personalizado, podemos usarlo fácilmente en nuestras plantillas:</p>\n  <pre><code>@cloud('digitalocean')\n    // The application is using the digitalocean cloud provider...\n@elsecloud('aws')\n    // The application is using the aws provider...\n@else\n    // The application is not using the digitalocean or aws environment...\n@endcloud\n\n@unlesscloud('aws')\n    // The application is not using the aws environment...\n@endcloud</code></pre>\n</section>"
      },
      {
        "titulo": "4.2 Localización",
        "contenido": "<section>\n  <h1>Localización</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Configuración de la configuración regional</li>\n      </ul></li>\n    <li>Definición de cadenas de traducción\n      <ul>\n        <li>Uso de teclas cortas</li>\n        <li>Usar cadenas de traducción como claves</li>\n      </ul></li>\n    <li>Recuperando cadenas de traducción\n      <ul>\n        <li>Reemplazo de parámetros en cadenas de traducción</li>\n        <li>Pluralización</li>\n      </ul></li>\n    <li>Anulación de archivos de idioma del paquete</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Las funciones de localización de Laravel brindan una forma conveniente de recuperar cadenas en varios idiomas, lo que le permite admitir fácilmente varios idiomas dentro de su aplicación. Las cadenas de idioma se almacenan en archivos dentro del directorio. Dentro de este directorio debe haber un subdirectorio para cada idioma admitido por la aplicación:<code>resources/lang</code></p>\n  <pre><code>/resources\n    /lang\n        /en\n            messages.php\n        /es\n            messages.php</code></pre>\n  <p>Todos los archivos de idioma devuelven una matriz de cadenas con clave. Por ejemplo:</p>\n  <pre><code>&lt;?php\n\nreturn [\n    'welcome' =&gt; 'Welcome to our application',\n];</code></pre>\n  <blockquote>\n    <p> Para los idiomas que difieren según el territorio, debe nombrar los directorios de idiomas de acuerdo con la norma ISO 15897. Por ejemplo, \"en_GB\" debe usarse para inglés británico en lugar de \"en-gb\".</p>\n  </blockquote>\n  <p></p>\n  <h3>Configuración de la configuración regional</h3>\n  <p>El idioma predeterminado para su aplicación se almacena en el archivo de configuración. Puede modificar este valor para adaptarlo a las necesidades de su aplicación. También puede cambiar el idioma activo en tiempo de ejecución usando el método en la fachada:<code>config/app.php</code><code>setLocale</code><code>App</code></p>\n  <pre><code>Route::get('welcome/{locale}', function ($locale) {\n    if (! in_array($locale, ['en', 'es', 'fr'])) {\n        abort(400);\n    }\n\n    App::setLocale($locale);\n\n    //\n});</code></pre>\n  <p>Puede configurar un \"idioma alternativo\", que se utilizará cuando el idioma activo no contenga una cadena de traducción determinada. Al igual que el idioma predeterminado, el idioma de reserva también se configura en el archivo de configuración:<code>config/app.php</code></p>\n  <pre><code>'fallback_locale' =&gt; 'en',</code></pre>\n  <h4>Determinar la configuración regional actual</h4>\n  <p>Puede usar los métodos <code>getLocale</code>y <code>isLocale</code>en la <code>App</code>fachada para determinar la configuración regional actual o verificar si la configuración regional es un valor dado:</p>\n  <pre><code>$locale = App::getLocale();\n\nif (App::isLocale('en')) {\n    //\n}</code></pre>\n  <p></p>\n  <h2>Definición de cadenas de traducción</h2>\n  <p></p>\n  <h3>Uso de teclas cortas</h3>\n  <p>Normalmente, las cadenas de traducción se almacenan en archivos dentro del directorio. Dentro de este directorio debe haber un subdirectorio para cada idioma admitido por la aplicación:<code>resources/lang</code></p>\n  <pre><code>/resources\n    /lang\n        /en\n            messages.php\n        /es\n            messages.php</code></pre>\n  <p>Todos los archivos de idioma devuelven una matriz de cadenas con clave. Por ejemplo:</p>\n  <pre><code>&lt;?php\n\n// resources/lang/en/messages.php\n\nreturn [\n    'welcome' =&gt; 'Welcome to our application',\n];</code></pre>\n  <p></p>\n  <h3>Usar cadenas de traducción como claves</h3>\n  <p>Para aplicaciones con grandes requisitos de traducción, definir cada cadena con una \"clave corta\" puede resultar rápidamente confuso al hacer referencia a ellas en sus vistas. Por esta razón, Laravel también proporciona soporte para definir cadenas de traducción usando la traducción \"predeterminada\" de la cadena como clave.</p>\n  <p>Los archivos de traducción que utilizan cadenas de traducción como claves se almacenan como archivos JSON en el directorio. Por ejemplo, si su aplicación tiene una traducción al español, debe crear un archivo:<code>resources/lang</code><code>resources/lang/es.json</code></p>\n  <pre><code>{\n    \"I love programming.\": \"Me encanta programar.\"\n}</code></pre>\n  <p></p>\n  <h2>Recuperando cadenas de traducción</h2>\n  <p>Puede recuperar líneas de archivos de idioma utilizando la <code>__</code>función auxiliar. El <code>__</code>método acepta el archivo y la clave de la cadena de traducción como primer argumento. Por ejemplo, recuperemos la <code>welcome</code>cadena de traducción del archivo de idioma:<code>resources/lang/messages.php</code></p>\n  <pre><code>echo __('messages.welcome');\n\necho __('I love programming.');</code></pre>\n  <p>Si está usando el motor de plantillas Blade , puede usar la sintaxis para hacer eco de la cadena de traducción o usar la directiva:<code>{{ }}</code><code>@lang</code></p>\n  <pre><code>{{ __('messages.welcome') }}\n\n@lang('messages.welcome')</code></pre>\n  <p>Si la cadena de traducción especificada no existe, la <code>__</code>función devolverá la clave de la cadena de traducción. Entonces, usando el ejemplo anterior, la <code>__</code>función regresaría si la cadena de traducción no existe.<code>messages.welcome</code></p>\n  <blockquote>\n    <p>La <code>@lang</code>directiva no escapa a ningún resultado. Usted es <strong>totalmente responsable</strong> de escapar de su propia salida al usar esta directiva.</p>\n  </blockquote>\n  <p></p>\n  <h3>Reemplazo de parámetros en cadenas de traducción</h3>\n  <p>Si lo desea, puede definir marcadores de posición en sus cadenas de traducción. Todos los marcadores de posición tienen el prefijo <code>:</code>. Por ejemplo, puede definir un mensaje de bienvenida con un nombre de marcador de posición:</p>\n  <pre><code>'welcome' =&gt; 'Welcome, :name',</code></pre>\n  <p>Para reemplazar los marcadores de posición al recuperar una cadena de traducción, pase una matriz de reemplazos como segundo argumento de la <code>__</code>función:</p>\n  <pre><code>echo __('messages.welcome', ['name' =&gt; 'dayle']);</code></pre>\n  <p>Si su marcador de posición contiene todas las letras mayúsculas, o solo tiene la primera letra en mayúscula, el valor traducido se escribirá en mayúscula en consecuencia:</p>\n  <pre><code>'welcome' =&gt; 'Welcome, :NAME', // Welcome, DAYLE\n'goodbye' =&gt; 'Goodbye, :Name', // Goodbye, Dayle</code></pre>\n  <p></p>\n  <h3>Pluralización</h3>\n  <p>La pluralización es un problema complejo, ya que los diferentes idiomas tienen una variedad de reglas complejas para la pluralización. Al usar un carácter de \"barra vertical\", puede distinguir las formas singular y plural de una cadena:</p>\n  <pre><code>'apples' =&gt; 'There is one apple|There are many apples',</code></pre>\n  <p>Incluso puede crear reglas de pluralización más complejas que especifiquen cadenas de traducción para múltiples rangos de números:</p>\n  <pre><code>'apples' =&gt; '{0} There are none|[1,19] There are some|[20,*] There are many',</code></pre>\n  <p>Después de definir una cadena de traducción que tiene opciones de pluralización, puede usar la <code>trans_choice</code>función para recuperar la línea para un \"recuento\" dado. En este ejemplo, dado que el recuento es mayor que uno, se devuelve la forma plural de la cadena de traducción:</p>\n  <pre><code>echo trans_choice('messages.apples', 10);</code></pre>\n  <p>También puede definir atributos de marcador de posición en cadenas de pluralización. Estos marcadores de posición se pueden reemplazar pasando una matriz como tercer argumento de la <code>trans_choice</code>función:</p>\n  <pre><code>'minutes_ago' =&gt; '{1} :value minute ago|[2,*] :value minutes ago',\n\necho trans_choice('time.minutes_ago', 5, ['value' =&gt; 5]);</code></pre>\n  <p>Si desea mostrar el valor entero que se pasó a la <code>trans_choice</code>función, puede usar el <code>:count</code>marcador de posición:</p>\n  <pre><code>'apples' =&gt; '{0} There are none|{1} There is one|[2,*] There are :count',</code></pre>\n  <p></p>\n  <h2>Anulación de archivos de idioma del paquete</h2>\n  <p>Algunos paquetes pueden enviarse con sus propios archivos de idioma. En lugar de cambiar los archivos principales del paquete para modificar estas líneas, puede anularlas colocando archivos en el directorio.<code>resources/lang/vendor/{package}/{locale}</code></p>\n  <p>Así, por ejemplo, si usted necesita para anular las cadenas de traducción Inglés en un paquete llamado , debe colocar un archivo de idioma en: . Dentro de este archivo, solo debe definir las cadenas de traducción que desea anular. Cualquier cadena de traducción que no anule se cargará desde los archivos de idioma original del paquete.<code>messages.php</code><code>skyrim/hearthfire</code><code>resources/lang/vendor/hearthfire/en/messages.php</code></p>\n</section>"
      },
      {
        "titulo": "4.3 Compilación de activos",
        "contenido": "<section>\n  <h1>Compilación de activos (mezcla)</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Instalación y configuración</li>\n    <li>Mezcla de ejecución</li>\n    <li>Trabajar con hojas de estilo\n      <ul>\n        <li>Menos</li>\n        <li>Hablar con descaro a</li>\n        <li>Aguja</li>\n        <li>PostCSS</li>\n        <li>CSS simple</li>\n        <li>Procesamiento de URL</li>\n        <li>Mapas de origen</li>\n      </ul></li>\n    <li>Trabajando con JavaScript\n      <ul>\n        <li>Extracción de proveedores</li>\n        <li>Reaccionar</li>\n        <li>Vanilla JS</li>\n        <li>Configuración de paquete web personalizado</li>\n      </ul></li>\n    <li>Copiar archivos y directorios</li>\n    <li>Control de versiones / Cache Busting</li>\n    <li>Recarga de Browsersync</li>\n    <li>Variables de entorno</li>\n    <li>Notificaciones</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel Mix proporciona una API fluida para definir los pasos de compilación de Webpack para su aplicación Laravel utilizando varios preprocesadores CSS y JavaScript comunes. A través del encadenamiento de métodos simple, puede definir con fluidez su canalización de activos. Por ejemplo:</p>\n  <pre><code>mix.js('resources/js/app.js', 'public/js')\n    .sass('resources/sass/app.scss', 'public/css');</code></pre>\n  <p>Si alguna vez ha estado confundido y abrumado por comenzar con Webpack y la compilación de activos, le encantará Laravel Mix. Sin embargo, no es necesario que lo utilice mientras desarrolla su aplicación; puede utilizar cualquier herramienta de canalización de activos que desee, o incluso ninguna.</p>\n  <p></p>\n  <h2>Instalación y configuración</h2>\n  <h4>Instalando Node</h4>\n  <p>Antes de activar Mix, primero debe asegurarse de que Node.js y NPM estén instalados en su máquina.</p>\n  <pre><code>node -v\nnpm -v</code></pre>\n  <p>De forma predeterminada, Laravel Homestead incluye todo lo que necesita; sin embargo, si no está usando Vagrant, puede instalar fácilmente la última versión de Node y NPM usando instaladores gráficos simples desde su página de descarga .</p>\n  <h4>Mezcla de Laravel</h4>\n  <p>El único paso restante es instalar Laravel Mix. Dentro de una nueva instalación de Laravel, encontrará un archivo en la raíz de la estructura de su directorio. El archivo predeterminado incluye todo lo que necesita para comenzar. Piense en esto como su archivo, excepto que define dependencias de nodo en lugar de PHP. Puede instalar las dependencias a las que hace referencia ejecutando:<code>package.json</code><code>package.json</code><code>composer.json</code></p>\n  <pre><code>npm install</code></pre>\n  <p></p>\n  <h2>Mezcla de ejecución</h2>\n  <p>Mix es una capa de configuración en la parte superior de Webpack , por lo que para ejecutar sus tareas de Mix solo necesita ejecutar uno de los scripts de NPM que se incluyen con el archivo Laravel predeterminado :<code>package.json</code></p>\n  <pre><code>// Run all Mix tasks...\nnpm run dev\n\n// Run all Mix tasks and minify output...\nnpm run production</code></pre>\n  <h4>Observación de cambios en los activos</h4>\n  <p>El <code>npm run watch</code>comando continuará ejecutándose en su terminal y observará todos los archivos relevantes para ver si hay cambios. Webpack luego recompilará automáticamente sus activos cuando detecte un cambio:</p>\n  <pre><code>npm run watch</code></pre>\n  <p>Puede encontrar que en ciertos entornos Webpack no se actualiza cuando cambian sus archivos. Si este es el caso en su sistema, considere usar el comando:<code>watch-poll</code></p>\n  <pre><code>npm run watch-poll</code></pre>\n  <p></p>\n  <h2>Trabajar con hojas de estilo</h2>\n  <p>El archivo es su punto de entrada para toda la compilación de activos. Piense en ello como una envoltura de configuración ligera alrededor de Webpack. Las tareas mixtas se pueden encadenar para definir exactamente cómo se deben compilar sus activos.<code>webpack.mix.js</code></p>\n  <p></p>\n  <h3>Menos</h3>\n  <p>El <code>less</code>método se puede utilizar para compilar Less en CSS. Compilemos nuestro archivo principal en .<code>app.less</code><code>public/css/app.css</code></p>\n  <pre><code>mix.less('resources/less/app.less', 'public/css');</code></pre>\n  <p>Se <code>less</code>pueden utilizar varias llamadas al método para compilar varios archivos:</p>\n  <pre><code>mix.less('resources/less/app.less', 'public/css')\n    .less('resources/less/admin.less', 'public/css');</code></pre>\n  <p>Si desea personalizar el nombre de archivo del CSS compilado, puede pasar una ruta de archivo completa como segundo argumento del <code>less</code>método:</p>\n  <pre><code>mix.less('resources/less/app.less', 'public/stylesheets/styles.css');</code></pre>\n  <p>Si necesita anular las opciones subyacentes del complemento Less , puede pasar un objeto como tercer argumento a :<code>mix.less()</code></p>\n  <pre><code>mix.less('resources/less/app.less', 'public/css', {\n    strictMath: true\n});</code></pre>\n  <p></p>\n  <h3>Hablar con descaro a</h3>\n  <p>El <code>sass</code>método le permite compilar Sass en CSS. Puedes usar el método así:</p>\n  <pre><code>mix.sass('resources/sass/app.scss', 'public/css');</code></pre>\n  <p>Nuevamente, al igual que el <code>less</code>método, puede compilar varios archivos Sass en sus propios archivos CSS respectivos e incluso personalizar el directorio de salida del CSS resultante:</p>\n  <pre><code>mix.sass('resources/sass/app.sass', 'public/css')\n    .sass('resources/sass/admin.sass', 'public/css/admin');</code></pre>\n  <p>Se pueden proporcionar opciones adicionales del complemento Node-Sass como tercer argumento:</p>\n  <pre><code>mix.sass('resources/sass/app.sass', 'public/css', {\n    precision: 5\n});</code></pre>\n  <p></p>\n  <h3>Aguja</h3>\n  <p>Similar a Less y Sass, el <code>stylus</code>método le permite compilar Stylus en CSS:</p>\n  <pre><code>mix.stylus('resources/stylus/app.styl', 'public/css');</code></pre>\n  <p>También puede instalar complementos adicionales de Stylus, como Rupture . Primero, instale el complemento en cuestión a través de NPM ( <code>npm install rupture</code>) y luego solicítelo en su llamada para :<code>mix.stylus()</code></p>\n  <pre><code>mix.stylus('resources/stylus/app.styl', 'public/css', {\n    use: [\n        require('rupture')()\n    ]\n});</code></pre>\n  <p></p>\n  <h3>PostCSS</h3>\n  <p>PostCSS , una poderosa herramienta para transformar su CSS, se incluye con Laravel Mix listo para usar . De forma predeterminada, Mix aprovecha el popular complemento Autoprefixer para aplicar automáticamente todos los prefijos de proveedores CSS3 necesarios. Sin embargo, puede agregar cualquier complemento adicional que sea apropiado para su aplicación. Primero, instale el complemento deseado a través de NPM y luego haga referencia a él en su archivo:<code>webpack.mix.js</code></p>\n  <pre><code>mix.sass('resources/sass/app.scss', 'public/css')\n    .options({\n        postCss: [\n            require('postcss-css-variables')()\n        ]\n    });</code></pre>\n  <p></p>\n  <h3>CSS simple</h3>\n  <p>Si solo desea concatenar algunas hojas de estilo CSS simples en un solo archivo, puede usar el <code>styles</code>método.</p>\n  <pre><code>mix.styles([\n    'public/css/vendor/normalize.css',\n    'public/css/vendor/videojs.css'\n], 'public/css/all.css');</code></pre>\n  <p></p>\n  <h3>Procesamiento de URL</h3>\n  <p>Debido a que Laravel Mix está construido sobre Webpack, es importante comprender algunos conceptos de Webpack. Para la compilación de CSS, Webpack reescribirá y optimizará cualquier llamada dentro de sus hojas de estilo. Si bien esto inicialmente puede sonar extraño, es una funcionalidad increíblemente poderosa. Imagina que queremos compilar Sass que incluye una URL relativa a una imagen:<code>url()</code></p>\n  <pre><code>.example {\n    background: url('../images/example.png');\n}</code></pre>\n  <blockquote>\n    <p>Las rutas absolutas para cualquier dado se excluirán de la reescritura de URL. Por ejemplo, o no se modificará.<code>url()</code><code>url('/images/thing.png')</code><code>url('http://example.com/images/thing.png')</code></p>\n  </blockquote>\n  <p>De forma predeterminada, Laravel Mix y Webpack lo encontrarán , lo copiarán en su carpeta y luego lo reescribirán dentro de su hoja de estilo generada. Como tal, su CSS compilado será:<code>example.png</code><code>public/images</code><code>url()</code></p>\n  <pre><code>.example {\n    background: url(/images/example.png?d41d8cd98f00b204e9800998ecf8427e);\n}</code></pre>\n  <p>Por muy útil que sea esta función, es posible que su estructura de carpetas existente ya esté configurada de la manera que desee. Si este es el caso, puede deshabilitar la reescritura así:<code>url()</code></p>\n  <pre><code>mix.sass('resources/sass/app.scss', 'public/css')\n    .options({\n        processCssUrls: false\n    });</code></pre>\n  <p>Con esta adición a su archivo, Mix ya no coincidirá ni copiará activos en su directorio público. En otras palabras, el CSS compilado se verá exactamente como lo escribió originalmente:<code>webpack.mix.js</code><code>url()</code></p>\n  <pre><code>.example {\n    background: url(\"../images/thing.png\");\n}</code></pre>\n  <p></p>\n  <h3>Mapas de origen</h3>\n  <p>Aunque están deshabilitados de forma predeterminada, los mapas de origen se pueden activar llamando al método en su archivo. Aunque viene con un costo de compilación / rendimiento, esto proporcionará información de depuración adicional a las herramientas de desarrollo de su navegador cuando utilice activos compilados.<code>mix.sourceMaps()</code><code>webpack.mix.js</code></p>\n  <pre><code>mix.js('resources/js/app.js', 'public/js')\n    .sourceMaps();</code></pre>\n  <h4>Estilo de asignación de fuentes</h4>\n  <p>Webpack ofrece una variedad de estilos de mapeo de fuentes . De forma predeterminada, el estilo de mapeo de origen de Mix está configurado en , lo que proporciona un tiempo de reconstrucción rápido. Si desea cambiar el estilo de mapeo, puede hacerlo usando el método:<code>eval-source-map</code><code>sourceMaps</code></p>\n  <pre><code>let productionSourceMaps = false;\n\nmix.js('resources/js/app.js', 'public/js')\n    .sourceMaps(productionSourceMaps, 'source-map');</code></pre>\n  <p></p>\n  <h2>Trabajando con JavaScript</h2>\n  <p>Mix proporciona varias funciones para ayudarlo a trabajar con sus archivos JavaScript, como compilar ECMAScript 2015, empaquetar módulos, minificar y concatenar archivos JavaScript sin formato. Aún mejor, todo esto funciona a la perfección, sin requerir una onza de configuración personalizada:</p>\n  <pre><code>mix.js('resources/js/app.js', 'public/js');</code></pre>\n  <p>Con esta única línea de código, ahora puede aprovechar:</p>\n  \n    <ul>\n      <li>Sintaxis de ES2015.</li>\n      <li>Módulos</li>\n      <li>Recopilación de <code>.vue</code>archivos.</li>\n      <li>Minificación para entornos de producción.</li>\n    </ul>\n  \n  <p></p>\n  <h3>Extracción de proveedores</h3>\n  <p>Una posible desventaja de agrupar todo el JavaScript específico de la aplicación con las bibliotecas de su proveedor es que dificulta el almacenamiento en caché a largo plazo. Por ejemplo, una sola actualización del código de su aplicación obligará al navegador a volver a descargar todas las bibliotecas de su proveedor, incluso si no han cambiado.</p>\n  <p>Si tiene la intención de realizar actualizaciones frecuentes al JavaScript de su aplicación, debería considerar la posibilidad de extraer todas las bibliotecas de su proveedor en su propio archivo. De esta manera, un cambio en el código de su aplicación no afectará el almacenamiento en caché de su archivo grande . El método de Mix hace que esto sea muy sencillo:<code>vendor.js</code><code>extract</code></p>\n  <pre><code>mix.js('resources/js/app.js', 'public/js')\n    .extract(['vue'])</code></pre>\n  <p>El <code>extract</code>método acepta una matriz de todas las bibliotecas o módulos que desea extraer en un archivo. Usando el fragmento anterior como ejemplo, Mix generará los siguientes archivos:<code>vendor.js</code></p>\n  \n    <ul>\n      <li><code>public/js/manifest.js</code>: <em>El tiempo de ejecución del manifiesto de Webpack</em></li>\n      <li><code>public/js/vendor.js</code>: Las <em>bibliotecas de su proveedor</em></li>\n      <li><code>public/js/app.js</code>: <em>Su código de aplicación</em></li>\n    </ul>\n  \n  <p>Para evitar errores de JavaScript, asegúrese de cargar estos archivos en el orden correcto:</p>\n  <pre><code>&lt;script src=\"/js/manifest.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/js/vendor.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/js/app.js\"&gt;&lt;/script&gt;</code></pre>\n  <p></p>\n  <h3>Reaccionar</h3>\n  <p>Mix puede instalar automáticamente los complementos de Babel necesarios para el soporte de React. Para comenzar, reemplace su llamada con :<code>mix.js()</code><code>mix.react()</code></p>\n  <pre><code>mix.react('resources/js/app.jsx', 'public/js');</code></pre>\n  <p>Detrás de escena, Mix descargará e incluirá el complemento de Babel apropiado .<code>babel-preset-react</code></p>\n  <p></p>\n  <h3>Vanilla JS</h3>\n  <p>De forma similar a combinar hojas de estilo con , también puede combinar y minimizar cualquier cantidad de archivos JavaScript con el método:<code>mix.styles()</code><code>scripts()</code></p>\n  <pre><code>mix.scripts([\n    'public/js/admin.js',\n    'public/js/dashboard.js'\n], 'public/js/all.js');</code></pre>\n  <p>Esta opción es particularmente útil para proyectos heredados en los que no necesita la compilación de Webpack para su JavaScript.</p>\n  <blockquote>\n    <p>Una ligera variación de es . Su firma de método es idéntica a ; sin embargo, el archivo concatenado recibirá la compilación de Babel, que traduce cualquier código de ES2015 a JavaScript vanilla que todos los navegadores entenderán.<code>mix.scripts()</code><code>mix.babel()</code><code>scripts</code></p>\n  </blockquote>\n  <p></p>\n  <h3>Configuración de paquete web personalizado</h3>\n  <p>Detrás de escena, Laravel Mix hace referencia a un archivo preconfigurado para que pueda comenzar a trabajar lo más rápido posible. Ocasionalmente, es posible que deba modificar manualmente este archivo. Es posible que tenga un cargador o complemento especial al que deba hacer referencia, o tal vez prefiera usar Stylus en lugar de Sass. En tales casos, tiene dos opciones:<code>webpack.config.js</code></p>\n  <h4>Fusionar configuración personalizada</h4>\n  <p>Mix proporciona un <code>webpackConfig</code>método útil que le permite fusionar cualquier modificación breve de configuración de Webpack. Esta es una opción particularmente atractiva, ya que no requiere que copie y mantenga su propia copia del archivo. El método acepta un objeto, que debe contener cualquier configuración específica de Webpack que desee aplicar.<code>webpack.config.js</code><code>webpackConfig</code></p>\n  <pre><code>mix.webpackConfig({\n    resolve: {\n        modules: [\n            path.resolve(__dirname, 'vendor/laravel/spark/resources/assets/js')\n        ]\n    }\n});</code></pre>\n  <h4>Archivos de configuración personalizados</h4>\n  <p>Si desea personalizar completamente la configuración de su paquete web, copie el archivo en el directorio raíz de su proyecto. A continuación, apunte todas las referencias en su archivo al archivo de configuración recién copiado. Si elige adoptar este enfoque de personalización, cualquier actualización ascendente futura de Mix debe fusionarse manualmente en su archivo personalizado.<code>node_modules/laravel-mix/setup/webpack.config.js</code><code>--config</code><code>package.json</code><code>webpack.config.js</code></p>\n  <p></p>\n  <h2>Copiar archivos y directorios</h2>\n  <p>El <code>copy</code>método se puede utilizar para copiar archivos y directorios a nuevas ubicaciones. Esto puede ser útil cuando un activo particular dentro de su <code>node_modules</code>directorio necesita ser reubicado en su <code>public</code>carpeta.</p>\n  <pre><code>mix.copy('node_modules/foo/bar.css', 'public/css/bar.css');</code></pre>\n  <p>Al copiar un directorio, el <code>copy</code>método aplanará la estructura del directorio. Para mantener la estructura original del directorio, debe usar el <code>copyDirectory</code>método en su lugar:</p>\n  <pre><code>mix.copyDirectory('resources/img', 'public/img');</code></pre>\n  <p></p>\n  <h2>Control de versiones / Cache Busting</h2>\n  <p>Muchos desarrolladores agregan un sufijo a sus activos compilados con una marca de tiempo o un token único para obligar a los navegadores a cargar los activos nuevos en lugar de entregar copias obsoletas del código. Mix puede manejar esto por ti usando el <code>version</code>método.</p>\n  <p>El <code>version</code>método agregará automáticamente un hash único a los nombres de archivo de todos los archivos compilados, lo que permite un almacenamiento de caché más conveniente:</p>\n  <pre><code>mix.js('resources/js/app.js', 'public/js')\n    .version();</code></pre>\n  <p>Después de generar el archivo versionado, no sabrá el nombre exacto del archivo. Por lo tanto, debe usar la <code>mix</code>función global de Laravel dentro de sus vistas para cargar el activo con hash apropiado. La <code>mix</code>función determinará automáticamente el nombre actual del archivo hash:</p>\n  <pre><code>&lt;script src=\"{{ mix('/js/app.js') }}\"&gt;&lt;/script&gt;</code></pre>\n  <p>Debido a que los archivos versionados generalmente no son necesarios en el desarrollo, puede indicarle al proceso de versionado que solo se ejecute durante <code>npm run production</code>:</p>\n  <pre><code>mix.js('resources/js/app.js', 'public/js');\n\nif (mix.inProduction()) {\n    mix.version();\n}</code></pre>\n  <h4>URL base de mezcla personalizada</h4>\n  <p>Si sus activos compilados de Mix se implementan en una CDN separada de su aplicación, deberá cambiar la URL base generada por la <code>mix</code>función. Puede hacerlo agregando una <code>mix_url</code>opción de configuración a su archivo de configuración:<code>config/app.php</code></p>\n  <pre><code>'mix_url' =&gt; env('MIX_ASSET_URL', null)</code></pre>\n  <p>Después de configurar la URL mixta, la <code>mix</code>función agregará un prefijo a la URL configurada al generar URL para activos:</p>\n  <pre><code>https://cdn.example.com/js/app.js?id=1964becbdd96414518cd</code></pre>\n  <p></p>\n  <h2>Recarga de Browsersync</h2>\n  <p>BrowserSync puede monitorear automáticamente sus archivos en busca de cambios e inyectar sus cambios en el navegador sin requerir una actualización manual. Puede habilitar el soporte llamando al método:<code>mix.browserSync()</code></p>\n  <pre><code>mix.browserSync('my-domain.test');\n\n// Or...\n\n// https://browsersync.io/docs/options\nmix.browserSync({\n    proxy: 'my-domain.test'\n});</code></pre>\n  <p>Puede pasar una cadena (proxy) u objeto (configuración de BrowserSync) a este método. A continuación, inicie el servidor de desarrollo de Webpack con el <code>npm run watch</code>comando. Ahora, cuando modifique un script o un archivo PHP, observe cómo el navegador actualiza instantáneamente la página para reflejar sus cambios.</p>\n  <p></p>\n  <h2>Variables de entorno</h2>\n  <p>Puede inyectar variables de entorno en Mix prefijando una clave en su <code>.env</code>archivo con <code>MIX_</code>:</p>\n  <pre><code>MIX_SENTRY_DSN_PUBLIC=http://example.com</code></pre>\n  <p>Una vez definida la variable en su <code>.env</code>archivo, puede acceder a ella a través del objeto. Si el valor cambia mientras está ejecutando una tarea, deberá reiniciar la tarea:<code>process.env</code><code>watch</code></p>\n  <pre><code>process.env.MIX_SENTRY_DSN_PUBLIC</code></pre>\n  <p></p>\n  <h2>Notificaciones</h2>\n  <p>Cuando esté disponible, Mix mostrará automáticamente las notificaciones del sistema operativo para cada paquete. Esto le dará una retroalimentación instantánea sobre si la compilación fue exitosa o no. Sin embargo, puede haber casos en los que prefiera desactivar estas notificaciones. Un ejemplo podría ser la activación de Mix en su servidor de producción. Las notificaciones se pueden desactivar mediante el <code>disableNotifications</code>método.</p>\n  <pre><code>mix.disableNotifications();</code></pre>\n</section>"
      }
    ]
  },
  {
    "titulo": "Seguridad",
    "subtitulo": "",
    "items": [
      {
        "titulo": "5.1 Autenticación",
        "contenido": "<section>\n  <h1>Autenticación</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Consideraciones de la base de datos</li>\n        <li>Descripción general del ecosistema</li>\n      </ul></li>\n    <li>Inicio rápido de autenticación\n      <ul>\n        <li>Enrutamiento</li>\n        <li>Puntos de vista</li>\n        <li>Autenticando</li>\n        <li>Recuperando el usuario autenticado</li>\n        <li>Protección de rutas</li>\n        <li>Limitación de inicio de sesión</li>\n      </ul></li>\n    <li>Autenticación manual de usuarios\n      <ul>\n        <li>Recordando a los usuarios</li>\n        <li>Otros métodos de autenticación</li>\n      </ul></li>\n    <li>Autenticación básica HTTP\n      <ul>\n        <li>Autenticación básica HTTP sin estado</li>\n      </ul></li>\n    <li>Saliendo de tu cuenta\n      <ul>\n        <li>Invalidación de sesiones en otros dispositivos</li>\n      </ul></li>\n    <li>Confirmación de contraseña\n      <ul>\n        <li>Configuración</li>\n        <li>Enrutamiento</li>\n        <li>Protección de rutas</li>\n      </ul></li>\n    <li>Autenticación social</li>\n    <li>Agregar guardias personalizados\n      <ul>\n        <li>Guardias de solicitud de cierre</li>\n      </ul></li>\n    <li>Agregar proveedores de usuarios personalizados\n      <ul>\n        <li>El contrato de proveedor de usuario</li>\n        <li>El contrato autenticable</li>\n      </ul></li>\n    <li>Eventos</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel hace que implementar la autenticación sea muy simple. De hecho, casi todo está configurado para usted de inmediato. El archivo de configuración de autenticación se encuentra en , que contiene varias opciones bien documentadas para ajustar el comportamiento de los servicios de autenticación.<code>config/auth.php</code></p>\n  <p>En esencia, las instalaciones de autenticación de Laravel están compuestas por \"guardias\" y \"proveedores\". Los guardias definen cómo se autentican los usuarios para cada solicitud. Por ejemplo, Laravel se envía con un <code>session</code>protector que mantiene el estado mediante el almacenamiento de sesiones y cookies.</p>\n  <p>Los proveedores definen cómo se recuperan los usuarios de su almacenamiento persistente. Laravel se envía con soporte para recuperar usuarios usando Eloquent y el generador de consultas de base de datos. Sin embargo, puede definir proveedores adicionales según sea necesario para su aplicación.</p>\n  <p>¡No se preocupe si todo esto suena confuso ahora! Muchas aplicaciones nunca necesitarán modificar la configuración de autenticación predeterminada.</p>\n  <h4>Comenzando Rápido</h4>\n  <p>¿Quieres empezar rápido? Instale Laravel Jetstream en una nueva aplicación Laravel. Después de migrar su base de datos, navegue en su navegador hacia <code>/register</code>o cualquier otra URL asignada a su aplicación. ¡Jetstream se encargará de montar todo su sistema de autenticación!</p>\n  <p></p>\n  <h3>Consideraciones de la base de datos</h3>\n  <p>De forma predeterminada, Laravel incluye un modelo Eloquent en su directorio. Este modelo se puede utilizar con el controlador de autenticación predeterminado de Eloquent. Si su aplicación no usa Eloquent, puede usar el controlador de autenticación que usa el generador de consultas de Laravel.<code>App\\Models\\User</code> <code>app/Models</code><code>database</code></p>\n  <p>Al crear el esquema de la base de datos para el modelo, asegúrese de que la columna de contraseña tenga al menos 60 caracteres de longitud. Mantener la longitud predeterminada de la columna de cadena de 255 caracteres sería una buena opción.<code>App\\Models\\User</code></p>\n  <p>Además, debe verificar que su <code>users</code>tabla (o equivalente) contenga una <code>remember_token</code>columna de cadena que acepta valores NULL de 100 caracteres. Esta columna se utilizará para almacenar un token para los usuarios que seleccionen la opción \"recordarme\" al iniciar sesión en su aplicación.</p>\n  <p></p>\n  <h3>Descripción general del ecosistema</h3>\n  <p>Laravel ofrece varios paquetes relacionados con la autenticación. Antes de continuar, revisaremos el ecosistema de autenticación general en Laravel y discutiremos el propósito de cada paquete.</p>\n  <p>Primero, considere cómo funciona la autenticación. Al utilizar un navegador web, el usuario proporcionará su nombre de usuario y contraseña mediante un formulario de inicio de sesión. Si estas credenciales son correctas, la aplicación almacenará información sobre el usuario autenticado en la sesión del usuario . Una cookie emitida al navegador contiene el ID de sesión para que las solicitudes posteriores a la aplicación puedan asociar al usuario con la sesión correcta. Una vez recibida la cookie de sesión, la aplicación recuperará los datos de la sesión basándose en el ID de la sesión, observará que la información de autenticación se ha almacenado en la sesión y considerará al usuario como \"autenticado\".</p>\n  <p>Cuando un servicio remoto necesita autenticarse para acceder a una API, las cookies no se utilizan normalmente porque no hay un navegador web. En cambio, el servicio remoto envía un token de API a la API en cada solicitud. La aplicación puede validar el token entrante contra una tabla de tokens API válidos y \"autenticar\" la solicitud como realizada por el usuario asociado con ese token API.</p>\n  <h4>Servicios de autenticación de navegador integrados de Laravel</h4>\n  <p>Laravel incluye servicios de sesión y autenticación integrados a los que normalmente se accede a través de las fachadas <code>Auth</code>y <code>Session</code>. Estas características proporcionan autenticación basada en cookies para solicitudes que se inician desde navegadores web. Proporcionan métodos que le permiten verificar las credenciales de un usuario y autenticar al usuario. Además, estos servicios almacenarán automáticamente los datos adecuados en la sesión del usuario y emitirán la cookie de sesión adecuada. En esta documentación se incluye una explicación de cómo utilizar estos servicios.</p>\n  <p><strong>Jetstream / Fortificar</strong></p>\n  <p>Como se explica en esta documentación, puede interactuar con estos servicios de autenticación manualmente para crear la capa de autenticación propia de su aplicación. Sin embargo, para ayudarlo a comenzar más rápidamente, hemos lanzado paquetes gratuitos que brindan una estructura sólida y moderna de toda la capa de autenticación. Estos paquetes son Laravel Jetstream y Laravel Fortify .</p>\n  <p>Laravel Fortify es un backend de autenticación sin cabeza para Laravel que implementa muchas de las características que se encuentran en esta documentación, incluida la autenticación basada en cookies, así como otras características como la autenticación de dos factores y la verificación del correo electrónico. Laravel Jetstream es una interfaz de usuario que consume y expone los servicios de autenticación de Fortify con una hermosa y moderna interfaz de usuario con tecnología Tailwind CSS , Laravel Livewire y / o Inertia.js . Laravel Jetstream, además de ofrecer autenticación de cookies basada en navegador, incluye integración incorporada con Laravel Sanctum para ofrecer autenticación de token API. Las ofertas de autenticación de API de Laravel se analizan a continuación.</p>\n  <h4>Servicios de autenticación de API de Laravel</h4>\n  <p>Laravel proporciona dos paquetes opcionales para ayudarlo a administrar tokens API y autenticar solicitudes realizadas con tokens API: Passport y Sanctum . Tenga en cuenta que estas bibliotecas y las bibliotecas de autenticación basadas en cookies integradas de Laravel no son mutuamente excluyentes. Estas bibliotecas se centran principalmente en la autenticación de token de API, mientras que los servicios de autenticación integrados se centran en la autenticación del navegador basada en cookies. Muchas aplicaciones utilizarán los servicios de autenticación basados \u200B\u200Ben cookies incorporados de Laravel y uno de los paquetes de autenticación API de Laravel.</p>\n  <p><strong>Pasaporte</strong></p>\n  <p>Passport es un proveedor de autenticación OAuth2 que ofrece una variedad de \"tipos de concesión\" de OAuth2 que le permiten emitir varios tipos de tokens. En general, este es un paquete robusto y complejo para la autenticación de API. Sin embargo, la mayoría de las aplicaciones no requieren las funciones complejas que ofrece la especificación OAuth2, lo que puede resultar confuso tanto para los usuarios como para los desarrolladores. Además, los desarrolladores han estado históricamente confundidos acerca de cómo autenticar aplicaciones SPA o aplicaciones móviles utilizando proveedores de autenticación OAuth2 como Passport.</p>\n  <p><strong>Santuario</strong></p>\n  <p>En respuesta a la complejidad de OAuth2 y la confusión del desarrollador, nos propusimos crear un paquete de autenticación más simple y optimizado que pudiera manejar tanto las solicitudes web de origen desde un navegador web como las solicitudes de API a través de tokens. Este objetivo se logró con el lanzamiento de Laravel Sanctum , que debe considerarse el paquete de autenticación preferido y recomendado para aplicaciones que ofrecerán una interfaz de usuario web propia además de una API, o que estarán impulsadas por una aplicación de una sola página que existe por separado de la aplicación Laravel backend, o aplicaciones que ofrecen un cliente móvil.</p>\n  <p>Laravel Sanctum es un paquete de autenticación web / API híbrido que puede administrar todo el proceso de autenticación de su aplicación. Esto es posible porque cuando las aplicaciones basadas en Sanctum reciben una solicitud, Sanctum primero determinará si la solicitud incluye una cookie de sesión que hace referencia a una sesión autenticada. Sanctum logra esto llamando a los servicios de autenticación integrados de Laravel que discutimos anteriormente. Si la solicitud no se está autenticando a través de una cookie de sesión, Sanctum inspeccionará la solicitud de un token de API. Si hay un token de API, Sanctum autenticará la solicitud utilizando ese token. Para obtener más información sobre este proceso, consulte la documentación de \"cómo funciona\" de Sanctum .</p>\n  <p>Laravel Sanctum es el paquete de API que hemos elegido incluir con el andamio de autenticación de Laravel Jetstream porque creemos que es el que mejor se adapta a la mayoría de las necesidades de autenticación de aplicaciones web.</p>\n  <h4>Resumen y elección de su pila</h4>\n  <p>En resumen, si se accederá a su aplicación utilizando un navegador, su aplicación utilizará los servicios de autenticación integrados de Laravel.</p>\n  <p>A continuación, si su aplicación ofrece una API, elegirá entre Passport o Sanctum para proporcionar autenticación de token API para su aplicación. En general, se debe preferir Sanctum cuando sea posible, ya que es una solución simple y completa para la autenticación de API, autenticación de SPA y autenticación móvil, que incluye soporte para \"alcances\" o \"habilidades\".</p>\n  <p>Se puede elegir Passport cuando su aplicación necesita absolutamente todas las características proporcionadas por la especificación OAuth2.</p>\n  <p>Y, si desea comenzar rápidamente, nos complace recomendar Laravel Jetstream como una forma rápida de iniciar una nueva aplicación Laravel que ya utiliza nuestra pila de autenticación preferida de los servicios de autenticación integrados de Laravel y Laravel Sanctum.</p>\n  <p></p>\n  <h2>Inicio rápido de autenticación</h2>\n  <blockquote>\n    <p>Esta parte de la documentación analiza la autenticación de usuarios a través del paquete Laravel Jetstream , que incluye andamios de interfaz de usuario para ayudarlo a comenzar rápidamente. Si desea integrarse directamente con los sistemas de autenticación de Laravel, consulte la documentación sobre cómo autenticar usuarios manualmente .</p>\n  </blockquote>\n  <p></p>\n  <h3>Enrutamiento</h3>\n  <p>El paquete de Laravel proporciona una forma rápida de estructurar todas las rutas, vistas y otra lógica de backend necesaria para la autenticación mediante unos pocos comandos simples:<code>laravel/jetstream</code></p>\n  <pre><code>composer require laravel/jetstream\n\n// Install Jetstream with the Livewire stack...\nphp artisan jetstream:install livewire\n\n// Install Jetstream with the Inertia stack...\nphp artisan jetstream:install inertia</code></pre>\n  <p>Este comando debe usarse en aplicaciones nuevas e instalará una vista de diseño, vistas de registro e inicio de sesión, así como rutas para todos los puntos finales de autenticación. <code>/dashboard</code>También se generará una ruta para manejar las solicitudes posteriores al inicio de sesión en el panel de su aplicación.</p>\n  <h4>Creación de aplicaciones, incluida la autenticación</h4>\n  <p>Si está iniciando una nueva aplicación y le gustaría incluir el andamio de autenticación, puede usar la <code>--jet</code>directiva al crear su aplicación a través del instalador de Laravel. Este comando creará una nueva aplicación con todos los andamios de autenticación compilados e instalados:</p>\n  <pre><code>laravel new kitetail --jet</code></pre>\n  <blockquote>\n    <p>Para obtener más información sobre Jetstream, visite la documentación oficial de Jetstream .</p>\n  </blockquote>\n  <p></p>\n  <h3>Puntos de vista</h3>\n  <p>Como se mencionó en la sección anterior, el comando del paquete creará todas las vistas que necesita para la autenticación y las colocará en el directorio.<code>laravel/jetstream</code><code>php artisan jetstream:install</code><code>resources/views/auth</code></p>\n  <p>Jetstream también creará un directorio que contiene un diseño base para su aplicación. Todas estas vistas utilizan el marco Tailwind CSS , pero puede personalizarlas como desee.<code>resources/views/layouts</code></p>\n  <p></p>\n  <h3>Autenticando</h3>\n  <p>Ahora que su aplicación ha sido modificada para la autenticación, ¡está listo para registrarse y autenticarse! Simplemente puede acceder a su aplicación en un navegador, ya que los controladores de autenticación de Jetstream ya contienen la lógica para autenticar a los usuarios existentes y almacenar nuevos usuarios en la base de datos.</p>\n  <h4>Personalización de ruta</h4>\n  <p>Cuando un usuario se autentica con éxito, normalmente será redirigido al <code>/home</code>URI. Puede personalizar la ruta de redireccionamiento posterior a la autenticación utilizando la <code>HOME</code>constante definida en su <code>RouteServiceProvider</code>:</p>\n  <pre><code>public const HOME = '/home';</code></pre>\n  <p>Al usar Laravel Jetstream, el proceso de instalación de Jetstream cambiará el valor de la <code>HOME</code>constante a <code>/dashboard</code>.</p>\n  <p></p>\n  <h3>Recuperando el usuario autenticado</h3>\n  <p>Mientras maneja una solicitud entrante, puede acceder al usuario autenticado a través de la <code>Auth</code>fachada:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Auth;\n\n// Get the currently authenticated user...\n$user = Auth::user();\n\n// Get the currently authenticated user's ID...\n$id = Auth::id();</code></pre>\n  <p>Alternativamente, una vez que un usuario está autenticado, puede acceder al usuario autenticado a través de una instancia. Recuerde, las clases con sugerencias de tipo se inyectarán automáticamente en los métodos de su controlador. Al escribir una sugerencia del objeto, puede obtener un acceso conveniente al usuario autenticado desde cualquier método de controlador en su aplicación:<code>Illuminate\\Http\\Request</code><code>Illuminate\\Http\\Request</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass FlightController extends Controller\n{\n    /**\n     * Get a list of all available flights.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function update(Request $request)\n    {\n        // $request-&gt;user() returns an instance of the authenticated user...\n    }\n}</code></pre>\n  <h4>Determinar si el usuario actual está autenticado</h4>\n  <p>Para determinar si el usuario ya inició sesión en su aplicación, puede usar el <code>check</code>método en la <code>Auth</code>fachada, que regresará <code>true</code>si el usuario está autenticado:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Auth;\n\nif (Auth::check()) {\n    // The user is logged in...\n}</code></pre>\n  <blockquote>\n    <p>Aunque es posible determinar si un usuario está autenticado mediante el <code>check</code>método, normalmente utilizará un middleware para verificar que el usuario esté autenticado antes de permitirle el acceso a determinadas rutas / controladores. Para obtener más información sobre esto, consulte la documentación sobre la protección de rutas .</p>\n  </blockquote>\n  <p></p>\n  <h3>Protección de rutas</h3>\n  <p>El middleware de ruta se puede utilizar para permitir que solo los usuarios autenticados accedan a una ruta determinada. Laravel se envía con un <code>auth</code>middleware, que hace referencia a la clase. Dado que este middleware ya está registrado en su kernel HTTP, todo lo que necesita hacer es adjuntar el middleware a una definición de ruta:<code>Illuminate\\Auth\\Middleware\\Authenticate</code></p>\n  <pre><code>Route::get('flights', function () {\n    // Only authenticated users may enter...\n})-&gt;middleware('auth');</code></pre>\n  <h4>Redirigir usuarios no autenticados</h4>\n  <p>When the <code>auth</code> middleware detects an unauthorized user, it will redirect the user to the <code>login</code> named route. You may modify this behavior by updating the <code>redirectTo</code> function in your <code>app/Http/Middleware/Authenticate.php</code> file:</p>\n  <pre><code>/**\n * Get the path the user should be redirected to.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @return string\n */\nprotected function redirectTo($request)\n{\n    return route('login');\n}</code></pre>\n  <h4>Specifying A Guard</h4>\n  <p>When attaching the <code>auth</code> middleware to a route, you may also specify which guard should be used to authenticate the user. The guard specified should correspond to one of the keys in the <code>guards</code> array of your <code>auth.php</code> configuration file:</p>\n  <pre><code>Route::get('flights', function () {\n    // Only authenticated users may enter...\n})-&gt;middleware('auth:api');</code></pre>\n  <p></p>\n  <h3>Login Throttling</h3>\n  <p>If you are using Laravel Jetstream, rate limiting will automatically be applied to login attempts. By default, the user will not be able to login for one minute if they fail to provide the correct credentials after several attempts. The throttling is unique to the user's username / e-mail address and their IP address.</p>\n  <blockquote>\n    <p>Si desea limitar la tarifa de sus propias rutas, consulte la documentación de limitación de tarifa .</p>\n  </blockquote>\n  <p></p>\n  <h2>Autenticación manual de usuarios</h2>\n  <p>No es necesario que utilice el andamio de autenticación incluido con Laravel Jetstream. Si elige no usar este andamio, deberá administrar la autenticación de usuario utilizando las clases de autenticación de Laravel directamente. No se preocupe, ¡es pan comido!</p>\n  <p>Accederemos a los servicios de autenticación de Laravel a través de la <code>Auth</code> fachada , por lo que tendremos que asegurarnos de importar la <code>Auth</code>fachada en la parte superior de la clase. A continuación, veamos el <code>attempt</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass LoginController extends Controller\n{\n    /**\n     * Handle an authentication attempt.\n     *\n     * @param  \\Illuminate\\Http\\Request $request\n     *\n     * @return Response\n     */\n    public function authenticate(Request $request)\n    {\n        $credentials = $request-&gt;only('email', 'password');\n\n        if (Auth::attempt($credentials)) {\n            // Authentication passed...\n            return redirect()-&gt;intended('dashboard');\n        }\n    }\n}</code></pre>\n  <p>El <code>attempt</code>método acepta una matriz de pares clave / valor como primer argumento. Los valores de la matriz se utilizarán para encontrar al usuario en la tabla de su base de datos. Entonces, en el ejemplo anterior, el usuario será recuperado por el valor de la <code>email</code>columna. Si se encuentra al usuario, la contraseña hash almacenada en la base de datos se comparará con el <code>password</code>valor pasado al método a través de la matriz. No debe aplicar un hash a la contraseña especificada como <code>password</code>valor, ya que el marco automáticamente hará un hash del valor antes de compararlo con la contraseña con hash en la base de datos. Si las dos contraseñas con hash coinciden, se iniciará una sesión autenticada para el usuario.</p>\n  <p>El <code>attempt</code>método regresará <code>true</code>si la autenticación fue exitosa. De lo contrario, <code>false</code>será devuelto.</p>\n  <p>The <code>intended</code> method on the redirector will redirect the user to the URL they were attempting to access before being intercepted by the authentication middleware. A fallback URI may be given to this method in case the intended destination is not available.</p>\n  <h4>Specifying Additional Conditions</h4>\n  <p>If you wish, you may also add extra conditions to the authentication query in addition to the user's e-mail and password. For example, we may verify that user is marked as \"active\":</p>\n  <pre><code>if (Auth::attempt(['email' =&gt; $email, 'password' =&gt; $password, 'active' =&gt; 1])) {\n    // The user is active, not suspended, and exists.\n}</code></pre>\n  <blockquote>\n    <p> In these examples, <code>email</code> is not a required option, it is merely used as an example. You should use whatever column name corresponds to a \"username\" in your database.</p>\n  </blockquote>\n  <h4>Accessing Specific Guard Instances</h4>\n  <p>Puede especificar qué instancia de guardia le gustaría utilizar utilizando el <code>guard</code>método en la <code>Auth</code>fachada. Esto le permite administrar la autenticación para partes separadas de su aplicación utilizando modelos o tablas de usuarios autenticables completamente separados.</p>\n  <p>El nombre de guardia pasado al <code>guard</code>método debe corresponder a uno de los guardias configurados en su archivo de configuración:<code>auth.php</code></p>\n  <pre><code>if (Auth::guard('admin')-&gt;attempt($credentials)) {\n    //\n}</code></pre>\n  <h4>Saliendo de tu cuenta</h4>\n  <p>Para desconectar a los usuarios de su aplicación, puede utilizar el <code>logout</code>método en la <code>Auth</code>fachada. Esto borrará la información de autenticación en la sesión del usuario:</p>\n  <pre><code>Auth::logout();</code></pre>\n  <p></p>\n  <h3>Recordando a los usuarios</h3>\n  <p>Si desea proporcionar la funcionalidad \"recordarme\" en su aplicación, puede pasar un valor booleano como segundo argumento del <code>attempt</code>método, lo que mantendrá al usuario autenticado indefinidamente o hasta que cierre la sesión manualmente. Su <code>users</code>tabla debe incluir la <code>remember_token</code>columna de cadena , que se utilizará para almacenar el token \"recordarme\".</p>\n  <pre><code>if (Auth::attempt(['email' =&gt; $email, 'password' =&gt; $password], $remember)) {\n    // The user is being remembered...\n}</code></pre>\n  <p>Si está \"recordando\" usuarios, puede utilizar el <code>viaRemember</code>método para determinar si el usuario fue autenticado mediante la cookie \"recordarme\":</p>\n  <pre><code>if (Auth::viaRemember()) {\n    //\n}</code></pre>\n  <p></p>\n  <h3>Otros métodos de autenticación</h3>\n  <h4>Autenticar una instancia de usuario</h4>\n  <p>Si necesita registrar una instancia de usuario existente en su aplicación, puede llamar al <code>login</code>método con la instancia de usuario. El objeto dado debe ser una implementación del contrato . El modelo incluido con Laravel ya implementa esta interfaz. Este método de autenticación es útil cuando ya tiene una instancia de usuario válida, como directamente después de que un usuario se registra en su aplicación:<code>Illuminate\\Contracts\\Auth\\Authenticatable</code> <code>App\\Models\\User</code></p>\n  <pre><code>Auth::login($user);\n\n// Login and \"remember\" the given user...\nAuth::login($user, true);</code></pre>\n  <p>Puede especificar la instancia de guardia que le gustaría usar:</p>\n  <pre><code>Auth::guard('admin')-&gt;login($user);</code></pre>\n  <h4>Autenticar un usuario por ID</h4>\n  <p>Para iniciar la sesión de un usuario en la aplicación por su ID, puede utilizar el <code>loginUsingId</code>método. Este método acepta la clave principal del usuario que desea autenticar:</p>\n  <pre><code>Auth::loginUsingId(1);\n\n// Login and \"remember\" the given user...\nAuth::loginUsingId(1, true);</code></pre>\n  <h4>Autenticar un usuario una vez</h4>\n  <p>Puede utilizar el <code>once</code>método para iniciar la sesión de un usuario en la aplicación para una sola solicitud. No se utilizarán sesiones ni cookies, lo que significa que este método puede ser útil al crear una API sin estado:</p>\n  <pre><code>if (Auth::once($credentials)) {\n    //\n}</code></pre>\n  <p></p>\n  <h2>Autenticación básica HTTP</h2>\n  <p>La autenticación básica HTTP proporciona una forma rápida de autenticar a los usuarios de su aplicación sin configurar una página de \"inicio de sesión\" dedicada. Para comenzar, adjunte el middleware a su ruta. El middleware está incluido con el marco de Laravel, por lo que no es necesario definirlo:<code>auth.basic</code> <code>auth.basic</code></p>\n  <pre><code>Route::get('profile', function () {\n    // Only authenticated users may enter...\n})-&gt;middleware('auth.basic');</code></pre>\n  <p>Una vez que el middleware se haya adjuntado a la ruta, se le solicitarán automáticamente las credenciales cuando acceda a la ruta en su navegador. De forma predeterminada, el middleware utilizará la columna del registro de usuario como \"nombre de usuario\".<code>auth.basic</code><code>email</code></p>\n  <h4>Una nota sobre FastCGI</h4>\n  <p>Si está utilizando PHP FastCGI, es posible que la autenticación HTTP básica no funcione correctamente desde el primer momento. Las siguientes líneas deben agregarse a su <code>.htaccess</code>archivo:</p>\n  <pre><code>RewriteCond %{HTTP:Authorization} ^(.+)$\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]</code></pre>\n  <p></p>\n  <h3>Autenticación básica HTTP sin estado</h3>\n  <p>También puede utilizar la autenticación básica HTTP sin configurar una cookie de identificación de usuario en la sesión, lo que es particularmente útil para la autenticación API. Para hacerlo, defina un middleware que llame al <code>onceBasic</code>método. Si el <code>onceBasic</code>método no devuelve ninguna respuesta , la solicitud puede pasarse a la aplicación:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass AuthenticateOnceWithBasicAuth\n{\n    /**\n     * Handle an incoming request.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Closure  $next\n     * @return mixed\n     */\n    public function handle($request, $next)\n    {\n        return Auth::onceBasic() ?: $next($request);\n    }\n\n}</code></pre>\n  <p>A continuación, registre el middleware de ruta y adjúntelo a una ruta:</p>\n  <pre><code>Route::get('api/user', function () {\n    // Only authenticated users may enter...\n})-&gt;middleware('auth.basic.once');</code></pre>\n  <p></p>\n  <h2>Saliendo de tu cuenta</h2>\n  <p>To manually log users out of your application, you may use the <code>logout</code> method on the <code>Auth</code> facade. This will clear the authentication information in the user's session:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Auth;\n\nAuth::logout();</code></pre>\n  <p></p>\n  <h3>Invalidating Sessions On Other Devices</h3>\n  <p>Laravel also provides a mechanism for invalidating and \"logging out\" a user's sessions that are active on other devices without invalidating the session on their current device. This feature is typically utilized when a user is changing or updating their password and you would like to invalidate sessions on other devices while keeping the current device authenticated.</p>\n  <p>Before getting started, you should make sure that the <code>Illuminate\\Session\\Middleware\\AuthenticateSession</code> middleware is present and un-commented in your <code>app/Http/Kernel.php</code> class' <code>web</code> middleware group:</p>\n  <pre><code>'web' =&gt; [\n    // ...\n    \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,\n    // ...\n],</code></pre>\n  <p>Luego, puede usar el <code>logoutOtherDevices</code>método en la <code>Auth</code>fachada. Este método requiere que el usuario proporcione su contraseña actual, que su aplicación debe aceptar a través de un formulario de entrada:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Auth;\n\nAuth::logoutOtherDevices($password);</code></pre>\n  <p>Cuando <code>logoutOtherDevices</code>se invoca el método, las otras sesiones del usuario se invalidarán por completo, lo que significa que se \"cerrarán la sesión\" de todos los guardias por los que fueron previamente autenticados.</p>\n  <blockquote>\n    <p>Cuando utilice el <code>AuthenticateSession</code>middleware en combinación con un nombre de ruta personalizado para la <code>login</code>ruta, debe anular el <code>unauthenticated</code>método en el controlador de excepciones de su aplicación para redirigir correctamente a los usuarios a su página de inicio de sesión.</p>\n  </blockquote>\n  <p></p>\n  <h2>Confirmación de contraseña</h2>\n  <p>Mientras crea su aplicación, es posible que ocasionalmente tenga acciones que requieran que el usuario confirme su contraseña antes de realizar la acción. Laravel incluye middleware integrado para facilitar este proceso. La implementación de esta función requerirá que defina dos rutas: una ruta para mostrar una vista que le pide al usuario que confirme su contraseña y una ruta para confirmar que la contraseña es válida y redirigir al usuario a su destino previsto.</p>\n  <blockquote>\n    <p>La siguiente documentación analiza cómo integrarse directamente con las funciones de confirmación de contraseña de Laravel; sin embargo, si desea comenzar más rápidamente, el paquete de andamios de autenticación de Laravel Jetstream incluye soporte para esta función.</p>\n  </blockquote>\n  <p></p>\n  <h3>Configuración</h3>\n  <p>After confirming their password, a user will not be asked to confirm their password again for three hours. However, you may configure the length of time before the user is re-prompted for their password by changing the value of the <code>password_timeout</code> configuration value within your <code>auth</code> configuration file.</p>\n  <p></p>\n  <h3>Routing</h3>\n  <h4>The Password Confirmation Form</h4>\n  <p>First, we will define the route that is needed to display a view requesting that the user confirm their password:</p>\n  <pre><code>Route::get('/confirm-password', function () {\n    return view('auth.confirm-password');\n})-&gt;middleware(['auth'])-&gt;name('password.confirm');</code></pre>\n  <p>As you might expect, the view that is returned by this route should have a form containing a <code>password</code> field. In addition, feel free to include text within the view that explains that the user is entering a protected area of the application and must confirm their password.</p>\n  <h4>Confirming The Password</h4>\n  <p>A continuación, definiremos una ruta que manejará la solicitud de formulario desde la vista \"confirmar contraseña\". Esta ruta será responsable de validar la contraseña y redirigir al usuario a su destino previsto:</p>\n  <pre><code>use Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Hash;\n\nRoute::post('/confirm-password', function (Request $request) {\n    if (! Hash::check($request-&gt;password, $request-&gt;user()-&gt;password)) {\n        return back()-&gt;withErrors([\n            'password' =&gt; ['The provided password does not match our records.']\n        ]);\n    }\n\n    $request-&gt;session()-&gt;passwordConfirmed();\n\n    return redirect()-&gt;intended();\n})-&gt;middleware(['auth', 'throttle:6,1'])-&gt;name('password.confirm');</code></pre>\n  <p>Antes de continuar, examinemos esta ruta con más detalle. Primero, <code>password</code>se determina que el atributo de la solicitud coincide realmente con la contraseña del usuario autenticado. Si la contraseña es válida, debemos informar a la sesión de Laravel que el usuario ha confirmado su contraseña. El <code>passwordConfirmed</code>método establecerá una marca de tiempo en la sesión del usuario que Laravel puede usar para determinar cuándo el usuario confirmó por última vez su contraseña. Finalmente, podemos redirigir al usuario a su destino previsto.</p>\n  <p></p>\n  <h3>Protección de rutas</h3>\n  <p>Debe asegurarse de que se asigne el middleware a cualquier ruta que realice una acción que deba requerir una confirmación de contraseña reciente . Este middleware se incluye con la instalación predeterminada de Laravel y almacenará automáticamente el destino deseado del usuario en la sesión para que el usuario pueda ser redirigido a esa ubicación después de confirmar su contraseña. Después de almacenar el destino previsto del usuario en la sesión, el middleware redirigirá al usuario a la ruta nombrada :<code>password.confirm</code><code>password.confirm</code> </p>\n  <pre><code>Route::get('/settings', function () {\n    // ...\n})-&gt;middleware(['password.confirm']);\n\nRoute::post('/settings', function () {\n    // ...\n})-&gt;middleware(['password.confirm']);</code></pre>\n  <p></p>\n  <h2>Agregar guardias personalizados</h2>\n  <p>Puede definir sus propias protecciones de autenticación utilizando el <code>extend</code>método de la <code>Auth</code>fachada. Debe realizar esta llamada <code>extend</code>dentro de un proveedor de servicios . Dado que Laravel ya se envía con un <code>AuthServiceProvider</code>, podemos colocar el código en ese proveedor:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse App\\Services\\Auth\\JwtGuard;\nuse Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass AuthServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application authentication / authorization services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        $this-&gt;registerPolicies();\n\n        Auth::extend('jwt', function ($app, $name, array $config) {\n            // Return an instance of Illuminate\\Contracts\\Auth\\Guard...\n\n            return new JwtGuard(Auth::createUserProvider($config['provider']));\n        });\n    }\n}</code></pre>\n  <p>Como puede ver en el ejemplo anterior, la devolución de llamada pasada al <code>extend</code>método debería devolver una implementación de . Esta interfaz contiene algunos métodos que deberá implementar para definir una protección personalizada. Una vez que se ha definido su protección personalizada, puede utilizar esta protección en la configuración de su archivo de configuración:<code>Illuminate\\Contracts\\Auth\\Guard</code><code>guards</code><code>auth.php</code></p>\n  <pre><code>'guards' =&gt; [\n    'api' =&gt; [\n        'driver' =&gt; 'jwt',\n        'provider' =&gt; 'users',\n    ],\n],</code></pre>\n  <p></p>\n  <h3>Guardias de solicitud de cierre</h3>\n  <p>La forma más sencilla de implementar un sistema de autenticación personalizado basado en solicitudes HTTP es mediante el método. Este método le permite definir rápidamente su proceso de autenticación utilizando un solo cierre.<code>Auth::viaRequest</code></p>\n  <p>Para comenzar, llame al método dentro del método de su . El método acepta un nombre de controlador de autenticación como primer argumento. Este nombre puede ser cualquier cadena que describa su guardia personalizada. El segundo argumento pasado al método debería ser un cierre que recibe la solicitud HTTP entrante y devuelve una instancia de usuario o, si falla la autenticación, :<code>Auth::viaRequest</code><code>boot</code><code>AuthServiceProvider</code><code>viaRequest</code><code>null</code></p>\n  <pre><code>use App\\Models\\User;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\n\n/**\n * Register any application authentication / authorization services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;registerPolicies();\n\n    Auth::viaRequest('custom-token', function ($request) {\n        return User::where('token', $request-&gt;token)-&gt;first();\n    });\n}</code></pre>\n  <p>Una vez que se ha definido su controlador de autenticación personalizado, lo utiliza como controlador dentro de la <code>guards</code>configuración de su archivo de configuración:<code>auth.php</code></p>\n  <pre><code>'guards' =&gt; [\n    'api' =&gt; [\n        'driver' =&gt; 'custom-token',\n    ],\n],</code></pre>\n  <p></p>\n  <h2>Agregar proveedores de usuarios personalizados</h2>\n  <p>Si no está utilizando una base de datos relacional tradicional para almacenar sus usuarios, deberá ampliar Laravel con su propio proveedor de usuarios de autenticación. Usaremos el <code>provider</code>método en la <code>Auth</code>fachada para definir un proveedor de usuario personalizado:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse App\\Extensions\\RiakUserProvider;\nuse Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass AuthServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application authentication / authorization services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        $this-&gt;registerPolicies();\n\n        Auth::provider('riak', function ($app, array $config) {\n            // Return an instance of Illuminate\\Contracts\\Auth\\UserProvider...\n\n            return new RiakUserProvider($app-&gt;make('riak.connection'));\n        });\n    }\n}</code></pre>\n  <p>Una vez que haya registrado el proveedor utilizando el <code>provider</code>método, puede cambiar al nuevo proveedor de usuario en su archivo de configuración. Primero, defina un que use su nuevo controlador:<code>auth.php</code><code>provider</code></p>\n  <pre><code>'providers' =&gt; [\n    'users' =&gt; [\n        'driver' =&gt; 'riak',\n    ],\n],</code></pre>\n  <p>Finalmente, puede usar este proveedor en su <code>guards</code>configuración:</p>\n  <pre><code>'guards' =&gt; [\n    'web' =&gt; [\n        'driver' =&gt; 'session',\n        'provider' =&gt; 'users',\n    ],\n],</code></pre>\n  <p></p>\n  <h3>El contrato de proveedor de usuario</h3>\n  <p>Las implementaciones solo son responsables de obtener una implementación de un sistema de almacenamiento persistente, como MySQL, Riak, etc. Estas dos interfaces permiten que los mecanismos de autenticación de Laravel continúen funcionando independientemente de cómo se almacenan los datos del usuario o qué tipo de clase se utiliza. para representarlo.<code>Illuminate\\Contracts\\Auth\\UserProvider</code><code>Illuminate\\Contracts\\Auth\\Authenticatable</code></p>\n  <p>Echemos un vistazo al contrato:<code>Illuminate\\Contracts\\Auth\\UserProvider</code></p>\n  <pre><code>&lt;?php\n\nnamespace Illuminate\\Contracts\\Auth;\n\ninterface UserProvider\n{\n    public function retrieveById($identifier);\n    public function retrieveByToken($identifier, $token);\n    public function updateRememberToken(Authenticatable $user, $token);\n    public function retrieveByCredentials(array $credentials);\n    public function validateCredentials(Authenticatable $user, array $credentials);\n}</code></pre>\n  <p>La <code>retrieveById</code>función normalmente recibe una clave que representa al usuario, como un ID de incremento automático de una base de datos MySQL. El <code>Authenticatable</code>método debe recuperar y devolver la implementación que coincida con el ID.</p>\n  <p>The <code>retrieveByToken</code> function retrieves a user by their unique <code>$identifier</code> and \"remember me\" <code>$token</code>, stored in a field <code>remember_token</code>. As with the previous method, the <code>Authenticatable</code> implementation should be returned.</p>\n  <p>The <code>updateRememberToken</code> method updates the <code>$user</code> field <code>remember_token</code> with the new <code>$token</code>. A fresh token is assigned on a successful \"remember me\" login attempt or when the user is logging out.</p>\n  <p>The <code>retrieveByCredentials</code> method receives the array of credentials passed to the <code>Auth::attempt</code> method when attempting to sign into an application. The method should then \"query\" the underlying persistent storage for the user matching those credentials. Typically, this method will run a query with a \"where\" condition on <code>$credentials['username']</code>. The method should then return an implementation of <code>Authenticatable</code>. <strong>This method should not attempt to do any password validation or authentication.</strong></p>\n  <p>The <code>validateCredentials</code> method should compare the given <code>$user</code> with the <code>$credentials</code> to authenticate the user. For example, this method should probably use <code>Hash::check</code> to compare the value of <code>$user-&gt;getAuthPassword()</code> to the value of <code>$credentials['password']</code>. This method should return <code>true</code> or <code>false</code> indicating on whether the password is valid.</p>\n  <p></p>\n  <h3>The Authenticatable Contract</h3>\n  <p>Now that we have explored each of the methods on the <code>UserProvider</code>, let's take a look at the <code>Authenticatable</code> contract. Remember, the provider should return implementations of this interface from the <code>retrieveById</code>, <code>retrieveByToken</code>, and <code>retrieveByCredentials</code> methods:</p>\n  <pre><code>&lt;?php\n\nnamespace Illuminate\\Contracts\\Auth;\n\ninterface Authenticatable\n{\n    public function getAuthIdentifierName();\n    public function getAuthIdentifier();\n    public function getAuthPassword();\n    public function getRememberToken();\n    public function setRememberToken($value);\n    public function getRememberTokenName();\n}</code></pre>\n  <p>Esta interfaz es simple. El <code>getAuthIdentifierName</code>método debe devolver el nombre del campo \"clave principal\" del usuario y el <code>getAuthIdentifier</code>método debe devolver la \"clave principal\" del usuario. En un back-end de MySQL, nuevamente, esta sería la clave primaria de incremento automático. El <code>getAuthPassword</code>debe devolver la contraseña hash del usuario. Esta interfaz permite que el sistema de autenticación funcione con cualquier clase de usuario, independientemente del ORM o la capa de abstracción de almacenamiento que esté utilizando. De forma predeterminada, Laravel incluye una <code>User</code>clase en el <code>app</code>directorio que implementa esta interfaz, por lo que puede consultar esta clase para obtener un ejemplo de implementación.</p>\n  <p></p>\n  <h2>Eventos</h2>\n  <p>Laravel genera una variedad de eventos durante el proceso de autenticación. Puede adjuntar oyentes a estos eventos en su <code>EventServiceProvider</code>:</p>\n  <pre><code>/**\n * The event listener mappings for the application.\n *\n * @var array\n */\nprotected $listen = [\n    'Illuminate\\Auth\\Events\\Registered' =&gt; [\n        'App\\Listeners\\LogRegisteredUser',\n    ],\n\n    'Illuminate\\Auth\\Events\\Attempting' =&gt; [\n        'App\\Listeners\\LogAuthenticationAttempt',\n    ],\n\n    'Illuminate\\Auth\\Events\\Authenticated' =&gt; [\n        'App\\Listeners\\LogAuthenticated',\n    ],\n\n    'Illuminate\\Auth\\Events\\Login' =&gt; [\n        'App\\Listeners\\LogSuccessfulLogin',\n    ],\n\n    'Illuminate\\Auth\\Events\\Failed' =&gt; [\n        'App\\Listeners\\LogFailedLogin',\n    ],\n\n    'Illuminate\\Auth\\Events\\Validated' =&gt; [\n        'App\\Listeners\\LogValidated',\n    ],\n\n    'Illuminate\\Auth\\Events\\Verified' =&gt; [\n        'App\\Listeners\\LogVerified',\n    ],\n\n    'Illuminate\\Auth\\Events\\Logout' =&gt; [\n        'App\\Listeners\\LogSuccessfulLogout',\n    ],\n\n    'Illuminate\\Auth\\Events\\CurrentDeviceLogout' =&gt; [\n        'App\\Listeners\\LogCurrentDeviceLogout',\n    ],\n\n    'Illuminate\\Auth\\Events\\OtherDeviceLogout' =&gt; [\n        'App\\Listeners\\LogOtherDeviceLogout',\n    ],\n\n    'Illuminate\\Auth\\Events\\Lockout' =&gt; [\n        'App\\Listeners\\LogLockout',\n    ],\n\n    'Illuminate\\Auth\\Events\\PasswordReset' =&gt; [\n        'App\\Listeners\\LogPasswordReset',\n    ],\n];</code></pre>\n</section>"
      },
      {
        "titulo": "5.2 Autorización",
        "contenido": "<section>\n  <h1>Autorización</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Puertas\n      <ul>\n        <li>Puertas de escritura</li>\n        <li>Autorizar acciones</li>\n        <li>Respuestas de puerta</li>\n        <li>Interceptar controles de puerta</li>\n      </ul></li>\n    <li>Creación de políticas\n      <ul>\n        <li>Generando políticas</li>\n        <li>Registro de políticas</li>\n      </ul></li>\n    <li>Políticas de redacción\n      <ul>\n        <li>Métodos de política</li>\n        <li>Respuestas de política</li>\n        <li>Métodos sin modelos</li>\n        <li>Usuarios invitados</li>\n        <li>Filtros de políticas</li>\n      </ul></li>\n    <li>Autorización de acciones mediante políticas\n      <ul>\n        <li>A través del modelo de usuario</li>\n        <li>Vía Middleware</li>\n        <li>A través de controladores auxiliares</li>\n        <li>A través de plantillas Blade</li>\n        <li>Proporcionar contexto adicional</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Además de proporcionar servicios de autenticación listos para usar, Laravel también proporciona una forma sencilla de autorizar las acciones del usuario contra un recurso determinado. Al igual que la autenticación, el enfoque de Laravel para la autorización es simple y hay dos formas principales de autorizar acciones: puertas y políticas.</p>\n  <p>Piense en puertas y políticas como rutas y controladores. Gates proporciona un enfoque de autorización simple basado en el cierre, mientras que las políticas, como los controladores, agrupan su lógica en torno a un modelo o recurso en particular. Primero exploraremos las puertas y luego examinaremos las políticas.</p>\n  <p>No es necesario que elija entre el uso exclusivo de puertas o el uso exclusivo de políticas al crear una aplicación. La mayoría de las aplicaciones probablemente contendrán una combinación de puertas y políticas, ¡y eso está perfectamente bien! Las puertas son más aplicables a acciones que no están relacionadas con ningún modelo o recurso, como ver un panel de administrador. Por el contrario, las políticas deben usarse cuando desee autorizar una acción para un modelo o recurso en particular.</p>\n  <p></p>\n  <h2>Puertas</h2>\n  <p></p>\n  <h3>Puertas de escritura</h3>\n  <p>Las puertas son cierres que determinan si un usuario está autorizado para realizar una acción determinada y normalmente se definen en la clase que utiliza la fachada. Las puertas siempre reciben una instancia de usuario como su primer argumento y, opcionalmente, pueden recibir argumentos adicionales, como un modelo Eloquent relevante:<code>App\\Providers\\AuthServiceProvider</code><code>Gate</code></p>\n  <pre><code>/**\n * Register any authentication / authorization services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;registerPolicies();\n\n    Gate::define('edit-settings', function ($user) {\n        return $user-&gt;isAdmin;\n    });\n\n    Gate::define('update-post', function ($user, $post) {\n        return $user-&gt;id === $post-&gt;user_id;\n    });\n}</code></pre>\n  <p>Las puertas también se pueden definir utilizando una matriz de devolución de llamada de clase, como controladores:</p>\n  <pre><code>use App\\Policies\\PostPolicy;\n\n/**\n * Register any authentication / authorization services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;registerPolicies();\n\n    Gate::define('update-post', [PostPolicy::class, 'update']);\n}</code></pre>\n  <p></p>\n  <h3>Autorizar acciones</h3>\n  <p>Para autorizar una acción mediante puertas, debe utilizar los métodos <code>allows</code>o <code>denies</code>. Tenga en cuenta que no es necesario que pase el usuario autenticado actualmente a estos métodos. Laravel se encargará automáticamente de pasar al usuario al cierre de la puerta:</p>\n  <pre><code>if (Gate::allows('edit-settings')) {\n    // The current user can edit settings\n}\n\nif (Gate::allows('update-post', $post)) {\n    // The current user can update the post...\n}\n\nif (Gate::denies('update-post', $post)) {\n    // The current user can't update the post...\n}</code></pre>\n  <p>Si desea determinar si un usuario en particular está autorizado para realizar una acción, puede usar el <code>forUser</code>método en la <code>Gate</code>fachada:</p>\n  <pre><code>if (Gate::forUser($user)-&gt;allows('update-post', $post)) {\n    // The user can update the post...\n}\n\nif (Gate::forUser($user)-&gt;denies('update-post', $post)) {\n    // The user can't update the post...\n}</code></pre>\n  <p>Puede autorizar varias acciones a la vez con los métodos <code>any</code>o <code>none</code>:</p>\n  <pre><code>if (Gate::any(['update-post', 'delete-post'], $post)) {\n    // The user can update or delete the post\n}\n\nif (Gate::none(['update-post', 'delete-post'], $post)) {\n    // The user cannot update or delete the post\n}</code></pre>\n  <h4>Autorizar o lanzar excepciones</h4>\n  <p>Si desea intentar autorizar una acción y lanzar automáticamente una si el usuario no tiene permiso para realizar la acción dada, puede usar el método. Las instancias de se convierten automáticamente en una respuesta HTTP:<code>Illuminate\\Auth\\Access\\AuthorizationException</code><code>Gate::authorize</code><code>AuthorizationException</code><code>403</code></p>\n  <pre><code>Gate::authorize('update-post', $post);\n\n// The action is authorized...</code></pre>\n  <h4>Proporcionar contexto adicional</h4>\n  <p>Los métodos de compuerta para habilidades que autorizan ( <code>allows</code>, <code>denies</code>, <code>check</code>, <code>any</code>, <code>none</code>, <code>authorize</code>, <code>can</code>, <code>cannot</code>) y la autorización de las directivas de la lámina ( <code>@can</code>, <code>@cannot</code>, <code>@canany</code>) pueden recibir una matriz como el segundo argumento. Estos elementos de matriz se pasan como parámetros a la puerta y se pueden usar para un contexto adicional al tomar decisiones de autorización:</p>\n  <pre><code>Gate::define('create-post', function ($user, $category, $extraFlag) {\n    return $category-&gt;group &gt; 3 &amp;&amp; $extraFlag === true;\n});\n\nif (Gate::check('create-post', [$category, $extraFlag])) {\n    // The user can create the post...\n}</code></pre>\n  <p></p>\n  <h3>Respuestas de puerta</h3>\n  <p>Hasta ahora, solo hemos examinado las puertas que devuelven valores booleanos simples. Sin embargo, a veces es posible que desee devolver una respuesta más detallada, incluido un mensaje de error. Para hacerlo, puede devolver un desde su puerta:<code>Illuminate\\Auth\\Access\\Response</code></p>\n  <pre><code>use Illuminate\\Auth\\Access\\Response;\nuse Illuminate\\Support\\Facades\\Gate;\n\nGate::define('edit-settings', function ($user) {\n    return $user-&gt;isAdmin\n                ? Response::allow()\n                : Response::deny('You must be a super administrator.');\n});</code></pre>\n  <p>Al devolver una respuesta de autorización desde su puerta, el método aún devolverá un valor booleano simple; sin embargo, puede usar el método para obtener la respuesta de autorización completa devuelta por la puerta:<code>Gate::allows</code><code>Gate::inspect</code></p>\n  <pre><code>$response = Gate::inspect('edit-settings', $post);\n\nif ($response-&gt;allowed()) {\n    // The action is authorized...\n} else {\n    echo $response-&gt;message();\n}</code></pre>\n  <p>Por supuesto, cuando se usa el método para lanzar un si la acción no está autorizada, el mensaje de error proporcionado por la respuesta de autorización se propagará a la respuesta HTTP:<code>Gate::authorize</code><code>AuthorizationException</code></p>\n  <pre><code>Gate::authorize('edit-settings', $post);\n\n// The action is authorized...</code></pre>\n  <p></p>\n  <h3>Interceptar controles de puerta</h3>\n  <p>A veces, es posible que desee otorgar todas las habilidades a un usuario específico. Puede usar el <code>before</code>método para definir una devolución de llamada que se ejecuta antes de todas las demás verificaciones de autorización:</p>\n  <pre><code>Gate::before(function ($user, $ability) {\n    if ($user-&gt;isSuperAdmin()) {\n        return true;\n    }\n});</code></pre>\n  <p>Si la <code>before</code>devolución de llamada devuelve un resultado no nulo, ese resultado se considerará el resultado de la verificación.</p>\n  <p>Puede usar el <code>after</code>método para definir una devolución de llamada que se ejecutará después de todas las demás verificaciones de autorización:</p>\n  <pre><code>Gate::after(function ($user, $ability, $result, $arguments) {\n    if ($user-&gt;isSuperAdmin()) {\n        return true;\n    }\n});</code></pre>\n  <p>Al igual que en la <code>before</code>verificación, si la <code>after</code>devolución de llamada devuelve un resultado no nulo, ese resultado se considerará el resultado de la verificación.</p>\n  <p></p>\n  <h2>Creación de políticas</h2>\n  <p></p>\n  <h3>Generando políticas</h3>\n  <p>Las políticas son clases que organizan la lógica de autorización en torno a un modelo o recurso en particular. Por ejemplo, si tu aplicación es un blog, es posible que tengas un <code>Post</code>modelo y un correspondiente <code>PostPolicy</code>para autorizar acciones del usuario como crear o actualizar publicaciones.</p>\n  <p>Puede generar una política utilizando el comando artisan . La política generada se colocará en el directorio. Si este directorio no existe en su aplicación, Laravel lo creará por usted:<code>make:policy</code> <code>app/Policies</code></p>\n  <pre><code>php artisan make:policy PostPolicy</code></pre>\n  <p>El comando generará una clase de política vacía. Si desea generar una clase con los métodos de política básicos \"CRUD\" ya incluidos en la clase, puede especificar un al ejecutar el comando:<code>make:policy</code><code>--model</code></p>\n  <pre><code>php artisan make:policy PostPolicy --model=Post</code></pre>\n  <blockquote>\n    <p>Todas las políticas se resuelven a través del contenedor de servicios de Laravel , lo que le permite escribir sugerencias sobre las dependencias necesarias en el constructor de la política para que se inyecten automáticamente.</p>\n  </blockquote>\n  <p></p>\n  <h3>Registro de políticas</h3>\n  <p>Una vez que existe la póliza, debe registrarse. El <code>AuthServiceProvider</code>incluido con las nuevas aplicaciones de Laravel contiene una <code>policies</code>propiedad que asigna sus modelos Eloquent a sus políticas correspondientes. El registro de una política le indicará a Laravel qué política utilizar al autorizar acciones contra un modelo determinado:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse App\\Models\\Post;\nuse App\\Policies\\PostPolicy;\nuse Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\nuse Illuminate\\Support\\Facades\\Gate;\n\nclass AuthServiceProvider extends ServiceProvider\n{\n    /**\n     * The policy mappings for the application.\n     *\n     * @var array\n     */\n    protected $policies = [\n        Post::class =&gt; PostPolicy::class,\n    ];\n\n    /**\n     * Register any application authentication / authorization services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        $this-&gt;registerPolicies();\n\n        //\n    }\n}</code></pre>\n  <h4>Detección automática de políticas</h4>\n  <p>En lugar de registrar manualmente las políticas del modelo, Laravel puede descubrir automáticamente las políticas siempre que el modelo y la política sigan las convenciones de nomenclatura estándar de Laravel. Específicamente, las políticas deben estar en un <code>Policies</code>directorio en o encima del directorio que contiene sus modelos. Entonces, por ejemplo, los modelos pueden colocarse en el directorio mientras que las políticas pueden colocarse en el directorio. En esta situación, Laravel verificará las políticas en ese momento . Además, el nombre de la política debe coincidir con el nombre del modelo y tener un sufijo. Entonces, un modelo correspondería a una clase.<code>app/Models</code><code>app/Policies</code><code>app/Models/Policies</code><code>app/Policies</code><code>Policy</code><code>User</code><code>UserPolicy</code></p>\n  <p>Si desea proporcionar su propia lógica de descubrimiento de políticas, puede registrar una devolución de llamada personalizada utilizando el método. Normalmente, este método debe llamarse desde el método de su aplicación :<code>Gate::guessPolicyNamesUsing</code><code>boot</code><code>AuthServiceProvider</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Gate;\n\nGate::guessPolicyNamesUsing(function ($modelClass) {\n    // return policy class name...\n});</code></pre>\n  <blockquote>\n    <p>Cualquier política que se asigne explícitamente en su <code>AuthServiceProvider</code>tendrá prioridad sobre cualquier política potencialmente descubierta automáticamente.</p>\n  </blockquote>\n  <p></p>\n  <h2>Políticas de redacción</h2>\n  <p></p>\n  <h3>Métodos de política</h3>\n  <p>Una vez que se haya registrado la política, puede agregar métodos para cada acción que autorice. Por ejemplo, definamos un <code>update</code>método en nuestro <code>PostPolicy</code>que determina si un determinado <code>User</code>puede actualizar una determinada <code>Post</code>instancia.</p>\n  <p>El <code>update</code>método recibirá una instancia <code>User</code>y una <code>Post</code>como sus argumentos, y debe devolver <code>true</code>o <code>false</code>indicar si el usuario está autorizado a actualizar el dado <code>Post</code>. Entonces, para este ejemplo, verifiquemos que el usuario <code>id</code>coincida con el <code>user_id</code>de la publicación:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\Post;\nuse App\\Models\\User;\n\nclass PostPolicy\n{\n    /**\n     * Determine if the given post can be updated by the user.\n     *\n     * @param  \\App\\Models\\User  $user\n     * @param  \\App\\Models\\Post  $post\n     * @return bool\n     */\n    public function update(User $user, Post $post)\n    {\n        return $user-&gt;id === $post-&gt;user_id;\n    }\n}</code></pre>\n  <p>Puede continuar definiendo métodos adicionales en la política según sea necesario para las diversas acciones que autoriza. Por ejemplo, puede definir <code>view</code>o <code>delete</code>métodos para autorizar varias <code>Post</code>acciones, pero recuerde que es libre de dar a sus métodos de política el nombre que desee.</p>\n  <blockquote>\n    <p>Si ha utilizado la <code>--model</code>opción cuando la generación de su política a través de la consola de Artisan, que ya contendrá los métodos para <code>viewAny</code>, <code>view</code>, <code>create</code>, <code>update</code>, <code>delete</code>, <code>restore</code>, y <code>forceDelete</code>acciones.</p>\n  </blockquote>\n  <p></p>\n  <h3>Respuestas de política</h3>\n  <p>Hasta ahora, solo hemos examinado métodos de política que devuelven valores booleanos simples. Sin embargo, a veces es posible que desee devolver una respuesta más detallada, incluido un mensaje de error. Para hacerlo, puede devolver un de su método de póliza:<code>Illuminate\\Auth\\Access\\Response</code></p>\n  <pre><code>use Illuminate\\Auth\\Access\\Response;\n\n/**\n * Determine if the given post can be updated by the user.\n *\n * @param  \\App\\Models\\User  $user\n * @param  \\App\\Models\\Post  $post\n * @return \\Illuminate\\Auth\\Access\\Response\n */\npublic function update(User $user, Post $post)\n{\n    return $user-&gt;id === $post-&gt;user_id\n                ? Response::allow()\n                : Response::deny('You do not own this post.');\n}</code></pre>\n  <p>Al devolver una respuesta de autorización de su política, el método seguirá devolviendo un valor booleano simple; sin embargo, puede usar el método para obtener la respuesta de autorización completa devuelta por la puerta:<code>Gate::allows</code><code>Gate::inspect</code></p>\n  <pre><code>$response = Gate::inspect('update', $post);\n\nif ($response-&gt;allowed()) {\n    // The action is authorized...\n} else {\n    echo $response-&gt;message();\n}</code></pre>\n  <p>Por supuesto, cuando se usa el método para lanzar un si la acción no está autorizada, el mensaje de error proporcionado por la respuesta de autorización se propagará a la respuesta HTTP:<code>Gate::authorize</code><code>AuthorizationException</code></p>\n  <pre><code>Gate::authorize('update', $post);\n\n// The action is authorized...</code></pre>\n  <p></p>\n  <h3>Métodos sin modelos</h3>\n  <p>Algunos métodos de política solo reciben al usuario actualmente autenticado y no una instancia del modelo que autorizan. Esta situación es más común a la hora de autorizar <code>create</code>acciones. Por ejemplo, si está creando un blog, es posible que desee comprobar si un usuario está autorizado para crear publicaciones.</p>\n  <p>Al definir métodos de política que no recibirán una instancia de modelo, como un <code>create</code>método, no recibirá una instancia de modelo. En su lugar, debe definir el método como solo esperando al usuario autenticado:</p>\n  <pre><code>/**\n * Determine if the given user can create posts.\n *\n * @param  \\App\\Models\\User  $user\n * @return bool\n */\npublic function create(User $user)\n{\n    //\n}</code></pre>\n  <p></p>\n  <h3>Usuarios invitados</h3>\n  <p>De forma predeterminada, todas las puertas y políticas regresan automáticamente <code>false</code>si la solicitud HTTP entrante no fue iniciada por un usuario autenticado. Sin embargo, puede permitir que estas verificaciones de autorización pasen a sus puertas y políticas declarando una sugerencia de tipo \"opcional\" o proporcionando un <code>null</code>valor predeterminado para la definición del argumento del usuario:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\Post;\nuse App\\Models\\User;\n\nclass PostPolicy\n{\n    /**\n     * Determine if the given post can be updated by the user.\n     *\n     * @param  \\App\\Models\\User  $user\n     * @param  \\App\\Models\\Post  $post\n     * @return bool\n     */\n    public function update(?User $user, Post $post)\n    {\n        return optional($user)-&gt;id === $post-&gt;user_id;\n    }\n}</code></pre>\n  <p></p>\n  <h3>Filtros de políticas</h3>\n  <p>Para ciertos usuarios, es posible que desee autorizar todas las acciones dentro de una política determinada. Para lograr esto, defina un <code>before</code>método en la política. El <code>before</code>método se ejecutará antes que cualquier otro método de la política, lo que le dará la oportunidad de autorizar la acción antes de que se llame al método de política deseado. Esta función se usa más comúnmente para autorizar a los administradores de aplicaciones a realizar cualquier acción:</p>\n  <pre><code>public function before($user, $ability)\n{\n    if ($user-&gt;isSuperAdmin()) {\n        return true;\n    }\n}</code></pre>\n  <p>Si desea denegar todas las autorizaciones de un usuario, debe regresar <code>false</code>del <code>before</code>método. Si <code>null</code>se devuelve, la autorización se aplicará al método de la póliza.</p>\n  <blockquote>\n    <p>El <code>before</code>método de una clase política no será llamado si la clase no contiene un método con el mismo nombre que el nombre de la capacidad que se comprueba.</p>\n  </blockquote>\n  <p></p>\n  <h2>Autorización de acciones mediante políticas</h2>\n  <p></p>\n  <h3>A través del modelo de usuario</h3>\n  <p>El <code>User</code>modelo que se incluye con su aplicación Laravel incluye dos métodos útiles para autorizar acciones: <code>can</code>y <code>cant</code>. El <code>can</code>método recibe la acción que desea autorizar y el modelo correspondiente. Por ejemplo, determinemos si un usuario está autorizado a actualizar un <code>Post</code>modelo determinado :</p>\n  <pre><code>if ($user-&gt;can('update', $post)) {\n    //\n}</code></pre>\n  <p>Si se registra una política para el modelo dado, el <code>can</code>método llamará automáticamente a la política adecuada y devolverá el resultado booleano. Si no se registra ninguna política para el modelo, el <code>can</code>método intentará llamar a la puerta basada en Closure que coincida con el nombre de acción dado.</p>\n  <h4>Acciones que no requieren modelos</h4>\n  <p>Recuerde, algunas acciones como <code>create</code>pueden no requerir una instancia de modelo. En estas situaciones, puede pasar un nombre de clase al <code>can</code>método. El nombre de la clase se utilizará para determinar qué política utilizar al autorizar la acción:</p>\n  <pre><code>use App\\Models\\Post;\n\nif ($user-&gt;can('create', Post::class)) {\n    // Executes the \"create\" method on the relevant policy...\n}</code></pre>\n  <p></p>\n  <h3>Vía Middleware</h3>\n  <p>Laravel incluye un middleware que puede autorizar acciones antes de que la solicitud entrante llegue incluso a sus rutas o controladores. De forma predeterminada, al middleware se le asigna la clave en su clase. Exploremos un ejemplo del uso del middleware para autorizar que un usuario pueda actualizar una publicación de blog:<code>Illuminate\\Auth\\Middleware\\Authorize</code><code>can</code><code>App\\Http\\Kernel</code><code>can</code></p>\n  <pre><code>use App\\Models\\Post;\n\nRoute::put('/post/{post}', function (Post $post) {\n    // The current user may update the post...\n})-&gt;middleware('can:update,post');</code></pre>\n  <p>En este ejemplo, le estamos pasando <code>can</code>dos argumentos al middleware. El primero es el nombre de la acción que deseamos autorizar y el segundo es el parámetro de ruta que deseamos pasar al método de política. En este caso, dado que estamos usando un enlace de modelo implícito , se <code>Post</code>pasará un modelo al método de política. Si el usuario no está autorizado para realizar la acción dada, <code>403</code>el middleware generará una respuesta HTTP con un código de estado.</p>\n  <h4>Acciones que no requieren modelos</h4>\n  <p>Nuevamente, algunas acciones como <code>create</code>pueden no requerir una instancia de modelo. En estas situaciones, puede pasar un nombre de clase al middleware. El nombre de la clase se utilizará para determinar qué política utilizar al autorizar la acción:</p>\n  <pre><code>Route::post('/post', function () {\n    // The current user may create posts...\n})-&gt;middleware('can:create,App\\Models\\Post');</code></pre>\n  <p></p>\n  <h3>A través de controladores auxiliares</h3>\n  <p>Además de los métodos útiles proporcionados al <code>User</code>modelo, Laravel proporciona un <code>authorize</code>método útil para cualquiera de sus controladores que amplían la clase base. Al igual que el método, este método acepta el nombre de la acción que desea autorizar y el modelo correspondiente. Si la acción no está autorizada, el método arrojará un , que el controlador de excepciones predeterminado de Laravel convertirá en una respuesta HTTP con un código de estado:<code>App\\Http\\Controllers\\Controller</code><code>can</code><code>authorize</code><code>Illuminate\\Auth\\Access\\AuthorizationException</code><code>403</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\Post;\nuse Illuminate\\Http\\Request;\n\nclass PostController extends Controller\n{\n    /**\n     * Update the given blog post.\n     *\n     * @param  Request  $request\n     * @param  Post  $post\n     * @return Response\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function update(Request $request, Post $post)\n    {\n        $this-&gt;authorize('update', $post);\n\n        // The current user can update the blog post...\n    }\n}</code></pre>\n  <h4>Acciones que no requieren modelos</h4>\n  <p>Como se discutió anteriormente, algunas acciones como <code>create</code>pueden no requerir una instancia de modelo. En estas situaciones, debe pasar un nombre de clase al <code>authorize</code>método. El nombre de la clase se utilizará para determinar qué política utilizar al autorizar la acción:</p>\n  <pre><code>/**\n * Create a new blog post.\n *\n * @param  Request  $request\n * @return Response\n * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n */\npublic function create(Request $request)\n{\n    $this-&gt;authorize('create', Post::class);\n\n    // The current user can create blog posts...\n}</code></pre>\n  <h4>Autorizar controladores de recursos</h4>\n  <p>Si está utilizando controladores de recursos , puede usar el <code>authorizeResource</code>método en el constructor del controlador. Este método adjuntará las <code>can</code>definiciones de middleware adecuadas a los métodos del controlador de recursos.</p>\n  <p>El <code>authorizeResource</code>método acepta el nombre de la clase del modelo como su primer argumento y el nombre del parámetro de ruta / solicitud que contendrá la ID del modelo como su segundo argumento. Debe asegurarse de que su controlador de recursos se cree con la <code>--model</code>marca para tener las firmas de método requeridas y las sugerencias de tipo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\Post;\nuse Illuminate\\Http\\Request;\n\nclass PostController extends Controller\n{\n    public function __construct()\n    {\n        $this-&gt;authorizeResource(Post::class, 'post');\n    }\n}</code></pre>\n  <p>Los siguientes métodos de controlador se asignarán a su método de política correspondiente:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Método del controlador</th>\n      <th>Método de política</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td>índice</td>\n      <td>viewAny</td>\n    </tr>\n    <tr>\n      <td>espectáculo</td>\n      <td>ver</td>\n    </tr>\n    <tr>\n      <td>crear</td>\n      <td>crear</td>\n    </tr>\n    <tr>\n      <td>Tienda</td>\n      <td>crear</td>\n    </tr>\n    <tr>\n      <td>editar</td>\n      <td>actualizar</td>\n    </tr>\n    <tr>\n      <td>actualizar</td>\n      <td>actualizar</td>\n    </tr>\n    <tr>\n      <td>destruir</td>\n      <td>Eliminar</td>\n    </tr>\n    </tbody>\n  </table>\n  <blockquote>\n    <p>Es posible utilizar el comando con la opción de generar rápidamente una clase política para un modelo dado: .<code>make:policy</code><code>--model</code><code>php artisan make:policy PostPolicy --model=Post</code></p>\n  </blockquote>\n  <p></p>\n  <h3>A través de plantillas Blade</h3>\n  <p>Al escribir plantillas Blade, es posible que desee mostrar una parte de la página solo si el usuario está autorizado para realizar una acción determinada. Por ejemplo, es posible que desee mostrar un formulario de actualización para una publicación de blog solo si el usuario puede actualizar la publicación. En esta situación, es posible utilizar el <code>@can</code>y <code>@cannot</code>la familia de las directivas:</p>\n  <pre><code>@can('update', $post)\n    &lt;!-- The Current User Can Update The Post --&gt;\n@elsecan('create', App\\Models\\Post::class)\n    &lt;!-- The Current User Can Create New Post --&gt;\n@endcan\n\n@cannot('update', $post)\n    &lt;!-- The Current User Cannot Update The Post --&gt;\n@elsecannot('create', App\\Models\\Post::class)\n    &lt;!-- The Current User Cannot Create A New Post --&gt;\n@endcannot</code></pre>\n  <p>Estas directivas son atajos convenientes para la redacción y las declaraciones. Las declaraciones y anteriores, respectivamente, se traducen en las siguientes declaraciones:<code>@if</code><code>@unless</code><code>@can</code><code>@cannot</code></p>\n  <pre><code>@if (Auth::user()-&gt;can('update', $post))\n    &lt;!-- The Current User Can Update The Post --&gt;\n@endif\n\n@unless (Auth::user()-&gt;can('update', $post))\n    &lt;!-- The Current User Cannot Update The Post --&gt;\n@endunless</code></pre>\n  <p>También puede determinar si un usuario tiene alguna capacidad de autorización de una lista determinada de capacidades. Para lograr esto, use la <code>@canany</code>directiva:</p>\n  <pre><code>@canany(['update', 'view', 'delete'], $post)\n    // The current user can update, view, or delete the post\n@elsecanany(['create'], \\App\\Models\\Post::class)\n    // The current user can create a post\n@endcanany</code></pre>\n  <h4>Acciones que no requieren modelos</h4>\n  <p>Como la mayoría de los otros métodos de autorización, puede pasar un nombre de clase a las directivas <code>@can</code>y <code>@cannot</code>si la acción no requiere una instancia de modelo:</p>\n  <pre><code>@can('create', App\\Models\\Post::class)\n    &lt;!-- The Current User Can Create Posts --&gt;\n@endcan\n\n@cannot('create', App\\Models\\Post::class)\n    &lt;!-- The Current User Can't Create Posts --&gt;\n@endcannot</code></pre>\n  <p></p>\n  <h3>Proporcionar contexto adicional</h3>\n  <p>Al autorizar acciones mediante políticas, puede pasar una matriz como segundo argumento a las diversas funciones de autorización y ayudantes. El primer elemento de la matriz se utilizará para determinar qué política debe invocarse, mientras que el resto de los elementos de la matriz se pasan como parámetros al método de política y se pueden utilizar para un contexto adicional al tomar decisiones de autorización. Por ejemplo, considere la siguiente <code>PostPolicy</code>definición de método que contiene un <code>$category</code>parámetro adicional :</p>\n  <pre><code>/**\n * Determine if the given post can be updated by the user.\n *\n * @param  \\App\\Models\\User  $user\n * @param  \\App\\Models\\  $post\n * @param  int  $category\n * @return bool\n */\npublic function update(User $user, Post $post, int $category)\n{\n    return $user-&gt;id === $post-&gt;user_id &amp;&amp;\n           $category &gt; 3;\n}</code></pre>\n  <p>Al intentar determinar si el usuario autenticado puede actualizar una publicación determinada, podemos invocar este método de política de la siguiente manera:</p>\n  <pre><code>/**\n * Update the given blog post.\n *\n * @param  Request  $request\n * @param  Post  $post\n * @return Response\n * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n */\npublic function update(Request $request, Post $post)\n{\n    $this-&gt;authorize('update', [$post, $request-&gt;input('category')]);\n\n    // The current user can update the blog post...\n}</code></pre>\n</section>"
      },
      {
        "titulo": "5.3 verificacion de email",
        "contenido": "<section>\n  <h1>verificacion de email</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Preparación del modelo</li>\n        <li>Preparación de la base de datos</li>\n      </ul></li>\n    <li>Enrutamiento\n      <ul>\n        <li>El aviso de verificación por correo electrónico</li>\n        <li>El controlador de verificación de correo electrónico</li>\n        <li>Reenvío del correo electrónico de verificación</li>\n        <li>Protección de rutas</li>\n      </ul></li>\n    <li>Eventos</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Muchas aplicaciones web requieren que los usuarios verifiquen sus direcciones de correo electrónico antes de usar la aplicación. En lugar de obligarlo a volver a implementar esto en cada aplicación, Laravel proporciona métodos convenientes para enviar y verificar solicitudes de verificación por correo electrónico.</p>\n  <blockquote>\n    <p>¿Quieres empezar rápido? Instale Laravel Jetstream en una nueva aplicación Laravel. Después de migrar su base de datos, navegue en su navegador hacia <code>/register</code>o cualquier otra URL asignada a su aplicación. Jetstream se encargará de montar todo su sistema de autenticación, incluido el soporte de verificación por correo electrónico.</p>\n  </blockquote>\n  <p></p>\n  <h3>Preparación del modelo</h3>\n  <p>Para comenzar, verifique que su modelo implemente el contrato:<code>App\\Models\\User</code><code>Illuminate\\Contracts\\Auth\\MustVerifyEmail</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Contracts\\Auth\\MustVerifyEmail;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Notifications\\Notifiable;\n\nclass User extends Authenticatable implements MustVerifyEmail\n{\n    use Notifiable;\n\n    // ...\n}</code></pre>\n  <p>Una vez que se haya agregado esta interfaz a su modelo, los usuarios recién registrados recibirán automáticamente un correo electrónico con un enlace de verificación por correo electrónico. Como puede ver al examinar su <code>EventServiceProvider</code>, Laravel ya contiene un <code>SendEmailVerificationNotification</code> oyente que está adjunto al evento.<code>Illuminate\\Auth\\Events\\Registered</code></p>\n  <p>Si está implementando manualmente el registro dentro de su aplicación en lugar de usar Laravel Jetstream , debe asegurarse de enviar el evento después de que el registro de un usuario sea exitoso:<code>Illuminate\\Auth\\Events\\Registered</code></p>\n  <pre><code>use Illuminate\\Auth\\Events\\Registered;\n\nevent(new Registered($user));</code></pre>\n  <p></p>\n  <h3>Preparación de la base de datos</h3>\n  <p>A continuación, su <code>user</code>tabla debe contener una <code>email_verified_at</code>columna para almacenar la fecha y hora en que se verificó la dirección de correo electrónico. De forma predeterminada, la <code>users</code>migración de la tabla incluida con el marco de Laravel ya incluye esta columna. Entonces, todo lo que necesita hacer es ejecutar las migraciones de su base de datos:</p>\n  <pre><code>php artisan migrate</code></pre>\n  <p></p>\n  <h2>Enrutamiento</h2>\n  <p>Para implementar correctamente la verificación por correo electrónico, será necesario definir tres rutas. Primero, se necesitará una ruta para mostrar un aviso al usuario de que debe hacer clic en el enlace de verificación del correo electrónico en el correo electrónico de verificación que Laravel les envió después del registro. En segundo lugar, se necesitará una ruta para manejar las solicitudes generadas cuando el usuario hace clic en el enlace de verificación del correo electrónico en el correo electrónico. En tercer lugar, se necesitará una ruta para reenviar un enlace de verificación si el usuario pierde accidentalmente el primero.</p>\n  <p></p>\n  <h3>El aviso de verificación por correo electrónico</h3>\n  <p>Como se mencionó anteriormente, se debe definir una ruta que devolverá una vista que le indique al usuario que haga clic en el enlace de verificación de correo electrónico que Laravel le envió por correo electrónico. Esta vista se mostrará a los usuarios cuando intenten acceder a otras partes de la aplicación sin verificar primero su dirección de correo electrónico. Recuerde, el enlace se envía automáticamente por correo electrónico al usuario siempre que su modelo implemente la interfaz:<code>App\\Models\\User</code><code>MustVerifyEmail</code></p>\n  <pre><code>Route::get('/email/verify', function () {\n    return view('auth.verify-email');\n})-&gt;middleware(['auth'])-&gt;name('verification.notice');</code></pre>\n  <p>Se debe nombrar la ruta que devuelve el aviso de verificación por correo electrónico . Es importante que a la ruta se le asigne este nombre exacto, ya que el middleware incluido con Laravel redirigirá automáticamente a este nombre de ruta si un usuario no ha verificado su dirección de correo electrónico.<code>verification.notice</code><code>verified</code></p>\n  <blockquote>\n    <p>Al implementar manualmente la verificación por correo electrónico, debe definir usted mismo el contenido de la vista del aviso de verificación. Si desea un andamio que incluya todas las vistas de autenticación y verificación necesarias, consulte Laravel Jetstream .</p>\n  </blockquote>\n  <p></p>\n  <h3>El controlador de verificación de correo electrónico</h3>\n  <p>A continuación, necesitamos una ruta que maneje las solicitudes generadas cuando el usuario hace clic en el enlace de verificación de correo electrónico que se le envió por correo electrónico. Esta ruta debe tener un nombre y asignársele los middlewares y :<code>verification.verify</code><code>auth</code><code>signed</code></p>\n  <pre><code>use Illuminate\\Foundation\\Auth\\EmailVerificationRequest;\nuse Illuminate\\Http\\Request;\n\nRoute::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {\n    $request-&gt;fulfill();\n\n    return redirect('/home');\n})-&gt;middleware(['auth', 'signed'])-&gt;name('verification.verify');</code></pre>\n  <p>Antes de continuar, echemos un vistazo más de cerca a esta ruta. Primero, notará que estamos usando un <code>EmailVerificationRequest</code>tipo de solicitud en lugar de la instancia típica . El es una solicitud de formulario que se incluye con laravel. Esta solicitud se encargará de validar automáticamente la solicitud y los parámetros.<code>Illuminate\\Http\\Request</code><code>EmailVerificationRequest</code><code>id</code><code>hash</code></p>\n  <p>A continuación, podemos proceder directamente a llamar al <code>fulfill</code>método en la solicitud. Este método llamará al <code>markEmailAsVerified</code>método en el usuario autenticado y enviará el evento. El método está disponible para el modelo predeterminado a través de la clase base. Una vez que se haya verificado la dirección de correo electrónico del usuario, puede redirigirlo a donde desee.<code>Illuminate\\Auth\\Events\\Verified</code><code>markEmailAsVerified</code><code>App\\Models\\User</code><code>Illuminate\\Foundation\\Auth\\User</code></p>\n  <p></p>\n  <h3>Reenvío del correo electrónico de verificación</h3>\n  <p>A veces, un usuario puede perder o eliminar accidentalmente el correo electrónico de verificación de la dirección de correo electrónico. Para adaptarse a esto, es posible que desee definir una ruta que permita al usuario solicitar que se vuelva a enviar el correo electrónico de verificación. Luego, puede realizar una solicitud a esta ruta colocando un botón de envío de formulario simple dentro de la vista de notificación de verificación :</p>\n  <pre><code>use Illuminate\\Http\\Request;\n\nRoute::post('/email/verification-notification', function (Request $request) {\n    $request-&gt;user()-&gt;sendEmailVerificationNotification();\n\n    return back()-&gt;with('status', 'verification-link-sent');\n})-&gt;middleware(['auth', 'throttle:6,1'])-&gt;name('verification.send');</code></pre>\n  <p></p>\n  <h3>Protección de rutas</h3>\n  <p>El middleware de ruta se puede utilizar para permitir que solo los usuarios verificados accedan a una ruta determinada. Laravel se envía con un <code>verified</code>middleware, que hace referencia a la clase. Dado que este middleware ya está registrado en el kernel HTTP de su aplicación, todo lo que necesita hacer es adjuntar el middleware a una definición de ruta:<code>Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified</code></p>\n  <pre><code>Route::get('profile', function () {\n    // Only verified users may enter...\n})-&gt;middleware('verified');</code></pre>\n  <p>Si un usuario no verificado intenta acceder a una ruta a la que se le ha asignado este middleware, será redirigido automáticamente a la ruta nombrada .<code>verification.notice</code> </p>\n  <p></p>\n  <h2>Eventos</h2>\n  <p>Al usar Laravel Jetstream , Laravel envía eventos durante el proceso de verificación de correo electrónico. Si está manejando manualmente la verificación por correo electrónico para su aplicación, es posible que desee enviar estos eventos manualmente después de que se complete la verificación. Puede adjuntar oyentes a estos eventos en su <code>EventServiceProvider</code>:</p>\n  <pre><code>/**\n * The event listener mappings for the application.\n *\n * @var array\n */\nprotected $listen = [\n    'Illuminate\\Auth\\Events\\Verified' =&gt; [\n        'App\\Listeners\\LogVerifiedUser',\n    ],\n];</code></pre>\n</section>"
      },
      {
        "titulo": "5.4 Cifrado",
        "contenido": "<section>\n  <h1>Cifrado</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Configuración</li>\n    <li>Usando el cifrador</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>El cifrado de Laravel utiliza OpenSSL para proporcionar cifrado AES-256 y AES-128. Se le recomienda encarecidamente que utilice las funciones de cifrado integradas de Laravel y no intente utilizar sus propios algoritmos de cifrado \"de cosecha propia\". Todos los valores cifrados de Laravel se firman utilizando un código de autenticación de mensajes (MAC) para que su valor subyacente no se pueda modificar una vez cifrados.</p>\n  <p></p>\n  <h2>Configuración</h2>\n  <p>Antes de usar el cifrador de Laravel, debe establecer una <code>key</code>opción en su archivo de configuración. Debe usar el comando para generar esta clave, ya que este comando Artisan usará el generador seguro de bytes aleatorios de PHP para construir su clave. Si este valor no se establece correctamente, todos los valores cifrados por Laravel serán inseguros.<code>config/app.php</code><code>php artisan key:generate</code></p>\n  <p></p>\n  <h2>Usando el cifrador</h2>\n  <h4>Cifrar un valor</h4>\n  <p>Puede cifrar un valor utilizando el <code>encryptString</code>método de la <code>Crypt</code>fachada. Todos los valores cifrados se cifran mediante OpenSSL y el cifrado. Además, todos los valores cifrados están firmados con un código de autenticación de mensajes (MAC) para detectar cualquier modificación en la cadena cifrada:<code>AES-256-CBC</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\User;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Crypt;\n\nclass UserController extends Controller\n{\n    /**\n     * Store a secret message for the user.\n     *\n     * @param  Request  $request\n     * @param  int  $id\n     * @return Response\n     */\n    public function storeSecret(Request $request, $id)\n    {\n        $user = User::findOrFail($id);\n\n        $user-&gt;fill([\n            'secret' =&gt; Crypt::encryptString($request-&gt;secret),\n        ])-&gt;save();\n    }\n}</code></pre>\n  <h4>Descifrando un valor</h4>\n  <p>Puede descifrar valores utilizando el <code>decryptString</code>método de la <code>Crypt</code>fachada. Si el valor no se puede descifrar correctamente, como cuando el MAC no es válido, se lanzará un :<code>Illuminate\\Contracts\\Encryption\\DecryptException</code></p>\n  <pre><code>use Illuminate\\Contracts\\Encryption\\DecryptException;\nuse Illuminate\\Support\\Facades\\Crypt;\n\ntry {\n    $decrypted = Crypt::decryptString($encryptedValue);\n} catch (DecryptException $e) {\n    //\n}</code></pre>\n</section>"
      },
      {
        "titulo": "5.5 Hashing",
        "contenido": "<section>\n  <h1>Hashing</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Configuración</li>\n    <li>Uso básico</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>La <code>Hash</code> fachada de Laravel proporciona hash Bcrypt y Argon2 seguro para almacenar contraseñas de usuario. Si está utilizando el andamio de autenticación Laravel Jetstream , Bcrypt se usará para el registro y la autenticación de forma predeterminada.</p>\n  <blockquote>\n    <p> Bcrypt es una excelente opción para hacer hash de contraseñas porque su \"factor de trabajo\" es ajustable, lo que significa que el tiempo que se tarda en generar un hash se puede aumentar a medida que aumenta la potencia del hardware.</p>\n  </blockquote>\n  <p></p>\n  <h2>Configuración</h2>\n  <p>El controlador de hash predeterminado para su aplicación se configura en el archivo de configuración. Actualmente, hay tres controladores compatibles: Bcrypt y Argon2 (variantes Argon2i y Argon2id).<code>config/hashing.php</code></p>\n  <blockquote>\n    <p> El controlador Argon2i requiere PHP 7.2.0 o superior y el controlador Argon2id requiere PHP 7.3.0 o superior.</p>\n  </blockquote>\n  <p></p>\n  <h2>Uso básico</h2>\n  <p>Puede aplicar hash a una contraseña llamando al <code>make</code>método en la <code>Hash</code>fachada:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Hash;\n\nclass UpdatePasswordController extends Controller\n{\n    /**\n     * Update the password for the user.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function update(Request $request)\n    {\n        // Validate the new password length...\n\n        $request-&gt;user()-&gt;fill([\n            'password' =&gt; Hash::make($request-&gt;newPassword)\n        ])-&gt;save();\n    }\n}</code></pre>\n  <h4>Ajuste del factor de trabajo de Bcrypt</h4>\n  <p>Si está usando el algoritmo Bcrypt, el <code>make</code>método le permite administrar el factor de trabajo del algoritmo usando la <code>rounds</code>opción; sin embargo, el valor predeterminado es aceptable para la mayoría de las aplicaciones:</p>\n  <pre><code>$hashed = Hash::make('password', [\n    'rounds' =&gt; 12,\n]);</code></pre>\n  <h4>Ajuste del factor de trabajo de Argon2</h4>\n  <p>Si está utilizando el algoritmo ARGON2, el <code>make</code>método permite administrar el factor de trabajo del algoritmo mediante el <code>memory</code>, <code>time</code>y <code>threads</code>opciones; sin embargo, los valores predeterminados son aceptables para la mayoría de las aplicaciones:</p>\n  <pre><code>$hashed = Hash::make('password', [\n    'memory' =&gt; 1024,\n    'time' =&gt; 2,\n    'threads' =&gt; 2,\n]);</code></pre>\n  <blockquote>\n    <p>Para obtener más información sobre estas opciones, consulte la documentación oficial de PHP .</p>\n  </blockquote>\n  <h4>Verificación de una contraseña contra un hash</h4>\n  <p>El <code>check</code>método le permite verificar que una determinada cadena de texto sin formato corresponde a un determinado hash:</p>\n  <pre><code>if (Hash::check('plain-text', $hashedPassword)) {\n    // The passwords match...\n}</code></pre>\n  <h4>Comprobación de si es necesario volver a modificar una contraseña</h4>\n  <p>La <code>needsRehash</code>función le permite determinar si el factor de trabajo utilizado por el hash ha cambiado desde que se hizo el hash de la contraseña:</p>\n  <pre><code>if (Hash::needsRehash($hashed)) {\n    $hashed = Hash::make('plain-text');\n}</code></pre>\n</section>"
      },
      {
        "titulo": "5.6 Restablecimiento de contraseña",
        "contenido": "<section>\n  <h1>Restablecimiento de contraseñas</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Preparación del modelo</li>\n        <li>Preparación de la base de datos</li>\n      </ul></li>\n    <li>Enrutamiento\n      <ul>\n        <li>Solicitar el enlace de restablecimiento de contraseña</li>\n        <li>Restablecimiento de la contraseña</li>\n      </ul></li>\n    <li>Personalización</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>La mayoría de las aplicaciones web ofrecen a los usuarios una forma de restablecer sus contraseñas olvidadas. En lugar de obligarlo a volver a implementar esto en cada aplicación, Laravel proporciona métodos convenientes para enviar recordatorios de contraseña y realizar restablecimientos de contraseña.</p>\n  <blockquote>\n    <p>¿Quieres empezar rápido? Instale Laravel Jetstream en una nueva aplicación Laravel. Después de migrar su base de datos, navegue en su navegador hacia <code>/register</code>o cualquier otra URL asignada a su aplicación. Jetstream se encargará de montar todo su sistema de autenticación, ¡incluido el restablecimiento de contraseñas!</p>\n  </blockquote>\n  <p></p>\n  <h3>Preparación del modelo</h3>\n  <p>Antes de usar las funciones de restablecimiento de contraseña de Laravel, su modelo debe usar el rasgo. Normalmente, este rasgo se incluye automáticamente en el modelo predeterminado que se incluye con Laravel.<code>App\\Models\\User</code><code>Illuminate\\Notifications\\Notifiable</code><code>App\\Models\\User</code></p>\n  <p>Luego, verifique que su modelo implemente el contrato. El modelo incluido con el marco ya implementa esta interfaz y usa el rasgo para incluir los métodos necesarios para implementar la interfaz.<code>App\\Models\\User</code><code>Illuminate\\Contracts\\Auth\\CanResetPassword</code><code>App\\Models\\User</code><code>Illuminate\\Auth\\Passwords\\CanResetPassword</code></p>\n  <p></p>\n  <h3>Preparación de la base de datos</h3>\n  <p>Se debe crear una tabla para almacenar los tokens de restablecimiento de contraseña de su aplicación. La migración para esta tabla está incluida en la instalación predeterminada de Laravel, por lo que solo necesita migrar su base de datos para crear esta tabla:</p>\n  <pre><code>php artisan migrate</code></pre>\n  <p></p>\n  <h2>Enrutamiento</h2>\n  <p>Para implementar correctamente el soporte que permita a los usuarios restablecer sus contraseñas, necesitaremos definir varias rutas. Primero, necesitaremos un par de rutas para manejar que permitan al usuario solicitar un enlace de restablecimiento de contraseña a través de su dirección de correo electrónico. En segundo lugar, necesitaremos un par de rutas para manejar el restablecimiento de la contraseña una vez que el usuario visita el enlace de restablecimiento de contraseña que se le envía por correo electrónico.</p>\n  <p></p>\n  <h3>Solicitar el enlace de restablecimiento de contraseña</h3>\n  <h4>El formulario de solicitud de enlace de restablecimiento de contraseña</h4>\n  <p>Primero, definiremos las rutas necesarias para solicitar enlaces de restablecimiento de contraseña. Para comenzar, definiremos una ruta que devuelva una vista con el formulario de solicitud de enlace de restablecimiento de contraseña:</p>\n  <pre><code>Route::get('/forgot-password', function () {\n    return view('auth.forgot-password');\n})-&gt;middleware(['guest'])-&gt;name('password.request');</code></pre>\n  <p>La vista que devuelve esta ruta debe tener un formulario que contenga un <code>email</code>campo, que permitirá al usuario solicitar un enlace de restablecimiento de contraseña para una dirección de correo electrónico determinada.</p>\n  <h4>Manejo del envío del formulario</h4>\n  <p>A continuación, definiremos una ruta que manejará la solicitud del formulario desde la vista \"contraseña olvidada\". Esta ruta será la encargada de validar la dirección de correo electrónico y enviar la solicitud de restablecimiento de contraseña al usuario correspondiente:</p>\n  <pre><code>use Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Password;\n\nRoute::post('/forgot-password', function (Request $request) {\n    $request-&gt;validate(['email' =&gt; 'required|email']);\n\n    $status = Password::sendResetLink(\n        $request-&gt;only('email')\n    );\n\n    return $status === Password::RESET_LINK_SENT\n                ? back()-&gt;with(['status' =&gt; __($status)])\n                : back()-&gt;withErrors(['email' =&gt; __($status)]);\n})-&gt;middleware(['guest'])-&gt;name('password.email');</code></pre>\n  <p>Antes de continuar, examinemos esta ruta con más detalle. Primero, <code>email</code>se valida el atributo de la solicitud . A continuación, utilizaremos el \"intermediario de contraseñas\" integrado de Laravel (a través de la <code>Password</code>fachada) para enviar un enlace de restablecimiento de contraseña al usuario. El corredor de contraseñas se encargará de recuperar al usuario por el campo dado (en este caso, la dirección de correo electrónico) y enviar al usuario un enlace de restablecimiento de contraseña a través del sistema de notificación incorporado de Laravel .</p>\n  <p>El <code>sendResetLink</code>método devuelve un slug de \"estado\". Este estado puede traducirse utilizando los ayudantes de localización de Laravel para mostrar un mensaje fácil de usar al usuario sobre el estado de su solicitud. La traducción del estado de restablecimiento de la contraseña está determinada por el archivo de idioma de su aplicación . Una entrada para cada valor posible de la barra de estado se encuentra dentro del archivo de idioma.<code>resources/lang/{lang}/passwords.php</code><code>passwords</code></p>\n  <blockquote>\n    <p>Al implementar manualmente el restablecimiento de contraseñas, debe definir el contenido de las vistas y rutas usted mismo. Si desea un andamiaje que incluya toda la lógica de autenticación y verificación necesaria, consulte Laravel Jetstream .</p>\n  </blockquote>\n  <p></p>\n  <h3>Restablecimiento de la contraseña</h3>\n  <h4>El formulario de restablecimiento de contraseña</h4>\n  <p>A continuación, definiremos las rutas necesarias para restablecer realmente la contraseña una vez que el usuario haga clic en el enlace de restablecimiento de contraseña que se le envió por correo electrónico y proporcionó una nueva contraseña. Primero, definamos la ruta que mostrará el formulario de restablecimiento de contraseña que se muestra cuando el usuario hace clic en el enlace de restablecimiento de contraseña. Esta ruta recibirá un <code>token</code>parámetro que usaremos más adelante para verificar la solicitud de restablecimiento de contraseña:</p>\n  <pre><code>Route::get('/reset-password/{token}', function ($token) {\n    return view('auth.reset-password', ['token' =&gt; $token]);\n})-&gt;middleware(['guest'])-&gt;name('password.reset');</code></pre>\n  <p>La vista que devuelve esta ruta debe tener un formulario que contenga un <code>email</code>campo, un <code>password</code>campo, un <code>password_confirmation</code>campo y un <code>token</code>campo oculto , que debe contener el valor del token secreto recibido por nuestra ruta.</p>\n  <h4>Manejo del envío del formulario</h4>\n  <p>Por supuesto, necesitamos definir una ruta para manejar realmente el envío del formulario de restablecimiento de contraseña. Esta ruta será la encargada de validar la solicitud entrante y actualizar la contraseña del usuario en la base de datos:</p>\n  <pre><code>use Illuminate\\Auth\\Events\\PasswordReset;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Facades\\Password;\nuse Illuminate\\Support\\Str;\n\nRoute::post('/reset-password', function (Request $request) {\n    $request-&gt;validate([\n        'token' =&gt; 'required',\n        'email' =&gt; 'required|email',\n        'password' =&gt; 'required|min:8|confirmed',\n    ]);\n\n    $status = Password::reset(\n        $request-&gt;only('email', 'password', 'password_confirmation', 'token'),\n        function ($user, $password) use ($request) {\n            $user-&gt;forceFill([\n                'password' =&gt; Hash::make($password)\n            ])-&gt;save();\n\n            $user-&gt;setRememberToken(Str::random(60));\n\n            event(new PasswordReset($user));\n        }\n    );\n\n    return $status == Password::PASSWORD_RESET\n                ? redirect()-&gt;route('login')-&gt;with('status', __($status))\n                : back()-&gt;withErrors(['email' =&gt; __($status)]);\n})-&gt;middleware(['guest'])-&gt;name('password.update');</code></pre>\n  <p>Antes de continuar, examinemos esta ruta con más detalle. En primer lugar, de la solicitud <code>token</code>, <code>email</code>y <code>password</code>atributos se validan. A continuación, utilizaremos el \"intermediario de contraseñas\" integrado de Laravel (a través de la <code>Password</code>fachada) para validar las credenciales de solicitud de restablecimiento de contraseña.</p>\n  <p>Si el token, la dirección de correo electrónico y la contraseña proporcionados al corredor de contraseñas son válidos, <code>reset</code>se invocará el cierre pasado al método. Dentro de este Cierre, que recibe la instancia del usuario y la contraseña de texto sin formato, podemos actualizar la contraseña del usuario en la base de datos.</p>\n  <p>El <code>reset</code>método devuelve un slug de \"estado\". Este estado puede traducirse utilizando los ayudantes de localización de Laravel para mostrar un mensaje fácil de usar al usuario sobre el estado de su solicitud. La traducción del estado de restablecimiento de la contraseña está determinada por el archivo de idioma de su aplicación . Una entrada para cada valor posible de la barra de estado se encuentra dentro del archivo de idioma.<code>resources/lang/{lang}/passwords.php</code><code>passwords</code></p>\n  <p></p>\n  <h2>Personalización</h2>\n  <h4>Restablecer la personalización del correo electrónico</h4>\n  <p>Puede modificar fácilmente la clase de notificación utilizada para enviar el enlace de restablecimiento de contraseña al usuario. Para comenzar, anule el <code>sendPasswordResetNotification</code>método en su <code>User</code>modelo. Dentro de este método, puede enviar la notificación utilizando cualquier clase de notificación que elija. El restablecimiento de la contraseña <code>$token</code>es el primer argumento que recibe el método:</p>\n  <pre><code>/**\n * Send the password reset notification.\n *\n * @param  string  $token\n * @return void\n */\npublic function sendPasswordResetNotification($token)\n{\n    $this-&gt;notify(new ResetPasswordNotification($token));\n}</code></pre>\n</section>"
      }
    ]
  },
  {
    "titulo": "Avanzado",
    "subtitulo": "",
    "items": [
      {
        "titulo": "6.1 Consola artesanal",
        "contenido": "<section>\n  <h1>Consola artesanal</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Tinker (REPL)</li>\n      </ul></li>\n    <li>Comandos de escritura\n      <ul>\n        <li>Generando comandos</li>\n        <li>Estructura de mando</li>\n        <li>Comandos de cierre</li>\n      </ul></li>\n    <li>Definición de expectativas de entrada\n      <ul>\n        <li>Argumentos</li>\n        <li>Opciones</li>\n        <li>Matrices de entrada</li>\n        <li>Descripciones de entrada</li>\n      </ul></li>\n    <li>E / S de comando\n      <ul>\n        <li>Recuperando entrada</li>\n        <li>Solicitar información</li>\n        <li>Salida de escritura</li>\n      </ul></li>\n    <li>Registro de comandos</li>\n    <li>Ejecución de comandos mediante programación\n      <ul>\n        <li>Llamada a comandos desde otros comandos</li>\n      </ul></li>\n    <li>Personalización de stub</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Artisan es la interfaz de línea de comandos incluida con Laravel. Proporciona una serie de comandos útiles que pueden ayudarlo mientras crea su aplicación. Para ver una lista de todos los comandos Artisan disponibles, puede usar el <code>list</code>comando:</p>\n  <pre><code>php artisan list</code></pre>\n  <p>Cada comando también incluye una pantalla de \"ayuda\" que muestra y describe los argumentos y opciones disponibles del comando. Para ver una pantalla de ayuda, preceda el nombre del comando con <code>help</code>:</p>\n  <pre><code>php artisan help migrate</code></pre>\n  <p></p>\n  <h3>Tinker (REPL)</h3>\n  <p>Laravel Tinker es un poderoso REPL para el marco de Laravel, impulsado por el paquete PsySH .</p>\n  <h4>Instalación</h4>\n  <p>Todas las aplicaciones de Laravel incluyen Tinker por defecto. Sin embargo, puede instalarlo manualmente si es necesario usando Composer:</p>\n  <pre><code>composer require laravel/tinker</code></pre>\n  <h4>Uso</h4>\n  <p>Tinker le permite interactuar con toda su aplicación Laravel en la línea de comando, incluido el ORM de Eloquent, trabajos, eventos y más. Para ingresar al entorno de Tinker, ejecute el <code>tinker</code>comando Artisan:</p>\n  <pre><code>php artisan tinker</code></pre>\n  <p>Puede publicar el archivo de configuración de Tinker usando el comando:<code>vendor:publish</code></p>\n  <pre><code>php artisan vendor:publish --provider=\"Laravel\\Tinker\\TinkerServiceProvider\"</code></pre>\n  <blockquote>\n    <div><div></div><p>La <code>dispatch</code>función auxiliar y el <code>dispatch</code>método de la <code>Dispatchable</code>clase dependen de la recolección de basura para colocar el trabajo en la cola. Por lo tanto, cuando use tinker, debe usar o para enviar trabajos.<code>Bus::dispatch</code><code>Queue::push</code></p></div>\n  </blockquote>\n  <h4>Lista blanca de comandos</h4>\n  <p>Tinker utiliza una lista blanca para determinar qué comandos de Artisan pueden ejecutarse dentro de su shell. Por defecto, es posible que encuentre los , , , , , , y comandos. Si desea incluir más comandos en la lista blanca, puede agregarlos a la matriz en su archivo de configuración:<code>clear-compiled</code><code>down</code><code>env</code><code>inspire</code><code>migrate</code><code>optimize</code><code>up</code><code>commands</code><code>tinker.php</code></p>\n  <pre><code>'commands' =&gt; [\n    // App\\Console\\Commands\\ExampleCommand::class,\n],</code></pre>\n  <h4>Clases que no deben tener alias</h4>\n  <p>Por lo general, Tinker asigna automáticamente un alias a las clases según las requiera en Tinker. Sin embargo, es posible que desee nunca asignar un alias a algunas clases. Puede lograr esto enumerando las clases en la <code>dont_alias</code>matriz de su archivo de configuración:<code>tinker.php</code></p>\n  <pre><code>'dont_alias' =&gt; [\n    App\\Models\\User::class,\n],</code></pre>\n  <p></p>\n  <h2>Comandos de escritura</h2>\n  <p>Además de los comandos proporcionados con Artisan, también puede crear sus propios comandos personalizados. Los comandos se almacenan normalmente en el directorio; sin embargo, puede elegir su propia ubicación de almacenamiento siempre que Composer pueda cargar sus comandos.<code>app/Console/Commands</code></p>\n  <p></p>\n  <h3>Generando comandos</h3>\n  <p>Para crear un nuevo comando, use el comando Artisan. Este comando creará una nueva clase de comando en el directorio. No se preocupe si este directorio no existe en su aplicación, ya que se creará la primera vez que ejecute el comando Artisan. El comando generado incluirá el conjunto predeterminado de propiedades y métodos que están presentes en todos los comandos:<code>make:command</code><code>app/Console/Commands</code><code>make:command</code></p>\n  <pre><code>php artisan make:command SendEmails</code></pre>\n  <p></p>\n  <h3>Estructura de mando</h3>\n  <p>Después de generar su comando, debe completar las propiedades <code>signature</code>y <code>description</code>de la clase, que se utilizarán al mostrar su comando en la <code>list</code>pantalla. El <code>handle</code>método se llamará cuando se ejecute su comando. Puede colocar su lógica de comando en este método.</p>\n  <blockquote>\n    <div><div></div><p>Para una mayor reutilización del código, es una buena práctica mantener los comandos de la consola ligeros y dejar que se remitan a los servicios de la aplicación para realizar sus tareas. En el siguiente ejemplo, observe que inyectamos una clase de servicio para hacer el \"trabajo pesado\" de enviar los correos electrónicos.</p></div>\n  </blockquote>\n  <p>Echemos un vistazo a un comando de ejemplo. Tenga en cuenta que podemos inyectar cualquier dependencia que necesitemos en el <code>handle</code>método del comando . El contenedor de servicios de Laravel inyectará automáticamente todas las dependencias que están insinuadas en la firma de este método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Console\\Commands;\n\nuse App\\Models\\User;\nuse App\\Support\\DripEmailer;\nuse Illuminate\\Console\\Command;\n\nclass SendEmails extends Command\n{\n    /**\n     * The name and signature of the console command.\n     *\n     * @var string\n     */\n    protected $signature = 'email:send {user}';\n\n    /**\n     * The console command description.\n     *\n     * @var string\n     */\n    protected $description = 'Send drip e-mails to a user';\n\n    /**\n     * Create a new command instance.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        parent::__construct();\n    }\n\n    /**\n     * Execute the console command.\n     *\n     * @param  \\App\\Support\\DripEmailer  $drip\n     * @return mixed\n     */\n    public function handle(DripEmailer $drip)\n    {\n        $drip-&gt;send(User::find($this-&gt;argument('user')));\n    }\n}</code></pre>\n  <p></p>\n  <h3>Comandos de cierre</h3>\n  <p>Los comandos basados \u200B\u200Ben cierres proporcionan una alternativa a la definición de comandos de consola como clases. De la misma manera que los cierres de ruta son una alternativa a los controladores, piense en los cierres de comando como una alternativa a las clases de comando. Dentro del <code>commands</code>método de su archivo, Laravel carga el archivo:<code>app/Console/Kernel.php</code><code>routes/console.php</code></p>\n  <pre><code>/**\n * Register the Closure based commands for the application.\n *\n * @return void\n */\nprotected function commands()\n{\n    require base_path('routes/console.php');\n}</code></pre>\n  <p>Aunque este archivo no define rutas HTTP, define puntos de entrada (rutas) basados \u200B\u200Ben consola en su aplicación. Dentro de este archivo, puede definir todas sus rutas basadas en Closure utilizando el método. El método acepta dos argumentos: la firma del comando y un cierre que recibe los argumentos y opciones de los comandos:<code>Artisan::command</code><code>command</code></p>\n  <pre><code>Artisan::command('build {project}', function ($project) {\n    $this-&gt;info(\"Building {$project}!\");\n});</code></pre>\n  <p>El cierre está vinculado a la instancia de comando subyacente, por lo que tiene acceso completo a todos los métodos auxiliares a los que normalmente podría acceder en una clase de comando completa.</p>\n  <h4>Dependencias de sugerencias de tipo</h4>\n  <p>Además de recibir los argumentos y las opciones de su comando, los cierres de comandos también pueden indicar dependencias adicionales que le gustaría que se resolvieran fuera del contenedor de servicios :</p>\n  <pre><code>use App\\Models\\User;\nuse App\\Support\\DripEmailer;\n\nArtisan::command('email:send {user}', function (DripEmailer $drip, $user) {\n    $drip-&gt;send(User::find($user));\n});</code></pre>\n  <h4>Descripciones de los comandos de cierre</h4>\n  <p>Al definir un comando basado en Closure, puede usar el <code>describe</code>método para agregar una descripción al comando. Esta descripción se mostrará cuando ejecute los comandos o :<code>php artisan list</code><code>php artisan help</code></p>\n  <pre><code>Artisan::command('build {project}', function ($project) {\n    $this-&gt;info(\"Building {$project}!\");\n})-&gt;describe('Build the project');</code></pre>\n  <p></p>\n  <h2>Definición de expectativas de entrada</h2>\n  <p>Al escribir comandos de consola, es común recopilar información del usuario a través de argumentos u opciones. Laravel hace que sea muy conveniente definir la entrada que espera del usuario usando la <code>signature</code>propiedad en sus comandos. La <code>signature</code>propiedad le permite definir el nombre, los argumentos y las opciones del comando en una sintaxis única, expresiva y similar a una ruta.</p>\n  <p></p>\n  <h3>Argumentos</h3>\n  <p>Todos los argumentos y opciones proporcionados por el usuario están entre llaves. En el siguiente ejemplo, el comando define un argumento <strong>requerido</strong><code>user</code> ::</p>\n  <pre><code>/**\n * The name and signature of the console command.\n *\n * @var string\n */\nprotected $signature = 'email:send {user}';</code></pre>\n  <p>También puede hacer que los argumentos sean opcionales y definir valores predeterminados para los argumentos:</p>\n  <pre><code>// Optional argument...\nemail:send {user?}\n\n// Optional argument with default value...\nemail:send {user=foo}</code></pre>\n  <p></p>\n  <h3>Opciones</h3>\n  <p>Las opciones, como los argumentos, son otra forma de entrada del usuario. Las opciones tienen como prefijo dos guiones ( <code>--</code>) cuando se especifican en la línea de comandos. Hay dos tipos de opciones: las que reciben un valor y las que no. Las opciones que no reciben un valor sirven como un \"cambio\" booleano. Echemos un vistazo a un ejemplo de este tipo de opción:</p>\n  <pre><code>/**\n * The name and signature of the console command.\n *\n * @var string\n */\nprotected $signature = 'email:send {user} {--queue}';</code></pre>\n  <p>En este ejemplo, el <code>--queue</code>conmutador se puede especificar al llamar al comando Artisan. Si <code>--queue</code>se pasa el cambio, el valor de la opción será <code>true</code>. De lo contrario, el valor será <code>false</code>:</p>\n  <pre><code>php artisan email:send 1 --queue</code></pre>\n  <p></p>\n  <h4>Opciones con valores</h4>\n  <p>A continuación, echemos un vistazo a una opción que espera un valor. Si el usuario debe especificar un valor para una opción, agregue un sufijo al nombre de la opción con un <code>=</code>signo:</p>\n  <pre><code>/**\n * The name and signature of the console command.\n *\n * @var string\n */\nprotected $signature = 'email:send {user} {--queue=}';</code></pre>\n  <p>En este ejemplo, el usuario puede pasar un valor para la opción así:</p>\n  <pre><code>php artisan email:send 1 --queue=default</code></pre>\n  <p>Puede asignar valores predeterminados a las opciones especificando el valor predeterminado después del nombre de la opción. Si el usuario no pasa ningún valor de opción, se utilizará el valor predeterminado:</p>\n  <pre><code>email:send {user} {--queue=default}</code></pre>\n  <p></p>\n  <h4>Atajos de opciones</h4>\n  <p>Para asignar un atajo al definir una opción, puede especificarlo antes del nombre de la opción y usar un | delimitador para separar el acceso directo del nombre completo de la opción:</p>\n  <pre><code>email:send {user} {--Q|queue}</code></pre>\n  <p></p>\n  <h3>Matrices de entrada</h3>\n  <p>Si desea definir argumentos u opciones para esperar entradas de matriz, puede usar el <code>*</code>carácter. Primero, echemos un vistazo a un ejemplo que especifica un argumento de matriz:</p>\n  <pre><code>email:send {user*}</code></pre>\n  <p>Al llamar a este método, los <code>user</code>argumentos pueden pasarse en orden a la línea de comando. Por ejemplo, el siguiente comando establecerá el valor de <code>user</code>en :<code>['foo', 'bar']</code></p>\n  <pre><code>php artisan email:send foo bar</code></pre>\n  <p>Al definir una opción que espera una entrada de matriz, cada valor de opción pasado al comando debe tener el prefijo del nombre de la opción:</p>\n  <pre><code>email:send {user} {--id=*}\n\nphp artisan email:send --id=1 --id=2</code></pre>\n  <p></p>\n  <h3>Descripciones de entrada</h3>\n  <p>Puede asignar descripciones a los argumentos y opciones de entrada separando el parámetro de la descripción con dos puntos. Si necesita un poco más de espacio para definir su comando, no dude en distribuir la definición en varias líneas:</p>\n  <pre><code>/**\n * The name and signature of the console command.\n *\n * @var string\n */\nprotected $signature = 'email:send\n                        {user : The ID of the user}\n                        {--queue= : Whether the job should be queued}';</code></pre>\n  <p></p>\n  <h2>E / S de comando</h2>\n  <p></p>\n  <h3>Recuperando entrada</h3>\n  <p>Mientras su comando se está ejecutando, obviamente necesitará acceder a los valores de los argumentos y opciones aceptados por su comando. Para hacerlo, puede utilizar los métodos <code>argument</code>y <code>option</code>:</p>\n  <pre><code>/**\n * Execute the console command.\n *\n * @return mixed\n */\npublic function handle()\n{\n    $userId = $this-&gt;argument('user');\n\n    //\n}</code></pre>\n  <p>Si necesita recuperar todos los argumentos como un <code>array</code>, llame al <code>arguments</code>método:</p>\n  <pre><code>$arguments = $this-&gt;arguments();</code></pre>\n  <p>Las opciones se pueden recuperar con la misma facilidad que los argumentos utilizando el <code>option</code>método. Para recuperar todas las opciones como una matriz, llame al <code>options</code>método:</p>\n  <pre><code>// Retrieve a specific option...\n$queueName = $this-&gt;option('queue');\n\n// Retrieve all options...\n$options = $this-&gt;options();</code></pre>\n  <p>Si el argumento u opción no existe, <code>null</code>se devolverá.</p>\n  <p></p>\n  <h3>Solicitar información</h3>\n  <p>Además de mostrar la salida, también puede pedirle al usuario que proporcione información durante la ejecución de su comando. El <code>ask</code>método solicitará al usuario la pregunta dada, aceptará su entrada y luego devolverá la entrada del usuario a su comando:</p>\n  <pre><code>/**\n * Execute the console command.\n *\n * @return mixed\n */\npublic function handle()\n{\n    $name = $this-&gt;ask('What is your name?');\n}</code></pre>\n  <p>El <code>secret</code>método es similar a <code>ask</code>, pero la entrada del usuario no será visible para ellos mientras escribe en la consola. Este método es útil cuando se solicita información confidencial, como una contraseña:</p>\n  <pre><code>$password = $this-&gt;secret('What is the password?');</code></pre>\n  <h4>Pidiendo confirmación</h4>\n  <p>Si necesita pedirle al usuario una simple confirmación, puede utilizar el <code>confirm</code>método. De forma predeterminada, este método volverá <code>false</code>. Sin embargo, si el usuario ingresa <code>y</code>o <code>yes</code>responde a la solicitud, el método regresará <code>true</code>.</p>\n  <pre><code>if ($this-&gt;confirm('Do you wish to continue?')) {\n    //\n}</code></pre>\n  <h4>Autocompletar</h4>\n  <p>El <code>anticipate</code>método se puede utilizar para proporcionar autocompletar para posibles opciones. El usuario aún puede elegir cualquier respuesta, independientemente de las sugerencias de autocompletar:</p>\n  <pre><code>$name = $this-&gt;anticipate('What is your name?', ['Taylor', 'Dayle']);</code></pre>\n  <p>Alternativamente, puede pasar un Closure como segundo argumento del <code>anticipate</code>método. El cierre se llamará cada vez que el usuario escriba un carácter de entrada. El cierre debe aceptar un parámetro de cadena que contenga la entrada del usuario hasta ahora y devolver una matriz de opciones para autocompletar:</p>\n  <pre><code>$name = $this-&gt;anticipate('What is your name?', function ($input) {\n    // Return auto-completion options...\n});</code></pre>\n  <h4>Preguntas de selección múltiple</h4>\n  <p>Si necesita darle al usuario un conjunto predefinido de opciones, puede usar el <code>choice</code>método. Puede configurar el índice de matriz del valor predeterminado que se devolverá si no se elige ninguna opción:</p>\n  <pre><code>$name = $this-&gt;choice('What is your name?', ['Taylor', 'Dayle'], $defaultIndex);</code></pre>\n  <p>Además, el <code>choice</code>método acepta argumentos cuarto y quinto opcionales para determinar el número máximo de intentos para seleccionar una respuesta válida y si se permiten selecciones múltiples:</p>\n  <pre><code>$name = $this-&gt;choice(\n    'What is your name?',\n    ['Taylor', 'Dayle'],\n    $defaultIndex,\n    $maxAttempts = null,\n    $allowMultipleSelections = false\n);</code></pre>\n  <p></p>\n  <h3>Salida de escritura</h3>\n  <p>Para enviar la salida a la consola, utilice los <code>line</code>, <code>info</code>, <code>comment</code>, <code>question</code>y <code>error</code>métodos. Cada uno de estos métodos utilizará colores ANSI apropiados para su propósito. Por ejemplo, mostremos información general al usuario. Normalmente, el <code>info</code>método se mostrará en la consola como texto verde:</p>\n  <pre><code>/**\n * Execute the console command.\n *\n * @return mixed\n */\npublic function handle()\n{\n    $this-&gt;info('Display this on the screen');\n}</code></pre>\n  <p>Para mostrar un mensaje de error, use el <code>error</code>método. El texto del mensaje de error generalmente se muestra en rojo:</p>\n  <pre><code>$this-&gt;error('Something went wrong!');</code></pre>\n  <p>Si desea mostrar una salida de consola simple y sin color, use el <code>line</code>método:</p>\n  <pre><code>$this-&gt;line('Display this on the screen');</code></pre>\n  <h4>Diseños de mesa</h4>\n  <p>El <code>table</code>método facilita el formateo correcto de varias filas / columnas de datos. Simplemente pase los encabezados y filas al método. El ancho y la altura se calcularán dinámicamente en función de los datos proporcionados:</p>\n  <pre><code>$headers = ['Name', 'Email'];\n\n$users = App\\Models\\User::all(['name', 'email'])-&gt;toArray();\n\n$this-&gt;table($headers, $users);</code></pre>\n  <h4>Barras de progreso</h4>\n  <p>Para tareas de ejecución prolongada, puede resultar útil mostrar un indicador de progreso. Usando el objeto de salida, podemos iniciar, avanzar y detener la barra de progreso. Primero, defina el número total de pasos que recorrerá el proceso. Luego, avance la barra de progreso después de procesar cada elemento:</p>\n  <pre><code>$users = App\\Models\\User::all();\n\n$bar = $this-&gt;output-&gt;createProgressBar(count($users));\n\n$bar-&gt;start();\n\nforeach ($users as $user) {\n    $this-&gt;performTask($user);\n\n    $bar-&gt;advance();\n}\n\n$bar-&gt;finish();</code></pre>\n  <p>Para opciones más avanzadas, consulte la documentación del componente de la barra de progreso de Symfony .</p>\n  <p></p>\n  <h2>Registro de comandos</h2>\n  <p>Debido a la <code>load</code>llamada al método en el <code>commands</code>método del kernel de su consola , todos los comandos dentro del directorio se registrarán automáticamente con Artisan. De hecho, puede realizar llamadas adicionales al método para escanear otros directorios en busca de comandos Artisan:<code>app/Console/Commands</code><code>load</code></p>\n  <pre><code>/**\n * Register the commands for the application.\n *\n * @return void\n */\nprotected function commands()\n{\n    $this-&gt;load(__DIR__.'/Commands');\n    $this-&gt;load(__DIR__.'/MoreCommands');\n\n    // ...\n}</code></pre>\n  <p>También puede registrar comandos manualmente agregando su nombre de clase a la <code>$commands</code>propiedad de su archivo. Cuando Artisan arranca, todos los comandos enumerados en esta propiedad serán resueltos por el contenedor de servicios y registrados con Artisan:<code>app/Console/Kernel.php</code></p>\n  <pre><code>protected $commands = [\n    Commands\\SendEmails::class\n];</code></pre>\n  <p></p>\n  <h2>Ejecución de comandos mediante programación</h2>\n  <p>A veces, es posible que desee ejecutar un comando Artisan fuera de la CLI. Por ejemplo, es posible que desee disparar un comando Artisan desde una ruta o controlador. Puede usar el <code>call</code>método en la <code>Artisan</code>fachada para lograr esto. El <code>call</code>método acepta el nombre o la clase del comando como primer argumento y una matriz de parámetros del comando como segundo argumento. Se devolverá el código de salida:</p>\n  <pre><code>Route::get('/foo', function () {\n    $exitCode = Artisan::call('email:send', [\n        'user' =&gt; 1, '--queue' =&gt; 'default'\n    ]);\n\n    //\n});</code></pre>\n  <p>Alternativamente, puede pasar el comando Artisan completo al <code>call</code>método como una cadena:</p>\n  <pre><code>Artisan::call('email:send 1 --queue=default');</code></pre>\n  <p>Usando el <code>queue</code>método en la <code>Artisan</code>fachada, incluso puede poner en cola comandos Artisan para que sean procesados \u200B\u200Ben segundo plano por sus trabajadores de cola . Antes de usar este método, asegúrese de haber configurado su cola y está ejecutando un detector de cola:</p>\n  <pre><code>Route::get('/foo', function () {\n    Artisan::queue('email:send', [\n        'user' =&gt; 1, '--queue' =&gt; 'default'\n    ]);\n\n    //\n});</code></pre>\n  <p>También puede especificar la conexión o cola a la que se debe enviar el comando Artisan:</p>\n  <pre><code>Artisan::queue('email:send', [\n    'user' =&gt; 1, '--queue' =&gt; 'default'\n])-&gt;onConnection('redis')-&gt;onQueue('commands');</code></pre>\n  <h4>Pasar valores de matriz</h4>\n  <p>Si su comando define una opción que acepta una matriz, puede pasar una matriz de valores a esa opción:</p>\n  <pre><code>Route::get('/foo', function () {\n    $exitCode = Artisan::call('email:send', [\n        'user' =&gt; 1, '--id' =&gt; [5, 13]\n    ]);\n});</code></pre>\n  <h4>Pasar valores booleanos</h4>\n  <p>Si necesita especificar el valor de una opción que no acepta valores de cadena, como la <code>--force</code>marca en el comando, debe pasar o :<code>migrate:refresh</code><code>true</code><code>false</code></p>\n  <pre><code>$exitCode = Artisan::call('migrate:refresh', [\n    '--force' =&gt; true,\n]);</code></pre>\n  <p></p>\n  <h3>Llamada a comandos desde otros comandos</h3>\n  <p>A veces es posible que desee llamar a otros comandos desde un comando Artisan existente. Puede hacerlo utilizando el <code>call</code>método. Este <code>call</code>método acepta el nombre del comando y una matriz de parámetros del comando:</p>\n  <pre><code>/**\n * Execute the console command.\n *\n * @return mixed\n */\npublic function handle()\n{\n    $this-&gt;call('email:send', [\n        'user' =&gt; 1, '--queue' =&gt; 'default'\n    ]);\n\n    //\n}</code></pre>\n  <p>Si desea llamar a otro comando de consola y suprimir toda su salida, puede usar el <code>callSilent</code>método. El <code>callSilent</code>método tiene la misma firma que el <code>call</code>método:</p>\n  <pre><code>$this-&gt;callSilent('email:send', [\n    'user' =&gt; 1, '--queue' =&gt; 'default'\n]);</code></pre>\n  <p></p>\n  <h2>Personalización de stub</h2>\n  <p>Los <code>make</code>comandos de la consola Artisan se utilizan para crear una variedad de clases, como controladores, trabajos, migraciones y pruebas. Estas clases se generan utilizando archivos \"stub\" que se rellenan con valores basados \u200B\u200Ben su entrada. Sin embargo, es posible que a veces desee realizar pequeños cambios en los archivos generados por Artisan. Para lograr esto, puede usar el comando para publicar los stubs más comunes para personalizarlos:<code>stub:publish</code></p>\n  <pre><code>php artisan stub:publish</code></pre>\n  <p>Los stubs publicados se ubicarán dentro de un <code>stubs</code>directorio en la raíz de su aplicación. Cualquier cambio que realice en estos stubs se reflejará cuando genere sus clases correspondientes utilizando los <code>make</code>comandos de Artisan .</p>\n</section>"
      },
      {
        "titulo": "6.2 Radio difusión",
        "contenido": "<section>\n  <h1>Radiodifusión</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Configuración</li>\n        <li>Requisitos previos del controlador</li>\n      </ul></li>\n    <li>Resumen del concepto\n      <ul>\n        <li>Usando una aplicación de ejemplo</li>\n      </ul></li>\n    <li>Definición de eventos de transmisión\n      <ul>\n        <li>Nombre de transmisión</li>\n        <li>Transmisión de datos</li>\n        <li>Cola de transmisión</li>\n        <li>Condiciones de transmisión</li>\n      </ul></li>\n    <li>Canales de autorización\n      <ul>\n        <li>Definición de rutas de autorización</li>\n        <li>Definición de devoluciones de llamada de autorización</li>\n        <li>Definición de clases de canales</li>\n      </ul></li>\n    <li>Eventos de transmisión\n      <ul>\n        <li>Solo para otros</li>\n      </ul></li>\n    <li>Recibir transmisiones\n      <ul>\n        <li>Instalación de Laravel Echo</li>\n        <li>Escuchando eventos</li>\n        <li>Saliendo de un canal</li>\n        <li>Espacios de nombres</li>\n      </ul></li>\n    <li>Canales de presencia\n      <ul>\n        <li>Autorización de canales de presencia</li>\n        <li>Unirse a los canales de presencia</li>\n        <li>Transmisión a canales de presencia</li>\n      </ul></li>\n    <li>Eventos del cliente</li>\n    <li>Notificaciones</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>En muchas aplicaciones web modernas, los WebSockets se utilizan para implementar interfaces de usuario que se actualizan en tiempo real. Cuando se actualizan algunos datos en el servidor, normalmente se envía un mensaje a través de una conexión WebSocket para que lo maneje el cliente. Esto proporciona una alternativa más sólida y eficiente para sondear continuamente su aplicación en busca de cambios.</p>\n  <p>Para ayudarlo a crear este tipo de aplicaciones, Laravel facilita la \"transmisión\" de sus eventos a través de una conexión WebSocket. La transmisión de sus eventos de Laravel le permite compartir los mismos nombres de eventos entre su código del lado del servidor y su aplicación JavaScript del lado del cliente.</p>\n  <blockquote>\n    <div><div></div><p>Antes de sumergirse en la transmisión de eventos, asegúrese de haber leído toda la documentación relacionada con los eventos y oyentes de Laravel .</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Configuración</h3>\n  <p>Toda la configuración de transmisión de eventos de su aplicación se almacena en el archivo de configuración. Laravel admite varios controladores de transmisión listos para usar: Pusher Channels , Redis y un controlador para el desarrollo local y la depuración. Además, se incluye un controlador que le permite deshabilitar totalmente la transmisión. Se incluye un ejemplo de configuración para cada uno de estos controladores en el archivo de configuración.<code>config/broadcasting.php</code><code>log</code><code>null</code><code>config/broadcasting.php</code></p>\n  <h4>Proveedor de servicios de transmisión</h4>\n  <p>Antes de transmitir cualquier evento, primero deberá registrar el . En aplicaciones nuevas de Laravel, solo necesita descomentar este proveedor en la matriz de su archivo de configuración. Este proveedor le permitirá registrar las rutas de autorización de transmisión y las devoluciones de llamada.<code>App\\Providers\\BroadcastServiceProvider</code><code>providers</code><code>config/app.php</code></p>\n  <h4>Token CSRF</h4>\n  <p>Laravel Echo necesitará acceso al token CSRF de la sesión actual. Debe verificar que el <code>head</code>elemento HTML de su aplicación define una <code>meta</code>etiqueta que contiene el token CSRF:</p>\n  <pre><code>&lt;meta name=\"csrf-token\" content=\"{{ csrf_token() }}\"&gt;</code></pre>\n  <p></p>\n  <h3>Requisitos previos del controlador</h3>\n  <h4>Canales de empuje</h4>\n  <p>Si está transmitiendo sus eventos a través de Pusher Channels , debe instalar el SDK PHP de Pusher Channels usando el administrador de paquetes Composer:</p>\n  <pre><code>composer require pusher/pusher-php-server \"~4.0\"</code></pre>\n  <p>A continuación, debe configurar las credenciales de sus canales en el archivo de configuración. En este archivo ya se incluye un ejemplo de configuración de Canales, lo que le permite especificar rápidamente su clave, secreto e ID de aplicación de Canales. La configuración del archivo también le permite especificar adicionales que son compatibles con los canales, como el clúster:<code>config/broadcasting.php</code><code>config/broadcasting.php</code><code>pusher</code><code>options</code></p>\n  <pre><code>'options' =&gt; [\n    'cluster' =&gt; 'eu',\n    'useTLS' =&gt; true\n],</code></pre>\n  <p>Cuando use Channels y Laravel Echo , debe especificar <code>pusher</code>como su locutor deseado al crear una instancia de Echo en su archivo:<code>resources/js/bootstrap.js</code></p>\n  <pre><code>import Echo from \"laravel-echo\";\n\nwindow.Pusher = require('pusher-js');\n\nwindow.Echo = new Echo({\n    broadcaster: 'pusher',\n    key: 'your-pusher-channels-key'\n});</code></pre>\n  <p>Finalmente, deberá cambiar su controlador de transmisión a <code>pusher</code>en su <code>.env</code>archivo:</p>\n  <pre><code>BROADCAST_DRIVER=pusher</code></pre>\n  <h4>Websockets Laravel compatibles con Pusher</h4>\n  <p>Los laravel-websockets es un PHP puro, Pusher paquete WebSocket compatible para laravel. Este paquete le permite aprovechar todo el poder de la transmisión de Laravel sin un proveedor de websocket externo o Node. Para obtener más información sobre la instalación y el uso de este paquete, consulte su documentación oficial .</p>\n  <h4>Redis</h4>\n  <p>Si está utilizando la emisora \u200B\u200BRedis, debe instalar la extensión PHP phpredis a través de PECL o instalar la biblioteca Predis a través de Composer:</p>\n  <pre><code>composer require predis/predis</code></pre>\n  <p>A continuación, debe actualizar su controlador de transmisión <code>redis</code>en su <code>.env</code>archivo:</p>\n  <pre><code>BROADCAST_DRIVER=redis</code></pre>\n  <p>La emisora \u200B\u200Bde Redis transmitirá mensajes utilizando la función pub / sub de Redis; sin embargo, necesitará emparejar esto con un servidor WebSocket que pueda recibir los mensajes de Redis y transmitirlos a sus canales WebSocket.</p>\n  <p>Cuando la emisora \u200B\u200Bde Redis publica un evento, se publicará en los nombres de canal especificados del evento y la carga útil será una cadena codificada en JSON que contiene el nombre del evento, una <code>data</code>carga útil y el usuario que generó el ID de socket del evento (si corresponde).</p>\n  <h4>Socket.IO</h4>\n  <p>Si va a emparejar la emisora \u200B\u200BRedis con un servidor Socket.IO, deberá incluir la biblioteca cliente JavaScript Socket.IO en su aplicación. Puede instalarlo a través del administrador de paquetes NPM:</p>\n  <pre><code>npm install --save socket.io-client</code></pre>\n  <p>A continuación, deberá crear una instancia de Echo con el conector y un .<code>socket.io</code><code>host</code></p>\n  <pre><code>import Echo from \"laravel-echo\"\n\nwindow.io = require('socket.io-client');\n\nwindow.Echo = new Echo({\n    broadcaster: 'socket.io',\n    host: window.location.hostname + ':6001'\n});</code></pre>\n  <p>Finalmente, necesitará ejecutar un servidor Socket.IO compatible. Laravel no incluye una implementación de servidor Socket.IO; sin embargo, actualmente se mantiene un servidor Socket.IO impulsado por la comunidad en el repositorio de GitHub tlaverdure / laravel-echo-server .</p>\n  <h4>Requisitos previos de la cola</h4>\n  <p>Antes de difundir eventos, también deberá configurar y ejecutar un detector de cola . Toda la transmisión de eventos se realiza a través de trabajos en cola para que el tiempo de respuesta de su aplicación no se vea seriamente afectado.</p>\n  <p></p>\n  <h2>Resumen del concepto</h2>\n  <p>La transmisión de eventos de Laravel le permite transmitir sus eventos de Laravel del lado del servidor a su aplicación JavaScript del lado del cliente utilizando un enfoque basado en controladores para WebSockets. Actualmente, Laravel se envía con controladores Pusher Channels y Redis. Los eventos se pueden consumir fácilmente en el lado del cliente utilizando el paquete Laravel Echo Javascript.</p>\n  <p>Los eventos se transmiten por \"canales\", que pueden especificarse como públicos o privados. Cualquier visitante de su aplicación puede suscribirse a un canal público sin ninguna autenticación o autorización; sin embargo, para suscribirse a un canal privado, un usuario debe estar autenticado y autorizado para escuchar en ese canal.</p>\n  <blockquote>\n    <div><div></div><p>Si desea utilizar una alternativa de código abierto impulsada por PHP a Pusher, consulte el paquete laravel-websockets .</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Usando una aplicación de ejemplo</h3>\n  <p>Antes de sumergirnos en cada componente de la transmisión de eventos, tomemos una descripción general de alto nivel utilizando una tienda de comercio electrónico como ejemplo. No discutiremos los detalles de la configuración de Pusher Channels o Laravel Echo, ya que eso se discutirá en detalle en otras secciones de esta documentación.</p>\n  <p>En nuestra aplicación, supongamos que tenemos una página que permite a los usuarios ver el estado de envío de sus pedidos. Supongamos también que se activa un <code>ShippingStatusUpdated</code>evento cuando la aplicación procesa una actualización del estado de envío:</p>\n  <pre><code>event(new ShippingStatusUpdated($update));</code></pre>\n  <h4>La <code>ShouldBroadcast</code>interfaz</h4>\n  <p>Cuando un usuario está viendo uno de sus pedidos, no queremos que tenga que actualizar la página para ver las actualizaciones de estado. En cambio, queremos transmitir las actualizaciones a la aplicación a medida que se crean. Entonces, necesitamos marcar el <code>ShippingStatusUpdated</code>evento con la <code>ShouldBroadcast</code>interfaz. Esto le indicará a Laravel que transmita el evento cuando se active:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Events;\n\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Broadcasting\\PresenceChannel;\nuse Illuminate\\Broadcasting\\PrivateChannel;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass ShippingStatusUpdated implements ShouldBroadcast\n{\n    /**\n     * Information about the shipping status update.\n     *\n     * @var string\n     */\n    public $update;\n}</code></pre>\n  <p>La <code>ShouldBroadcast</code>interfaz requiere que nuestro evento defina un <code>broadcastOn</code>método. Este método se encarga de devolver los canales en los que debería emitirse el evento. Un código auxiliar vacío de este método ya está definido en las clases de eventos generadas, por lo que solo necesitamos completar sus detalles. Solo queremos que el creador del pedido pueda ver las actualizaciones de estado, por lo que transmitiremos el evento en un canal privado que esté vinculado al pedido:</p>\n  <pre><code>/**\n * Get the channels the event should broadcast on.\n *\n * @return \\Illuminate\\Broadcasting\\PrivateChannel\n */\npublic function broadcastOn()\n{\n    return new PrivateChannel('order.'.$this-&gt;update-&gt;order_id);\n}</code></pre>\n  <h4>Canales de autorización</h4>\n  <p>Recuerde, los usuarios deben estar autorizados para escuchar en canales privados. Podemos definir nuestras reglas de autorización de canal en el archivo. En este ejemplo, debemos verificar que cualquier usuario que intente escuchar en el canal privado sea \u200B\u200Ben realidad el creador de la orden:<code>routes/channels.php</code><code>order.1</code></p>\n  <pre><code>Broadcast::channel('order.{orderId}', function ($user, $orderId) {\n    return $user-&gt;id === Order::findOrNew($orderId)-&gt;user_id;\n});</code></pre>\n  <p>El <code>channel</code>método acepta dos argumentos: el nombre del canal y una devolución de llamada que devuelve <code>true</code>o <code>false</code>indica si el usuario está autorizado a escuchar en el canal.</p>\n  <p>Todas las devoluciones de llamada de autorización reciben al usuario actualmente autenticado como su primer argumento y cualquier parámetro comodín adicional como sus argumentos posteriores. En este ejemplo, usamos el marcador de posición para indicar que la parte \"ID\" del nombre del canal es un comodín.<code>{orderId}</code></p>\n  <h4>Escuchar transmisiones de eventos</h4>\n  <p>A continuación, todo lo que queda es escuchar el evento en nuestra aplicación JavaScript. Podemos hacer esto usando Laravel Echo. Primero, usaremos el <code>private</code>método para suscribirnos al canal privado. Entonces, podemos usar el <code>listen</code>método para escuchar el <code>ShippingStatusUpdated</code>evento. De forma predeterminada, todas las propiedades públicas del evento se incluirán en el evento de transmisión:</p>\n  <pre><code>Echo.private(`order.${orderId}`)\n    .listen('ShippingStatusUpdated', (e) =&gt; {\n        console.log(e.update);\n    });</code></pre>\n  <p></p>\n  <h2>Definición de eventos de transmisión</h2>\n  <p>Para informar a Laravel de que se debe transmitir un evento determinado, implemente la interfaz en la clase de evento. Esta interfaz ya está importada a todas las clases de eventos generadas por el marco, por lo que puede agregarla fácilmente a cualquiera de sus eventos.<code>Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast</code></p>\n  <p>La <code>ShouldBroadcast</code>interfaz que se requiere para implementar un único método: <code>broadcastOn</code>. El <code>broadcastOn</code>método debe devolver un canal o una serie de canales en los que debe transmitirse el evento. Los canales deben ser instancias de <code>Channel</code>, <code>PrivateChannel</code>, o <code>PresenceChannel</code>. Los casos de <code>Channel</code>representan los canales públicos que cualquier usuario puede suscribirse a, mientras que <code>PrivateChannels</code>y <code>PresenceChannels</code>representar a los canales privados que requieren la autorización del canal :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Events;\n\nuse App\\Models\\User;\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Broadcasting\\PresenceChannel;\nuse Illuminate\\Broadcasting\\PrivateChannel;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass ServerCreated implements ShouldBroadcast\n{\n    use SerializesModels;\n\n    public $user;\n\n    /**\n     * Create a new event instance.\n     *\n     * @return void\n     */\n    public function __construct(User $user)\n    {\n        $this-&gt;user = $user;\n    }\n\n    /**\n     * Get the channels the event should broadcast on.\n     *\n     * @return Channel|array\n     */\n    public function broadcastOn()\n    {\n        return new PrivateChannel('user.'.$this-&gt;user-&gt;id);\n    }\n}</code></pre>\n  <p>Entonces, solo necesita disparar el evento como lo haría normalmente. Una vez que se ha disparado el evento, un trabajo en cola transmitirá automáticamente el evento a través de su controlador de transmisión especificado.</p>\n  <p></p>\n  <h3>Nombre de transmisión</h3>\n  <p>De forma predeterminada, Laravel transmitirá el evento usando el nombre de la clase del evento. Sin embargo, puede personalizar el nombre de la transmisión definiendo un <code>broadcastAs</code>método en el evento:</p>\n  <pre><code>/**\n * The event's broadcast name.\n *\n * @return string\n */\npublic function broadcastAs()\n{\n    return 'server.created';\n}</code></pre>\n  <p>Si personaliza el nombre de la transmisión usando el <code>broadcastAs</code>método, debe asegurarse de registrar a su oyente con un <code>.</code>personaje principal . Esto le indicará a Echo que no anteponga el espacio de nombres de la aplicación al evento:</p>\n  <pre><code>.listen('.server.created', function (e) {\n    ....\n});</code></pre>\n  <p></p>\n  <h3>Transmisión de datos</h3>\n  <p>Cuando se transmite un evento, todas sus <code>public</code>propiedades se serializan y transmiten automáticamente como la carga útil del evento, lo que le permite acceder a cualquiera de sus datos públicos desde su aplicación JavaScript. Entonces, por ejemplo, si su evento tiene una sola <code>$user</code>propiedad pública que contiene un modelo Eloquent, la carga útil de transmisión del evento sería:</p>\n  <pre><code>{\n    \"user\": {\n        \"id\": 1,\n        \"name\": \"Patrick Stewart\"\n        ...\n    }\n}</code></pre>\n  <p>Sin embargo, si desea tener un control más detallado sobre su carga útil de transmisión, puede agregar un <code>broadcastWith</code>método a su evento. Este método debe devolver la matriz de datos que desea transmitir como carga útil del evento:</p>\n  <pre><code>/**\n * Get the data to broadcast.\n *\n * @return array\n */\npublic function broadcastWith()\n{\n    return ['id' =&gt; $this-&gt;user-&gt;id];\n}</code></pre>\n  <p></p>\n  <h3>Cola de transmisión</h3>\n  <p>De forma predeterminada, cada evento de difusión se coloca en la cola predeterminada para la conexión de cola predeterminada especificada en su archivo de configuración. Puede personalizar la cola utilizada por la emisora \u200B\u200Bdefiniendo una propiedad en su clase de evento. Esta propiedad debe especificar el nombre de la cola que desea usar al transmitir:<code>queue.php</code><code>broadcastQueue</code></p>\n  <pre><code>/**\n * The name of the queue on which to place the event.\n *\n * @var string\n */\npublic $broadcastQueue = 'your-queue-name';</code></pre>\n  <p>Si desea transmitir su evento utilizando la <code>sync</code>cola en lugar del controlador de cola predeterminado, puede implementar la <code>ShouldBroadcastNow</code>interfaz en lugar de <code>ShouldBroadcast</code>:</p>\n  <pre><code>&lt;?php\n\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow;\n\nclass ShippingStatusUpdated implements ShouldBroadcastNow\n{\n    //\n}</code></pre>\n  <p></p>\n  <h3>Condiciones de transmisión</h3>\n  <p>A veces, desea transmitir su evento solo si una condición determinada es verdadera. Puede definir estas condiciones agregando un <code>broadcastWhen</code>método a su clase de evento:</p>\n  <pre><code>/**\n * Determine if this event should broadcast.\n *\n * @return bool\n */\npublic function broadcastWhen()\n{\n    return $this-&gt;value &gt; 100;\n}</code></pre>\n  <p></p>\n  <h2>Canales de autorización</h2>\n  <p>Los canales privados requieren que usted autorice que el usuario actualmente autenticado realmente pueda escuchar en el canal. Esto se logra haciendo una solicitud HTTP a su aplicación Laravel con el nombre del canal y permitiendo que su aplicación determine si el usuario puede escuchar en ese canal. Al usar Laravel Echo , la solicitud HTTP para autorizar las suscripciones a canales privados se realizará automáticamente; sin embargo, necesita definir las rutas adecuadas para responder a estas solicitudes.</p>\n  <p></p>\n  <h3>Definición de rutas de autorización</h3>\n  <p>Afortunadamente, Laravel facilita la definición de rutas para responder a las solicitudes de autorización del canal. En el <code>BroadcastServiceProvider</code>incluido con su aplicación Laravel, verá una llamada al método. Este método registrará la ruta para manejar las solicitudes de autorización:<code>Broadcast::routes</code><code>/broadcasting/auth</code></p>\n  <pre><code>Broadcast::routes();</code></pre>\n  <p>El método colocará automáticamente sus rutas dentro del grupo de middleware; sin embargo, puede pasar una serie de atributos de ruta al método si desea personalizar los atributos asignados:<code>Broadcast::routes</code><code>web</code></p>\n  <pre><code>Broadcast::routes($attributes);</code></pre>\n  <h4>Personalización del punto final de autorización</h4>\n  <p>De forma predeterminada, Echo utilizará el punto final para autorizar el acceso al canal. Sin embargo, puede especificar su propio punto final de autorización pasando la opción de configuración a su instancia de Echo:<code>/broadcasting/auth</code><code>authEndpoint</code></p>\n  <pre><code>window.Echo = new Echo({\n    broadcaster: 'pusher',\n    key: 'your-pusher-channels-key',\n    authEndpoint: '/custom/endpoint/auth'\n});</code></pre>\n  <p></p>\n  <h3>Definición de devoluciones de llamada de autorización</h3>\n  <p>A continuación, necesitamos definir la lógica que realmente realizará la autorización del canal. Esto se hace en el archivo que se incluye con su aplicación. En este archivo, puede utilizar el método para registrar devoluciones de llamada de autorización de canal:<code>routes/channels.php</code><code>Broadcast::channel</code></p>\n  <pre><code>Broadcast::channel('order.{orderId}', function ($user, $orderId) {\n    return $user-&gt;id === Order::findOrNew($orderId)-&gt;user_id;\n});</code></pre>\n  <p>El <code>channel</code>método acepta dos argumentos: el nombre del canal y una devolución de llamada que devuelve <code>true</code>o <code>false</code>indica si el usuario está autorizado a escuchar en el canal.</p>\n  <p>Todas las devoluciones de llamada de autorización reciben al usuario actualmente autenticado como su primer argumento y cualquier parámetro comodín adicional como sus argumentos posteriores. En este ejemplo, usamos el marcador de posición para indicar que la parte \"ID\" del nombre del canal es un comodín.<code>{orderId}</code></p>\n  <h4>Enlace de modelo de devolución de llamada de autorización</h4>\n  <p>Al igual que las rutas HTTP, las rutas de canal también pueden aprovechar el enlace de modelo de ruta implícito y explícito . Por ejemplo, en lugar de recibir la cadena o el ID de pedido numérico, puede solicitar una <code>Order</code>instancia de modelo real :</p>\n  <pre><code>use App\\Models\\Order;\n\nBroadcast::channel('order.{order}', function ($user, Order $order) {\n    return $user-&gt;id === $order-&gt;user_id;\n});</code></pre>\n  <h4>Autenticación de devolución de llamada de autorización</h4>\n  <p>Los canales de transmisión privados y de presencia autentican al usuario actual a través de la protección de autenticación predeterminada de su aplicación. Si el usuario no está autenticado, la autorización del canal se deniega automáticamente y la devolución de llamada de autorización nunca se ejecuta. Sin embargo, puede asignar varios guardias personalizados que deben autenticar la solicitud entrante si es necesario:</p>\n  <pre><code>Broadcast::channel('channel', function () {\n    // ...\n}, ['guards' =&gt; ['web', 'admin']]);</code></pre>\n  <p></p>\n  <h3>Definición de clases de canales</h3>\n  <p>Si su aplicación consume muchos canales diferentes, su archivo podría volverse voluminoso. Entonces, en lugar de usar Closures para autorizar canales, puede usar clases de canal. Para generar una clase de canal, use el comando Artisan. Este comando colocará una nueva clase de canal en el directorio.<code>routes/channels.php</code><code>make:channel</code><code>App/Broadcasting</code></p>\n  <pre><code>php artisan make:channel OrderChannel</code></pre>\n  <p>A continuación, registre su canal en su archivo:<code>routes/channels.php</code></p>\n  <pre><code>use App\\Broadcasting\\OrderChannel;\n\nBroadcast::channel('order.{order}', OrderChannel::class);</code></pre>\n  <p>Finalmente, puede colocar la lógica de autorización para su canal en el <code>join</code>método de la clase de canal . Este <code>join</code>método albergará la misma lógica que normalmente habría colocado en el cierre de autorización de su canal. También puede aprovechar la vinculación del modelo de canal:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Broadcasting;\n\nuse App\\Models\\Order;\nuse App\\Models\\User;\n\nclass OrderChannel\n{\n    /**\n     * Create a new channel instance.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        //\n    }\n\n    /**\n     * Authenticate the user's access to the channel.\n     *\n     * @param  \\App\\Models\\User  $user\n     * @param  \\App\\Models\\Order  $order\n     * @return array|bool\n     */\n    public function join(User $user, Order $order)\n    {\n        return $user-&gt;id === $order-&gt;user_id;\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Como muchas otras clases en Laravel, las clases de canal serán resueltas automáticamente por el contenedor de servicios . Por lo tanto, puede escribir sugerencias sobre cualquier dependencia requerida por su canal en su constructor.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Eventos de transmisión</h2>\n  <p>Una vez que haya definido un evento y lo haya marcado con la <code>ShouldBroadcast</code>interfaz, solo necesita disparar el evento usando la <code>event</code>función. El despachador de eventos notará que el evento está marcado con la <code>ShouldBroadcast</code>interfaz y lo pondrá en cola para su transmisión:</p>\n  <pre><code>event(new ShippingStatusUpdated($update));</code></pre>\n  <p></p>\n  <h3>Solo para otros</h3>\n  <p>Al crear una aplicación que utiliza la transmisión de eventos, puede sustituir la <code>event</code>función por la <code>broadcast</code>función. Al igual que la <code>event</code>función, la <code>broadcast</code>función envía el evento a los oyentes del lado del servidor:</p>\n  <pre><code>broadcast(new ShippingStatusUpdated($update));</code></pre>\n  <p>Sin embargo, la <code>broadcast</code>función también expone el <code>toOthers</code>método que le permite excluir al usuario actual de los destinatarios de la transmisión:</p>\n  <pre><code>broadcast(new ShippingStatusUpdated($update))-&gt;toOthers();</code></pre>\n  <p>Para comprender mejor cuándo es posible que desee utilizar el <code>toOthers</code>método, imaginemos una aplicación de lista de tareas en la que un usuario puede crear una nueva tarea ingresando un nombre de tarea. Para crear una tarea, su aplicación puede realizar una solicitud a un <code>/task</code>punto final que transmite la creación de la tarea y devuelve una representación JSON de la nueva tarea. Cuando su aplicación JavaScript recibe la respuesta del punto final, podría insertar directamente la nueva tarea en su lista de tareas así:</p>\n  <pre><code>axios.post('/task', task)\n    .then((response) =&gt; {\n        this.tasks.push(response.data);\n    });</code></pre>\n  <p>Sin embargo, recuerde que también transmitimos la creación de la tarea. Si su aplicación JavaScript está escuchando este evento para agregar tareas a la lista de tareas, tendrá tareas duplicadas en su lista: una desde el punto final y otra desde la transmisión. Puede resolver esto utilizando el <code>toOthers</code>método para indicar a la emisora \u200B\u200Bque no transmita el evento al usuario actual.</p>\n  <blockquote>\n    <div><div></div><p>Tu evento debe usar el rasgo para poder llamar al método.<code>Illuminate\\Broadcasting\\InteractsWithSockets</code><code>toOthers</code></p></div>\n  </blockquote>\n  <h4>Configuración</h4>\n  <p>Cuando inicializa una instancia de Laravel Echo, se asigna un ID de socket a la conexión. Si está utilizando Vue y Axios , la ID del socket se adjuntará automáticamente a cada solicitud saliente como un encabezado. Luego, cuando llames al método, Laravel extraerá el ID de socket del encabezado e indicará a la emisora \u200B\u200Bque no transmita a ninguna conexión con ese ID de socket.<code>X-Socket-ID</code><code>toOthers</code></p>\n  <p>Si no está utilizando Vue y Axios, deberá configurar manualmente su aplicación JavaScript para enviar el encabezado. Puede recuperar el ID del socket utilizando el método:<code>X-Socket-ID</code><code>Echo.socketId</code></p>\n  <pre><code>var socketId = Echo.socketId();</code></pre>\n  <p></p>\n  <h2>Recibir transmisiones</h2>\n  <p></p>\n  <h3>Instalación de Laravel Echo</h3>\n  <p>Laravel Echo es una biblioteca de JavaScript que hace que sea sencillo suscribirse a canales y escuchar eventos transmitidos por Laravel. Puede instalar Echo a través del administrador de paquetes NPM. En este ejemplo, también instalaremos el paquete, ya que usaremos la emisora \u200B\u200BPusher Channels:<code>pusher-js</code></p>\n  <pre><code>npm install --save laravel-echo pusher-js</code></pre>\n  <p>Una vez que Echo está instalado, está listo para crear una nueva instancia de Echo en el JavaScript de su aplicación. Un gran lugar para hacer esto es en la parte inferior del archivo que se incluye con el marco de Laravel:<code>resources/js/bootstrap.js</code></p>\n  <pre><code>import Echo from \"laravel-echo\"\n\nwindow.Echo = new Echo({\n    broadcaster: 'pusher',\n    key: 'your-pusher-channels-key'\n});</code></pre>\n  <p>Al crear una instancia de Echo que usa el <code>pusher</code>conector, también puede especificar <code>cluster</code>si la conexión debe realizarse a través de TLS (de forma predeterminada, cuando <code>forceTLS</code>es <code>false</code>, se realizará una conexión que no sea TLS si la página se cargó a través de HTTP, o como alternativa si falla una conexión TLS):</p>\n  <pre><code>window.Echo = new Echo({\n    broadcaster: 'pusher',\n    key: 'your-pusher-channels-key',\n    cluster: 'eu',\n    forceTLS: true\n});</code></pre>\n  <h4>Usar una instancia de cliente existente</h4>\n  <p>Si ya tiene una instancia de cliente Pusher Channels o Socket.io que le gustaría que Echo utilizara, puede pasarla a Echo a través de la <code>client</code>opción de configuración:</p>\n  <pre><code>const client = require('pusher-js');\n\nwindow.Echo = new Echo({\n    broadcaster: 'pusher',\n    key: 'your-pusher-channels-key',\n    client: client\n});</code></pre>\n  <p></p>\n  <h3>Escuchando eventos</h3>\n  <p>Una vez que haya instalado y creado una instancia de Echo, estará listo para comenzar a escuchar las transmisiones de eventos. Primero, use el <code>channel</code>método para recuperar una instancia de un canal, luego llame al <code>listen</code>método para escuchar un evento específico:</p>\n  <pre><code>Echo.channel('orders')\n    .listen('OrderShipped', (e) =&gt; {\n        console.log(e.order.name);\n    });</code></pre>\n  <p>Si desea escuchar eventos en un canal privado, use el <code>private</code>método en su lugar. Puede continuar encadenando llamadas al <code>listen</code>método para escuchar múltiples eventos en un solo canal:</p>\n  <pre><code>Echo.private('orders')\n    .listen(...)\n    .listen(...)\n    .listen(...);</code></pre>\n  <p></p>\n  <h3>Saliendo de un canal</h3>\n  <p>Para salir de un canal, puede llamar al <code>leaveChannel</code>método en su instancia de Echo:</p>\n  <pre><code>Echo.leaveChannel('orders');</code></pre>\n  <p>Si desea abandonar un canal y también sus canales privados y de presencia asociados, puede llamar al <code>leave</code>método:</p>\n  <pre><code>Echo.leave('orders');</code></pre>\n  <p></p>\n  <h3>Espacios de nombres</h3>\n  <p>Es posible que haya notado en los ejemplos anteriores que no especificamos el espacio de nombres completo para las clases de eventos. Esto se debe a que Echo asumirá automáticamente que los eventos están ubicados en el espacio de nombres. Sin embargo, puede configurar el espacio de nombres raíz cuando crea una instancia de Echo pasando una opción de configuración:<code>App\\Events</code><code>namespace</code></p>\n  <pre><code>window.Echo = new Echo({\n    broadcaster: 'pusher',\n    key: 'your-pusher-channels-key',\n    namespace: 'App.Other.Namespace'\n});</code></pre>\n  <p>Alternativamente, puede prefijar las clases de eventos con un <code>.</code>al suscribirse a ellas usando Echo. Esto le permitirá especificar siempre el nombre de clase completo:</p>\n  <pre><code>Echo.channel('orders')\n    .listen('.Namespace\\\\Event\\\\Class', (e) =&gt; {\n        //\n    });</code></pre>\n  <p></p>\n  <h2>Canales de presencia</h2>\n  <p>Los canales de presencia se basan en la seguridad de los canales privados, al tiempo que exponen la característica adicional de saber quién está suscrito al canal. Esto facilita la creación de funciones de aplicaciones colaborativas potentes, como notificar a los usuarios cuando otro usuario está viendo la misma página.</p>\n  <p></p>\n  <h3>Autorización de canales de presencia</h3>\n  <p>Todos los canales de presencia también son canales privados; por lo tanto, los usuarios deben tener autorización para acceder a ellos . Sin embargo, al definir devoluciones de llamada de autorización para canales de presencia, no regresará <code>true</code>si el usuario está autorizado a unirse al canal. En su lugar, debe devolver una matriz de datos sobre el usuario.</p>\n  <p>Los datos devueltos por la devolución de llamada de autorización estarán disponibles para los oyentes de eventos del canal de presencia en su aplicación JavaScript. Si el usuario no está autorizado para unirse al canal de presencia, debe regresar <code>false</code>o <code>null</code>:</p>\n  <pre><code>Broadcast::channel('chat.{roomId}', function ($user, $roomId) {\n    if ($user-&gt;canJoinRoom($roomId)) {\n        return ['id' =&gt; $user-&gt;id, 'name' =&gt; $user-&gt;name];\n    }\n});</code></pre>\n  <p></p>\n  <h3>Unirse a los canales de presencia</h3>\n  <p>Para unirse a un canal de presencia, puede utilizar el <code>join</code>método de Echo . El <code>join</code>método devolverá una <code>PresenceChannel</code>aplicación que, junto con la exposición del <code>listen</code>método, permite suscribirse a los <code>here</code>, <code>joining</code>y <code>leaving</code>eventos.</p>\n  <pre><code>Echo.join(`chat.${roomId}`)\n    .here((users) =&gt; {\n        //\n    })\n    .joining((user) =&gt; {\n        console.log(user.name);\n    })\n    .leaving((user) =&gt; {\n        console.log(user.name);\n    });</code></pre>\n  <p>La <code>here</code>devolución de llamada se ejecutará inmediatamente una vez que el canal se haya unido correctamente y recibirá una matriz que contiene la información del usuario de todos los demás usuarios actualmente suscritos al canal. El <code>joining</code>método se ejecutará cuando un nuevo usuario se una a un canal, mientras que el <code>leaving</code>método se ejecutará cuando un usuario abandone el canal.</p>\n  <p></p>\n  <h3>Transmisión a canales de presencia</h3>\n  <p>Los canales de presencia pueden recibir eventos al igual que los canales públicos o privados. Usando el ejemplo de una sala de chat, es posible que deseemos transmitir <code>NewMessage</code>eventos al canal de presencia de la sala. Para hacerlo, devolveremos una instancia de <code>PresenceChannel</code>del <code>broadcastOn</code>método del evento :</p>\n  <pre><code>/**\n * Get the channels the event should broadcast on.\n *\n * @return Channel|array\n */\npublic function broadcastOn()\n{\n    return new PresenceChannel('room.'.$this-&gt;message-&gt;room_id);\n}</code></pre>\n  <p>Al igual que los eventos públicos o privados, los eventos del canal de presencia pueden transmitirse utilizando la <code>broadcast</code>función. Al igual que con otros eventos, puede usar el <code>toOthers</code>método para excluir al usuario actual de recibir la transmisión:</p>\n  <pre><code>broadcast(new NewMessage($message));\n\nbroadcast(new NewMessage($message))-&gt;toOthers();</code></pre>\n  <p>Puede escuchar el evento de unión a través del <code>listen</code>método de Echo :</p>\n  <pre><code>Echo.join(`chat.${roomId}`)\n    .here(...)\n    .joining(...)\n    .leaving(...)\n    .listen('NewMessage', (e) =&gt; {\n        //\n    });</code></pre>\n  <p></p>\n  <h2>Eventos del cliente</h2>\n  <blockquote>\n    <div><div></div><p>Al utilizar los canales Pusher , debe habilitar la opción \"Eventos del cliente\" en la sección \"Configuración de la aplicación\" del panel de control de su aplicación para enviar eventos del cliente.</p></div>\n  </blockquote>\n  <p>A veces, es posible que desee transmitir un evento a otros clientes conectados sin presionar en absoluto su aplicación Laravel. Esto puede ser particularmente útil para cosas como notificaciones de \"escritura\", donde desea alertar a los usuarios de su aplicación que otro usuario está escribiendo un mensaje en una pantalla determinada.</p>\n  <p>Para transmitir eventos de clientes, puede usar el <code>whisper</code>método de Echo :</p>\n  <pre><code>Echo.private('chat')\n    .whisper('typing', {\n        name: this.user.name\n    });</code></pre>\n  <p>Para escuchar los eventos del cliente, puede usar el <code>listenForWhisper</code>método:</p>\n  <pre><code>Echo.private('chat')\n    .listenForWhisper('typing', (e) =&gt; {\n        console.log(e.name);\n    });</code></pre>\n  <p></p>\n  <h2>Notificaciones</h2>\n  <p>Al vincular la transmisión de eventos con notificaciones , su aplicación JavaScript puede recibir nuevas notificaciones a medida que ocurren sin necesidad de actualizar la página. Primero, asegúrese de leer la documentación sobre el uso del canal de notificación de transmisión .</p>\n  <p>Una vez que haya configurado una notificación para usar el canal de transmisión, puede escuchar los eventos de transmisión usando el <code>notification</code>método de Echo . Recuerde, el nombre del canal debe coincidir con el nombre de la clase de la entidad que recibe las notificaciones:</p>\n  <pre><code>Echo.private(`App.User.${userId}`)\n    .notification((notification) =&gt; {\n        console.log(notification.type);\n    });</code></pre>\n  <p>En este ejemplo, todas las notificaciones enviadas a las instancias a través del canal serían recibidas por la devolución de llamada. Una devolución de llamada de autorización de canal para el canal se incluye en el valor predeterminado que se envía con el marco de Laravel.<code>App\\Models\\User</code><code>broadcast</code><code>App.User.{id}</code><code>BroadcastServiceProvider</code></p>\n</section>"
      },
      {
        "titulo": "6.3 Cache",
        "contenido": "<section>\n  <h1>Cache</h1>\n  <ul>\n    <li>Configuración\n      <ul>\n        <li>Requisitos previos del controlador</li>\n      </ul></li>\n    <li>Uso de caché\n      <ul>\n        <li>Obtener una instancia de caché</li>\n        <li>Recuperar elementos de la caché</li>\n        <li>Almacenamiento de elementos en la caché</li>\n        <li>Eliminar elementos de la caché</li>\n        <li>El ayudante de caché</li>\n      </ul></li>\n    <li>Etiquetas de caché\n      <ul>\n        <li>Almacenamiento de elementos de caché etiquetados</li>\n        <li>Acceso a elementos de caché etiquetados</li>\n        <li>Eliminación de elementos de caché etiquetados</li>\n      </ul></li>\n    <li>Cerraduras atómicas\n      <ul>\n        <li>Requisitos previos del controlador</li>\n        <li>Administrar cerraduras</li>\n        <li>Gestión de bloqueos en procesos</li>\n      </ul></li>\n    <li>Agregar controladores de caché personalizados\n      <ul>\n        <li>Escribiendo el controlador</li>\n        <li>Registro del conductor</li>\n      </ul></li>\n    <li>Eventos</li>\n  </ul>\n  <p></p>\n  <h2>Configuración</h2>\n  <p>Laravel proporciona una API unificada y expresiva para varios backends de almacenamiento en caché. La configuración de la caché se encuentra en . En este archivo, puede especificar qué controlador de caché le gustaría que se usara de forma predeterminada en toda su aplicación. Laravel admite backends de almacenamiento en caché populares como Memcached y Redis listos para usar .<code>config/cache.php</code></p>\n  <p>El archivo de configuración de la caché también contiene varias otras opciones, que están documentadas en el archivo, así que asegúrese de leer estas opciones. De forma predeterminada, Laravel está configurado para usar el <code>file</code>controlador de caché, que almacena los objetos en caché serializados en el sistema de archivos. Para aplicaciones más grandes, se recomienda que utilice un controlador más robusto como Memcached o Redis. Incluso puede configurar varias configuraciones de caché para el mismo controlador.</p>\n  <p></p>\n  <h3>Requisitos previos del controlador</h3>\n  <h4>Base de datos</h4>\n  <p>Cuando utilice el <code>database</code>controlador de caché, deberá configurar una tabla para contener los elementos de caché. Encontrará una <code>Schema</code>declaración de ejemplo para la tabla siguiente:</p>\n  <pre><code>Schema::create('cache', function ($table) {\n    $table-&gt;string('key')-&gt;unique();\n    $table-&gt;text('value');\n    $table-&gt;integer('expiration');\n});</code></pre>\n  <blockquote>\n    <div><div></div><p>También puede utilizar el comando Artisan para generar una migración con el esquema adecuado.<code>php artisan cache:table</code></p></div>\n  </blockquote>\n  <h4>Memcached</h4>\n  <p>El uso del controlador Memcached requiere la instalación del paquete Memcached PECL . Puede enumerar todos sus servidores Memcached en el archivo de configuración:<code>config/cache.php</code></p>\n  <pre><code>'memcached' =&gt; [\n    [\n        'host' =&gt; '127.0.0.1',\n        'port' =&gt; 11211,\n        'weight' =&gt; 100\n    ],\n],</code></pre>\n  <p>También puede establecer la <code>host</code>opción en una ruta de socket UNIX. Si hace esto, la <code>port</code>opción debe establecerse en <code>0</code>:</p>\n  <pre><code>'memcached' =&gt; [\n    [\n        'host' =&gt; '/var/run/memcached/memcached.sock',\n        'port' =&gt; 0,\n        'weight' =&gt; 100\n    ],\n],</code></pre>\n  <h4>Redis</h4>\n  <p>Antes de usar un caché de Redis con Laravel, deberá instalar la extensión PHP PhpRedis a través de PECL o instalar el paquete (~ 1.0) a través de Composer.<code>predis/predis</code></p>\n  <p>Para obtener más información sobre la configuración de Redis, consulte su página de documentación de Laravel .</p>\n  <p></p>\n  <h2>Uso de caché</h2>\n  <p></p>\n  <h3>Obtener una instancia de caché</h3>\n  <p>Los contratos y proporcionan acceso a los servicios de caché de Laravel. El contrato proporciona acceso a todos los controladores de caché definidos para su aplicación. El contrato suele ser una implementación del controlador de caché predeterminado para su aplicación según lo especificado por su archivo de configuración.<code>Illuminate\\Contracts\\Cache\\Factory</code><code>Illuminate\\Contracts\\Cache\\Repository</code> <code>Factory</code><code>Repository</code><code>cache</code></p>\n  <p>Sin embargo, también puede utilizar la <code>Cache</code>fachada, que es la que usaremos a lo largo de esta documentación. La <code>Cache</code>fachada proporciona un acceso conveniente y conciso a las implementaciones subyacentes de los contratos de caché de Laravel:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Support\\Facades\\Cache;\n\nclass UserController extends Controller\n{\n    /**\n     * Show a list of all users of the application.\n     *\n     * @return Response\n     */\n    public function index()\n    {\n        $value = Cache::get('key');\n\n        //\n    }\n}</code></pre>\n  <h4>Acceder a varios almacenes de caché</h4>\n  <p>Usando la <code>Cache</code>fachada, puede acceder a varios almacenes de caché a través del <code>store</code>método. La clave pasada al <code>store</code>método debe corresponder a una de las tiendas enumeradas en la <code>stores</code>matriz de configuración en su <code>cache</code>archivo de configuración:</p>\n  <pre><code>$value = Cache::store('file')-&gt;get('foo');\n\nCache::store('redis')-&gt;put('bar', 'baz', 600); // 10 Minutes</code></pre>\n  <p></p>\n  <h3>Recuperar elementos de la caché</h3>\n  <p>El <code>get</code>método de la <code>Cache</code>fachada se utiliza para recuperar elementos del caché. Si el elemento no existe en la caché, <code>null</code>se devolverá. Si lo desea, puede pasar un segundo argumento al <code>get</code>método que especifica el valor predeterminado que desea que se le devuelva si el elemento no existe:</p>\n  <pre><code>$value = Cache::get('key');\n\n$value = Cache::get('key', 'default');</code></pre>\n  <p>Incluso puede pasar a <code>Closure</code>como valor predeterminado. El resultado de <code>Closure</code>se devolverá si el elemento especificado no existe en la caché. Pasar un cierre le permite diferir la recuperación de valores predeterminados de una base de datos u otro servicio externo:</p>\n  <pre><code>$value = Cache::get('key', function () {\n    return DB::table(...)-&gt;get();\n});</code></pre>\n  <h4>Comprobación de la existencia del artículo</h4>\n  <p>El <code>has</code>método puede usarse para determinar si un elemento existe en la caché. Este método regresará <code>false</code>si el valor es <code>null</code>:</p>\n  <pre><code>if (Cache::has('key')) {\n    //\n}</code></pre>\n  <h4>Incrementar / Decrementar valores</h4>\n  <p>Los métodos <code>increment</code>y <code>decrement</code>pueden usarse para ajustar el valor de elementos enteros en la caché. Ambos métodos aceptan un segundo argumento opcional que indica la cantidad en la que aumentar o disminuir el valor del artículo:</p>\n  <pre><code>Cache::increment('key');\nCache::increment('key', $amount);\nCache::decrement('key');\nCache::decrement('key', $amount);</code></pre>\n  <h4>Recuperar y almacenar</h4>\n  <p>A veces es posible que desee recuperar un elemento de la caché, pero también almacenar un valor predeterminado si el elemento solicitado no existe. Por ejemplo, es posible que desee recuperar todos los usuarios del caché o, si no existen, recuperarlos de la base de datos y agregarlos al caché. Puede hacer esto usando el método:<code>Cache::remember</code></p>\n  <pre><code>$value = Cache::remember('users', $seconds, function () {\n    return DB::table('users')-&gt;get();\n});</code></pre>\n  <p>Si el elemento no existe en la caché, se ejecutará <code>Closure</code>el <code>remember</code>método pasado y su resultado se colocará en la caché.</p>\n  <p>Puede utilizar el <code>rememberForever</code>método para recuperar un elemento del caché o almacenarlo para siempre:</p>\n  <pre><code>$value = Cache::rememberForever('users', function () {\n    return DB::table('users')-&gt;get();\n});</code></pre>\n  <h4>Recuperar y eliminar</h4>\n  <p>Si necesita recuperar un elemento de la caché y luego eliminarlo, puede utilizar el <code>pull</code>método. Al igual que el <code>get</code>método, <code>null</code>se devolverá si el elemento no existe en el caché:</p>\n  <pre><code>$value = Cache::pull('key');</code></pre>\n  <p></p>\n  <h3>Almacenamiento de elementos en la caché</h3>\n  <p>Puede usar el <code>put</code>método en la <code>Cache</code>fachada para almacenar elementos en el caché:</p>\n  <pre><code>Cache::put('key', 'value', $seconds);</code></pre>\n  <p>Si el tiempo de almacenamiento no se pasa al <code>put</code>método, el artículo se almacenará indefinidamente:</p>\n  <pre><code>Cache::put('key', 'value');</code></pre>\n  <p>En lugar de pasar el número de segundos como un número entero, también puede pasar una <code>DateTime</code>instancia que represente el tiempo de vencimiento del elemento almacenado en caché:</p>\n  <pre><code>Cache::put('key', 'value', now()-&gt;addMinutes(10));</code></pre>\n  <h4>Almacenar si no está presente</h4>\n  <p>El <code>add</code>método solo agregará el elemento al caché si aún no existe en el almacén de caché. El método volverá <code>true</code>si el elemento se agrega realmente a la caché. De lo contrario, el método devolverá <code>false</code>:</p>\n  <pre><code>Cache::add('key', 'value', $seconds);</code></pre>\n  <h4>Almacenar artículos para siempre</h4>\n  <p>El <code>forever</code>método se puede utilizar para almacenar un elemento en la caché de forma permanente. Dado que estos elementos no caducarán, deben eliminarse manualmente de la caché mediante el <code>forget</code>método:</p>\n  <pre><code>Cache::forever('key', 'value');</code></pre>\n  <blockquote>\n    <div><div></div><p> Si está utilizando el controlador Memcached, los elementos que se almacenan \"para siempre\" pueden eliminarse cuando la caché alcanza su límite de tamaño.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Eliminar elementos de la caché</h3>\n  <p>Puede eliminar elementos del caché usando el <code>forget</code>método:</p>\n  <pre><code>Cache::forget('key');</code></pre>\n  <p>También puede eliminar elementos proporcionando un TTL cero o negativo:</p>\n  <pre><code>Cache::put('key', 'value', 0);\n\nCache::put('key', 'value', -5);</code></pre>\n  <p>Puede borrar todo el caché usando el <code>flush</code>método:</p>\n  <pre><code>Cache::flush();</code></pre>\n  <blockquote>\n    <div><div></div><p>Limpiar la caché no respeta el prefijo de la caché y eliminará todas las entradas de la caché. Considere esto cuidadosamente cuando borre un caché que es compartido por otras aplicaciones.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>El ayudante de caché</h3>\n  <p>Además de utilizar el contrato de<code>Cache</code> fachada o caché , también puede utilizar la <code>cache</code>función global para recuperar y almacenar datos a través de la caché. Cuando <code>cache</code>se llama a la función con un solo argumento de cadena, devolverá el valor de la clave dada:</p>\n  <pre><code>$value = cache('key');</code></pre>\n  <p>Si proporciona una matriz de pares clave / valor y un tiempo de vencimiento para la función, almacenará valores en la caché durante el tiempo especificado:</p>\n  <pre><code>cache(['key' =&gt; 'value'], $seconds);\n\ncache(['key' =&gt; 'value'], now()-&gt;addMinutes(10));</code></pre>\n  <p>Cuando <code>cache</code>se llama a la función sin argumentos, devuelve una instancia de la implementación, lo que le permite llamar a otros métodos de almacenamiento en caché:<code>Illuminate\\Contracts\\Cache\\Factory</code></p>\n  <pre><code>cache()-&gt;remember('users', $seconds, function () {\n    return DB::table('users')-&gt;get();\n});</code></pre>\n  <blockquote>\n    <div><div></div><p>Al probar la llamada a la <code>cache</code>función global , puede usar el método como si estuviera probando una fachada .<code>Cache::shouldReceive</code></p></div>\n  </blockquote>\n  <p></p>\n  <h2>Etiquetas de caché</h2>\n  <blockquote>\n    <div><div></div><p>Etiquetas de caché no son compatibles cuando se utiliza el <code>file</code>, <code>dynamodb</code>o <code>database</code>los conductores de caché. Además, cuando se utilizan varias etiquetas con cachés que se almacenan \"para siempre\", el rendimiento será mejor con un controlador como <code>memcached</code>, que purga automáticamente los registros obsoletos.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Almacenamiento de elementos de caché etiquetados</h3>\n  <p>Las etiquetas de caché le permiten etiquetar elementos relacionados en la caché y luego vaciar todos los valores en caché que se les ha asignado una etiqueta determinada. Puede acceder a un caché etiquetado pasando una matriz ordenada de nombres de etiquetas. Por ejemplo, accedamos a un caché etiquetado y a un <code>put</code>valor en el caché:</p>\n  <pre><code>Cache::tags(['people', 'artists'])-&gt;put('John', $john, $seconds);\n\nCache::tags(['people', 'authors'])-&gt;put('Anne', $anne, $seconds);</code></pre>\n  <p></p>\n  <h3>Acceso a elementos de caché etiquetados</h3>\n  <p>Para recuperar un elemento de caché etiquetado, pase la misma lista ordenada de etiquetas al <code>tags</code>método y luego llame al <code>get</code>método con la clave que desea recuperar:</p>\n  <pre><code>$john = Cache::tags(['people', 'artists'])-&gt;get('John');\n\n$anne = Cache::tags(['people', 'authors'])-&gt;get('Anne');</code></pre>\n  <p></p>\n  <h3>Eliminación de elementos de caché etiquetados</h3>\n  <p>Puede eliminar todos los elementos que tengan asignada una etiqueta o una lista de etiquetas. Por ejemplo, esta declaración eliminaría todas las cachés etiquetados con cualquiera de los dos <code>people</code>, <code>authors</code>o ambos. Entonces, ambos <code>Anne</code>y <code>John</code>se eliminarían del caché:</p>\n  <pre><code>Cache::tags(['people', 'authors'])-&gt;flush();</code></pre>\n  <p>Por el contrario, esta declaración eliminaría solo los cachés etiquetados con <code>authors</code>, por <code>Anne</code>lo que se eliminaría, pero no <code>John</code>:</p>\n  <pre><code>Cache::tags('authors')-&gt;flush();</code></pre>\n  <p></p>\n  <h2>Cerraduras atómicas</h2>\n  <blockquote>\n    <div><div></div><p>Para utilizar esta función, la aplicación debe ser el uso de la <code>memcached</code>, <code>dynamodb</code>, <code>redis</code>, <code>database</code>, o <code>array</code>controlador de caché como controlador predeterminado de la caché de la aplicación. Además, todos los servidores deben comunicarse con el mismo servidor de caché central.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Requisitos previos del controlador</h3>\n  <h4>Base de datos</h4>\n  <p>Cuando utilice el <code>database</code>controlador de caché, deberá configurar una tabla para contener los bloqueos de caché. Encontrará una <code>Schema</code>declaración de ejemplo para la tabla siguiente:</p>\n  <pre><code>Schema::create('cache_locks', function ($table) {\n    $table-&gt;string('key')-&gt;primary();\n    $table-&gt;string('owner');\n    $table-&gt;integer('expiration');\n});</code></pre>\n  <p></p>\n  <h3>Administrar cerraduras</h3>\n  <p>Las cerraduras atómicas permiten la manipulación de cerraduras distribuidas sin preocuparse por las condiciones de carrera. Por ejemplo, Laravel Forge utiliza bloqueos atómicos para garantizar que solo se ejecute una tarea remota en un servidor a la vez. Puede crear y administrar bloqueos utilizando el método:<code>Cache::lock</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Cache;\n\n$lock = Cache::lock('foo', 10);\n\nif ($lock-&gt;get()) {\n    // Lock acquired for 10 seconds...\n\n    $lock-&gt;release();\n}</code></pre>\n  <p>El <code>get</code>método también acepta un cierre. Una vez que se ejecuta el cierre, Laravel liberará automáticamente el bloqueo:</p>\n  <pre><code>Cache::lock('foo')-&gt;get(function () {\n    // Lock acquired indefinitely and automatically released...\n});</code></pre>\n  <p>Si el bloqueo no está disponible en el momento en que lo solicitas, puedes indicarle a Laravel que espere una cantidad específica de segundos. Si el bloqueo no se puede adquirir dentro del límite de tiempo especificado, se lanzará un :<code>Illuminate\\Contracts\\Cache\\LockTimeoutException</code></p>\n  <pre><code>use Illuminate\\Contracts\\Cache\\LockTimeoutException;\n\n$lock = Cache::lock('foo', 10);\n\ntry {\n    $lock-&gt;block(5);\n\n    // Lock acquired after waiting maximum of 5 seconds...\n} catch (LockTimeoutException $e) {\n    // Unable to acquire lock...\n} finally {\n    optional($lock)-&gt;release();\n}\n\nCache::lock('foo', 10)-&gt;block(5, function () {\n    // Lock acquired after waiting maximum of 5 seconds...\n});</code></pre>\n  <p></p>\n  <h3>Gestión de bloqueos en procesos</h3>\n  <p>A veces, es posible que desee adquirir un bloqueo en un proceso y liberarlo en otro proceso. Por ejemplo, puede adquirir un bloqueo durante una solicitud web y desea liberar el bloqueo al final de un trabajo en cola que se activa por esa solicitud. En este escenario, debe pasar el \"token de propietario\" del candado al trabajo en cola para que el trabajo pueda volver a crear una instancia del bloqueo utilizando el token dado:</p>\n  <pre><code>// Within Controller...\n$podcast = Podcast::find($id);\n\n$lock = Cache::lock('foo', 120);\n\nif ($result = $lock-&gt;get()) {\n    ProcessPodcast::dispatch($podcast, $lock-&gt;owner());\n}\n\n// Within ProcessPodcast Job...\nCache::restoreLock('foo', $this-&gt;owner)-&gt;release();</code></pre>\n  <p>Si desea liberar un bloqueo sin respetar a su propietario actual, puede utilizar el <code>forceRelease</code>método:</p>\n  <pre><code>Cache::lock('foo')-&gt;forceRelease();</code></pre>\n  <p></p>\n  <h2>Agregar controladores de caché personalizados</h2>\n  <p></p>\n  <h3>Escribiendo el controlador</h3>\n  <p>Para crear nuestro controlador de caché personalizado, primero debemos implementar el contrato . Entonces, una implementación de caché de MongoDB se vería así:<code>Illuminate\\Contracts\\Cache\\Store</code> </p>\n  <pre><code>&lt;?php\n\nnamespace App\\Extensions;\n\nuse Illuminate\\Contracts\\Cache\\Store;\n\nclass MongoStore implements Store\n{\n    public function get($key) {}\n    public function many(array $keys) {}\n    public function put($key, $value, $seconds) {}\n    public function putMany(array $values, $seconds) {}\n    public function increment($key, $value = 1) {}\n    public function decrement($key, $value = 1) {}\n    public function forever($key, $value) {}\n    public function forget($key) {}\n    public function flush() {}\n    public function getPrefix() {}\n}</code></pre>\n  <p>Solo necesitamos implementar cada uno de estos métodos usando una conexión MongoDB. Para ver un ejemplo de cómo implementar cada uno de estos métodos, eche un vistazo al en el código fuente del marco. Una vez que se complete nuestra implementación, podemos finalizar nuestro registro de controlador personalizado.<code>Illuminate\\Cache\\MemcachedStore</code></p>\n  <pre><code>Cache::extend('mongo', function ($app) {\n    return Cache::repository(new MongoStore);\n});</code></pre>\n  <blockquote>\n    <div><div></div><p>Si se pregunta dónde colocar su código de controlador de caché personalizado, puede crear un <code>Extensions</code>espacio de nombres dentro de su <code>app</code>directorio. Sin embargo, tenga en cuenta que Laravel no tiene una estructura de aplicación rígida y usted es libre de organizar su aplicación según sus preferencias.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Registro del conductor</h3>\n  <p>Para registrar el controlador de caché personalizado con Laravel, usaremos el <code>extend</code>método en la <code>Cache</code>fachada. La llamada a podría realizarse con el método predeterminado que se envía con las nuevas aplicaciones de Laravel, o puede crear su propio proveedor de servicios para albergar la extensión, pero no olvide registrar el proveedor en la matriz de proveedores:<code>Cache::extend</code><code>boot</code><code>App\\Providers\\AppServiceProvider</code><code>config/app.php</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse App\\Extensions\\MongoStore;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass CacheServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Cache::extend('mongo', function ($app) {\n            return Cache::repository(new MongoStore);\n        });\n    }\n}</code></pre>\n  <p>El primer argumento que se pasa al <code>extend</code>método es el nombre del controlador. Esto corresponderá a su <code>driver</code>opción en el archivo de configuración. El segundo argumento es un cierre que debería devolver una instancia. Al cierre se le pasará una instancia, que es una instancia del contenedor de servicios .<code>config/cache.php</code><code>Illuminate\\Cache\\Repository</code><code>$app</code></p>\n  <p>Una vez que su extensión esté registrada, actualice la opción de su archivo de configuración al nombre de su extensión.<code>config/cache.php</code><code>driver</code></p>\n  <p></p>\n  <h2>Eventos</h2>\n  <p>Para ejecutar código en cada operación de caché, puede escuchar los eventos disparados por el caché. Por lo general, debe colocar estos detectores de eventos dentro de su <code>EventServiceProvider</code>:</p>\n  <pre><code>/**\n * The event listener mappings for the application.\n *\n * @var array\n */\nprotected $listen = [\n    'Illuminate\\Cache\\Events\\CacheHit' =&gt; [\n        'App\\Listeners\\LogCacheHit',\n    ],\n\n    'Illuminate\\Cache\\Events\\CacheMissed' =&gt; [\n        'App\\Listeners\\LogCacheMissed',\n    ],\n\n    'Illuminate\\Cache\\Events\\KeyForgotten' =&gt; [\n        'App\\Listeners\\LogKeyForgotten',\n    ],\n\n    'Illuminate\\Cache\\Events\\KeyWritten' =&gt; [\n        'App\\Listeners\\LogKeyWritten',\n    ],\n];</code></pre>\n</section>"
      },
      {
        "titulo": "6.4 Colecciones",
        "contenido": "<section>\n  <h1>Colecciones</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Creando colecciones</li>\n        <li>Ampliación de colecciones</li>\n      </ul></li>\n    <li>Métodos disponibles</li>\n    <li>Mensajes de orden superior</li>\n    <li>Colecciones perezosas\n      <ul>\n        <li>Introducción</li>\n        <li>Crear colecciones perezosas</li>\n        <li>El contrato enumerable</li>\n        <li>Métodos de recolección perezosos</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>La clase proporciona un envoltorio fluido y conveniente para trabajar con matrices de datos. Por ejemplo, consulte el siguiente código. Usaremos el ayudante para crear una nueva instancia de colección a partir de la matriz, ejecutaremos la función en cada elemento y luego eliminaremos todos los elementos vacíos:<code>Illuminate\\Support\\Collection</code><code>collect</code><code>strtoupper</code></p>\n  <pre><code>$collection = collect(['taylor', 'abigail', null])-&gt;map(function ($name) {\n    return strtoupper($name);\n})\n-&gt;reject(function ($name) {\n    return empty($name);\n});</code></pre>\n  <p>Como puede ver, la <code>Collection</code>clase le permite encadenar sus métodos para realizar un mapeo fluido y reducir la matriz subyacente. En general, las colecciones son inmutables, lo que significa que cada <code>Collection</code>método devuelve una <code>Collection</code>instancia completamente nueva .</p>\n  <p></p>\n  <h3>Creando colecciones</h3>\n  <p>Como se mencionó anteriormente, el <code>collect</code>asistente devuelve una nueva instancia para la matriz dada. Entonces, crear una colección es tan simple como:<code>Illuminate\\Support\\Collection</code></p>\n  <pre><code>$collection = collect([1, 2, 3]);</code></pre>\n  <blockquote>\n    <div><div></div><p>Los resultados de las consultas de Eloquent siempre se devuelven como <code>Collection</code>instancias.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Ampliación de colecciones</h3>\n  <p>Las colecciones son \"macroable\", lo que le permite agregar métodos adicionales a la <code>Collection</code>clase en tiempo de ejecución. Por ejemplo, el siguiente código agrega un <code>toUpper</code>método a la <code>Collection</code>clase:</p>\n  <pre><code>use Illuminate\\Support\\Collection;\nuse Illuminate\\Support\\Str;\n\nCollection::macro('toUpper', function () {\n    return $this-&gt;map(function ($value) {\n        return Str::upper($value);\n    });\n});\n\n$collection = collect(['first', 'second']);\n\n$upper = $collection-&gt;toUpper();\n\n// ['FIRST', 'SECOND']</code></pre>\n  <p>Normalmente, debería declarar macros de colección en un proveedor de servicios .</p>\n  <p></p>\n  <h2>Métodos disponibles</h2>\n  <p>Para el resto de esta documentación, discutiremos cada método disponible en la <code>Collection</code>clase. Recuerde, todos estos métodos pueden encadenarse para manipular con fluidez la matriz subyacente. Además, casi todos los métodos devuelven una nueva <code>Collection</code>instancia, lo que le permite conservar la copia original de la colección cuando sea necesario:</p>\n  <style>\n    #collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    #collection-method-list a {\n        display: block;\n    }\n</style>\n  <div>\n    <p>todas\n      promedio\n      promedio\n      pedazo\n      chunkMientras\n      colapso\n      recoger\n      combinar\n      concat\n      contiene\n      contieneEstricto\n      contar\n      countBy\n      crossUnirse\n      dd\n      diff\n      diffAssoc\n      diffKeys\n      tugurio\n      duplicados\n      duplicadosEstricto\n      cada\n      cada uno\n      cada\n      excepto\n      filtrar\n      primero\n      primero donde\n      mapa plano\n      aplanar\n      dar la vuelta\n      olvidar\n      forPage\n      obtener\n      agrupar por\n      tiene\n      implosionar\n      intersecarse\n      intersectByKeys\n      esta vacio\n      no está vacío\n      unirse\n      keyBy\n      llaves\n      último\n      macro\n      hacer\n      mapa\n      mapInto\n      mapSpread\n      mapToGroups\n      mapWithKeys\n      max\n      mediana\n      unir\n      mergeRecursive\n      min\n      modo\n      enésimo\n      solamente\n      almohadilla\n      dividir\n      tubo\n      arrancar\n      popular\n      anteponer\n      Halar\n      empujar\n      poner\n      aleatorio\n      reducir\n      rechazar\n      reemplazar\n      Reemplazar recursivo\n      contrarrestar\n      buscar\n      cambio\n      barajar\n      omitir\n      saltarHasta que\n      skipWhile\n      rebanada\n      algunos\n      ordenar\n      ordenar por\n      sortByDesc\n      sortDesc\n      sortKeys\n      sortKeysDesc\n      empalme\n      división\n      suma\n      tomar\n      tomar hasta\n      tomar mientras\n      grifo\n      veces\n      toArray\n      toJson\n      transformar\n      Unión\n      único\n      uniqueStrict\n      a no ser que\n      a menos que esté vacío\n      a menos que no esté vacío\n      desenvolver\n      valores\n      cuando\n      whenEmpty\n      whenNotEmpty\n      dónde\n      whereStrict\n      whereBetween\n      donde\n      whereInStrict\n      whereInstanceOf\n      whereNotBetween\n      whereNotIn\n      whereNotInStrict\n      whereNotNull\n      whereNull\n      envolver\n      Código Postal</p>\n  </div>\n  <p></p>\n  <h2>Listado de métodos</h2>\n  <style>\n    #collection-method code {\n        font-size: 14px;\n    }\n\n    #collection-method:not(.first-collection-method) {\n        margin-top: 50px;\n    }\n</style>\n  <p></p>\n  <h4><code>all()</code></h4>\n  <p>El <code>all</code>método devuelve la matriz subyacente representada por la colección:</p>\n  <pre><code>collect([1, 2, 3])-&gt;all();\n\n// [1, 2, 3]</code></pre>\n  <p></p>\n  <h4><code>average()</code></h4>\n  <p>Alias \u200B\u200Bdel <code>avg</code>método.</p>\n  <p></p>\n  <h4><code>avg()</code></h4>\n  <p>El <code>avg</code>método devuelve el valor promedio de una clave determinada:</p>\n  <pre><code>$average = collect([['foo' =&gt; 10], ['foo' =&gt; 10], ['foo' =&gt; 20], ['foo' =&gt; 40]])-&gt;avg('foo');\n\n// 20\n\n$average = collect([1, 1, 2, 4])-&gt;avg();\n\n// 2</code></pre>\n  <p></p>\n  <h4><code>chunk()</code></h4>\n  <p>El <code>chunk</code>método divide la colección en varias colecciones más pequeñas de un tamaño determinado:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5, 6, 7]);\n\n$chunks = $collection-&gt;chunk(4);\n\n$chunks-&gt;toArray();\n\n// [[1, 2, 3, 4], [5, 6, 7]]</code></pre>\n  <p>Este método es especialmente útil en las vistas cuando se trabaja con un sistema de cuadrícula como Bootstrap . Imagine que tiene una colección de modelos Eloquent que desea mostrar en una cuadrícula:</p>\n  <pre><code>@foreach ($products-&gt;chunk(3) as $chunk)\n    &lt;div class=\"row\"&gt;\n        @foreach ($chunk as $product)\n            &lt;div class=\"col-xs-4\"&gt;{{ $product-&gt;name }}&lt;/div&gt;\n        @endforeach\n    &lt;/div&gt;\n@endforeach</code></pre>\n  <p></p>\n  <h4><code>chunkWhile()</code></h4>\n  <p>El <code>chunkWhile</code>método divide la colección en varias colecciones más pequeñas según la evaluación de la devolución de llamada dada:</p>\n  <pre><code>$collection = collect(str_split('AABBCCCD'));\n\n$chunks = $collection-&gt;chunkWhile(function($current, $key, $chunk) {\n    return $current === $chunk-&gt;last();\n});\n\n$chunks-&gt;toArray();\n\n// [['A', 'A'], ['B', 'B'], ['C', 'C', 'C'], ['D']]</code></pre>\n  <p></p>\n  <h4><code>collapse()</code></h4>\n  <p>El <code>collapse</code>método colapsa una colección de matrices en una única colección plana:</p>\n  <pre><code>$collection = collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\n\n$collapsed = $collection-&gt;collapse();\n\n$collapsed-&gt;all();\n\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>\n  <p></p>\n  <h4><code>combine()</code></h4>\n  <p>El <code>combine</code>método combina los valores de la colección, como claves, con los valores de otra matriz o colección:</p>\n  <pre><code>$collection = collect(['name', 'age']);\n\n$combined = $collection-&gt;combine(['George', 29]);\n\n$combined-&gt;all();\n\n// ['name' =&gt; 'George', 'age' =&gt; 29]</code></pre>\n  <p></p>\n  <h4><code>collect()</code></h4>\n  <p>El <code>collect</code>método devuelve una nueva <code>Collection</code>instancia con los elementos que se encuentran actualmente en la colección:</p>\n  <pre><code>$collectionA = collect([1, 2, 3]);\n\n$collectionB = $collectionA-&gt;collect();\n\n$collectionB-&gt;all();\n\n// [1, 2, 3]</code></pre>\n  <p>El <code>collect</code>método es principalmente útil para convertir colecciones diferidas en <code>Collection</code>instancias estándar :</p>\n  <pre><code>$lazyCollection = LazyCollection::make(function () {\n    yield 1;\n    yield 2;\n    yield 3;\n});\n\n$collection = $lazyCollection-&gt;collect();\n\nget_class($collection);\n\n// 'Illuminate\\Support\\Collection'\n\n$collection-&gt;all();\n\n// [1, 2, 3]</code></pre>\n  <blockquote>\n    <div><div></div><p>El <code>collect</code>método es especialmente útil cuando tiene una instancia de <code>Enumerable</code>y necesita una instancia de colección no diferida. Dado que es parte del contrato, puede usarlo de manera segura para obtener una instancia.<code>collect()</code><code>Enumerable</code><code>Collection</code></p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>concat()</code></h4>\n  <p>El <code>concat</code>método agrega los <code>array</code>valores dados o de la colección al final de la colección:</p>\n  <pre><code>$collection = collect(['John Doe']);\n\n$concatenated = $collection-&gt;concat(['Jane Doe'])-&gt;concat(['name' =&gt; 'Johnny Doe']);\n\n$concatenated-&gt;all();\n\n// ['John Doe', 'Jane Doe', 'Johnny Doe']</code></pre>\n  <p></p>\n  <h4><code>contains()</code></h4>\n  <p>El <code>contains</code>método determina si la colección contiene un elemento determinado:</p>\n  <pre><code>$collection = collect(['name' =&gt; 'Desk', 'price' =&gt; 100]);\n\n$collection-&gt;contains('Desk');\n\n// true\n\n$collection-&gt;contains('New York');\n\n// false</code></pre>\n  <p>También puede pasar un par clave / valor al <code>contains</code>método, que determinará si el par dado existe en la colección:</p>\n  <pre><code>$collection = collect([\n    ['product' =&gt; 'Desk', 'price' =&gt; 200],\n    ['product' =&gt; 'Chair', 'price' =&gt; 100],\n]);\n\n$collection-&gt;contains('product', 'Bookcase');\n\n// false</code></pre>\n  <p>Finalmente, también puede pasar una devolución de llamada al <code>contains</code>método para realizar su propia prueba de verdad:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-&gt;contains(function ($value, $key) {\n    return $value &gt; 5;\n});\n\n// false</code></pre>\n  <p>El <code>contains</code>método utiliza comparaciones \"sueltas\" al verificar los valores de los elementos, lo que significa que una cadena con un valor entero se considerará igual a un número entero del mismo valor. Utilice el <code>containsStrict</code>método para filtrar mediante comparaciones \"estrictas\".</p>\n  <p></p>\n  <h4><code>containsStrict()</code></h4>\n  <p>Este método tiene la misma firma que el <code>contains</code>método; sin embargo, todos los valores se comparan mediante comparaciones \"estrictas\".</p>\n  <blockquote>\n    <div><div></div><p>El comportamiento de este método se modifica al utilizar Eloquent Collections .</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>count()</code></h4>\n  <p>El <code>count</code>método devuelve el número total de elementos de la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$collection-&gt;count();\n\n// 4</code></pre>\n  <p></p>\n  <h4><code>countBy()</code></h4>\n  <p>El <code>countBy</code>método cuenta las apariciones de valores en la colección. Por defecto, el método cuenta las ocurrencias de cada elemento:</p>\n  <pre><code>$collection = collect([1, 2, 2, 2, 3]);\n\n$counted = $collection-&gt;countBy();\n\n$counted-&gt;all();\n\n// [1 =&gt; 1, 2 =&gt; 3, 3 =&gt; 1]</code></pre>\n  <p>Sin embargo, pasa una devolución de llamada al <code>countBy</code>método para contar todos los elementos por un valor personalizado:</p>\n  <pre><code>$collection = collect(['alice@gmail.com', 'bob@yahoo.com', 'carlos@gmail.com']);\n\n$counted = $collection-&gt;countBy(function ($email) {\n    return substr(strrchr($email, \"@\"), 1);\n});\n\n$counted-&gt;all();\n\n// ['gmail.com' =&gt; 2, 'yahoo.com' =&gt; 1]</code></pre>\n  <p></p>\n  <h4><code>crossJoin()</code></h4>\n  <p>El <code>crossJoin</code>método une los valores de la colección entre las matrices o colecciones dadas, devolviendo un producto cartesiano con todas las permutaciones posibles:</p>\n  <pre><code>$collection = collect([1, 2]);\n\n$matrix = $collection-&gt;crossJoin(['a', 'b']);\n\n$matrix-&gt;all();\n\n/*\n    [\n        [1, 'a'],\n        [1, 'b'],\n        [2, 'a'],\n        [2, 'b'],\n    ]\n*/\n\n$collection = collect([1, 2]);\n\n$matrix = $collection-&gt;crossJoin(['a', 'b'], ['I', 'II']);\n\n$matrix-&gt;all();\n\n/*\n    [\n        [1, 'a', 'I'],\n        [1, 'a', 'II'],\n        [1, 'b', 'I'],\n        [1, 'b', 'II'],\n        [2, 'a', 'I'],\n        [2, 'a', 'II'],\n        [2, 'b', 'I'],\n        [2, 'b', 'II'],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>dd()</code></h4>\n  <p>El <code>dd</code>método vuelca los elementos de la colección y finaliza la ejecución del script:</p>\n  <pre><code>$collection = collect(['John Doe', 'Jane Doe']);\n\n$collection-&gt;dd();\n\n/*\n    Collection {\n        #items: array:2 [\n            0 =&gt; \"John Doe\"\n            1 =&gt; \"Jane Doe\"\n        ]\n    }\n*/</code></pre>\n  <p>Si no desea dejar de ejecutar el script, utilice el <code>dump</code>método en su lugar.</p>\n  <p></p>\n  <h4><code>diff()</code></h4>\n  <p>El <code>diff</code>método compara la colección con otra colección o un PHP simple en <code>array</code>función de sus valores. Este método devolverá los valores de la colección original que no están presentes en la colección dada:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$diff = $collection-&gt;diff([2, 4, 6, 8]);\n\n$diff-&gt;all();\n\n// [1, 3, 5]</code></pre>\n  <blockquote>\n    <div><div></div><p>El comportamiento de este método se modifica al utilizar Eloquent Collections .</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>diffAssoc()</code></h4>\n  <p>The <code>diffAssoc</code> method compares the collection against another collection or a plain PHP <code>array</code> based on its keys and values. This method will return the key / value pairs in the original collection that are not present in the given collection:</p>\n  <pre><code>$collection = collect([\n    'color' =&gt; 'orange',\n    'type' =&gt; 'fruit',\n    'remain' =&gt; 6,\n]);\n\n$diff = $collection-&gt;diffAssoc([\n    'color' =&gt; 'yellow',\n    'type' =&gt; 'fruit',\n    'remain' =&gt; 3,\n    'used' =&gt; 6,\n]);\n\n$diff-&gt;all();\n\n// ['color' =&gt; 'orange', 'remain' =&gt; 6]</code></pre>\n  <p></p>\n  <h4><code>diffKeys()</code></h4>\n  <p>The <code>diffKeys</code> method compares the collection against another collection or a plain PHP <code>array</code> based on its keys. This method will return the key / value pairs in the original collection that are not present in the given collection:</p>\n  <pre><code>$collection = collect([\n    'one' =&gt; 10,\n    'two' =&gt; 20,\n    'three' =&gt; 30,\n    'four' =&gt; 40,\n    'five' =&gt; 50,\n]);\n\n$diff = $collection-&gt;diffKeys([\n    'two' =&gt; 2,\n    'four' =&gt; 4,\n    'six' =&gt; 6,\n    'eight' =&gt; 8,\n]);\n\n$diff-&gt;all();\n\n// ['one' =&gt; 10, 'three' =&gt; 30, 'five' =&gt; 50]</code></pre>\n  <p></p>\n  <h4><code>dump()</code></h4>\n  <p>The <code>dump</code> method dumps the collection's items:</p>\n  <pre><code>$collection = collect(['John Doe', 'Jane Doe']);\n\n$collection-&gt;dump();\n\n/*\n    Collection {\n        #items: array:2 [\n            0 =&gt; \"John Doe\"\n            1 =&gt; \"Jane Doe\"\n        ]\n    }\n*/</code></pre>\n  <p>If you want to stop executing the script after dumping the collection, use the <code>dd</code> method instead.</p>\n  <p></p>\n  <h4><code>duplicates()</code></h4>\n  <p>The <code>duplicates</code> method retrieves and returns duplicate values from the collection:</p>\n  <pre><code>$collection = collect(['a', 'b', 'a', 'c', 'b']);\n\n$collection-&gt;duplicates();\n\n// [2 =&gt; 'a', 4 =&gt; 'b']</code></pre>\n  <p>Si la colección contiene matrices u objetos, puede pasar la clave de los atributos que desea verificar en busca de valores duplicados:</p>\n  <pre><code>$employees = collect([\n    ['email' =&gt; 'abigail@example.com', 'position' =&gt; 'Developer'],\n    ['email' =&gt; 'james@example.com', 'position' =&gt; 'Designer'],\n    ['email' =&gt; 'victoria@example.com', 'position' =&gt; 'Developer'],\n])\n\n$employees-&gt;duplicates('position');\n\n// [2 =&gt; 'Developer']</code></pre>\n  <p></p>\n  <h4><code>duplicatesStrict()</code></h4>\n  <p>Este método tiene la misma firma que el <code>duplicates</code>método; sin embargo, todos los valores se comparan mediante comparaciones \"estrictas\".</p>\n  <p></p>\n  <h4><code>each()</code></h4>\n  <p>El <code>each</code>método itera sobre los elementos de la colección y pasa cada elemento a una devolución de llamada:</p>\n  <pre><code>$collection-&gt;each(function ($item, $key) {\n    //\n});</code></pre>\n  <p>Si desea dejar de iterar a través de los elementos, puede regresar <code>false</code>de su devolución de llamada:</p>\n  <pre><code>$collection-&gt;each(function ($item, $key) {\n    if (/* some condition */) {\n        return false;\n    }\n});</code></pre>\n  <p></p>\n  <h4><code>eachSpread()</code></h4>\n  <p>El <code>eachSpread</code>método itera sobre los elementos de la colección, pasando cada valor de elemento anidado a la devolución de llamada dada:</p>\n  <pre><code>$collection = collect([['John Doe', 35], ['Jane Doe', 33]]);\n\n$collection-&gt;eachSpread(function ($name, $age) {\n    //\n});</code></pre>\n  <p>Puede dejar de recorrer los elementos volviendo <code>false</code>de la devolución de llamada:</p>\n  <pre><code>$collection-&gt;eachSpread(function ($name, $age) {\n    return false;\n});</code></pre>\n  <p></p>\n  <h4><code>every()</code></h4>\n  <p>El <code>every</code>método se puede utilizar para verificar que todos los elementos de una colección pasen una prueba de verdad determinada:</p>\n  <pre><code>collect([1, 2, 3, 4])-&gt;every(function ($value, $key) {\n    return $value &gt; 2;\n});\n\n// false</code></pre>\n  <p>Si la colección está vacía, <code>every</code>devolverá verdadero:</p>\n  <pre><code>$collection = collect([]);\n\n$collection-&gt;every(function ($value, $key) {\n    return $value &gt; 2;\n});\n\n// true</code></pre>\n  <p></p>\n  <h4><code>except()</code></h4>\n  <p>El <code>except</code>método devuelve todos los elementos de la colección, excepto aquellos con las claves especificadas:</p>\n  <pre><code>$collection = collect(['product_id' =&gt; 1, 'price' =&gt; 100, 'discount' =&gt; false]);\n\n$filtered = $collection-&gt;except(['price', 'discount']);\n\n$filtered-&gt;all();\n\n// ['product_id' =&gt; 1]</code></pre>\n  <p>Para el inverso de <code>except</code>, vea el único método.</p>\n  <blockquote>\n    <div><div></div><p>El comportamiento de este método se modifica al utilizar Eloquent Collections .</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>filter()</code></h4>\n  <p>El <code>filter</code>método filtra la colección usando la devolución de llamada dada, manteniendo solo aquellos elementos que pasan una prueba de verdad determinada:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$filtered = $collection-&gt;filter(function ($value, $key) {\n    return $value &gt; 2;\n});\n\n$filtered-&gt;all();\n\n// [3, 4]</code></pre>\n  <p>Si no se proporciona ninguna devolución de llamada, <code>false</code>se eliminarán todas las entradas de la colección que sean equivalentes a :</p>\n  <pre><code>$collection = collect([1, 2, 3, null, false, '', 0, []]);\n\n$collection-&gt;filter()-&gt;all();\n\n// [1, 2, 3]</code></pre>\n  <p>Para el inverso de <code>filter</code>, consulte el método de rechazo .</p>\n  <p></p>\n  <h4><code>first()</code></h4>\n  <p>El <code>first</code>método devuelve el primer elemento de la colección que pasa una prueba de verdad determinada:</p>\n  <pre><code>collect([1, 2, 3, 4])-&gt;first(function ($value, $key) {\n    return $value &gt; 2;\n});\n\n// 3</code></pre>\n  <p>También puede llamar al <code>first</code>método sin argumentos para obtener el primer elemento de la colección. Si la colección está vacía, <code>null</code>se devuelve:</p>\n  <pre><code>collect([1, 2, 3, 4])-&gt;first();\n\n// 1</code></pre>\n  <p></p>\n  <h4><code>firstWhere()</code></h4>\n  <p>El <code>firstWhere</code>método devuelve el primer elemento de la colección con el par clave / valor dado:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'Regena', 'age' =&gt; null],\n    ['name' =&gt; 'Linda', 'age' =&gt; 14],\n    ['name' =&gt; 'Diego', 'age' =&gt; 23],\n    ['name' =&gt; 'Linda', 'age' =&gt; 84],\n]);\n\n$collection-&gt;firstWhere('name', 'Linda');\n\n// ['name' =&gt; 'Linda', 'age' =&gt; 14]</code></pre>\n  <p>También puede llamar al <code>firstWhere</code>método con un operador:</p>\n  <pre><code>$collection-&gt;firstWhere('age', '&gt;=', 18);\n\n// ['name' =&gt; 'Diego', 'age' =&gt; 23]</code></pre>\n  <p>Al igual que el método where , puede pasar un argumento al <code>firstWhere</code>método. En este escenario, el <code>firstWhere</code>método devolverá el primer elemento donde el valor de la clave del elemento dado es \"verdadero\":</p>\n  <pre><code>$collection-&gt;firstWhere('age');\n\n// ['name' =&gt; 'Linda', 'age' =&gt; 14]</code></pre>\n  <p></p>\n  <h4><code>flatMap()</code></h4>\n  <p>El <code>flatMap</code>método itera a través de la colección y pasa cada valor a la devolución de llamada dada. La devolución de llamada es libre de modificar el artículo y devolverlo, formando así una nueva colección de artículos modificados. Luego, la matriz se aplana por un nivel:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'Sally'],\n    ['school' =&gt; 'Arkansas'],\n    ['age' =&gt; 28]\n]);\n\n$flattened = $collection-&gt;flatMap(function ($values) {\n    return array_map('strtoupper', $values);\n});\n\n$flattened-&gt;all();\n\n// ['name' =&gt; 'SALLY', 'school' =&gt; 'ARKANSAS', 'age' =&gt; '28'];</code></pre>\n  <p></p>\n  <h4><code>flatten()</code></h4>\n  <p>El <code>flatten</code>método aplana una colección multidimensional en una sola dimensión:</p>\n  <pre><code>$collection = collect(['name' =&gt; 'taylor', 'languages' =&gt; ['php', 'javascript']]);\n\n$flattened = $collection-&gt;flatten();\n\n$flattened-&gt;all();\n\n// ['taylor', 'php', 'javascript'];</code></pre>\n  <p>Opcionalmente, puede pasar a la función un argumento de \"profundidad\":</p>\n  <pre><code>$collection = collect([\n    'Apple' =&gt; [\n        ['name' =&gt; 'iPhone 6S', 'brand' =&gt; 'Apple'],\n    ],\n    'Samsung' =&gt; [\n        ['name' =&gt; 'Galaxy S7', 'brand' =&gt; 'Samsung'],\n    ],\n]);\n\n$products = $collection-&gt;flatten(1);\n\n$products-&gt;values()-&gt;all();\n\n/*\n    [\n        ['name' =&gt; 'iPhone 6S', 'brand' =&gt; 'Apple'],\n        ['name' =&gt; 'Galaxy S7', 'brand' =&gt; 'Samsung'],\n    ]\n*/</code></pre>\n  <p>En este ejemplo, llamar <code>flatten</code>sin proporcionar la profundidad también habría aplanado las matrices anidadas, dando como resultado . Proporcionar una profundidad le permite restringir los niveles de matrices anidadas que se aplanarán.<code>['iPhone 6S', 'Apple', 'Galaxy S7', 'Samsung']</code></p>\n  <p></p>\n  <h4><code>flip()</code></h4>\n  <p>El <code>flip</code>método intercambia las claves de la colección con sus valores correspondientes:</p>\n  <pre><code>$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);\n\n$flipped = $collection-&gt;flip();\n\n$flipped-&gt;all();\n\n// ['taylor' =&gt; 'name', 'laravel' =&gt; 'framework']</code></pre>\n  <p></p>\n  <h4><code>forget()</code></h4>\n  <p>El <code>forget</code>método elimina un elemento de la colección por su clave:</p>\n  <pre><code>$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);\n\n$collection-&gt;forget('name');\n\n$collection-&gt;all();\n\n// ['framework' =&gt; 'laravel']</code></pre>\n  <blockquote>\n    <div><div></div><p>A diferencia de la mayoría de los otros métodos de colección, <code>forget</code>no devuelve una nueva colección modificada; modifica la colección a la que se llama.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>forPage()</code></h4>\n  <p>The <code>forPage</code> method returns a new collection containing the items that would be present on a given page number. The method accepts the page number as its first argument and the number of items to show per page as its second argument:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n$chunk = $collection-&gt;forPage(2, 3);\n\n$chunk-&gt;all();\n\n// [4, 5, 6]</code></pre>\n  <p></p>\n  <h4><code>get()</code></h4>\n  <p>The <code>get</code> method returns the item at a given key. If the key does not exist, <code>null</code> is returned:</p>\n  <pre><code>$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);\n\n$value = $collection-&gt;get('name');\n\n// taylor</code></pre>\n  <p>You may optionally pass a default value as the second argument:</p>\n  <pre><code>$collection = collect(['name' =&gt; 'taylor', 'framework' =&gt; 'laravel']);\n\n$value = $collection-&gt;get('foo', 'default-value');\n\n// default-value</code></pre>\n  <p>You may even pass a callback as the default value. The result of the callback will be returned if the specified key does not exist:</p>\n  <pre><code>$collection-&gt;get('email', function () {\n    return 'default-value';\n});\n\n// default-value</code></pre>\n  <p></p>\n  <h4><code>groupBy()</code></h4>\n  <p>The <code>groupBy</code> method groups the collection's items by a given key:</p>\n  <pre><code>$collection = collect([\n    ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Chair'],\n    ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Bookcase'],\n    ['account_id' =&gt; 'account-x11', 'product' =&gt; 'Desk'],\n]);\n\n$grouped = $collection-&gt;groupBy('account_id');\n\n$grouped-&gt;toArray();\n\n/*\n    [\n        'account-x10' =&gt; [\n            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Chair'],\n            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Bookcase'],\n        ],\n        'account-x11' =&gt; [\n            ['account_id' =&gt; 'account-x11', 'product' =&gt; 'Desk'],\n        ],\n    ]\n*/</code></pre>\n  <p>Instead of passing a string <code>key</code>, you may pass a callback. The callback should return the value you wish to key the group by:</p>\n  <pre><code>$grouped = $collection-&gt;groupBy(function ($item, $key) {\n    return substr($item['account_id'], -3);\n});\n\n$grouped-&gt;toArray();\n\n/*\n    [\n        'x10' =&gt; [\n            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Chair'],\n            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Bookcase'],\n        ],\n        'x11' =&gt; [\n            ['account_id' =&gt; 'account-x11', 'product' =&gt; 'Desk'],\n        ],\n    ]\n*/</code></pre>\n  <p>Se pueden pasar varios criterios de agrupación como una matriz. Cada elemento de la matriz se aplicará al nivel correspondiente dentro de una matriz multidimensional:</p>\n  <pre><code>$data = new Collection([\n    10 =&gt; ['user' =&gt; 1, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_3']],\n    20 =&gt; ['user' =&gt; 2, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_2']],\n    30 =&gt; ['user' =&gt; 3, 'skill' =&gt; 2, 'roles' =&gt; ['Role_1']],\n    40 =&gt; ['user' =&gt; 4, 'skill' =&gt; 2, 'roles' =&gt; ['Role_2']],\n]);\n\n$result = $data-&gt;groupBy([\n    'skill',\n    function ($item) {\n        return $item['roles'];\n    },\n], $preserveKeys = true);\n\n/*\n[\n    1 =&gt; [\n        'Role_1' =&gt; [\n            10 =&gt; ['user' =&gt; 1, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_3']],\n            20 =&gt; ['user' =&gt; 2, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_2']],\n        ],\n        'Role_2' =&gt; [\n            20 =&gt; ['user' =&gt; 2, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_2']],\n        ],\n        'Role_3' =&gt; [\n            10 =&gt; ['user' =&gt; 1, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_3']],\n        ],\n    ],\n    2 =&gt; [\n        'Role_1' =&gt; [\n            30 =&gt; ['user' =&gt; 3, 'skill' =&gt; 2, 'roles' =&gt; ['Role_1']],\n        ],\n        'Role_2' =&gt; [\n            40 =&gt; ['user' =&gt; 4, 'skill' =&gt; 2, 'roles' =&gt; ['Role_2']],\n        ],\n    ],\n];\n*/</code></pre>\n  <p></p>\n  <h4><code>has()</code></h4>\n  <p>El <code>has</code>método determina si existe una clave determinada en la colección:</p>\n  <pre><code>$collection = collect(['account_id' =&gt; 1, 'product' =&gt; 'Desk', 'amount' =&gt; 5]);\n\n$collection-&gt;has('product');\n\n// true\n\n$collection-&gt;has(['product', 'amount']);\n\n// true\n\n$collection-&gt;has(['amount', 'price']);\n\n// false</code></pre>\n  <p></p>\n  <h4><code>implode()</code></h4>\n  <p>El <code>implode</code>método une los elementos de una colección. Sus argumentos dependen del tipo de elementos de la colección. Si la colección contiene matrices u objetos, debe pasar la clave de los atributos que desea unir y la cadena de \"pegamento\" que desea colocar entre los valores:</p>\n  <pre><code>$collection = collect([\n    ['account_id' =&gt; 1, 'product' =&gt; 'Desk'],\n    ['account_id' =&gt; 2, 'product' =&gt; 'Chair'],\n]);\n\n$collection-&gt;implode('product', ', ');\n\n// Desk, Chair</code></pre>\n  <p>Si la colección contiene cadenas simples o valores numéricos, pase el \"pegamento\" como el único argumento del método:</p>\n  <pre><code>collect([1, 2, 3, 4, 5])-&gt;implode('-');\n\n// '1-2-3-4-5'</code></pre>\n  <p></p>\n  <h4><code>intersect()</code></h4>\n  <p>El <code>intersect</code>método elimina cualquier valor de la colección original que no esté presente en la <code>array</code>colección dada . La colección resultante conservará las claves de la colección original:</p>\n  <pre><code>$collection = collect(['Desk', 'Sofa', 'Chair']);\n\n$intersect = $collection-&gt;intersect(['Desk', 'Chair', 'Bookcase']);\n\n$intersect-&gt;all();\n\n// [0 =&gt; 'Desk', 2 =&gt; 'Chair']</code></pre>\n  <blockquote>\n    <div><div></div><p>El comportamiento de este método se modifica al utilizar Eloquent Collections .</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>intersectByKeys()</code></h4>\n  <p>El <code>intersectByKeys</code>método elimina las claves de la colección original que no están presentes en la <code>array</code>colección dada :</p>\n  <pre><code>$collection = collect([\n    'serial' =&gt; 'UX301', 'type' =&gt; 'screen', 'year' =&gt; 2009,\n]);\n\n$intersect = $collection-&gt;intersectByKeys([\n    'reference' =&gt; 'UX404', 'type' =&gt; 'tab', 'year' =&gt; 2011,\n]);\n\n$intersect-&gt;all();\n\n// ['type' =&gt; 'screen', 'year' =&gt; 2009]</code></pre>\n  <p></p>\n  <h4><code>isEmpty()</code></h4>\n  <p>El <code>isEmpty</code>método regresa <code>true</code>si la colección está vacía; de lo contrario, <code>false</code>se devuelve:</p>\n  <pre><code>collect([])-&gt;isEmpty();\n\n// true</code></pre>\n  <p></p>\n  <h4><code>isNotEmpty()</code></h4>\n  <p>El <code>isNotEmpty</code>método regresa <code>true</code>si la colección no está vacía; de lo contrario, <code>false</code>se devuelve:</p>\n  <pre><code>collect([])-&gt;isNotEmpty();\n\n// false</code></pre>\n  <p></p>\n  <h4><code>join()</code></h4>\n  <p>El <code>join</code>método une los valores de la colección con una cadena:</p>\n  <pre><code>collect(['a', 'b', 'c'])-&gt;join(', '); // 'a, b, c'\ncollect(['a', 'b', 'c'])-&gt;join(', ', ', and '); // 'a, b, and c'\ncollect(['a', 'b'])-&gt;join(', ', ' and '); // 'a and b'\ncollect(['a'])-&gt;join(', ', ' and '); // 'a'\ncollect([])-&gt;join(', ', ' and '); // ''</code></pre>\n  <p></p>\n  <h4><code>keyBy()</code></h4>\n  <p>El <code>keyBy</code>método codifica la colección por la clave dada. Si varios elementos tienen la misma clave, solo el último aparecerá en la nueva colección:</p>\n  <pre><code>$collection = collect([\n    ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],\n    ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],\n]);\n\n$keyed = $collection-&gt;keyBy('product_id');\n\n$keyed-&gt;all();\n\n/*\n    [\n        'prod-100' =&gt; ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],\n        'prod-200' =&gt; ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],\n    ]\n*/</code></pre>\n  <p>También puede pasar una devolución de llamada al método. La devolución de llamada debe devolver el valor a la clave de la colección por:</p>\n  <pre><code>$keyed = $collection-&gt;keyBy(function ($item) {\n    return strtoupper($item['product_id']);\n});\n\n$keyed-&gt;all();\n\n/*\n    [\n        'PROD-100' =&gt; ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],\n        'PROD-200' =&gt; ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>keys()</code></h4>\n  <p>El <code>keys</code>método devuelve todas las claves de la colección:</p>\n  <pre><code>$collection = collect([\n    'prod-100' =&gt; ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],\n    'prod-200' =&gt; ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],\n]);\n\n$keys = $collection-&gt;keys();\n\n$keys-&gt;all();\n\n// ['prod-100', 'prod-200']</code></pre>\n  <p></p>\n  <h4><code>last()</code></h4>\n  <p>El <code>last</code>método devuelve el último elemento de la colección que pasa una prueba de verdad determinada:</p>\n  <pre><code>collect([1, 2, 3, 4])-&gt;last(function ($value, $key) {\n    return $value &lt; 3;\n});\n\n// 2</code></pre>\n  <p>También puede llamar al <code>last</code>método sin argumentos para obtener el último elemento de la colección. Si la colección está vacía, <code>null</code>se devuelve:</p>\n  <pre><code>collect([1, 2, 3, 4])-&gt;last();\n\n// 4</code></pre>\n  <p></p>\n  <h4><code>macro()</code></h4>\n  <p>El <code>macro</code>método estático le permite agregar métodos a la <code>Collection</code>clase en tiempo de ejecución. Consulte la documentación sobre la ampliación de cobros para obtener más información.</p>\n  <p></p>\n  <h4><code>make()</code></h4>\n  <p>El <code>make</code>método estático crea una nueva instancia de colección. Consulte la sección Creación de colecciones .</p>\n  <p></p>\n  <h4><code>map()</code></h4>\n  <p>El <code>map</code>método itera a través de la colección y pasa cada valor a la devolución de llamada dada. La devolución de llamada es libre de modificar el artículo y devolverlo, formando así una nueva colección de artículos modificados:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$multiplied = $collection-&gt;map(function ($item, $key) {\n    return $item * 2;\n});\n\n$multiplied-&gt;all();\n\n// [2, 4, 6, 8, 10]</code></pre>\n  <blockquote>\n    <div><div></div><p>Como la mayoría de los otros métodos de colección, <code>map</code>devuelve una nueva instancia de colección; no modifica la colección a la que se llama. Si desea transformar la colección original, use el <code>transform</code>método.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>mapInto()</code></h4>\n  <p>El método itera sobre la colección, creando una nueva instancia de la clase dada pasando el valor al constructor:<code>mapInto()</code></p>\n  <pre><code>class Currency\n{\n    /**\n     * Create a new currency instance.\n     *\n     * @param  string  $code\n     * @return void\n     */\n    function __construct(string $code)\n    {\n        $this-&gt;code = $code;\n    }\n}\n\n$collection = collect(['USD', 'EUR', 'GBP']);\n\n$currencies = $collection-&gt;mapInto(Currency::class);\n\n$currencies-&gt;all();\n\n// [Currency('USD'), Currency('EUR'), Currency('GBP')]</code></pre>\n  <p></p>\n  <h4><code>mapSpread()</code></h4>\n  <p>El <code>mapSpread</code>método itera sobre los elementos de la colección, pasando cada valor de elemento anidado a la devolución de llamada dada. La devolución de llamada es libre de modificar el artículo y devolverlo, formando así una nueva colección de artículos modificados:</p>\n  <pre><code>$collection = collect([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n$chunks = $collection-&gt;chunk(2);\n\n$sequence = $chunks-&gt;mapSpread(function ($even, $odd) {\n    return $even + $odd;\n});\n\n$sequence-&gt;all();\n\n// [1, 5, 9, 13, 17]</code></pre>\n  <p></p>\n  <h4><code>mapToGroups()</code></h4>\n  <p>El <code>mapToGroups</code>método agrupa los elementos de la colección por la devolución de llamada dada. La devolución de llamada debe devolver una matriz asociativa que contenga un solo par clave / valor, formando así una nueva colección de valores agrupados:</p>\n  <pre><code>$collection = collect([\n    [\n        'name' =&gt; 'John Doe',\n        'department' =&gt; 'Sales',\n    ],\n    [\n        'name' =&gt; 'Jane Doe',\n        'department' =&gt; 'Sales',\n    ],\n    [\n        'name' =&gt; 'Johnny Doe',\n        'department' =&gt; 'Marketing',\n    ]\n]);\n\n$grouped = $collection-&gt;mapToGroups(function ($item, $key) {\n    return [$item['department'] =&gt; $item['name']];\n});\n\n$grouped-&gt;toArray();\n\n/*\n    [\n        'Sales' =&gt; ['John Doe', 'Jane Doe'],\n        'Marketing' =&gt; ['Johnny Doe'],\n    ]\n*/\n\n$grouped-&gt;get('Sales')-&gt;all();\n\n// ['John Doe', 'Jane Doe']</code></pre>\n  <p></p>\n  <h4><code>mapWithKeys()</code></h4>\n  <p>El <code>mapWithKeys</code>método itera a través de la colección y pasa cada valor a la devolución de llamada dada. La devolución de llamada debe devolver una matriz asociativa que contenga un solo par clave / valor:</p>\n  <pre><code>$collection = collect([\n    [\n        'name' =&gt; 'John',\n        'department' =&gt; 'Sales',\n        'email' =&gt; 'john@example.com',\n    ],\n    [\n        'name' =&gt; 'Jane',\n        'department' =&gt; 'Marketing',\n        'email' =&gt; 'jane@example.com',\n    ]\n]);\n\n$keyed = $collection-&gt;mapWithKeys(function ($item) {\n    return [$item['email'] =&gt; $item['name']];\n});\n\n$keyed-&gt;all();\n\n/*\n    [\n        'john@example.com' =&gt; 'John',\n        'jane@example.com' =&gt; 'Jane',\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>max()</code></h4>\n  <p>El <code>max</code>método devuelve el valor máximo de una clave determinada:</p>\n  <pre><code>$max = collect([['foo' =&gt; 10], ['foo' =&gt; 20]])-&gt;max('foo');\n\n// 20\n\n$max = collect([1, 2, 3, 4, 5])-&gt;max();\n\n// 5</code></pre>\n  <p></p>\n  <h4><code>median()</code></h4>\n  <p>El <code>median</code>método devuelve el valor mediano de una clave determinada:</p>\n  <pre><code>$median = collect([['foo' =&gt; 10], ['foo' =&gt; 10], ['foo' =&gt; 20], ['foo' =&gt; 40]])-&gt;median('foo');\n\n// 15\n\n$median = collect([1, 1, 2, 4])-&gt;median();\n\n// 1.5</code></pre>\n  <p></p>\n  <h4><code>merge()</code></h4>\n  <p>The <code>merge</code> method merges the given array or collection with the original collection. If a string key in the given items matches a string key in the original collection, the given items's value will overwrite the value in the original collection:</p>\n  <pre><code>$collection = collect(['product_id' =&gt; 1, 'price' =&gt; 100]);\n\n$merged = $collection-&gt;merge(['price' =&gt; 200, 'discount' =&gt; false]);\n\n$merged-&gt;all();\n\n// ['product_id' =&gt; 1, 'price' =&gt; 200, 'discount' =&gt; false]</code></pre>\n  <p>If the given items's keys are numeric, the values will be appended to the end of the collection:</p>\n  <pre><code>$collection = collect(['Desk', 'Chair']);\n\n$merged = $collection-&gt;merge(['Bookcase', 'Door']);\n\n$merged-&gt;all();\n\n// ['Desk', 'Chair', 'Bookcase', 'Door']</code></pre>\n  <p></p>\n  <h4><code>mergeRecursive()</code></h4>\n  <p>The <code>mergeRecursive</code> method merges the given array or collection recursively with the original collection. If a string key in the given items matches a string key in the original collection, then the values for these keys are merged together into an array, and this is done recursively:</p>\n  <pre><code>$collection = collect(['product_id' =&gt; 1, 'price' =&gt; 100]);\n\n$merged = $collection-&gt;mergeRecursive(['product_id' =&gt; 2, 'price' =&gt; 200, 'discount' =&gt; false]);\n\n$merged-&gt;all();\n\n// ['product_id' =&gt; [1, 2], 'price' =&gt; [100, 200], 'discount' =&gt; false]</code></pre>\n  <p></p>\n  <h4><code>min()</code></h4>\n  <p>The <code>min</code> method returns the minimum value of a given key:</p>\n  <pre><code>$min = collect([['foo' =&gt; 10], ['foo' =&gt; 20]])-&gt;min('foo');\n\n// 10\n\n$min = collect([1, 2, 3, 4, 5])-&gt;min();\n\n// 1</code></pre>\n  <p></p>\n  <h4><code>mode()</code></h4>\n  <p>The <code>mode</code> method returns the mode value of a given key:</p>\n  <pre><code>$mode = collect([['foo' =&gt; 10], ['foo' =&gt; 10], ['foo' =&gt; 20], ['foo' =&gt; 40]])-&gt;mode('foo');\n\n// [10]\n\n$mode = collect([1, 1, 2, 4])-&gt;mode();\n\n// [1]</code></pre>\n  <p></p>\n  <h4><code>nth()</code></h4>\n  <p>El <code>nth</code>método crea una nueva colección que consta de cada elemento n-ésimo:</p>\n  <pre><code>$collection = collect(['a', 'b', 'c', 'd', 'e', 'f']);\n\n$collection-&gt;nth(4);\n\n// ['a', 'e']</code></pre>\n  <p>Opcionalmente, puede pasar un desplazamiento como segundo argumento:</p>\n  <pre><code>$collection-&gt;nth(4, 1);\n\n// ['b', 'f']</code></pre>\n  <p></p>\n  <h4><code>only()</code></h4>\n  <p>El <code>only</code>método devuelve los elementos de la colección con las claves especificadas:</p>\n  <pre><code>$collection = collect(['product_id' =&gt; 1, 'name' =&gt; 'Desk', 'price' =&gt; 100, 'discount' =&gt; false]);\n\n$filtered = $collection-&gt;only(['product_id', 'name']);\n\n$filtered-&gt;all();\n\n// ['product_id' =&gt; 1, 'name' =&gt; 'Desk']</code></pre>\n  <p>Para el inverso de <code>only</code>, vea el método except .</p>\n  <blockquote>\n    <div><div></div><p>El comportamiento de este método se modifica al utilizar Eloquent Collections .</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>pad()</code></h4>\n  <p>El <code>pad</code>método llenará la matriz con el valor dado hasta que la matriz alcance el tamaño especificado. Este método se comporta como la función PHP array_pad .</p>\n  <p>Para rellenar a la izquierda, debe especificar un tamaño negativo. No se realizará ningún relleno si el valor absoluto del tamaño dado es menor o igual que la longitud de la matriz:</p>\n  <pre><code>$collection = collect(['A', 'B', 'C']);\n\n$filtered = $collection-&gt;pad(5, 0);\n\n$filtered-&gt;all();\n\n// ['A', 'B', 'C', 0, 0]\n\n$filtered = $collection-&gt;pad(-5, 0);\n\n$filtered-&gt;all();\n\n// [0, 0, 'A', 'B', 'C']</code></pre>\n  <p></p>\n  <h4><code>partition()</code></h4>\n  <p>El <code>partition</code>método puede combinarse con la <code>list</code>función PHP para separar los elementos que pasan una prueba de verdad determinada de los que no:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5, 6]);\n\nlist($underThree, $equalOrAboveThree) = $collection-&gt;partition(function ($i) {\n    return $i &lt; 3;\n});\n\n$underThree-&gt;all();\n\n// [1, 2]\n\n$equalOrAboveThree-&gt;all();\n\n// [3, 4, 5, 6]</code></pre>\n  <p></p>\n  <h4><code>pipe()</code></h4>\n  <p>El <code>pipe</code>método pasa la colección a la devolución de llamada dada y devuelve el resultado:</p>\n  <pre><code>$collection = collect([1, 2, 3]);\n\n$piped = $collection-&gt;pipe(function ($collection) {\n    return $collection-&gt;sum();\n});\n\n// 6</code></pre>\n  <p></p>\n  <h4><code>pluck()</code></h4>\n  <p>El <code>pluck</code>método recupera todos los valores de una clave determinada:</p>\n  <pre><code>$collection = collect([\n    ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],\n    ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],\n]);\n\n$plucked = $collection-&gt;pluck('name');\n\n$plucked-&gt;all();\n\n// ['Desk', 'Chair']</code></pre>\n  <p>También puede especificar cómo desea que se codifique la colección resultante:</p>\n  <pre><code>$plucked = $collection-&gt;pluck('name', 'product_id');\n\n$plucked-&gt;all();\n\n// ['prod-100' =&gt; 'Desk', 'prod-200' =&gt; 'Chair']</code></pre>\n  <p>El <code>pluck</code>método también admite la recuperación de valores anidados mediante la notación de \"puntos\":</p>\n  <pre><code>$collection = collect([\n    [\n        'speakers' =&gt; [\n            'first_day' =&gt; ['Rosa', 'Judith'],\n            'second_day' =&gt; ['Angela', 'Kathleen'],\n        ],\n    ],\n]);\n\n$plucked = $collection-&gt;pluck('speakers.first_day');\n\n$plucked-&gt;all();\n\n// ['Rosa', 'Judith']</code></pre>\n  <p>Si existen claves duplicadas, el último elemento coincidente se insertará en la colección extraída:</p>\n  <pre><code>$collection = collect([\n    ['brand' =&gt; 'Tesla',  'color' =&gt; 'red'],\n    ['brand' =&gt; 'Pagani', 'color' =&gt; 'white'],\n    ['brand' =&gt; 'Tesla',  'color' =&gt; 'black'],\n    ['brand' =&gt; 'Pagani', 'color' =&gt; 'orange'],\n]);\n\n$plucked = $collection-&gt;pluck('color', 'brand');\n\n$plucked-&gt;all();\n\n// ['Tesla' =&gt; 'black', 'Pagani' =&gt; 'orange']</code></pre>\n  <p></p>\n  <h4><code>pop()</code></h4>\n  <p>El <code>pop</code>método elimina y devuelve el último elemento de la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-&gt;pop();\n\n// 5\n\n$collection-&gt;all();\n\n// [1, 2, 3, 4]</code></pre>\n  <p></p>\n  <h4><code>prepend()</code></h4>\n  <p>El <code>prepend</code>método agrega un elemento al comienzo de la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-&gt;prepend(0);\n\n$collection-&gt;all();\n\n// [0, 1, 2, 3, 4, 5]</code></pre>\n  <p>También puede pasar un segundo argumento para establecer la clave del elemento antepuesto:</p>\n  <pre><code>$collection = collect(['one' =&gt; 1, 'two' =&gt; 2]);\n\n$collection-&gt;prepend(0, 'zero');\n\n$collection-&gt;all();\n\n// ['zero' =&gt; 0, 'one' =&gt; 1, 'two' =&gt; 2]</code></pre>\n  <p></p>\n  <h4><code>pull()</code></h4>\n  <p>El <code>pull</code>método elimina y devuelve un elemento de la colección por su clave:</p>\n  <pre><code>$collection = collect(['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk']);\n\n$collection-&gt;pull('name');\n\n// 'Desk'\n\n$collection-&gt;all();\n\n// ['product_id' =&gt; 'prod-100']</code></pre>\n  <p></p>\n  <h4><code>push()</code></h4>\n  <p>El <code>push</code>método agrega un elemento al final de la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$collection-&gt;push(5);\n\n$collection-&gt;all();\n\n// [1, 2, 3, 4, 5]</code></pre>\n  <p></p>\n  <h4><code>put()</code></h4>\n  <p>El <code>put</code>método establece la clave y el valor dados en la colección:</p>\n  <pre><code>$collection = collect(['product_id' =&gt; 1, 'name' =&gt; 'Desk']);\n\n$collection-&gt;put('price', 100);\n\n$collection-&gt;all();\n\n// ['product_id' =&gt; 1, 'name' =&gt; 'Desk', 'price' =&gt; 100]</code></pre>\n  <p></p>\n  <h4><code>random()</code></h4>\n  <p>El <code>random</code>método devuelve un elemento aleatorio de la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-&gt;random();\n\n// 4 - (retrieved randomly)</code></pre>\n  <p>Opcionalmente, puede pasar un número entero a <code>random</code>para especificar cuántos elementos le gustaría recuperar aleatoriamente. Siempre se devuelve una colección de artículos cuando se pasa explícitamente la cantidad de artículos que desea recibir:</p>\n  <pre><code>$random = $collection-&gt;random(3);\n\n$random-&gt;all();\n\n// [2, 4, 5] - (retrieved randomly)</code></pre>\n  <p>Si la colección tiene menos elementos de los solicitados, el método arrojará un <code>InvalidArgumentException</code>.</p>\n  <p></p>\n  <h4><code>reduce()</code></h4>\n  <p>El <code>reduce</code>método reduce la colección a un solo valor, pasando el resultado de cada iteración a la siguiente iteración:</p>\n  <pre><code>$collection = collect([1, 2, 3]);\n\n$total = $collection-&gt;reduce(function ($carry, $item) {\n    return $carry + $item;\n});\n\n// 6</code></pre>\n  <p>El valor de <code>$carry</code>en la primera iteración es <code>null</code>; sin embargo, puede especificar su valor inicial pasando un segundo argumento a <code>reduce</code>:</p>\n  <pre><code>$collection-&gt;reduce(function ($carry, $item) {\n    return $carry + $item;\n}, 4);\n\n// 10</code></pre>\n  <p></p>\n  <h4><code>reject()</code></h4>\n  <p>El <code>reject</code>método filtra la colección usando la devolución de llamada dada. La devolución de llamada debe regresar <code>true</code>si el elemento debe eliminarse de la colección resultante:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$filtered = $collection-&gt;reject(function ($value, $key) {\n    return $value &gt; 2;\n});\n\n$filtered-&gt;all();\n\n// [1, 2]</code></pre>\n  <p>Para el inverso del <code>reject</code>método, vea el <code>filter</code>método.</p>\n  <p></p>\n  <h4><code>replace()</code></h4>\n  <p>El <code>replace</code>método se comporta de manera similar a <code>merge</code>; sin embargo, además de sobrescribir elementos coincidentes con claves de cadena, el <code>replace</code>método también sobrescribirá elementos de la colección que tengan claves numéricas coincidentes:</p>\n  <pre><code>$collection = collect(['Taylor', 'Abigail', 'James']);\n\n$replaced = $collection-&gt;replace([1 =&gt; 'Victoria', 3 =&gt; 'Finn']);\n\n$replaced-&gt;all();\n\n// ['Taylor', 'Victoria', 'James', 'Finn']</code></pre>\n  <p></p>\n  <h4><code>replaceRecursive()</code></h4>\n  <p>Este método funciona como <code>replace</code>, pero se repetirá en matrices y aplicará el mismo proceso de reemplazo a los valores internos:</p>\n  <pre><code>$collection = collect(['Taylor', 'Abigail', ['James', 'Victoria', 'Finn']]);\n\n$replaced = $collection-&gt;replaceRecursive(['Charlie', 2 =&gt; [1 =&gt; 'King']]);\n\n$replaced-&gt;all();\n\n// ['Charlie', 'Abigail', ['James', 'King', 'Finn']]</code></pre>\n  <p></p>\n  <h4><code>reverse()</code></h4>\n  <p>El <code>reverse</code>método invierte el orden de los elementos de la colección, conservando las claves originales:</p>\n  <pre><code>$collection = collect(['a', 'b', 'c', 'd', 'e']);\n\n$reversed = $collection-&gt;reverse();\n\n$reversed-&gt;all();\n\n/*\n    [\n        4 =&gt; 'e',\n        3 =&gt; 'd',\n        2 =&gt; 'c',\n        1 =&gt; 'b',\n        0 =&gt; 'a',\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>search()</code></h4>\n  <p>El <code>search</code>método busca en la colección el valor dado y devuelve su clave si la encuentra. Si el artículo no se encuentra, <code>false</code>se devuelve.</p>\n  <pre><code>$collection = collect([2, 4, 6, 8]);\n\n$collection-&gt;search(4);\n\n// 1</code></pre>\n  <p>La búsqueda se realiza mediante una comparación \"suelta\", lo que significa que una cadena con un valor entero se considerará igual a un número entero del mismo valor. Para usar una comparación \"estricta\", pase <code>true</code>como segundo argumento al método:</p>\n  <pre><code>$collection-&gt;search('4', true);\n\n// false</code></pre>\n  <p>Alternativamente, puede pasar su propia devolución de llamada para buscar el primer elemento que pase su prueba de verdad:</p>\n  <pre><code>$collection-&gt;search(function ($item, $key) {\n    return $item &gt; 5;\n});\n\n// 2</code></pre>\n  <p></p>\n  <h4><code>shift()</code></h4>\n  <p>El <code>shift</code>método elimina y devuelve el primer elemento de la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-&gt;shift();\n\n// 1\n\n$collection-&gt;all();\n\n// [2, 3, 4, 5]</code></pre>\n  <p></p>\n  <h4><code>shuffle()</code></h4>\n  <p>El <code>shuffle</code>método baraja aleatoriamente los elementos de la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$shuffled = $collection-&gt;shuffle();\n\n$shuffled-&gt;all();\n\n// [3, 2, 5, 1, 4] - (generated randomly)</code></pre>\n  <p></p>\n  <h4><code>skip()</code></h4>\n  <p>El <code>skip</code>método devuelve una nueva colección, sin la primera cantidad dada de elementos:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\n$collection = $collection-&gt;skip(4);\n\n$collection-&gt;all();\n\n// [5, 6, 7, 8, 9, 10]</code></pre>\n  <p></p>\n  <h4><code>skipUntil()</code></h4>\n  <p>El <code>skipUntil</code>método omite elementos hasta que la devolución de llamada dada regrese <code>true</code>y luego devuelve los elementos restantes en la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$subset = $collection-&gt;skipUntil(function ($item) {\n    return $item &gt;= 3;\n});\n\n$subset-&gt;all();\n\n// [3, 4]</code></pre>\n  <p>También puede pasar un valor simple al <code>skipUntil</code>método para omitir todos los elementos hasta que se encuentre el valor dado:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$subset = $collection-&gt;skipUntil(3);\n\n$subset-&gt;all();\n\n// [3, 4]</code></pre>\n  <blockquote>\n    <div><div></div><p>Si no se encuentra el valor dado o la devolución de llamada nunca regresa <code>true</code>, el <code>skipUntil</code>método devolverá una colección vacía.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>skipWhile()</code></h4>\n  <p>El <code>skipWhile</code>método omite elementos mientras la devolución de llamada dada regresa <code>true</code>y luego devuelve los elementos restantes en la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$subset = $collection-&gt;skipWhile(function ($item) {\n    return $item &lt;= 3;\n});\n\n$subset-&gt;all();\n\n// [4]</code></pre>\n  <blockquote>\n    <div><div></div><p>Si la devolución de llamada nunca regresa <code>true</code>, el <code>skipWhile</code>método devolverá una colección vacía.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>slice()</code></h4>\n  <p>El <code>slice</code>método devuelve una porción de la colección comenzando en el índice dado:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\n$slice = $collection-&gt;slice(4);\n\n$slice-&gt;all();\n\n// [5, 6, 7, 8, 9, 10]</code></pre>\n  <p>Si desea limitar el tamaño del segmento devuelto, pase el tamaño deseado como segundo argumento del método:</p>\n  <pre><code>$slice = $collection-&gt;slice(4, 2);\n\n$slice-&gt;all();\n\n// [5, 6]</code></pre>\n  <p>El segmento devuelto conservará las claves de forma predeterminada. Si no desea conservar las claves originales, puede utilizar el <code>values</code>método para volver a indexarlas.</p>\n  <p></p>\n  <h4><code>some()</code></h4>\n  <p>Alias \u200B\u200Bdel <code>contains</code>método.</p>\n  <p></p>\n  <h4><code>sort()</code></h4>\n  <p>El <code>sort</code>método ordena la colección. La colección ordenada mantiene las claves de matriz originales, por lo que en este ejemplo usaremos el <code>values</code>método para restablecer las claves a índices numerados consecutivamente:</p>\n  <pre><code>$collection = collect([5, 3, 1, 2, 4]);\n\n$sorted = $collection-&gt;sort();\n\n$sorted-&gt;values()-&gt;all();\n\n// [1, 2, 3, 4, 5]</code></pre>\n  <p>Si sus necesidades de clasificación son más avanzadas, puede pasar una devolución de llamada <code>sort</code>con su propio algoritmo. Consulte la documentación de PHP en <code>uasort</code>, que es lo que el <code>sort</code>método de la colección llama bajo el capó.</p>\n  <blockquote>\n    <div><div></div><p> If you need to sort a collection of nested arrays or objects, see the <code>sortBy</code> and <code>sortByDesc</code> methods.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>sortBy()</code></h4>\n  <p>The <code>sortBy</code> method sorts the collection by the given key. The sorted collection keeps the original array keys, so in this example we'll use the <code>values</code> method to reset the keys to consecutively numbered indexes:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'Desk', 'price' =&gt; 200],\n    ['name' =&gt; 'Chair', 'price' =&gt; 100],\n    ['name' =&gt; 'Bookcase', 'price' =&gt; 150],\n]);\n\n$sorted = $collection-&gt;sortBy('price');\n\n$sorted-&gt;values()-&gt;all();\n\n/*\n    [\n        ['name' =&gt; 'Chair', 'price' =&gt; 100],\n        ['name' =&gt; 'Bookcase', 'price' =&gt; 150],\n        ['name' =&gt; 'Desk', 'price' =&gt; 200],\n    ]\n*/</code></pre>\n  <p>You can also pass your own callback to determine how to sort the collection values:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'Desk', 'colors' =&gt; ['Black', 'Mahogany']],\n    ['name' =&gt; 'Chair', 'colors' =&gt; ['Black']],\n    ['name' =&gt; 'Bookcase', 'colors' =&gt; ['Red', 'Beige', 'Brown']],\n]);\n\n$sorted = $collection-&gt;sortBy(function ($product, $key) {\n    return count($product['colors']);\n});\n\n$sorted-&gt;values()-&gt;all();\n\n/*\n    [\n        ['name' =&gt; 'Chair', 'colors' =&gt; ['Black']],\n        ['name' =&gt; 'Desk', 'colors' =&gt; ['Black', 'Mahogany']],\n        ['name' =&gt; 'Bookcase', 'colors' =&gt; ['Red', 'Beige', 'Brown']],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>sortByDesc()</code></h4>\n  <p>This method has the same signature as the <code>sortBy</code> method, but will sort the collection in the opposite order.</p>\n  <p></p>\n  <h4><code>sortDesc()</code></h4>\n  <p>This method will sort the collection in the opposite order as the <code>sort</code> method:</p>\n  <pre><code>$collection = collect([5, 3, 1, 2, 4]);\n\n$sorted = $collection-&gt;sortDesc();\n\n$sorted-&gt;values()-&gt;all();\n\n// [5, 4, 3, 2, 1]</code></pre>\n  <p>Unlike <code>sort</code>, you may not pass a callback to <code>sortDesc</code>. If you wish to use a callback, you should use <code>sort</code> and invert your comparison.</p>\n  <p></p>\n  <h4><code>sortKeys()</code></h4>\n  <p>El <code>sortKeys</code>método ordena la colección por las claves de la matriz asociativa subyacente:</p>\n  <pre><code>$collection = collect([\n    'id' =&gt; 22345,\n    'first' =&gt; 'John',\n    'last' =&gt; 'Doe',\n]);\n\n$sorted = $collection-&gt;sortKeys();\n\n$sorted-&gt;all();\n\n/*\n    [\n        'first' =&gt; 'John',\n        'id' =&gt; 22345,\n        'last' =&gt; 'Doe',\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>sortKeysDesc()</code></h4>\n  <p>Este método tiene la misma firma que el <code>sortKeys</code>método, pero clasificará la colección en el orden opuesto.</p>\n  <p></p>\n  <h4><code>splice()</code></h4>\n  <p>El <code>splice</code>método elimina y devuelve una porción de elementos que comienzan en el índice especificado:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection-&gt;splice(2);\n\n$chunk-&gt;all();\n\n// [3, 4, 5]\n\n$collection-&gt;all();\n\n// [1, 2]</code></pre>\n  <p>Puede pasar un segundo argumento para limitar el tamaño del fragmento resultante:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection-&gt;splice(2, 1);\n\n$chunk-&gt;all();\n\n// [3]\n\n$collection-&gt;all();\n\n// [1, 2, 4, 5]</code></pre>\n  <p>Además, puede pasar un tercer argumento que contenga los nuevos elementos para reemplazar los elementos eliminados de la colección:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection-&gt;splice(2, 1, [10, 11]);\n\n$chunk-&gt;all();\n\n// [3]\n\n$collection-&gt;all();\n\n// [1, 2, 10, 11, 4, 5]</code></pre>\n  <p></p>\n  <h4><code>split()</code></h4>\n  <p>El <code>split</code>método divide una colección en el número dado de grupos:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$groups = $collection-&gt;split(3);\n\n$groups-&gt;toArray();\n\n// [[1, 2], [3, 4], [5]]</code></pre>\n  <p></p>\n  <h4><code>sum()</code></h4>\n  <p>El <code>sum</code>método devuelve la suma de todos los elementos de la colección:</p>\n  <pre><code>collect([1, 2, 3, 4, 5])-&gt;sum();\n\n// 15</code></pre>\n  <p>Si la colección contiene matrices u objetos anidados, debe pasar una clave para usarla para determinar qué valores sumar:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'JavaScript: The Good Parts', 'pages' =&gt; 176],\n    ['name' =&gt; 'JavaScript: The Definitive Guide', 'pages' =&gt; 1096],\n]);\n\n$collection-&gt;sum('pages');\n\n// 1272</code></pre>\n  <p>Además, puede pasar su propia devolución de llamada para determinar qué valores de la colección sumarán:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'Chair', 'colors' =&gt; ['Black']],\n    ['name' =&gt; 'Desk', 'colors' =&gt; ['Black', 'Mahogany']],\n    ['name' =&gt; 'Bookcase', 'colors' =&gt; ['Red', 'Beige', 'Brown']],\n]);\n\n$collection-&gt;sum(function ($product) {\n    return count($product['colors']);\n});\n\n// 6</code></pre>\n  <p></p>\n  <h4><code>take()</code></h4>\n  <p>El <code>take</code>método devuelve una nueva colección con el número especificado de elementos:</p>\n  <pre><code>$collection = collect([0, 1, 2, 3, 4, 5]);\n\n$chunk = $collection-&gt;take(3);\n\n$chunk-&gt;all();\n\n// [0, 1, 2]</code></pre>\n  <p>También puede pasar un número entero negativo para tomar la cantidad especificada de elementos del final de la colección:</p>\n  <pre><code>$collection = collect([0, 1, 2, 3, 4, 5]);\n\n$chunk = $collection-&gt;take(-2);\n\n$chunk-&gt;all();\n\n// [4, 5]</code></pre>\n  <p></p>\n  <h4><code>takeUntil()</code></h4>\n  <p>El <code>takeUntil</code>método devuelve elementos de la colección hasta que la devolución de llamada dada devuelve <code>true</code>:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$subset = $collection-&gt;takeUntil(function ($item) {\n    return $item &gt;= 3;\n});\n\n$subset-&gt;all();\n\n// [1, 2]</code></pre>\n  <p>También puede pasar un valor simple al <code>takeUntil</code>método para obtener los elementos hasta que se encuentre el valor dado:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$subset = $collection-&gt;takeUntil(3);\n\n$subset-&gt;all();\n\n// [1, 2]</code></pre>\n  <blockquote>\n    <div><div></div><p>Si no se encuentra el valor dado o la devolución de llamada nunca regresa <code>true</code>, el <code>takeUntil</code>método devolverá todos los elementos de la colección.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>takeWhile()</code></h4>\n  <p>El <code>takeWhile</code>método devuelve elementos de la colección hasta que la devolución de llamada dada devuelve <code>false</code>:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4]);\n\n$subset = $collection-&gt;takeWhile(function ($item) {\n    return $item &lt; 3;\n});\n\n$subset-&gt;all();\n\n// [1, 2]</code></pre>\n  <blockquote>\n    <div><div></div><p>Si la devolución de llamada nunca regresa <code>false</code>, el <code>takeWhile</code>método devolverá todos los elementos de la colección.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>tap()</code></h4>\n  <p>El <code>tap</code>método pasa la colección a la devolución de llamada dada, lo que le permite \"tocar\" en la colección en un punto específico y hacer algo con los elementos sin afectar la colección en sí:</p>\n  <pre><code>collect([2, 4, 3, 1, 5])\n    -&gt;sort()\n    -&gt;tap(function ($collection) {\n        Log::debug('Values after sorting', $collection-&gt;values()-&gt;toArray());\n    })\n    -&gt;shift();\n\n// 1</code></pre>\n  <p></p>\n  <h4><code>times()</code></h4>\n  <p>El <code>times</code>método estático crea una nueva colección invocando la devolución de llamada una cantidad determinada de veces:</p>\n  <pre><code>$collection = Collection::times(10, function ($number) {\n    return $number * 9;\n});\n\n$collection-&gt;all();\n\n// [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]</code></pre>\n  <p>Este método puede ser útil cuando se combina con fábricas para crear modelos Eloquent :</p>\n  <pre><code>$categories = Collection::times(3, function ($number) {\n    return Category::factory()-&gt;create(['name' =&gt; \"Category No. $number\"]);\n});\n\n$categories-&gt;all();\n\n/*\n    [\n        ['id' =&gt; 1, 'name' =&gt; 'Category No. 1'],\n        ['id' =&gt; 2, 'name' =&gt; 'Category No. 2'],\n        ['id' =&gt; 3, 'name' =&gt; 'Category No. 3'],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>toArray()</code></h4>\n  <p>El <code>toArray</code>método convierte la colección en PHP simple <code>array</code>. Si los valores de la colección son modelos Eloquent , los modelos también se convertirán en matrices:</p>\n  <pre><code>$collection = collect(['name' =&gt; 'Desk', 'price' =&gt; 200]);\n\n$collection-&gt;toArray();\n\n/*\n    [\n        ['name' =&gt; 'Desk', 'price' =&gt; 200],\n    ]\n*/</code></pre>\n  <blockquote>\n    <div><div></div><p> <code>toArray</code>también convierte todos los objetos anidados de la colección que son una instancia de <code>Arrayable</code>en una matriz. Si desea obtener la matriz subyacente sin procesar, use el <code>all</code>método en su lugar.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>toJson()</code></h4>\n  <p>El <code>toJson</code>método convierte la colección en una cadena serializada JSON:</p>\n  <pre><code>$collection = collect(['name' =&gt; 'Desk', 'price' =&gt; 200]);\n\n$collection-&gt;toJson();\n\n// '{\"name\":\"Desk\", \"price\":200}'</code></pre>\n  <p></p>\n  <h4><code>transform()</code></h4>\n  <p>El <code>transform</code>método itera sobre la colección y llama a la devolución de llamada dada con cada elemento de la colección. Los elementos de la colección serán reemplazados por los valores devueltos por la devolución de llamada:</p>\n  <pre><code>$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-&gt;transform(function ($item, $key) {\n    return $item * 2;\n});\n\n$collection-&gt;all();\n\n// [2, 4, 6, 8, 10]</code></pre>\n  <blockquote>\n    <div><div></div><p>A diferencia de la mayoría de los otros métodos de recopilación, <code>transform</code>modifica la propia recopilación. Si desea crear una nueva colección, utilice el <code>map</code>método.</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>union()</code></h4>\n  <p>El <code>union</code>método agrega la matriz dada a la colección. Si la matriz dada contiene claves que ya están en la colección original, se preferirán los valores de la colección original:</p>\n  <pre><code>$collection = collect([1 =&gt; ['a'], 2 =&gt; ['b']]);\n\n$union = $collection-&gt;union([3 =&gt; ['c'], 1 =&gt; ['b']]);\n\n$union-&gt;all();\n\n// [1 =&gt; ['a'], 2 =&gt; ['b'], 3 =&gt; ['c']]</code></pre>\n  <p></p>\n  <h4><code>unique()</code></h4>\n  <p>El <code>unique</code>método devuelve todos los elementos únicos de la colección. La colección devuelta mantiene las claves de matriz originales, por lo que en este ejemplo usaremos el <code>values</code>método para restablecer las claves a índices numerados consecutivamente:</p>\n  <pre><code>$collection = collect([1, 1, 2, 2, 3, 4, 2]);\n\n$unique = $collection-&gt;unique();\n\n$unique-&gt;values()-&gt;all();\n\n// [1, 2, 3, 4]</code></pre>\n  <p>Cuando se trata de matrices u objetos anidados, puede especificar la clave utilizada para determinar la unicidad:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'iPhone 6', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],\n    ['name' =&gt; 'iPhone 5', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],\n    ['name' =&gt; 'Apple Watch', 'brand' =&gt; 'Apple', 'type' =&gt; 'watch'],\n    ['name' =&gt; 'Galaxy S6', 'brand' =&gt; 'Samsung', 'type' =&gt; 'phone'],\n    ['name' =&gt; 'Galaxy Gear', 'brand' =&gt; 'Samsung', 'type' =&gt; 'watch'],\n]);\n\n$unique = $collection-&gt;unique('brand');\n\n$unique-&gt;values()-&gt;all();\n\n/*\n    [\n        ['name' =&gt; 'iPhone 6', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],\n        ['name' =&gt; 'Galaxy S6', 'brand' =&gt; 'Samsung', 'type' =&gt; 'phone'],\n    ]\n*/</code></pre>\n  <p>También puede pasar su propia devolución de llamada para determinar la exclusividad del artículo:</p>\n  <pre><code>$unique = $collection-&gt;unique(function ($item) {\n    return $item['brand'].$item['type'];\n});\n\n$unique-&gt;values()-&gt;all();\n\n/*\n    [\n        ['name' =&gt; 'iPhone 6', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],\n        ['name' =&gt; 'Apple Watch', 'brand' =&gt; 'Apple', 'type' =&gt; 'watch'],\n        ['name' =&gt; 'Galaxy S6', 'brand' =&gt; 'Samsung', 'type' =&gt; 'phone'],\n        ['name' =&gt; 'Galaxy Gear', 'brand' =&gt; 'Samsung', 'type' =&gt; 'watch'],\n    ]\n*/</code></pre>\n  <p>El <code>unique</code>método utiliza comparaciones \"sueltas\" al verificar los valores de los elementos, lo que significa que una cadena con un valor entero se considerará igual a un número entero del mismo valor. Utilice el <code>uniqueStrict</code>método para filtrar mediante comparaciones \"estrictas\".</p>\n  <blockquote>\n    <div><div></div><p>El comportamiento de este método se modifica al utilizar Eloquent Collections .</p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>uniqueStrict()</code></h4>\n  <p>Este método tiene la misma firma que el <code>unique</code>método; sin embargo, todos los valores se comparan mediante comparaciones \"estrictas\".</p>\n  <p></p>\n  <h4><code>unless()</code></h4>\n  <p>El <code>unless</code>método ejecutará la devolución de llamada dada a menos que el primer argumento dado al método se evalúe como <code>true</code>:</p>\n  <pre><code>$collection = collect([1, 2, 3]);\n\n$collection-&gt;unless(true, function ($collection) {\n    return $collection-&gt;push(4);\n});\n\n$collection-&gt;unless(false, function ($collection) {\n    return $collection-&gt;push(5);\n});\n\n$collection-&gt;all();\n\n// [1, 2, 3, 5]</code></pre>\n  <p>Para el inverso de <code>unless</code>, vea el <code>when</code>método.</p>\n  <p></p>\n  <h4><code>unlessEmpty()</code></h4>\n  <p>Alias \u200B\u200Bdel <code>whenNotEmpty</code>método.</p>\n  <p></p>\n  <h4><code>unlessNotEmpty()</code></h4>\n  <p>Alias \u200B\u200Bdel <code>whenEmpty</code>método.</p>\n  <p></p>\n  <h4><code>unwrap()</code></h4>\n  <p>El <code>unwrap</code>método estático devuelve los elementos subyacentes de la colección a partir del valor dado cuando corresponde:</p>\n  <pre><code>Collection::unwrap(collect('John Doe'));\n\n// ['John Doe']\n\nCollection::unwrap(['John Doe']);\n\n// ['John Doe']\n\nCollection::unwrap('John Doe');\n\n// 'John Doe'</code></pre>\n  <p></p>\n  <h4><code>values()</code></h4>\n  <p>El <code>values</code>método devuelve una nueva colección con las claves restablecidas a enteros consecutivos:</p>\n  <pre><code>$collection = collect([\n    10 =&gt; ['product' =&gt; 'Desk', 'price' =&gt; 200],\n    11 =&gt; ['product' =&gt; 'Desk', 'price' =&gt; 200],\n]);\n\n$values = $collection-&gt;values();\n\n$values-&gt;all();\n\n/*\n    [\n        0 =&gt; ['product' =&gt; 'Desk', 'price' =&gt; 200],\n        1 =&gt; ['product' =&gt; 'Desk', 'price' =&gt; 200],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>when()</code></h4>\n  <p>El <code>when</code>método ejecutará la devolución de llamada dada cuando el primer argumento dado al método se evalúe como <code>true</code>:</p>\n  <pre><code>$collection = collect([1, 2, 3]);\n\n$collection-&gt;when(true, function ($collection) {\n    return $collection-&gt;push(4);\n});\n\n$collection-&gt;when(false, function ($collection) {\n    return $collection-&gt;push(5);\n});\n\n$collection-&gt;all();\n\n// [1, 2, 3, 4]</code></pre>\n  <p>Para el inverso de <code>when</code>, vea el <code>unless</code>método.</p>\n  <p></p>\n  <h4><code>whenEmpty()</code></h4>\n  <p>El <code>whenEmpty</code>método ejecutará la devolución de llamada dada cuando la colección esté vacía:</p>\n  <pre><code>$collection = collect(['michael', 'tom']);\n\n$collection-&gt;whenEmpty(function ($collection) {\n    return $collection-&gt;push('adam');\n});\n\n$collection-&gt;all();\n\n// ['michael', 'tom']\n\n$collection = collect();\n\n$collection-&gt;whenEmpty(function ($collection) {\n    return $collection-&gt;push('adam');\n});\n\n$collection-&gt;all();\n\n// ['adam']\n\n$collection = collect(['michael', 'tom']);\n\n$collection-&gt;whenEmpty(function ($collection) {\n    return $collection-&gt;push('adam');\n}, function ($collection) {\n    return $collection-&gt;push('taylor');\n});\n\n$collection-&gt;all();\n\n// ['michael', 'tom', 'taylor']</code></pre>\n  <p>Para el inverso de <code>whenEmpty</code>, vea el <code>whenNotEmpty</code>método.</p>\n  <p></p>\n  <h4><code>whenNotEmpty()</code></h4>\n  <p>El <code>whenNotEmpty</code>método ejecutará la devolución de llamada dada cuando la colección no esté vacía:</p>\n  <pre><code>$collection = collect(['michael', 'tom']);\n\n$collection-&gt;whenNotEmpty(function ($collection) {\n    return $collection-&gt;push('adam');\n});\n\n$collection-&gt;all();\n\n// ['michael', 'tom', 'adam']\n\n$collection = collect();\n\n$collection-&gt;whenNotEmpty(function ($collection) {\n    return $collection-&gt;push('adam');\n});\n\n$collection-&gt;all();\n\n// []\n\n$collection = collect();\n\n$collection-&gt;whenNotEmpty(function ($collection) {\n    return $collection-&gt;push('adam');\n}, function ($collection) {\n    return $collection-&gt;push('taylor');\n});\n\n$collection-&gt;all();\n\n// ['taylor']</code></pre>\n  <p>Para el inverso de <code>whenNotEmpty</code>, vea el <code>whenEmpty</code>método.</p>\n  <p></p>\n  <h4><code>where()</code></h4>\n  <p>El <code>where</code>método filtra la colección por un par clave / valor dado:</p>\n  <pre><code>$collection = collect([\n    ['product' =&gt; 'Desk', 'price' =&gt; 200],\n    ['product' =&gt; 'Chair', 'price' =&gt; 100],\n    ['product' =&gt; 'Bookcase', 'price' =&gt; 150],\n    ['product' =&gt; 'Door', 'price' =&gt; 100],\n]);\n\n$filtered = $collection-&gt;where('price', 100);\n\n$filtered-&gt;all();\n\n/*\n    [\n        ['product' =&gt; 'Chair', 'price' =&gt; 100],\n        ['product' =&gt; 'Door', 'price' =&gt; 100],\n    ]\n*/</code></pre>\n  <p>El <code>where</code>método utiliza comparaciones \"sueltas\" al verificar los valores de los elementos, lo que significa que una cadena con un valor entero se considerará igual a un número entero del mismo valor. Utilice el <code>whereStrict</code>método para filtrar mediante comparaciones \"estrictas\".</p>\n  <p>Opcionalmente, puede pasar un operador de comparación como segundo parámetro.</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'Jim', 'deleted_at' =&gt; '2019-01-01 00:00:00'],\n    ['name' =&gt; 'Sally', 'deleted_at' =&gt; '2019-01-02 00:00:00'],\n    ['name' =&gt; 'Sue', 'deleted_at' =&gt; null],\n]);\n\n$filtered = $collection-&gt;where('deleted_at', '!=', null);\n\n$filtered-&gt;all();\n\n/*\n    [\n        ['name' =&gt; 'Jim', 'deleted_at' =&gt; '2019-01-01 00:00:00'],\n        ['name' =&gt; 'Sally', 'deleted_at' =&gt; '2019-01-02 00:00:00'],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>whereStrict()</code></h4>\n  <p>Este método tiene la misma firma que el <code>where</code>método; sin embargo, todos los valores se comparan mediante comparaciones \"estrictas\".</p>\n  <p></p>\n  <h4><code>whereBetween()</code></h4>\n  <p>El <code>whereBetween</code>método filtra la colección dentro de un rango determinado:</p>\n  <pre><code>$collection = collect([\n    ['product' =&gt; 'Desk', 'price' =&gt; 200],\n    ['product' =&gt; 'Chair', 'price' =&gt; 80],\n    ['product' =&gt; 'Bookcase', 'price' =&gt; 150],\n    ['product' =&gt; 'Pencil', 'price' =&gt; 30],\n    ['product' =&gt; 'Door', 'price' =&gt; 100],\n]);\n\n$filtered = $collection-&gt;whereBetween('price', [100, 200]);\n\n$filtered-&gt;all();\n\n/*\n    [\n        ['product' =&gt; 'Desk', 'price' =&gt; 200],\n        ['product' =&gt; 'Bookcase', 'price' =&gt; 150],\n        ['product' =&gt; 'Door', 'price' =&gt; 100],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>whereIn()</code></h4>\n  <p>El <code>whereIn</code>método filtra la colección por una clave / valor dado dentro de la matriz dada:</p>\n  <pre><code>$collection = collect([\n    ['product' =&gt; 'Desk', 'price' =&gt; 200],\n    ['product' =&gt; 'Chair', 'price' =&gt; 100],\n    ['product' =&gt; 'Bookcase', 'price' =&gt; 150],\n    ['product' =&gt; 'Door', 'price' =&gt; 100],\n]);\n\n$filtered = $collection-&gt;whereIn('price', [150, 200]);\n\n$filtered-&gt;all();\n\n/*\n    [\n        ['product' =&gt; 'Desk', 'price' =&gt; 200],\n        ['product' =&gt; 'Bookcase', 'price' =&gt; 150],\n    ]\n*/</code></pre>\n  <p>El <code>whereIn</code>método utiliza comparaciones \"sueltas\" al verificar los valores de los elementos, lo que significa que una cadena con un valor entero se considerará igual a un número entero del mismo valor. Utilice el <code>whereInStrict</code>método para filtrar mediante comparaciones \"estrictas\".</p>\n  <p></p>\n  <h4><code>whereInStrict()</code></h4>\n  <p>Este método tiene la misma firma que el <code>whereIn</code>método; sin embargo, todos los valores se comparan mediante comparaciones \"estrictas\".</p>\n  <p></p>\n  <h4><code>whereInstanceOf()</code></h4>\n  <p>El <code>whereInstanceOf</code>método filtra la colección por un tipo de clase determinado:</p>\n  <pre><code>use App\\Models\\User;\nuse App\\Models\\Post;\n\n$collection = collect([\n    new User,\n    new User,\n    new Post,\n]);\n\n$filtered = $collection-&gt;whereInstanceOf(User::class);\n\n$filtered-&gt;all();\n\n// [App\\Models\\User, App\\Models\\User]</code></pre>\n  <p></p>\n  <h4><code>whereNotBetween()</code></h4>\n  <p>El <code>whereNotBetween</code>método filtra la colección dentro de un rango determinado:</p>\n  <pre><code>$collection = collect([\n    ['product' =&gt; 'Desk', 'price' =&gt; 200],\n    ['product' =&gt; 'Chair', 'price' =&gt; 80],\n    ['product' =&gt; 'Bookcase', 'price' =&gt; 150],\n    ['product' =&gt; 'Pencil', 'price' =&gt; 30],\n    ['product' =&gt; 'Door', 'price' =&gt; 100],\n]);\n\n$filtered = $collection-&gt;whereNotBetween('price', [100, 200]);\n\n$filtered-&gt;all();\n\n/*\n    [\n        ['product' =&gt; 'Chair', 'price' =&gt; 80],\n        ['product' =&gt; 'Pencil', 'price' =&gt; 30],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>whereNotIn()</code></h4>\n  <p>El <code>whereNotIn</code>método filtra la colección por una clave / valor dado que no está contenido en la matriz dada:</p>\n  <pre><code>$collection = collect([\n    ['product' =&gt; 'Desk', 'price' =&gt; 200],\n    ['product' =&gt; 'Chair', 'price' =&gt; 100],\n    ['product' =&gt; 'Bookcase', 'price' =&gt; 150],\n    ['product' =&gt; 'Door', 'price' =&gt; 100],\n]);\n\n$filtered = $collection-&gt;whereNotIn('price', [150, 200]);\n\n$filtered-&gt;all();\n\n/*\n    [\n        ['product' =&gt; 'Chair', 'price' =&gt; 100],\n        ['product' =&gt; 'Door', 'price' =&gt; 100],\n    ]\n*/</code></pre>\n  <p>El <code>whereNotIn</code>método utiliza comparaciones \"sueltas\" al verificar los valores de los elementos, lo que significa que una cadena con un valor entero se considerará igual a un número entero del mismo valor. Utilice el <code>whereNotInStrict</code>método para filtrar mediante comparaciones \"estrictas\".</p>\n  <p></p>\n  <h4><code>whereNotInStrict()</code></h4>\n  <p>Este método tiene la misma firma que el <code>whereNotIn</code>método; sin embargo, todos los valores se comparan mediante comparaciones \"estrictas\".</p>\n  <p></p>\n  <h4><code>whereNotNull()</code></h4>\n  <p>El <code>whereNotNull</code>método filtra elementos donde la clave dada no es nula:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'Desk'],\n    ['name' =&gt; null],\n    ['name' =&gt; 'Bookcase'],\n]);\n\n$filtered = $collection-&gt;whereNotNull('name');\n\n$filtered-&gt;all();\n\n/*\n    [\n        ['name' =&gt; 'Desk'],\n        ['name' =&gt; 'Bookcase'],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>whereNull()</code></h4>\n  <p>El <code>whereNull</code>método filtra elementos donde la clave dada es nula:</p>\n  <pre><code>$collection = collect([\n    ['name' =&gt; 'Desk'],\n    ['name' =&gt; null],\n    ['name' =&gt; 'Bookcase'],\n]);\n\n$filtered = $collection-&gt;whereNull('name');\n\n$filtered-&gt;all();\n\n/*\n    [\n        ['name' =&gt; null],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>wrap()</code></h4>\n  <p>El <code>wrap</code>método estático envuelve el valor dado en una colección cuando corresponde:</p>\n  <pre><code>$collection = Collection::wrap('John Doe');\n\n$collection-&gt;all();\n\n// ['John Doe']\n\n$collection = Collection::wrap(['John Doe']);\n\n$collection-&gt;all();\n\n// ['John Doe']\n\n$collection = Collection::wrap(collect('John Doe'));\n\n$collection-&gt;all();\n\n// ['John Doe']</code></pre>\n  <p></p>\n  <h4><code>zip()</code></h4>\n  <p>El <code>zip</code>método fusiona los valores de la matriz dada con los valores de la colección original en el índice correspondiente:</p>\n  <pre><code>$collection = collect(['Chair', 'Desk']);\n\n$zipped = $collection-&gt;zip([100, 200]);\n\n$zipped-&gt;all();\n\n// [['Chair', 100], ['Desk', 200]]</code></pre>\n  <p></p>\n  <h2>Mensajes de orden superior</h2>\n  <p>Las colecciones también brindan soporte para \"mensajes de orden superior\", que son atajos para realizar acciones comunes en las colecciones. Los métodos de recolección que proporcionan mensajes de orden superior son: <code>average</code>, <code>avg</code>, <code>contains</code>, <code>each</code>, <code>every</code>, <code>filter</code>, <code>first</code>, <code>flatMap</code>, <code>groupBy</code>, <code>keyBy</code>, <code>map</code>, <code>max</code>, <code>min</code>, <code>partition</code>, <code>reject</code>, <code>skipUntil</code>, <code>skipWhile</code>, <code>some</code>, <code>sortBy</code>, <code>sortByDesc</code>, <code>sum</code>, <code>takeUntil</code>, <code>takeWhile</code>y <code>unique</code>.</p>\n  <p>Se puede acceder a cada mensaje de orden superior como una propiedad dinámica en una instancia de colección. Por ejemplo, usemos el <code>each</code>mensaje de orden superior para llamar a un método en cada objeto dentro de una colección:</p>\n  <pre><code>$users = User::where('votes', '&gt;', 500)-&gt;get();\n\n$users-&gt;each-&gt;markAsVip();</code></pre>\n  <p>Del mismo modo, podemos usar el <code>sum</code>mensaje de orden superior para recopilar el número total de \"votos\" para una colección de usuarios:</p>\n  <pre><code>$users = User::where('group', 'Development')-&gt;get();\n\nreturn $users-&gt;sum-&gt;votes;</code></pre>\n  <p></p>\n  <h2>Colecciones perezosas</h2>\n  <p></p>\n  <h3>Introducción</h3>\n  <blockquote>\n    <div><div></div><p>Antes de aprender más sobre las colecciones perezosas de Laravel, tómate un tiempo para familiarizarte con los generadores de PHP .</p></div>\n  </blockquote>\n  <p>Para complementar la <code>Collection</code>clase ya poderosa , la <code>LazyCollection</code>clase aprovecha los generadores de PHP para permitirle trabajar con conjuntos de datos muy grandes mientras mantiene bajo el uso de memoria.</p>\n  <p>Por ejemplo, imagine que su aplicación necesita procesar un archivo de registro de varios gigabytes mientras aprovecha los métodos de recopilación de Laravel para analizar los registros. En lugar de leer todo el archivo en la memoria a la vez, se pueden usar colecciones diferidas para mantener solo una pequeña parte del archivo en la memoria en un momento dado:</p>\n  <pre><code>use App\\Models\\LogEntry;\nuse Illuminate\\Support\\LazyCollection;\n\nLazyCollection::make(function () {\n    $handle = fopen('log.txt', 'r');\n\n    while (($line = fgets($handle)) !== false) {\n        yield $line;\n    }\n})-&gt;chunk(4)-&gt;map(function ($lines) {\n    return LogEntry::fromLines($lines);\n})-&gt;each(function (LogEntry $logEntry) {\n    // Process the log entry...\n});</code></pre>\n  <p>O imagina que necesitas iterar a través de 10,000 modelos Eloquent. Al usar colecciones tradicionales de Laravel, todos los 10,000 modelos Eloquent deben cargarse en la memoria al mismo tiempo:</p>\n  <pre><code>$users = App\\Models\\User::all()-&gt;filter(function ($user) {\n    return $user-&gt;id &gt; 500;\n});</code></pre>\n  <p>Sin embargo, el <code>cursor</code>método del generador de consultas devuelve una <code>LazyCollection</code>instancia. Esto le permite seguir ejecutando una única consulta en la base de datos, pero también mantener solo un modelo Eloquent cargado en la memoria a la vez. En este ejemplo, la <code>filter</code>devolución de llamada no se ejecuta hasta que iteramos sobre cada usuario individualmente, lo que permite una reducción drástica en el uso de memoria:</p>\n  <pre><code>$users = App\\Models\\User::cursor()-&gt;filter(function ($user) {\n    return $user-&gt;id &gt; 500;\n});\n\nforeach ($users as $user) {\n    echo $user-&gt;id;\n}</code></pre>\n  <p></p>\n  <h3>Crear colecciones perezosas</h3>\n  <p>Para crear una instancia de colección perezosa, debe pasar una función generadora de PHP al <code>make</code>método de la colección :</p>\n  <pre><code>use Illuminate\\Support\\LazyCollection;\n\nLazyCollection::make(function () {\n    $handle = fopen('log.txt', 'r');\n\n    while (($line = fgets($handle)) !== false) {\n        yield $line;\n    }\n});</code></pre>\n  <p></p>\n  <h3>El contrato enumerable</h3>\n  <p>Casi todos los métodos disponibles en la <code>Collection</code>clase también están disponibles en la <code>LazyCollection</code>clase. Ambas clases implementan el contrato, que define los siguientes métodos:<code>Illuminate\\Support\\Enumerable</code></p>\n  <div>\n    <p>todas\n      promedio\n      promedio\n      pedazo\n      chunkMientras\n      colapso\n      recoger\n      combinar\n      concat\n      contiene\n      contieneEstricto\n      contar\n      countBy\n      crossUnirse\n      dd\n      diff\n      diffAssoc\n      diffKeys\n      tugurio\n      duplicados\n      duplicadosEstricto\n      cada\n      cada uno\n      cada\n      excepto\n      filtrar\n      primero\n      primero donde\n      mapa plano\n      aplanar\n      dar la vuelta\n      forPage\n      obtener\n      agrupar por\n      tiene\n      implosionar\n      intersecarse\n      intersectByKeys\n      esta vacio\n      no está vacío\n      unirse\n      keyBy\n      llaves\n      último\n      macro\n      hacer\n      mapa\n      mapInto\n      mapSpread\n      mapToGroups\n      mapWithKeys\n      max\n      mediana\n      unir\n      mergeRecursive\n      min\n      modo\n      enésimo\n      solamente\n      almohadilla\n      dividir\n      tubo\n      arrancar\n      aleatorio\n      reducir\n      rechazar\n      reemplazar\n      Reemplazar recursivo\n      contrarrestar\n      buscar\n      barajar\n      omitir\n      rebanada\n      algunos\n      ordenar\n      ordenar por\n      sortByDesc\n      sortKeys\n      sortKeysDesc\n      división\n      suma\n      tomar\n      grifo\n      veces\n      toArray\n      toJson\n      Unión\n      único\n      uniqueStrict\n      a no ser que\n      a menos que esté vacío\n      a menos que no esté vacío\n      desenvolver\n      valores\n      cuando\n      whenEmpty\n      whenNotEmpty\n      dónde\n      whereStrict\n      whereBetween\n      donde\n      whereInStrict\n      whereInstanceOf\n      whereNotBetween\n      whereNotIn\n      whereNotInStrict\n      envolver\n      Código Postal</p>\n  </div>\n  <blockquote>\n    <div><div></div><p>Métodos que mutan la colección (tales como <code>shift</code>, <code>pop</code>, <code>prepend</code>etc.) son <em>no</em> disponibles en la <code>LazyCollection</code>clase.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Métodos de recolección perezosos</h3>\n  <p>Además de los métodos definidos en el <code>Enumerable</code>contrato, la <code>LazyCollection</code>clase contiene los siguientes métodos:</p>\n  <p></p>\n  <h4><code>tapEach()</code></h4>\n  <p>Si bien el <code>each</code>método llama a la devolución de llamada dada para cada elemento de la colección de inmediato, el <code>tapEach</code>método solo llama a la devolución de llamada dada a medida que los elementos se extraen de la lista uno por uno:</p>\n  <pre><code>$lazyCollection = LazyCollection::times(INF)-&gt;tapEach(function ($value) {\n    dump($value);\n});\n\n// Nothing has been dumped so far...\n\n$array = $lazyCollection-&gt;take(3)-&gt;all();\n\n// 1\n// 2\n// 3</code></pre>\n  <p></p>\n  <h4><code>remember()</code></h4>\n  <p>El <code>remember</code>método devuelve una nueva colección diferida que recordará los valores que ya se han enumerado y no los recuperará de nuevo cuando la colección se vuelva a enumerar:</p>\n  <pre><code>$users = User::cursor()-&gt;remember();\n\n// No query has been executed yet...\n\n$users-&gt;take(5)-&gt;all();\n\n// The query has been executed and the first 5 users have been hydrated from the database...\n\n$users-&gt;take(20)-&gt;all();\n\n// First 5 users come from the collection's cache... The rest are hydrated from the database...</code></pre>\n</section>"
      },
      {
        "titulo": "6.4 Eventos",
        "contenido": "<section>\n  <h1>Eventos</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Registro de eventos y oyentes\n      <ul>\n        <li>Generación de eventos y oyentes</li>\n        <li>Registro manual de eventos</li>\n        <li>Descubrimiento de eventos</li>\n      </ul></li>\n    <li>Definición de eventos</li>\n    <li>Definición de oyentes</li>\n    <li>Oyentes de eventos en cola\n      <ul>\n        <li>Acceder manualmente a la cola</li>\n        <li>Manejo de trabajos fallidos</li>\n      </ul></li>\n    <li>Despacho de eventos</li>\n    <li>Suscriptores de eventos\n      <ul>\n        <li>Suscriptores de eventos de escritura</li>\n        <li>Registro de suscriptores de eventos</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Los eventos de Laravel proporcionan una implementación de observador simple, lo que le permite suscribirse y escuchar varios eventos que ocurren en su aplicación. Las clases de eventos generalmente se almacenan en el directorio, mientras que sus oyentes se almacenan en . No se preocupe si no ve estos directorios en su aplicación, ya que se crearán para usted a medida que genere eventos y oyentes utilizando los comandos de la consola Artisan.<code>app/Events</code><code>app/Listeners</code></p>\n  <p>Los eventos sirven como una excelente manera de desacoplar varios aspectos de su aplicación, ya que un solo evento puede tener múltiples oyentes que no dependen unos de otros. Por ejemplo, es posible que desee enviar una notificación de Slack a su usuario cada vez que se envíe un pedido. En lugar de acoplar su código de procesamiento de pedidos a su código de notificación de Slack, puede generar un <code>OrderShipped</code>evento, que un oyente puede recibir y transformar en una notificación de Slack.</p>\n  <p></p>\n  <h2>Registro de eventos y oyentes</h2>\n  <p>El <code>EventServiceProvider</code>incluido con su aplicación Laravel proporciona un lugar conveniente para registrar todos los oyentes de eventos de su aplicación. La <code>listen</code>propiedad contiene una matriz de todos los eventos (claves) y sus oyentes (valores). Puede agregar tantos eventos a esta matriz como requiera su aplicación. Por ejemplo, agreguemos un <code>OrderShipped</code>evento:</p>\n  <pre><code>/**\n * The event listener mappings for the application.\n *\n * @var array\n */\nprotected $listen = [\n    'App\\Events\\OrderShipped' =&gt; [\n        'App\\Listeners\\SendShipmentNotification',\n    ],\n];</code></pre>\n  <p></p>\n  <h3>Generación de eventos y oyentes</h3>\n  <p>Por supuesto, la creación manual de archivos para cada evento y oyente es engorrosa. En su lugar, agregue oyentes y eventos a su <code>EventServiceProvider</code>y use el comando. Este comando generará cualquier evento o escucha que se enumere en su . Los eventos y oyentes que ya existen no se modificarán:<code>event:generate</code><code>EventServiceProvider</code></p>\n  <pre><code>php artisan event:generate</code></pre>\n  <p></p>\n  <h3>Registro manual de eventos</h3>\n  <p>Normalmente, los eventos deben registrarse a través de la <code>EventServiceProvider</code> <code>$listen</code>matriz; sin embargo, también puede registrar eventos basados \u200B\u200Ben cierres manualmente en el <code>boot</code>método de su <code>EventServiceProvider</code>:</p>\n  <pre><code>use App\\Events\\PodcastProcessed;\n\n/**\n * Register any other events for your application.\n *\n * @return void\n */\npublic function boot()\n{\n    Event::listen(function (PodcastProcessed $event) {\n        //\n    });\n}</code></pre>\n  <p></p>\n  <h4>Oyentes de eventos anónimos en cola</h4>\n  <p>Al registrar los oyentes de eventos manualmente, puede envolver el cierre del oyente dentro de la función para indicar a Laravel que ejecute el oyente usando la cola :<code>Illuminate\\Events\\queueable</code></p>\n  <pre><code>use App\\Events\\PodcastProcessed;\nuse function Illuminate\\Events\\queueable;\nuse Illuminate\\Support\\Facades\\Event;\n\n/**\n * Register any other events for your application.\n *\n * @return void\n */\npublic function boot()\n{\n    Event::listen(queueable(function (PodcastProcessed $event) {\n        //\n    }));\n}</code></pre>\n  <p>Al igual que los trabajos en espera, puede utilizar los <code>onConnection</code>, <code>onQueue</code>y <code>delay</code>métodos para personalizar la ejecución del oyente en cola:</p>\n  <pre><code>Event::listen(queueable(function (PodcastProcessed $event) {\n    //\n})-&gt;onConnection('redis')-&gt;onQueue('podcasts')-&gt;delay(now()-&gt;addSeconds(10)));</code></pre>\n  <p>Si desea manejar fallas anónimas del oyente en cola, puede proporcionar un cierre al <code>catch</code>método mientras define el <code>queueable</code>oyente:</p>\n  <pre><code>use App\\Events\\PodcastProcessed;\nuse function Illuminate\\Events\\queueable;\nuse Illuminate\\Support\\Facades\\Event;\nuse Throwable;\n\nEvent::listen(queueable(function (PodcastProcessed $event) {\n    //\n})-&gt;catch(function (PodcastProcessed $event, Throwable $e) {\n    // The queued listener failed...\n}));</code></pre>\n  <h4>Oyentes de eventos comodín</h4>\n  <p>Incluso puede registrar oyentes utilizando <code>*</code>como parámetro comodín, lo que le permite capturar varios eventos en el mismo oyente. Los oyentes comodín reciben el nombre del evento como primer argumento y la matriz completa de datos del evento como segundo argumento:</p>\n  <pre><code>Event::listen('event.*', function ($eventName, array $data) {\n    //\n});</code></pre>\n  <p></p>\n  <h3>Descubrimiento de eventos</h3>\n  <p>En lugar de registrar eventos y oyentes manualmente en la <code>$listen</code>matriz del <code>EventServiceProvider</code>, puede habilitar el descubrimiento automático de eventos. Cuando el descubrimiento de eventos está habilitado, Laravel encontrará y registrará automáticamente sus eventos y oyentes escaneando el <code>Listeners</code>directorio de su aplicación . Además, se registrarán todos los eventos definidos explícitamente que se enumeran en el <code>EventServiceProvider</code>.</p>\n  <p>Laravel encuentra oyentes de eventos escaneando las clases de oyentes usando la reflexión. Cuando Laravel encuentra cualquier método de clase de escucha que comience con <code>handle</code>, Laravel registrará esos métodos como detectores de eventos para el evento que está insinuado en la firma del método:</p>\n  <pre><code>use App\\Events\\PodcastProcessed;\n\nclass SendPodcastProcessedNotification\n{\n    /**\n     * Handle the given event.\n     *\n     * @param  \\App\\Events\\PodcastProcessed\n     * @return void\n     */\n    public function handle(PodcastProcessed $event)\n    {\n        //\n    }\n}</code></pre>\n  <p>El descubrimiento de eventos está deshabilitado de forma predeterminada, pero puede habilitarlo anulando el <code>shouldDiscoverEvents</code>método de su aplicación <code>EventServiceProvider</code>:</p>\n  <pre><code>/**\n * Determine if events and listeners should be automatically discovered.\n *\n * @return bool\n */\npublic function shouldDiscoverEvents()\n{\n    return true;\n}</code></pre>\n  <p>De forma predeterminada, se analizarán todos los oyentes del directorio de oyentes de su aplicación. Si desea definir directorios adicionales para escanear, puede anular el <code>discoverEventsWithin</code>método en su <code>EventServiceProvider</code>:</p>\n  <pre><code>/**\n * Get the listener directories that should be used to discover events.\n *\n * @return array\n */\nprotected function discoverEventsWithin()\n{\n    return [\n        $this-&gt;app-&gt;path('Listeners'),\n    ];\n}</code></pre>\n  <p>En producción, es probable que no desee que el marco analice todos sus oyentes en cada solicitud. Por lo tanto, durante su proceso de implementación, debe ejecutar el comando Artisan para almacenar en caché un manifiesto de todos los eventos y oyentes de su aplicación. Este manifiesto será utilizado por el marco para acelerar el proceso de registro de eventos. El comando puede usarse para destruir el caché.<code>event:cache</code><code>event:clear</code></p>\n  <blockquote>\n    <div><div></div><p>El comando se puede utilizar para mostrar una lista de todos los eventos y oyentes registrados por su aplicación.<code>event:list</code></p></div>\n  </blockquote>\n  <p></p>\n  <h2>Definición de eventos</h2>\n  <p>Una clase de evento es un contenedor de datos que contiene la información relacionada con el evento. Por ejemplo, supongamos que nuestro <code>OrderShipped</code>evento generado recibe un objeto ORM Eloquent :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Events;\n\nuse App\\Models\\Order;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass OrderShipped\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n\n    public $order;\n\n    /**\n     * Create a new event instance.\n     *\n     * @param  \\App\\Models\\Order  $order\n     * @return void\n     */\n    public function __construct(Order $order)\n    {\n        $this-&gt;order = $order;\n    }\n}</code></pre>\n  <p>Como puede ver, esta clase de evento no contiene lógica. Es un contenedor para la <code>Order</code>instancia que se compró. El <code>SerializesModels</code>rasgo usado por el evento serializará con gracia cualquier modelo Eloquent si el objeto de evento se serializa usando la <code>serialize</code>función de PHP .</p>\n  <p></p>\n  <h2>Definición de oyentes</h2>\n  <p>A continuación, echemos un vistazo al oyente de nuestro evento de ejemplo. Los detectores de eventos reciben la instancia del evento en su <code>handle</code>método. El comando importará automáticamente la clase de evento adecuada y tecleará el evento en el método. Dentro del método, puede realizar las acciones necesarias para responder al evento:<code>event:generate</code><code>handle</code><code>handle</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderShipped;\n\nclass SendShipmentNotification\n{\n    /**\n     * Create the event listener.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        //\n    }\n\n    /**\n     * Handle the event.\n     *\n     * @param  \\App\\Events\\OrderShipped  $event\n     * @return void\n     */\n    public function handle(OrderShipped $event)\n    {\n        // Access the order using $event-&gt;order...\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Los oyentes de eventos también pueden indicar cualquier dependencia que necesiten en sus constructores. Todos los detectores de eventos se resuelven a través del contenedor de servicios de Laravel , por lo que las dependencias se inyectarán automáticamente.</p></div>\n  </blockquote>\n  <h4>Detener la propagación de un evento</h4>\n  <p>A veces, es posible que desee detener la propagación de un evento a otros oyentes. Puede hacerlo regresando <code>false</code>del <code>handle</code>método de su oyente .</p>\n  <p></p>\n  <h2>Oyentes de eventos en cola</h2>\n  <p>Los oyentes en cola pueden ser beneficiosos si su oyente va a realizar una tarea lenta, como enviar un correo electrónico o realizar una solicitud HTTP. Antes de comenzar con los oyentes en cola, asegúrese de configurar su cola e iniciar un oyente de cola en su servidor o entorno de desarrollo local.</p>\n  <p>Para especificar que un oyente debe estar en cola, agregue la <code>ShouldQueue</code>interfaz a la clase de oyente. Los oyentes generados por el comando Artisan ya tienen esta interfaz importada en el espacio de nombres actual, por lo que puede usarla de inmediato:<code>event:generate</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderShipped;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\n\nclass SendShipmentNotification implements ShouldQueue\n{\n    //\n}</code></pre>\n  <p>¡Eso es! Ahora, cuando se llama a este oyente para un evento, el despachador de eventos lo pondrá en cola automáticamente utilizando el sistema de cola de Laravel . Si no se producen excepciones cuando la cola ejecuta el oyente, el trabajo en cola se eliminará automáticamente una vez que haya terminado de procesarse.</p>\n  <h4>Personalizar la conexión de la cola y el nombre de la cola</h4>\n  <p>Si desea personalizar la conexión de cola, cola de nombre, o cola de tiempo de retardo de un detector de eventos, es posible definir la <code>$connection</code>, <code>$queue</code>o <code>$delay</code>las propiedades de su clase de escucha:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderShipped;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\n\nclass SendShipmentNotification implements ShouldQueue\n{\n    /**\n     * The name of the connection the job should be sent to.\n     *\n     * @var string|null\n     */\n    public $connection = 'sqs';\n\n    /**\n     * The name of the queue the job should be sent to.\n     *\n     * @var string|null\n     */\n    public $queue = 'listeners';\n\n    /**\n     * The time (seconds) before the job should be processed.\n     *\n     * @var int\n     */\n    public $delay = 60;\n}</code></pre>\n  <p>Si desea definir la cola del oyente en tiempo de ejecución, puede definir un <code>viaQueue</code>método en el oyente:</p>\n  <pre><code>/**\n * Get the name of the listener's queue.\n *\n * @return string\n */\npublic function viaQueue()\n{\n    return 'listeners';\n}</code></pre>\n  <h4>Oyentes de cola condicional</h4>\n  <p>A veces, es posible que deba determinar si un oyente debe estar en cola en función de algunos datos que solo están disponibles en tiempo de ejecución. Para lograr esto, <code>shouldQueue</code>se puede agregar un método a un oyente para determinar si el oyente debe estar en cola. Si el <code>shouldQueue</code>método regresa <code>false</code>, el oyente no se ejecutará:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderPlaced;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\n\nclass RewardGiftCard implements ShouldQueue\n{\n    /**\n     * Reward a gift card to the customer.\n     *\n     * @param  \\App\\Events\\OrderPlaced  $event\n     * @return void\n     */\n    public function handle(OrderPlaced $event)\n    {\n        //\n    }\n\n    /**\n     * Determine whether the listener should be queued.\n     *\n     * @param  \\App\\Events\\OrderPlaced  $event\n     * @return bool\n     */\n    public function shouldQueue(OrderPlaced $event)\n    {\n        return $event-&gt;order-&gt;subtotal &gt;= 5000;\n    }\n}</code></pre>\n  <p></p>\n  <h3>Acceder manualmente a la cola</h3>\n  <p>Si necesita acceder manualmente a los métodos <code>delete</code>y trabajos de cola subyacentes del oyente <code>release</code>, puede hacerlo utilizando el rasgo. Este rasgo se importa de forma predeterminada en los oyentes generados y proporciona acceso a estos métodos:<code>Illuminate\\Queue\\InteractsWithQueue</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderShipped;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Queue\\InteractsWithQueue;\n\nclass SendShipmentNotification implements ShouldQueue\n{\n    use InteractsWithQueue;\n\n    /**\n     * Handle the event.\n     *\n     * @param  \\App\\Events\\OrderShipped  $event\n     * @return void\n     */\n    public function handle(OrderShipped $event)\n    {\n        if (true) {\n            $this-&gt;release(30);\n        }\n    }\n}</code></pre>\n  <p></p>\n  <h3>Manejo de trabajos fallidos</h3>\n  <p>A veces, sus oyentes de eventos en cola pueden fallar. Si el oyente en cola excede el número máximo de intentos definido por su trabajador de cola, el <code>failed</code>método se llamará en su oyente. El <code>failed</code>método recibe la instancia del evento y la excepción que causó el error:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderShipped;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Queue\\InteractsWithQueue;\n\nclass SendShipmentNotification implements ShouldQueue\n{\n    use InteractsWithQueue;\n\n    /**\n     * Handle the event.\n     *\n     * @param  \\App\\Events\\OrderShipped  $event\n     * @return void\n     */\n    public function handle(OrderShipped $event)\n    {\n        //\n    }\n\n    /**\n     * Handle a job failure.\n     *\n     * @param  \\App\\Events\\OrderShipped  $event\n     * @param  \\Throwable  $exception\n     * @return void\n     */\n    public function failed(OrderShipped $event, $exception)\n    {\n        //\n    }\n}</code></pre>\n  <p></p>\n  <h2>Despacho de eventos</h2>\n  <p>Para enviar un evento, puede pasar una instancia del evento al <code>event</code>ayudante. El ayudante enviará el evento a todos sus oyentes registrados. Dado que el <code>event</code>asistente está disponible globalmente, puede llamarlo desde cualquier lugar de su aplicación:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Events\\OrderShipped;\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\Order;\n\nclass OrderController extends Controller\n{\n    /**\n     * Ship the given order.\n     *\n     * @param  int  $orderId\n     * @return Response\n     */\n    public function ship($orderId)\n    {\n        $order = Order::findOrFail($orderId);\n\n        // Order shipment logic...\n\n        event(new OrderShipped($order));\n    }\n}</code></pre>\n  <p>Alternativamente, si su evento usa el rasgo, puede llamar al método estático en el evento. Cualquier argumento que se pase al método se pasará al constructor del evento:<code>Illuminate\\Foundation\\Events\\Dispatchable</code><code>dispatch</code><code>dispatch</code></p>\n  <pre><code>OrderShipped::dispatch($order);</code></pre>\n  <blockquote>\n    <div><div></div><p>Al realizar las pruebas, puede ser útil afirmar que ciertos eventos se enviaron sin activar realmente a sus oyentes. Los ayudantes de prueba integrados de Laravel lo hacen muy fácil.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Suscriptores de eventos</h2>\n  <p></p>\n  <h3>Suscriptores de eventos de escritura</h3>\n  <p>Los suscriptores de eventos son clases que pueden suscribirse a múltiples eventos dentro de la propia clase, lo que le permite definir varios controladores de eventos dentro de una sola clase. Los suscriptores deben definir un <code>subscribe</code>método, al que se le pasará una instancia de despachador de eventos. Puede llamar al <code>listen</code>método en el despachador dado para registrar oyentes de eventos:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Listeners;\n\nclass UserEventSubscriber\n{\n    /**\n     * Handle user login events.\n     */\n    public function handleUserLogin($event) {}\n\n    /**\n     * Handle user logout events.\n     */\n    public function handleUserLogout($event) {}\n\n    /**\n     * Register the listeners for the subscriber.\n     *\n     * @param  \\Illuminate\\Events\\Dispatcher  $events\n     * @return void\n     */\n    public function subscribe($events)\n    {\n        $events-&gt;listen(\n            'Illuminate\\Auth\\Events\\Login',\n            [UserEventSubscriber::class, 'handleUserLogin']\n        );\n\n        $events-&gt;listen(\n            'Illuminate\\Auth\\Events\\Logout',\n            [UserEventSubscriber::class, 'handleUserLogout']\n        );\n    }\n}</code></pre>\n  <p>Alternativamente, el <code>subscribe</code>método de su suscriptor puede devolver una matriz de eventos a las asignaciones de controladores. En este caso, las asignaciones del detector de eventos se registrarán automáticamente:</p>\n  <pre><code>use Illuminate\\Auth\\Events\\Login;\nuse Illuminate\\Auth\\Events\\Logout;\n\n/**\n * Register the listeners for the subscriber.\n *\n * @return array\n */\npublic function subscribe()\n{\n    return [\n        Login::class =&gt; [UserEventSubscriber::class, 'handleUserLogin'],\n        Logout::class =&gt; [UserEventSubscriber::class, 'handleUserLogout'],\n    ];\n}</code></pre>\n  <p></p>\n  <h3>Registro de suscriptores de eventos</h3>\n  <p>Después de escribir el suscriptor, está listo para registrarlo con el despachador de eventos. Puede registrar suscriptores utilizando la <code>$subscribe</code>propiedad en el <code>EventServiceProvider</code>. Por ejemplo, agreguemos el <code>UserEventSubscriber</code>a la lista:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\n\nclass EventServiceProvider extends ServiceProvider\n{\n    /**\n     * The event listener mappings for the application.\n     *\n     * @var array\n     */\n    protected $listen = [\n        //\n    ];\n\n    /**\n     * The subscriber classes to register.\n     *\n     * @var array\n     */\n    protected $subscribe = [\n        'App\\Listeners\\UserEventSubscriber',\n    ];\n}</code></pre>\n</section>"
      },
      {
        "titulo": "6.5  de archivos",
        "contenido": "<section>\n  <h1>Almacenamiento de archivos</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Configuración\n      <ul>\n        <li>El disco público</li>\n        <li>El conductor local</li>\n        <li>Requisitos previos del controlador</li>\n        <li>Almacenamiento en caché</li>\n      </ul></li>\n    <li>Obtención de instancias de disco</li>\n    <li>Recuperando archivos\n      <ul>\n        <li>Descargando archivos</li>\n        <li>URL de archivo</li>\n        <li>Metadatos de archivo</li>\n      </ul></li>\n    <li>Almacenamiento de archivos\n      <ul>\n        <li>Subidas de archivos</li>\n        <li>Visibilidad de archivos</li>\n      </ul></li>\n    <li>Eliminar archivos</li>\n    <li>Directorios</li>\n    <li>Sistemas de archivos personalizados</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel proporciona una poderosa abstracción del sistema de archivos gracias al maravilloso paquete PHP Flysystem de Frank de Jonge. La integración de Laravel Flysystem proporciona controladores fáciles de usar para trabajar con sistemas de archivos locales y Amazon S3. Aún mejor, es increíblemente sencillo cambiar entre estas opciones de almacenamiento, ya que la API sigue siendo la misma para cada sistema.</p>\n  <p></p>\n  <h2>Configuración</h2>\n  <p>El archivo de configuración del sistema de archivos se encuentra en . Dentro de este archivo puede configurar todos sus \"discos\". Cada disco representa un controlador de almacenamiento y una ubicación de almacenamiento particulares. En el archivo de configuración se incluyen ejemplos de configuraciones para cada controlador compatible. Por lo tanto, modifique la configuración para reflejar sus preferencias y credenciales de almacenamiento.<code>config/filesystems.php</code></p>\n  <p>Puede configurar tantos discos como desee, e incluso puede tener varios discos que utilicen el mismo controlador.</p>\n  <p></p>\n  <h3>El disco público</h3>\n  <p>El <code>public</code>disco está diseñado para archivos que serán de acceso público. De forma predeterminada, el <code>public</code>disco usa el <code>local</code>controlador y almacena estos archivos en formato . Para que sean accesibles desde la web, debe crear un enlace simbólico desde hasta . Esta convención mantendrá sus archivos de acceso público en un directorio que se puede compartir fácilmente entre implementaciones cuando se utilizan sistemas de implementación sin tiempo de inactividad como Envoyer .<code>storage/app/public</code><code>public/storage</code><code>storage/app/public</code></p>\n  <p>Para crear el enlace simbólico, puede usar el comando Artisan:<code>storage:link</code></p>\n  <pre><code>php artisan storage:link</code></pre>\n  <p>Una vez que se ha almacenado un archivo y se ha creado el enlace simbólico, puede crear una URL a los archivos utilizando el <code>asset</code>asistente:</p>\n  <pre><code>echo asset('storage/file.txt');</code></pre>\n  <p>Puede configurar enlaces simbólicos adicionales en su <code>filesystems</code>archivo de configuración. Cada uno de los enlaces configurados se creará cuando ejecute el comando:<code>storage:link</code></p>\n  <pre><code>'links' =&gt; [\n    public_path('storage') =&gt; storage_path('app/public'),\n    public_path('images') =&gt; storage_path('app/images'),\n],</code></pre>\n  <p></p>\n  <h3>El conductor local</h3>\n  <p>Al usar el <code>local</code>controlador, todas las operaciones de archivo son relativas al <code>root</code>directorio definido en su <code>filesystems</code>archivo de configuración. De forma predeterminada, este valor se establece en el directorio. Por lo tanto, el siguiente método almacenaría un archivo en :<code>storage/app</code><code>storage/app/file.txt</code></p>\n  <pre><code>Storage::disk('local')-&gt;put('file.txt', 'Contents');</code></pre>\n  <h4>Permisos</h4>\n  <p>La <code>public</code> visibilidad se traduce en <code>0755</code>directorios y <code>0644</code>archivos. Puede modificar las asignaciones de permisos en su <code>filesystems</code>archivo de configuración:</p>\n  <pre><code>'local' =&gt; [\n    'driver' =&gt; 'local',\n    'root' =&gt; storage_path('app'),\n    'permissions' =&gt; [\n        'file' =&gt; [\n            'public' =&gt; 0664,\n            'private' =&gt; 0600,\n        ],\n        'dir' =&gt; [\n            'public' =&gt; 0775,\n            'private' =&gt; 0700,\n        ],\n    ],\n],</code></pre>\n  <p></p>\n  <h3>Requisitos previos del controlador</h3>\n  <h4>Paquetes de compositor</h4>\n  <p>Antes de usar los controladores SFTP o S3, deberá instalar el paquete apropiado a través de Composer:</p>\n  <ul>\n    <li>SFTP: <code>league/flysystem-sftp ~1.0</code></li>\n    <li>Amazon S3: <code>league/flysystem-aws-s3-v3 ~1.0</code></li>\n  </ul>\n  <p>Una necesidad absoluta para el rendimiento es utilizar un adaptador en caché. Necesitará un paquete adicional para esto:</p>\n  <ul>\n    <li>CachedAdapter: <code>league/flysystem-cached-adapter ~1.0</code></li>\n  </ul>\n  <h4>Configuración del controlador S3</h4>\n  <p>La información de configuración del controlador S3 se encuentra en su archivo de configuración. Este archivo contiene una matriz de configuración de ejemplo para un controlador S3. Puede modificar esta matriz con su propia configuración y credenciales de S3. Para mayor comodidad, estas variables de entorno coinciden con la convención de nomenclatura utilizada por la AWS CLI.<code>config/filesystems.php</code></p>\n  <h4>Configuración del controlador FTP</h4>\n  <p>Las integraciones de Flysystem de Laravel funcionan muy bien con FTP; sin embargo, no se incluye una configuración de muestra con el archivo de configuración predeterminado del marco . Si necesita configurar un sistema de archivos FTP, puede usar la configuración de ejemplo a continuación:<code>filesystems.php</code></p>\n  <pre><code>'ftp' =&gt; [\n    'driver' =&gt; 'ftp',\n    'host' =&gt; 'ftp.example.com',\n    'username' =&gt; 'your-username',\n    'password' =&gt; 'your-password',\n\n    // Optional FTP Settings...\n    // 'port' =&gt; 21,\n    // 'root' =&gt; '',\n    // 'passive' =&gt; true,\n    // 'ssl' =&gt; true,\n    // 'timeout' =&gt; 30,\n],</code></pre>\n  <h4>Configuración del controlador SFTP</h4>\n  <p>Las integraciones de Flysystem de Laravel funcionan muy bien con SFTP; sin embargo, no se incluye una configuración de muestra con el archivo de configuración predeterminado del marco . Si necesita configurar un sistema de archivos SFTP, puede usar la configuración de ejemplo a continuación:<code>filesystems.php</code></p>\n  <pre><code>'sftp' =&gt; [\n    'driver' =&gt; 'sftp',\n    'host' =&gt; 'example.com',\n    'username' =&gt; 'your-username',\n    'password' =&gt; 'your-password',\n\n    // Settings for SSH key based authentication...\n    // 'privateKey' =&gt; '/path/to/privateKey',\n    // 'password' =&gt; 'encryption-password',\n\n    // Optional SFTP Settings...\n    // 'port' =&gt; 22,\n    // 'root' =&gt; '',\n    // 'timeout' =&gt; 30,\n],</code></pre>\n  <p></p>\n  <h3>Almacenamiento en caché</h3>\n  <p>Para habilitar el almacenamiento en caché para un disco determinado, puede agregar una <code>cache</code>directiva a las opciones de configuración del disco. La <code>cache</code>opción debe ser una matriz de opciones de almacenamiento en caché que contenga el <code>disk</code>nombre, el <code>expire</code>tiempo en segundos y el caché <code>prefix</code>:</p>\n  <pre><code>'s3' =&gt; [\n    'driver' =&gt; 's3',\n\n    // Other Disk Options...\n\n    'cache' =&gt; [\n        'store' =&gt; 'memcached',\n        'expire' =&gt; 600,\n        'prefix' =&gt; 'cache-prefix',\n    ],\n],</code></pre>\n  <p></p>\n  <h2>Obtención de instancias de disco</h2>\n  <p>La <code>Storage</code>fachada se puede utilizar para interactuar con cualquiera de sus discos configurados. Por ejemplo, puede utilizar el <code>put</code>método en la fachada para almacenar un avatar en el disco predeterminado. Si llama a métodos en la <code>Storage</code>fachada sin llamar primero al <code>disk</code>método, la llamada al método se pasará automáticamente al disco predeterminado:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Storage;\n\nStorage::put('avatars/1', $fileContents);</code></pre>\n  <p>Si su aplicación interactúa con varios discos, puede usar el <code>disk</code>método en la <code>Storage</code>fachada para trabajar con archivos en un disco en particular:</p>\n  <pre><code>Storage::disk('s3')-&gt;put('avatars/1', $fileContents);</code></pre>\n  <p></p>\n  <h2>Recuperando archivos</h2>\n  <p>El <code>get</code>método puede usarse para recuperar el contenido de un archivo. El método devolverá el contenido de la cadena sin procesar del archivo. Recuerde, todas las rutas de archivo deben especificarse en relación con la ubicación \"raíz\" configurada para el disco:</p>\n  <pre><code>$contents = Storage::get('file.jpg');</code></pre>\n  <p>El <code>exists</code>método se puede usar para determinar si existe un archivo en el disco:</p>\n  <pre><code>$exists = Storage::disk('s3')-&gt;exists('file.jpg');</code></pre>\n  <p>El <code>missing</code>método se puede utilizar para determinar si falta un archivo en el disco:</p>\n  <pre><code>$missing = Storage::disk('s3')-&gt;missing('file.jpg');</code></pre>\n  <p></p>\n  <h3>Descargando archivos</h3>\n  <p>El <code>download</code>método puede usarse para generar una respuesta que obligue al navegador del usuario a descargar el archivo en la ruta dada. El <code>download</code>método acepta un nombre de archivo como segundo argumento del método, que determinará el nombre de archivo que verá el usuario que lo descarga. Finalmente, puede pasar una matriz de encabezados HTTP como tercer argumento del método:</p>\n  <pre><code>return Storage::download('file.jpg');\n\nreturn Storage::download('file.jpg', $name, $headers);</code></pre>\n  <p></p>\n  <h3>URL de archivo</h3>\n  <p>Puede utilizar el <code>url</code>método para obtener la URL del archivo dado. Si está utilizando el <code>local</code>controlador, normalmente se antepondrá <code>/storage</code>a la ruta dada y devolverá una URL relativa al archivo. Si está utilizando el <code>s3</code>controlador, se devolverá la URL remota totalmente calificada:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Storage;\n\n$url = Storage::url('file.jpg');</code></pre>\n  <p>Al usar el <code>local</code>controlador, todos los archivos que deberían ser de acceso público deben colocarse en el directorio. Además, debe crear un enlace simbólico en el que apunte al directorio.<code>storage/app/public</code><code>public/storage</code><code>storage/app/public</code></p>\n  <blockquote>\n    <div><div></div><p>Cuando se utiliza el <code>local</code>controlador, el valor de retorno de <code>url</code>no está codificado en URL. Por esta razón, recomendamos almacenar siempre sus archivos con nombres que crearán URL válidas.</p></div>\n  </blockquote>\n  <h4>URL temporales</h4>\n  <p>Para los archivos almacenados con el <code>s3</code>, puede crear una URL temporal para un archivo determinado usando el <code>temporaryUrl</code>método. Este método acepta una ruta y una <code>DateTime</code>instancia que especifican cuándo debe caducar la URL:</p>\n  <pre><code>$url = Storage::temporaryUrl(\n    'file.jpg', now()-&gt;addMinutes(5)\n);</code></pre>\n  <p>Si necesita especificar parámetros de solicitud de S3 adicionales , puede pasar la matriz de parámetros de solicitud como tercer argumento del <code>temporaryUrl</code>método:</p>\n  <pre><code>$url = Storage::temporaryUrl(\n    'file.jpg',\n    now()-&gt;addMinutes(5),\n    [\n        'ResponseContentType' =&gt; 'application/octet-stream',\n        'ResponseContentDisposition' =&gt; 'attachment; filename=file2.jpg',\n    ]\n);</code></pre>\n  <h4>Personalización del host de URL</h4>\n  <p>Si desea predefinir el host para las URL de archivos generadas mediante la <code>Storage</code>fachada, puede agregar una <code>url</code>opción a la matriz de configuración del disco:</p>\n  <pre><code>'public' =&gt; [\n    'driver' =&gt; 'local',\n    'root' =&gt; storage_path('app/public'),\n    'url' =&gt; env('APP_URL').'/storage',\n    'visibility' =&gt; 'public',\n],</code></pre>\n  <p></p>\n  <h3>Metadatos de archivo</h3>\n  <p>Además de leer y escribir archivos, Laravel también puede proporcionar información sobre los archivos en sí. Por ejemplo, el <code>size</code>método puede usarse para obtener el tamaño del archivo en bytes:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Storage;\n\n$size = Storage::size('file.jpg');</code></pre>\n  <p>El <code>lastModified</code>método devuelve la marca de tiempo UNIX de la última vez que se modificó el archivo:</p>\n  <pre><code>$time = Storage::lastModified('file.jpg');</code></pre>\n  <p></p>\n  <h2>Almacenamiento de archivos</h2>\n  <p>El <code>put</code>método se puede utilizar para almacenar el contenido del archivo sin formato en un disco. También puede pasar un PHP <code>resource</code>al <code>put</code>método, que utilizará el soporte de flujo subyacente de Flysystem. Recuerde, todas las rutas de archivo deben especificarse en relación con la ubicación \"raíz\" configurada para el disco:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Storage;\n\nStorage::put('file.jpg', $contents);\n\nStorage::put('file.jpg', $resource);</code></pre>\n  <h4>Transmisión automática</h4>\n  <p>Si desea que Laravel administre automáticamente la transmisión de un archivo determinado a su ubicación de almacenamiento, puede usar el método <code>putFile</code>o <code>putFileAs</code>. Este método acepta una instancia o y transmitirá automáticamente el archivo a la ubicación deseada:<code>Illuminate\\Http\\File</code><code>Illuminate\\Http\\UploadedFile</code></p>\n  <pre><code>use Illuminate\\Http\\File;\nuse Illuminate\\Support\\Facades\\Storage;\n\n// Automatically generate a unique ID for file name...\nStorage::putFile('photos', new File('/path/to/photo'));\n\n// Manually specify a file name...\nStorage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg');</code></pre>\n  <p>Hay algunas cosas importantes a tener en cuenta sobre el <code>putFile</code>método. Tenga en cuenta que solo especificamos un nombre de directorio, no un nombre de archivo. De forma predeterminada, el <code>putFile</code>método generará un ID único para que sirva como nombre de archivo. La extensión del archivo se determinará examinando el tipo MIME del archivo. El <code>putFile</code>método devolverá la ruta al archivo para que pueda almacenar la ruta, incluido el nombre del archivo generado, en su base de datos.</p>\n  <p>Los métodos <code>putFile</code>y <code>putFileAs</code>también aceptan un argumento para especificar la \"visibilidad\" del archivo almacenado. Esto es particularmente útil si está almacenando el archivo en un disco en la nube como S3 y desea que el archivo sea de acceso público:</p>\n  <pre><code>Storage::putFile('photos', new File('/path/to/photo'), 'public');</code></pre>\n  <h4>Anteponer y agregar a archivos</h4>\n  <p>Los métodos <code>prepend</code>y le <code>append</code>permiten escribir al principio o al final de un archivo:</p>\n  <pre><code>Storage::prepend('file.log', 'Prepended Text');\n\nStorage::append('file.log', 'Appended Text');</code></pre>\n  <h4>Copiar y mover archivos</h4>\n  <p>El <code>copy</code>método puede usarse para copiar un archivo existente a una nueva ubicación en el disco, mientras que el <code>move</code>método puede usarse para cambiar el nombre o mover un archivo existente a una nueva ubicación:</p>\n  <pre><code>Storage::copy('old/file.jpg', 'new/file.jpg');\n\nStorage::move('old/file.jpg', 'new/file.jpg');</code></pre>\n  <p></p>\n  <h3>Subidas de archivos</h3>\n  <p>En las aplicaciones web, uno de los casos de uso más comunes para almacenar archivos es almacenar archivos cargados por el usuario, como imágenes de perfil, fotos y documentos. Laravel hace que sea muy fácil almacenar archivos cargados usando el <code>store</code>método en una instancia de archivo cargado. Llame al <code>store</code>método con la ruta en la que desea almacenar el archivo cargado:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\n\nclass UserAvatarController extends Controller\n{\n    /**\n     * Update the avatar for the user.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function update(Request $request)\n    {\n        $path = $request-&gt;file('avatar')-&gt;store('avatars');\n\n        return $path;\n    }\n}</code></pre>\n  <p>Hay algunas cosas importantes a tener en cuenta sobre este ejemplo. Tenga en cuenta que solo especificamos un nombre de directorio, no un nombre de archivo. De forma predeterminada, el <code>store</code>método generará un ID único para que sirva como nombre de archivo. La extensión del archivo se determinará examinando el tipo MIME del archivo. El <code>store</code>método devolverá la ruta al archivo para que pueda almacenar la ruta, incluido el nombre del archivo generado, en su base de datos.</p>\n  <p>También puede llamar al <code>putFile</code>método en la <code>Storage</code>fachada para realizar la misma manipulación de archivos que en el ejemplo anterior:</p>\n  <pre><code>$path = Storage::putFile('avatars', $request-&gt;file('avatar'));</code></pre>\n  <h4>Especificar un nombre de archivo</h4>\n  <p>Si no desea que se asigne automáticamente un nombre de archivo a su archivo almacenado, puede usar el <code>storeAs</code>método, que recibe la ruta, el nombre del archivo y el disco (opcional) como argumentos:</p>\n  <pre><code>$path = $request-&gt;file('avatar')-&gt;storeAs(\n    'avatars', $request-&gt;user()-&gt;id\n);</code></pre>\n  <p>También puede usar el <code>putFileAs</code>método en la <code>Storage</code>fachada, que realizará la misma manipulación de archivos que en el ejemplo anterior:</p>\n  <pre><code>$path = Storage::putFileAs(\n    'avatars', $request-&gt;file('avatar'), $request-&gt;user()-&gt;id\n);</code></pre>\n  <blockquote>\n    <div><div></div><p>Los caracteres Unicode no imprimibles y no válidos se eliminarán automáticamente de las rutas de archivo. Por lo tanto, es posible que desee desinfectar las rutas de sus archivos antes de pasarlas a los métodos de almacenamiento de archivos de Laravel. Las rutas de archivo se normalizan mediante el método.<code>League\\Flysystem\\Util::normalizePath</code></p></div>\n  </blockquote>\n  <h4>Especificar un disco</h4>\n  <p>De forma predeterminada, este método utilizará su disco predeterminado. Si desea especificar otro disco, pase el nombre del disco como segundo argumento del <code>store</code>método:</p>\n  <pre><code>$path = $request-&gt;file('avatar')-&gt;store(\n    'avatars/'.$request-&gt;user()-&gt;id, 's3'\n);</code></pre>\n  <p>Si está utilizando el <code>storeAs</code>método, puede pasar el nombre del disco como tercer argumento del método:</p>\n  <pre><code>$path = $request-&gt;file('avatar')-&gt;storeAs(\n    'avatars',\n    $request-&gt;user()-&gt;id,\n    's3'\n);</code></pre>\n  <h4>Otra información de archivo</h4>\n  <p>Si desea obtener el nombre original del archivo cargado, puede hacerlo usando el <code>getClientOriginalName</code>método:</p>\n  <pre><code>$name = $request-&gt;file('avatar')-&gt;getClientOriginalName();</code></pre>\n  <p>El <code>extension</code>método se puede utilizar para obtener la extensión del archivo cargado:</p>\n  <pre><code>$extension = $request-&gt;file('avatar')-&gt;extension();</code></pre>\n  <p></p>\n  <h3>Visibilidad de archivos</h3>\n  <p>En la integración de Flysystem de Laravel, la \"visibilidad\" es una abstracción de los permisos de archivos en múltiples plataformas. Los archivos pueden estar declarados <code>public</code>o <code>private</code>. Cuando se declara un archivo <code>public</code>, está indicando que, en general, los demás deberían poder acceder al archivo. Por ejemplo, al utilizar el controlador S3, puede recuperar las URL de los <code>public</code>archivos.</p>\n  <p>Puede configurar la visibilidad al configurar el archivo a través del <code>put</code>método:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Storage;\n\nStorage::put('file.jpg', $contents, 'public');</code></pre>\n  <p>Si el archivo ya se ha almacenado, su visibilidad se puede recuperar y configurar mediante los métodos <code>getVisibility</code>y <code>setVisibility</code>:</p>\n  <pre><code>$visibility = Storage::getVisibility('file.jpg');\n\nStorage::setVisibility('file.jpg', 'public');</code></pre>\n  <p>Al interactuar con archivos cargados, puede utilizar los métodos <code>storePublicly</code>y <code>storePubliclyAs</code>para almacenar el archivo cargado con <code>public</code>visibilidad:</p>\n  <pre><code>$path = $request-&gt;file('avatar')-&gt;storePublicly('avatars', 's3');\n\n$path = $request-&gt;file('avatar')-&gt;storePubliclyAs(\n    'avatars',\n    $request-&gt;user()-&gt;id,\n    's3'\n);</code></pre>\n  <p></p>\n  <h2>Eliminar archivos</h2>\n  <p>El <code>delete</code>método acepta un solo nombre de archivo o una matriz de archivos para eliminar del disco:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Storage;\n\nStorage::delete('file.jpg');\n\nStorage::delete(['file.jpg', 'file2.jpg']);</code></pre>\n  <p>Si es necesario, puede especificar el disco del que se debe eliminar el archivo:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Storage;\n\nStorage::disk('s3')-&gt;delete('folder_path/file_name.jpg');</code></pre>\n  <p></p>\n  <h2>Directorios</h2>\n  <h4>Obtener todos los archivos dentro de un directorio</h4>\n  <p>El <code>files</code>método devuelve una matriz de todos los archivos de un directorio determinado. Si desea recuperar una lista de todos los archivos dentro de un directorio determinado, incluidos todos los subdirectorios, puede usar el <code>allFiles</code>método:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Storage;\n\n$files = Storage::files($directory);\n\n$files = Storage::allFiles($directory);</code></pre>\n  <h4>Obtener todos los directorios dentro de un directorio</h4>\n  <p>El <code>directories</code>método devuelve una matriz de todos los directorios dentro de un directorio determinado. Además, puede usar el <code>allDirectories</code>método para obtener una lista de todos los directorios dentro de un directorio determinado y todos sus subdirectorios:</p>\n  <pre><code>$directories = Storage::directories($directory);\n\n// Recursive...\n$directories = Storage::allDirectories($directory);</code></pre>\n  <h4>Crear un directorio</h4>\n  <p>El <code>makeDirectory</code>método creará el directorio dado, incluidos los subdirectorios necesarios:</p>\n  <pre><code>Storage::makeDirectory($directory);</code></pre>\n  <h4>Eliminar un directorio</h4>\n  <p>Finalmente, el <code>deleteDirectory</code>método puede usarse para eliminar un directorio y todos sus archivos:</p>\n  <pre><code>Storage::deleteDirectory($directory);</code></pre>\n  <p></p>\n  <h2>Sistemas de archivos personalizados</h2>\n  <p>La integración Flysystem de Laravel proporciona controladores para varios \"controladores\" listos para usar; sin embargo, Flysystem no se limita a estos y tiene adaptadores para muchos otros sistemas de almacenamiento. Puede crear un controlador personalizado si desea utilizar uno de estos adaptadores adicionales en su aplicación Laravel.</p>\n  <p>Para configurar el sistema de archivos personalizado, necesitará un adaptador Flysystem. Agreguemos un adaptador de Dropbox mantenido por la comunidad a nuestro proyecto:</p>\n  <pre><code>composer require spatie/flysystem-dropbox</code></pre>\n  <p>A continuación, debe crear un proveedor de servicios como <code>DropboxServiceProvider</code>. En el <code>boot</code>método del proveedor , puede utilizar el método de la <code>Storage</code>fachada <code>extend</code>para definir el controlador personalizado:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\Storage;\nuse Illuminate\\Support\\ServiceProvider;\nuse League\\Flysystem\\Filesystem;\nuse Spatie\\Dropbox\\Client as DropboxClient;\nuse Spatie\\FlysystemDropbox\\DropboxAdapter;\n\nclass DropboxServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Storage::extend('dropbox', function ($app, $config) {\n            $client = new DropboxClient(\n                $config['authorization_token']\n            );\n\n            return new Filesystem(new DropboxAdapter($client));\n        });\n    }\n}</code></pre>\n  <p>El primer argumento del <code>extend</code>método es el nombre del controlador y el segundo es un cierre que recibe las variables <code>$app</code>y <code>$config</code>. El cierre del resolutor debe devolver una instancia de . La variable contiene los valores definidos en para el disco especificado.<code>League\\Flysystem\\Filesystem</code><code>$config</code><code>config/filesystems.php</code></p>\n  <p>A continuación, registre el proveedor de servicios en su archivo de configuración:<code>config/app.php</code></p>\n  <pre><code>'providers' =&gt; [\n    // ...\n    App\\Providers\\DropboxServiceProvider::class,\n];</code></pre>\n  <p>Una vez que haya creado y registrado el proveedor de servicios de la extensión, puede usar el <code>dropbox</code>controlador en su archivo de configuración.<code>config/filesystems.php</code></p>\n</section>"
      },
      {
        "titulo": "6.6 Ayudantes",
        "contenido": "<section>\n  <h1>Ayudantes</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Métodos disponibles</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel incluye una variedad de funciones PHP \"auxiliares\" globales. Muchas de estas funciones son utilizadas por el propio framework; sin embargo, puede utilizarlos en sus propias aplicaciones si los encuentra convenientes.</p>\n  <p></p>\n  <h2>Métodos disponibles</h2>\n  <style>\n    .collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    .collection-method-list a {\n        display: block;\n    }\n</style>\n  <h3>Matrices y objetos</h3>\n  <div>\n    <p>Arr :: accesible\n      Arr :: agregar\n      Arr :: colapso\n      Arr :: crossÚnete\n      Arr :: dividir\n      Arr :: punto\n      Arr :: excepto\n      Arr :: existe\n      Arr :: primero\n      Arr :: aplanar\n      Arr :: olvidar\n      Arr :: obtener\n      Arr :: tiene\n      Arr :: hasAny\n      Arr :: isAssoc\n      Arr :: último\n      Arr :: solo\n      Arr :: arrancar\n      Arr :: anteponer\n      Arr :: tirar\n      Arr :: consulta\n      Arr :: aleatorio\n      Arr :: conjunto\n      Arr :: barajar\n      Arr :: ordenar\n      Arr :: sortRecursivo\n      Arr :: donde\n      Arr :: abrigo\n      relleno_de_datos\n      data_get\n      data_set\n      cabeza\n      último</p>\n  </div>\n  <h3>Caminos</h3>\n  <div>\n    <p>app_path\n      ruta_base\n      config_path\n      database_path\n      mezcla\n      public_path\n      resource_path\n      ruta_almacenamiento</p>\n  </div>\n  <h3>Instrumentos de cuerda</h3>\n  <div>\n    <p>__\n      class_basename\n      mi\n      preg_replace_array\n      Str :: después\n      Str :: afterLast\n      Str :: ascii\n      Str :: antes\n      Str :: beforeLast\n      Str :: entre\n      Str :: camello\n      Str :: contiene\n      Str :: containsAll\n      Str :: endsWith\n      Str :: acabado\n      Str :: es\n      Str :: isAscii\n      Str :: isUuid\n      Str :: kebab\n      Str :: longitud\n      Str :: límite\n      Str :: inferior\n      Str :: OrderUuid\n      Str :: padBoth\n      Str :: padLeft\n      Str :: padRight\n      Str :: plural\n      Str :: aleatorio\n      Str :: replaceArray\n      Str :: replaceFirst\n      Str :: replaceLast\n      Str :: singular\n      Str :: babosa\n      Str :: serpiente\n      Str :: inicio\n      Str :: startsWith\n      Str :: studly\n      Str :: substr\n      Str :: título\n      Str :: ucfirst\n      Str :: superior\n      Str :: uuid\n      Str :: palabras\n      trans\n      trans_choice</p>\n  </div>\n  <p></p>\n  <h3>Cuerdas fluidas</h3>\n  <div>\n    <p>después\n      afterLast\n      adjuntar\n      ascii\n      nombre de base\n      antes de\n      antes del ultimo\n      camello\n      contiene\n      contiene todo\n      dirname\n      termina con\n      exactamente\n      explotar\n      terminar\n      es\n      isAscii\n      esta vacio\n      no está vacío\n      brocheta\n      longitud\n      límite\n      inferior\n      ltrim\n      partido\n      matchAll\n      padBoth\n      padLeft\n      padRight\n      plural\n      anteponer\n      reemplazar\n      replaceArray\n      replaceFirst\n      replaceLast\n      replaceMatches\n      rtrim\n      singular\n      babosa\n      serpiente\n      división\n      comienzo\n      comienza con\n      semental\n      substr\n      título\n      podar\n      ucfirst\n      Superior\n      cuando\n      whenEmpty\n      palabras</p>\n  </div>\n  <h3>URLs</h3>\n  <div>\n    <p>acción\n      activo\n      ruta\n      activo_seguro\n      secure_url\n      url</p>\n  </div>\n  <h3>Diverso</h3>\n  <div>\n    <p>abortar\n      abort_if\n      abortar a menos\n      aplicación\n      auth\n      espalda\n      bcrypt\n      blanco\n      transmitir\n      cache\n      class_uses_recursive\n      recoger\n      config\n      Galleta\n      csrf_field\n      csrf_token\n      dd\n      envío\n      despacho_ahora\n      tugurio\n      env\n      evento\n      lleno\n      info\n      registrador\n      campo_método\n      ahora\n      antiguo\n      Opcional\n      política\n      redireccionar\n      reporte\n      solicitud\n      rescate\n      resolver\n      respuesta\n      rever\n      sesión\n      grifo\n      throw_if\n      lanzar_a menos\n      hoy\n      trait_uses_recursive\n      transformar\n      validador\n      valor\n      ver\n      con</p>\n  </div>\n  <p></p>\n  <h2>Listado de métodos</h2>\n  <style>\n    #collection-method code {\n        font-size: 14px;\n    }\n\n    #collection-method:not(.first-collection-method) {\n        margin-top: 50px;\n    }\n</style>\n  <p></p>\n  <h2>Matrices y objetos</h2>\n  <p></p>\n  <h4><code>Arr::accessible()</code></h4>\n  <p>El método verifica que el valor dado sea accesible a la matriz:<code>Arr::accessible</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\nuse Illuminate\\Support\\Collection;\n\n$isAccessible = Arr::accessible(['a' =&gt; 1, 'b' =&gt; 2]);\n\n// true\n\n$isAccessible = Arr::accessible(new Collection);\n\n// true\n\n$isAccessible = Arr::accessible('abc');\n\n// false\n\n$isAccessible = Arr::accessible(new stdClass);\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Arr::add()</code></h4>\n  <p>El método agrega un par clave / valor dado a una matriz si la clave dada aún no existe en la matriz o está establecida en :<code>Arr::add</code><code>null</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = Arr::add(['name' =&gt; 'Desk'], 'price', 100);\n\n// ['name' =&gt; 'Desk', 'price' =&gt; 100]\n\n$array = Arr::add(['name' =&gt; 'Desk', 'price' =&gt; null], 'price', 100);\n\n// ['name' =&gt; 'Desk', 'price' =&gt; 100]</code></pre>\n  <p></p>\n  <h4><code>Arr::collapse()</code></h4>\n  <p>El método colapsa una matriz de matrices en una sola matriz:<code>Arr::collapse</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\n\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>\n  <p></p>\n  <h4><code>Arr::crossJoin()</code></h4>\n  <p>El método cruza las matrices dadas, devolviendo un producto cartesiano con todas las permutaciones posibles:<code>Arr::crossJoin</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$matrix = Arr::crossJoin([1, 2], ['a', 'b']);\n\n/*\n    [\n        [1, 'a'],\n        [1, 'b'],\n        [2, 'a'],\n        [2, 'b'],\n    ]\n*/\n\n$matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);\n\n/*\n    [\n        [1, 'a', 'I'],\n        [1, 'a', 'II'],\n        [1, 'b', 'I'],\n        [1, 'b', 'II'],\n        [2, 'a', 'I'],\n        [2, 'a', 'II'],\n        [2, 'b', 'I'],\n        [2, 'b', 'II'],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>Arr::divide()</code></h4>\n  <p>El método devuelve dos matrices, una que contiene las claves y la otra que contiene los valores de la matriz dada:<code>Arr::divide</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n[$keys, $values] = Arr::divide(['name' =&gt; 'Desk']);\n\n// $keys: ['name']\n\n// $values: ['Desk']</code></pre>\n  <p></p>\n  <h4><code>Arr::dot()</code></h4>\n  <p>El método aplana una matriz multidimensional en una matriz de un solo nivel que utiliza la notación de \"puntos\" para indicar la profundidad:<code>Arr::dot</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];\n\n$flattened = Arr::dot($array);\n\n// ['products.desk.price' =&gt; 100]</code></pre>\n  <p></p>\n  <h4><code>Arr::except()</code></h4>\n  <p>El método elimina los pares clave / valor dados de una matriz:<code>Arr::except</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];\n\n$filtered = Arr::except($array, ['price']);\n\n// ['name' =&gt; 'Desk']</code></pre>\n  <p></p>\n  <h4><code>Arr::exists()</code></h4>\n  <p>El método verifica que la clave dada exista en la matriz proporcionada:<code>Arr::exists</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['name' =&gt; 'John Doe', 'age' =&gt; 17];\n\n$exists = Arr::exists($array, 'name');\n\n// true\n\n$exists = Arr::exists($array, 'salary');\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Arr::first()</code></h4>\n  <p>El método devuelve el primer elemento de una matriz que pasa una prueba de verdad determinada:<code>Arr::first</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = [100, 200, 300];\n\n$first = Arr::first($array, function ($value, $key) {\n    return $value &gt;= 150;\n});\n\n// 200</code></pre>\n  <p>También se puede pasar un valor predeterminado como tercer parámetro del método. Este valor se devolverá si ningún valor pasa la prueba de verdad:</p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$first = Arr::first($array, $callback, $default);</code></pre>\n  <p></p>\n  <h4><code>Arr::flatten()</code></h4>\n  <p>El método aplana una matriz multidimensional en una matriz de un solo nivel:<code>Arr::flatten</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['name' =&gt; 'Joe', 'languages' =&gt; ['PHP', 'Ruby']];\n\n$flattened = Arr::flatten($array);\n\n// ['Joe', 'PHP', 'Ruby']</code></pre>\n  <p></p>\n  <h4><code>Arr::forget()</code></h4>\n  <p>El método elimina un par clave / valor dado de una matriz profundamente anidada usando la notación de \"puntos\":<code>Arr::forget</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];\n\nArr::forget($array, 'products.desk');\n\n// ['products' =&gt; []]</code></pre>\n  <p></p>\n  <h4><code>Arr::get()</code></h4>\n  <p>El método recupera un valor de una matriz profundamente anidada usando la notación \"punto\":<code>Arr::get</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];\n\n$price = Arr::get($array, 'products.desk.price');\n\n// 100</code></pre>\n  <p>El método también acepta un valor predeterminado, que se devolverá si no se encuentra la clave específica:<code>Arr::get</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$discount = Arr::get($array, 'products.desk.discount', 0);\n\n// 0</code></pre>\n  <p></p>\n  <h4><code>Arr::has()</code></h4>\n  <p>El método verifica si un elemento o elementos determinados existen en una matriz mediante la notación de \"puntos\":<code>Arr::has</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]];\n\n$contains = Arr::has($array, 'product.name');\n\n// true\n\n$contains = Arr::has($array, ['product.price', 'product.discount']);\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Arr::hasAny()</code></h4>\n  <p>El método verifica si algún elemento de un conjunto determinado existe en una matriz utilizando la notación de \"punto\":<code>Arr::hasAny</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]];\n\n$contains = Arr::hasAny($array, 'product.name');\n\n// true\n\n$contains = Arr::hasAny($array, ['product.name', 'product.discount']);\n\n// true\n\n$contains = Arr::hasAny($array, ['category', 'product.discount']);\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Arr::isAssoc()</code></h4>\n  <p>Los rendimientos si la matriz es una matriz asociativa. Una matriz se considera \"asociativa\" si no tiene claves numéricas secuenciales que comiencen con cero:<code>Arr::isAssoc</code><code>true</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$isAssoc = Arr::isAssoc(['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]]);\n\n// true\n\n$isAssoc = Arr::isAssoc([1, 2, 3]);\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Arr::last()</code></h4>\n  <p>El método devuelve el último elemento de una matriz que pasa una prueba de verdad determinada:<code>Arr::last</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = [100, 200, 300, 110];\n\n$last = Arr::last($array, function ($value, $key) {\n    return $value &gt;= 150;\n});\n\n// 300</code></pre>\n  <p>Se puede pasar un valor predeterminado como tercer argumento del método. Este valor se devolverá si ningún valor pasa la prueba de verdad:</p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$last = Arr::last($array, $callback, $default);</code></pre>\n  <p></p>\n  <h4><code>Arr::only()</code></h4>\n  <p>El método devuelve solo los pares clave / valor especificados de la matriz dada:<code>Arr::only</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['name' =&gt; 'Desk', 'price' =&gt; 100, 'orders' =&gt; 10];\n\n$slice = Arr::only($array, ['name', 'price']);\n\n// ['name' =&gt; 'Desk', 'price' =&gt; 100]</code></pre>\n  <p></p>\n  <h4><code>Arr::pluck()</code></h4>\n  <p>El método recupera todos los valores de una clave determinada de una matriz:<code>Arr::pluck</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = [\n    ['developer' =&gt; ['id' =&gt; 1, 'name' =&gt; 'Taylor']],\n    ['developer' =&gt; ['id' =&gt; 2, 'name' =&gt; 'Abigail']],\n];\n\n$names = Arr::pluck($array, 'developer.name');\n\n// ['Taylor', 'Abigail']</code></pre>\n  <p>También puede especificar cómo desea que se ingrese la lista resultante:</p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$names = Arr::pluck($array, 'developer.name', 'developer.id');\n\n// [1 =&gt; 'Taylor', 2 =&gt; 'Abigail']</code></pre>\n  <p></p>\n  <h4><code>Arr::prepend()</code></h4>\n  <p>El método empujará un elemento al comienzo de una matriz:<code>Arr::prepend</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['one', 'two', 'three', 'four'];\n\n$array = Arr::prepend($array, 'zero');\n\n// ['zero', 'one', 'two', 'three', 'four']</code></pre>\n  <p>Si es necesario, puede especificar la clave que debe usarse para el valor:</p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['price' =&gt; 100];\n\n$array = Arr::prepend($array, 'Desk', 'name');\n\n// ['name' =&gt; 'Desk', 'price' =&gt; 100]</code></pre>\n  <p></p>\n  <h4><code>Arr::pull()</code></h4>\n  <p>El método devuelve y elimina un par clave / valor de una matriz:<code>Arr::pull</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];\n\n$name = Arr::pull($array, 'name');\n\n// $name: Desk\n\n// $array: ['price' =&gt; 100]</code></pre>\n  <p>Se puede pasar un valor predeterminado como tercer argumento del método. Este valor se devolverá si la clave no existe:</p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$value = Arr::pull($array, $key, $default);</code></pre>\n  <p></p>\n  <h4><code>Arr::query()</code></h4>\n  <p>El método convierte la matriz en una cadena de consulta:<code>Arr::query</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['name' =&gt; 'Taylor', 'order' =&gt; ['column' =&gt; 'created_at', 'direction' =&gt; 'desc']];\n\nArr::query($array);\n\n// name=Taylor&amp;order[column]=created_at&amp;order[direction]=desc</code></pre>\n  <p></p>\n  <h4><code>Arr::random()</code></h4>\n  <p>El método devuelve un valor aleatorio de una matriz:<code>Arr::random</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = [1, 2, 3, 4, 5];\n\n$random = Arr::random($array);\n\n// 4 - (retrieved randomly)</code></pre>\n  <p>También puede especificar el número de elementos que se devolverán como segundo argumento opcional. Tenga en cuenta que proporcionar este argumento devolverá una matriz, incluso si solo se desea un elemento:</p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$items = Arr::random($array, 2);\n\n// [2, 5] - (retrieved randomly)</code></pre>\n  <p></p>\n  <h4><code>Arr::set()</code></h4>\n  <p>El método establece un valor dentro de una matriz profundamente anidada usando la notación de \"puntos\":<code>Arr::set</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];\n\nArr::set($array, 'products.desk.price', 200);\n\n// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]</code></pre>\n  <p></p>\n  <h4><code>Arr::shuffle()</code></h4>\n  <p>El método baraja aleatoriamente los elementos de la matriz:<code>Arr::shuffle</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = Arr::shuffle([1, 2, 3, 4, 5]);\n\n// [3, 2, 5, 1, 4] - (generated randomly)</code></pre>\n  <p></p>\n  <h4><code>Arr::sort()</code></h4>\n  <p>El método ordena una matriz por sus valores:<code>Arr::sort</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = ['Desk', 'Table', 'Chair'];\n\n$sorted = Arr::sort($array);\n\n// ['Chair', 'Desk', 'Table']</code></pre>\n  <p>También puede ordenar la matriz por los resultados del cierre dado:</p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = [\n    ['name' =&gt; 'Desk'],\n    ['name' =&gt; 'Table'],\n    ['name' =&gt; 'Chair'],\n];\n\n$sorted = array_values(Arr::sort($array, function ($value) {\n    return $value['name'];\n}));\n\n/*\n    [\n        ['name' =&gt; 'Chair'],\n        ['name' =&gt; 'Desk'],\n        ['name' =&gt; 'Table'],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>Arr::sortRecursive()</code></h4>\n  <p>El método ordena recursivamente una matriz usando la función para matrices sub = numéricas y para submatrices asociativas:<code>Arr::sortRecursive</code><code>sort</code><code>ksort</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = [\n    ['Roman', 'Taylor', 'Li'],\n    ['PHP', 'Ruby', 'JavaScript'],\n    ['one' =&gt; 1, 'two' =&gt; 2, 'three' =&gt; 3],\n];\n\n$sorted = Arr::sortRecursive($array);\n\n/*\n    [\n        ['JavaScript', 'PHP', 'Ruby'],\n        ['one' =&gt; 1, 'three' =&gt; 3, 'two' =&gt; 2],\n        ['Li', 'Roman', 'Taylor'],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>Arr::where()</code></h4>\n  <p>El método filtra una matriz usando el Closure dado:<code>Arr::where</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$array = [100, '200', 300, '400', 500];\n\n$filtered = Arr::where($array, function ($value, $key) {\n    return is_string($value);\n});\n\n// [1 =&gt; '200', 3 =&gt; '400']</code></pre>\n  <p></p>\n  <h4><code>Arr::wrap()</code></h4>\n  <p>El método envuelve el valor dado en una matriz. Si el valor dado ya es una matriz, no se cambiará:<code>Arr::wrap</code></p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$string = 'Laravel';\n\n$array = Arr::wrap($string);\n\n// ['Laravel']</code></pre>\n  <p>Si el valor dado es nulo, se devolverá una matriz vacía:</p>\n  <pre><code>use Illuminate\\Support\\Arr;\n\n$nothing = null;\n\n$array = Arr::wrap($nothing);\n\n// []</code></pre>\n  <p></p>\n  <h4><code>data_fill()</code></h4>\n  <p>La <code>data_fill</code>función establece un valor faltante dentro de una matriz u objeto anidado usando la notación de \"punto\":</p>\n  <pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];\n\ndata_fill($data, 'products.desk.price', 200);\n\n// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]\n\ndata_fill($data, 'products.desk.discount', 10);\n\n// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100, 'discount' =&gt; 10]]]</code></pre>\n  <p>Esta función también acepta asteriscos como comodines y completará el destino en consecuencia:</p>\n  <pre><code>$data = [\n    'products' =&gt; [\n        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],\n        ['name' =&gt; 'Desk 2'],\n    ],\n];\n\ndata_fill($data, 'products.*.price', 200);\n\n/*\n    [\n        'products' =&gt; [\n            ['name' =&gt; 'Desk 1', 'price' =&gt; 100],\n            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],\n        ],\n    ]\n*/</code></pre>\n  <p></p>\n  <h4><code>data_get()</code></h4>\n  <p>La <code>data_get</code>función recupera un valor de una matriz u objeto anidado usando la notación \"punto\":</p>\n  <pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];\n\n$price = data_get($data, 'products.desk.price');\n\n// 100</code></pre>\n  <p>La <code>data_get</code>función también acepta un valor predeterminado, que se devolverá si no se encuentra la clave especificada:</p>\n  <pre><code>$discount = data_get($data, 'products.desk.discount', 0);\n\n// 0</code></pre>\n  <p>La función también acepta comodines usando asteriscos, que pueden apuntar a cualquier clave de la matriz u objeto:</p>\n  <pre><code>$data = [\n    'product-one' =&gt; ['name' =&gt; 'Desk 1', 'price' =&gt; 100],\n    'product-two' =&gt; ['name' =&gt; 'Desk 2', 'price' =&gt; 150],\n];\n\ndata_get($data, '*.name');\n\n// ['Desk 1', 'Desk 2'];</code></pre>\n  <p></p>\n  <h4><code>data_set()</code></h4>\n  <p>La <code>data_set</code>función establece un valor dentro de una matriz u objeto anidado usando la notación \"punto\":</p>\n  <pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];\n\ndata_set($data, 'products.desk.price', 200);\n\n// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]</code></pre>\n  <p>Esta función también acepta comodines y establecerá valores en el objetivo en consecuencia:</p>\n  <pre><code>$data = [\n    'products' =&gt; [\n        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],\n        ['name' =&gt; 'Desk 2', 'price' =&gt; 150],\n    ],\n];\n\ndata_set($data, 'products.*.price', 200);\n\n/*\n    [\n        'products' =&gt; [\n            ['name' =&gt; 'Desk 1', 'price' =&gt; 200],\n            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],\n        ],\n    ]\n*/</code></pre>\n  <p>De forma predeterminada, se sobrescriben los valores existentes. Si solo desea establecer un valor si no existe, puede pasar <code>false</code>como el cuarto argumento:</p>\n  <pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];\n\ndata_set($data, 'products.desk.price', 200, false);\n\n// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]</code></pre>\n  <p></p>\n  <h4><code>head()</code></h4>\n  <p>La <code>head</code>función devuelve el primer elemento de la matriz dada:</p>\n  <pre><code>$array = [100, 200, 300];\n\n$first = head($array);\n\n// 100</code></pre>\n  <p></p>\n  <h4><code>last()</code></h4>\n  <p>La <code>last</code>función devuelve el último elemento de la matriz dada:</p>\n  <pre><code>$array = [100, 200, 300];\n\n$last = last($array);\n\n// 300</code></pre>\n  <p></p>\n  <h2>Caminos</h2>\n  <p></p>\n  <h4><code>app_path()</code></h4>\n  <p>La <code>app_path</code>función devuelve la ruta completa al <code>app</code>directorio. También puede usar la <code>app_path</code>función para generar una ruta completa a un archivo relativo al directorio de la aplicación:</p>\n  <pre><code>$path = app_path();\n\n$path = app_path('Http/Controllers/Controller.php');</code></pre>\n  <p></p>\n  <h4><code>base_path()</code></h4>\n  <p>La <code>base_path</code>función devuelve la ruta completamente calificada a la raíz del proyecto. También puede usar la <code>base_path</code>función para generar una ruta completa a un archivo dado en relación con el directorio raíz del proyecto:</p>\n  <pre><code>$path = base_path();\n\n$path = base_path('vendor/bin');</code></pre>\n  <p></p>\n  <h4><code>config_path()</code></h4>\n  <p>La <code>config_path</code>función devuelve la ruta completa al <code>config</code>directorio. También puede usar la <code>config_path</code>función para generar una ruta completamente calificada a un archivo dado dentro del directorio de configuración de la aplicación:</p>\n  <pre><code>$path = config_path();\n\n$path = config_path('app.php');</code></pre>\n  <p></p>\n  <h4><code>database_path()</code></h4>\n  <p>La <code>database_path</code>función devuelve la ruta completa al <code>database</code>directorio. También puede usar la <code>database_path</code>función para generar una ruta completa a un archivo dado dentro del directorio de la base de datos:</p>\n  <pre><code>$path = database_path();\n\n$path = database_path('factories/UserFactory.php');</code></pre>\n  <p></p>\n  <h4><code>mix()</code></h4>\n  <p>La <code>mix</code>función devuelve la ruta a un archivo Mix versionado :</p>\n  <pre><code>$path = mix('css/app.css');</code></pre>\n  <p></p>\n  <h4><code>public_path()</code></h4>\n  <p>La <code>public_path</code>función devuelve la ruta completa al <code>public</code>directorio. También puede usar la <code>public_path</code>función para generar una ruta completa a un archivo dado dentro del directorio público:</p>\n  <pre><code>$path = public_path();\n\n$path = public_path('css/app.css');</code></pre>\n  <p></p>\n  <h4><code>resource_path()</code></h4>\n  <p>La <code>resource_path</code>función devuelve la ruta completa al <code>resources</code>directorio. También puede usar la <code>resource_path</code>función para generar una ruta completa a un archivo dado dentro del directorio de recursos:</p>\n  <pre><code>$path = resource_path();\n\n$path = resource_path('sass/app.scss');</code></pre>\n  <p></p>\n  <h4><code>storage_path()</code></h4>\n  <p>La <code>storage_path</code>función devuelve la ruta completa al <code>storage</code>directorio. También puede usar la <code>storage_path</code>función para generar una ruta completamente calificada a un archivo dado dentro del directorio de almacenamiento:</p>\n  <pre><code>$path = storage_path();\n\n$path = storage_path('app/file.txt');</code></pre>\n  <p></p>\n  <h2>Instrumentos de cuerda</h2>\n  <p></p>\n  <h4><code>__()</code></h4>\n  <p>La <code>__</code>función traduce la cadena de traducción dada o la clave de traducción usando sus archivos de localización :</p>\n  <pre><code>echo __('Welcome to our application');\n\necho __('messages.welcome');</code></pre>\n  <p>Si la cadena o clave de traducción especificada no existe, la <code>__</code>función devolverá el valor dado. Entonces, usando el ejemplo anterior, la <code>__</code>función regresaría si esa clave de traducción no existe.<code>messages.welcome</code></p>\n  <p></p>\n  <h4><code>class_basename()</code></h4>\n  <p>La <code>class_basename</code>función devuelve el nombre de clase de la clase dada con el espacio de nombres de la clase eliminado:</p>\n  <pre><code>$class = class_basename('Foo\\Bar\\Baz');\n\n// Baz</code></pre>\n  <p></p>\n  <h4><code>e()</code></h4>\n  <p>La <code>e</code>función ejecuta la <code>htmlspecialchars</code>función de PHP con la <code>double_encode</code>opción configurada <code>true</code>por defecto:</p>\n  <pre><code>echo e('&lt;html&gt;foo&lt;/html&gt;');\n\n// &amp;lt;html&amp;gt;foo&amp;lt;/html&amp;gt;</code></pre>\n  <p></p>\n  <h4><code>preg_replace_array()</code></h4>\n  <p>La <code>preg_replace_array</code>función reemplaza un patrón dado en la cadena secuencialmente usando una matriz:</p>\n  <pre><code>$string = 'The event will take place between :start and :end';\n\n$replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);\n\n// The event will take place between 8:30 and 9:00</code></pre>\n  <p></p>\n  <h4><code>Str::after()</code></h4>\n  <p>El método devuelve todo después del valor dado en una cadena. Se devolverá la cadena completa si el valor no existe dentro de la cadena:<code>Str::after</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::after('This is my name', 'This is');\n\n// ' my name'</code></pre>\n  <p></p>\n  <h4><code>Str::afterLast()</code></h4>\n  <p>El método devuelve todo después de la última aparición del valor dado en una cadena. Se devolverá la cadena completa si el valor no existe dentro de la cadena:<code>Str::afterLast</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::afterLast('App\\Http\\Controllers\\Controller', '\\\\');\n\n// 'Controller'</code></pre>\n  <p></p>\n  <h4><code>Str::ascii()</code></h4>\n  <p>El método intentará transliterar la cadena en un valor ASCII:<code>Str::ascii</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::ascii('û');\n\n// 'u'</code></pre>\n  <p></p>\n  <h4><code>Str::before()</code></h4>\n  <p>El método devuelve todo antes del valor dado en una cadena:<code>Str::before</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::before('This is my name', 'my name');\n\n// 'This is '</code></pre>\n  <p></p>\n  <h4><code>Str::beforeLast()</code></h4>\n  <p>El método devuelve todo antes de la última aparición del valor dado en una cadena:<code>Str::beforeLast</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::beforeLast('This is my name', 'is');\n\n// 'This '</code></pre>\n  <p></p>\n  <h4><code>Str::between()</code></h4>\n  <p>El método devuelve la parte de una cadena entre dos valores:<code>Str::between</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::between('This is my name', 'This', 'name');\n\n// ' is my '</code></pre>\n  <p></p>\n  <h4><code>Str::camel()</code></h4>\n  <p>El método convierte la cadena dada a :<code>Str::camel</code><code>camelCase</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::camel('foo_bar');\n\n// fooBar</code></pre>\n  <p></p>\n  <h4><code>Str::contains()</code></h4>\n  <p>El método determina si la cadena dada contiene el valor dado (distingue entre mayúsculas y minúsculas):<code>Str::contains</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$contains = Str::contains('This is my name', 'my');\n\n// true</code></pre>\n  <p>También puede pasar una matriz de valores para determinar si la cadena dada contiene alguno de los valores:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$contains = Str::contains('This is my name', ['my', 'foo']);\n\n// true</code></pre>\n  <p></p>\n  <h4><code>Str::containsAll()</code></h4>\n  <p>El método determina si la cadena dada contiene todos los valores de la matriz:<code>Str::containsAll</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$containsAll = Str::containsAll('This is my name', ['my', 'name']);\n\n// true</code></pre>\n  <p></p>\n  <h4><code>Str::endsWith()</code></h4>\n  <p>El método determina si la cadena dada termina con el valor dado:<code>Str::endsWith</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::endsWith('This is my name', 'name');\n\n// true</code></pre>\n  <p>También puede pasar una matriz de valores para determinar si la cadena dada termina con alguno de los valores dados:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::endsWith('This is my name', ['name', 'foo']);\n\n// true\n\n$result = Str::endsWith('This is my name', ['this', 'foo']);\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Str::finish()</code></h4>\n  <p>El método agrega una única instancia del valor dado a una cadena si aún no termina con el valor:<code>Str::finish</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$adjusted = Str::finish('this/string', '/');\n\n// this/string/\n\n$adjusted = Str::finish('this/string/', '/');\n\n// this/string/</code></pre>\n  <p></p>\n  <h4><code>Str::is()</code></h4>\n  <p>El método determina si una determinada cadena coincide con un patrón determinado. Se pueden utilizar asteriscos para indicar comodines:<code>Str::is</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$matches = Str::is('foo*', 'foobar');\n\n// true\n\n$matches = Str::is('baz*', 'foobar');\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Str::isAscii()</code></h4>\n  <p>El método determina si una cadena dada es ASCII de 7 bits:<code>Str::isAscii</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$isAscii = Str::isAscii('Taylor');\n\n// true\n\n$isAscii = Str::isAscii('ü');\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Str::isUuid()</code></h4>\n  <p>El método determina si la cadena dada es un UUID válido:<code>Str::isUuid</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');\n\n// true\n\n$isUuid = Str::isUuid('laravel');\n\n// false</code></pre>\n  <p></p>\n  <h4><code>Str::kebab()</code></h4>\n  <p>El método convierte la cadena dada a :<code>Str::kebab</code><code>kebab-case</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::kebab('fooBar');\n\n// foo-bar</code></pre>\n  <p></p>\n  <h4><code>Str::length()</code></h4>\n  <p>El método devuelve la longitud de la cadena dada:<code>Str::length</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$length = Str::length('Laravel');\n\n// 7</code></pre>\n  <p></p>\n  <h4><code>Str::limit()</code></h4>\n  <p>El método trunca la cadena dada en la longitud especificada:<code>Str::limit</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20);\n\n// The quick brown fox...</code></pre>\n  <p>También puede pasar un tercer argumento para cambiar la cadena que se agregará al final:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20, ' (...)');\n\n// The quick brown fox (...)</code></pre>\n  <p></p>\n  <h4><code>Str::lower()</code></h4>\n  <p>El método convierte la cadena dada a minúsculas:<code>Str::lower</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::lower('LARAVEL');\n\n// laravel</code></pre>\n  <p></p>\n  <h4><code>Str::orderedUuid()</code></h4>\n  <p>El método genera un UUID de \"marca de tiempo primero\" que se puede almacenar de manera eficiente en una columna de base de datos indexada:<code>Str::orderedUuid</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\nreturn (string) Str::orderedUuid();</code></pre>\n  <p></p>\n  <h4><code>Str::padBoth()</code></h4>\n  <p>El método envuelve la función de PHP , rellenando ambos lados de una cadena con otra:<code>Str::padBoth</code><code>str_pad</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$padded = Str::padBoth('James', 10, '_');\n\n// '__James___'\n\n$padded = Str::padBoth('James', 10);\n\n// '  James   '</code></pre>\n  <p></p>\n  <h4><code>Str::padLeft()</code></h4>\n  <p>El método envuelve la función de PHP , rellenando el lado izquierdo de una cadena con otro:<code>Str::padLeft</code><code>str_pad</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$padded = Str::padLeft('James', 10, '-=');\n\n// '-=-=-James'\n\n$padded = Str::padLeft('James', 10);\n\n// '     James'</code></pre>\n  <p></p>\n  <h4><code>Str::padRight()</code></h4>\n  <p>El método envuelve la función de PHP , rellenando el lado derecho de una cadena con otro:<code>Str::padRight</code><code>str_pad</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$padded = Str::padRight('James', 10, '-');\n\n// 'James-----'\n\n$padded = Str::padRight('James', 10);\n\n// 'James     '</code></pre>\n  <p></p>\n  <h4><code>Str::plural()</code></h4>\n  <p>El método convierte una cadena de una sola palabra a su forma plural. Actualmente, esta función solo admite el idioma inglés:<code>Str::plural</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$plural = Str::plural('car');\n\n// cars\n\n$plural = Str::plural('child');\n\n// children</code></pre>\n  <p>Puede proporcionar un número entero como segundo argumento a la función para recuperar la forma singular o plural de la cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$plural = Str::plural('child', 2);\n\n// children\n\n$plural = Str::plural('child', 1);\n\n// child</code></pre>\n  <p></p>\n  <h4><code>Str::random()</code></h4>\n  <p>El método genera una cadena aleatoria de la longitud especificada. Esta función usa la función de PHP :<code>Str::random</code><code>random_bytes</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$random = Str::random(40);</code></pre>\n  <p></p>\n  <h4><code>Str::replaceArray()</code></h4>\n  <p>El método reemplaza un valor dado en la cadena secuencialmente usando una matriz:<code>Str::replaceArray</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = 'The event will take place between ? and ?';\n\n$replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);\n\n// The event will take place between 8:30 and 9:00</code></pre>\n  <p></p>\n  <h4><code>Str::replaceFirst()</code></h4>\n  <p>El método reemplaza la primera aparición de un valor dado en una cadena:<code>Str::replaceFirst</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');\n\n// a quick brown fox jumps over the lazy dog</code></pre>\n  <p></p>\n  <h4><code>Str::replaceLast()</code></h4>\n  <p>El método reemplaza la última aparición de un valor dado en una cadena:<code>Str::replaceLast</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');\n\n// the quick brown fox jumps over a lazy dog</code></pre>\n  <p></p>\n  <h4><code>Str::singular()</code></h4>\n  <p>El método convierte una cadena a su forma singular. Actualmente, esta función solo admite el idioma inglés:<code>Str::singular</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$singular = Str::singular('cars');\n\n// car\n\n$singular = Str::singular('children');\n\n// child</code></pre>\n  <p></p>\n  <h4><code>Str::slug()</code></h4>\n  <p>El método genera un \"slug\" compatible con URL a partir de la cadena dada:<code>Str::slug</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slug = Str::slug('Laravel 5 Framework', '-');\n\n// laravel-5-framework</code></pre>\n  <p></p>\n  <h4><code>Str::snake()</code></h4>\n  <p>El método convierte la cadena dada a :<code>Str::snake</code><code>snake_case</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::snake('fooBar');\n\n// foo_bar</code></pre>\n  <p></p>\n  <h4><code>Str::start()</code></h4>\n  <p>El método agrega una única instancia del valor dado a una cadena si aún no comienza con el valor:<code>Str::start</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$adjusted = Str::start('this/string', '/');\n\n// /this/string\n\n$adjusted = Str::start('/this/string', '/');\n\n// /this/string</code></pre>\n  <p></p>\n  <h4><code>Str::startsWith()</code></h4>\n  <p>El método determina si la cadena dada comienza con el valor dado:<code>Str::startsWith</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::startsWith('This is my name', 'This');\n\n// true</code></pre>\n  <p></p>\n  <h4><code>Str::studly()</code></h4>\n  <p>El método convierte la cadena dada a :<code>Str::studly</code><code>StudlyCase</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::studly('foo_bar');\n\n// FooBar</code></pre>\n  <p></p>\n  <h4><code>Str::substr()</code></h4>\n  <p>El método devuelve la parte de cadena especificada por los parámetros de inicio y longitud:<code>Str::substr</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::substr('The Laravel Framework', 4, 7);\n\n// Laravel</code></pre>\n  <p></p>\n  <h4><code>Str::title()</code></h4>\n  <p>El método convierte la cadena dada a :<code>Str::title</code><code>Title Case</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::title('a nice title uses the correct case');\n\n// A Nice Title Uses The Correct Case</code></pre>\n  <p></p>\n  <h4><code>Str::ucfirst()</code></h4>\n  <p>El método devuelve la cadena dada con el primer carácter en mayúscula:<code>Str::ucfirst</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::ucfirst('foo bar');\n\n// Foo bar</code></pre>\n  <p></p>\n  <h4><code>Str::upper()</code></h4>\n  <p>El método convierte la cadena dada a mayúsculas:<code>Str::upper</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::upper('laravel');\n\n// LARAVEL</code></pre>\n  <p></p>\n  <h4><code>Str::uuid()</code></h4>\n  <p>El método genera un UUID (versión 4):<code>Str::uuid</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\nreturn (string) Str::uuid();</code></pre>\n  <p></p>\n  <h4><code>Str::words()</code></h4>\n  <p>El método limita la cantidad de palabras en una cadena:<code>Str::words</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\nreturn Str::words('Perfectly balanced, as all things should be.', 3, ' &gt;&gt;&gt;');\n\n// Perfectly balanced, as &gt;&gt;&gt;</code></pre>\n  <p></p>\n  <h4><code>trans()</code></h4>\n  <p>La <code>trans</code>función traduce la clave de traducción dada usando sus archivos de localización :</p>\n  <pre><code>echo trans('messages.welcome');</code></pre>\n  <p>If the specified translation key does not exist, the <code>trans</code> function will return the given key. So, using the example above, the <code>trans</code> function would return <code>messages.welcome</code> if the translation key does not exist.</p>\n  <p></p>\n  <h4><code>trans_choice()</code></h4>\n  <p>The <code>trans_choice</code> function translates the given translation key with inflection:</p>\n  <pre><code>echo trans_choice('messages.notifications', $unreadCount);</code></pre>\n  <p>If the specified translation key does not exist, the <code>trans_choice</code> function will return the given key. So, using the example above, the <code>trans_choice</code> function would return <code>messages.notifications</code> if the translation key does not exist.</p>\n  <p></p>\n  <h2>Fluent Strings</h2>\n  <p>Fluent strings provide a more fluent, object-oriented interface for working with string values, allowing you to chain multiple string operations together using a more readable syntax compared to traditional string operations.</p>\n  <p></p>\n  <h4><code>after</code></h4>\n  <p>The <code>after</code> method returns everything after the given value in a string. The entire string will be returned if the value does not exist within the string:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::of('This is my name')-&gt;after('This is');\n\n// ' my name'</code></pre>\n  <p></p>\n  <h4><code>afterLast</code></h4>\n  <p>El <code>afterLast</code>método devuelve todo después de la última aparición del valor dado en una cadena. Se devolverá la cadena completa si el valor no existe dentro de la cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::of('App\\Http\\Controllers\\Controller')-&gt;afterLast('\\\\');\n\n// 'Controller'</code></pre>\n  <p></p>\n  <h4><code>append</code></h4>\n  <p>El <code>append</code>método agrega los valores dados a la cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('Taylor')-&gt;append(' Otwell');\n\n// 'Taylor Otwell'</code></pre>\n  <p></p>\n  <h4><code>ascii</code></h4>\n  <p>El <code>ascii</code>método intentará transliterar la cadena en un valor ASCII:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('ü')-&gt;ascii();\n\n// 'u'</code></pre>\n  <p></p>\n  <h4><code>basename</code></h4>\n  <p>El <code>basename</code>método devolverá el componente de nombre final de la cadena dada:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('/foo/bar/baz')-&gt;basename();\n\n// 'baz'</code></pre>\n  <p>Si es necesario, puede proporcionar una \"extensión\" que se eliminará del componente final:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('/foo/bar/baz.jpg')-&gt;basename('.jpg');\n\n// 'baz'</code></pre>\n  <p></p>\n  <h4><code>before</code></h4>\n  <p>El <code>before</code>método devuelve todo antes del valor dado en una cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::of('This is my name')-&gt;before('my name');\n\n// 'This is '</code></pre>\n  <p></p>\n  <h4><code>beforeLast</code></h4>\n  <p>El <code>beforeLast</code>método devuelve todo antes de la última aparición del valor dado en una cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slice = Str::of('This is my name')-&gt;beforeLast('is');\n\n// 'This '</code></pre>\n  <p></p>\n  <h4><code>camel</code></h4>\n  <p>El <code>camel</code>método convierte la cadena dada a <code>camelCase</code>:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::of('foo_bar')-&gt;camel();\n\n// fooBar</code></pre>\n  <p></p>\n  <h4><code>contains</code></h4>\n  <p>El <code>contains</code>método determina si la cadena dada contiene el valor dado (distingue entre mayúsculas y minúsculas):</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$contains = Str::of('This is my name')-&gt;contains('my');\n\n// true</code></pre>\n  <p>También puede pasar una matriz de valores para determinar si la cadena dada contiene alguno de los valores:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$contains = Str::of('This is my name')-&gt;contains(['my', 'foo']);\n\n// true</code></pre>\n  <p></p>\n  <h4><code>containsAll</code></h4>\n  <p>El <code>containsAll</code>método determina si la cadena dada contiene todos los valores de la matriz:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$containsAll = Str::of('This is my name')-&gt;containsAll(['my', 'name']);\n\n// true</code></pre>\n  <p></p>\n  <h4><code>dirname</code></h4>\n  <p>El <code>dirname</code>método devuelve la parte del directorio principal de la cadena dada:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('/foo/bar/baz')-&gt;dirname();\n\n// '/foo/bar'</code></pre>\n  <p>Opcionalmente, puede especificar cuántos niveles de directorio desea recortar de la cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('/foo/bar/baz')-&gt;dirname(2);\n\n// '/foo'</code></pre>\n  <p></p>\n  <h4><code>endsWith</code></h4>\n  <p>El <code>endsWith</code>método determina si la cadena dada termina con el valor dado:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('This is my name')-&gt;endsWith('name');\n\n// true</code></pre>\n  <p>También puede pasar una matriz de valores para determinar si la cadena dada termina con alguno de los valores dados:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('This is my name')-&gt;endsWith(['name', 'foo']);\n\n// true\n\n$result = Str::of('This is my name')-&gt;endsWith(['this', 'foo']);\n\n// false</code></pre>\n  <p></p>\n  <h4><code>exactly</code></h4>\n  <p>El <code>exactly</code>método determina si la cadena dada es una coincidencia exacta con otra cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('Laravel')-&gt;exactly('Laravel');\n\n// true</code></pre>\n  <p></p>\n  <h4><code>explode</code></h4>\n  <p>El <code>explode</code>método divide la cadena por el delimitador dado y devuelve una colección que contiene cada sección de la cadena dividida:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$collection = Str::of('foo bar baz')-&gt;explode(' ');\n\n// collect(['foo', 'bar', 'baz'])</code></pre>\n  <p></p>\n  <h4><code>finish</code></h4>\n  <p>El <code>finish</code>método agrega una única instancia del valor dado a una cadena si aún no termina con el valor:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$adjusted = Str::of('this/string')-&gt;finish('/');\n\n// this/string/\n\n$adjusted = Str::of('this/string/')-&gt;finish('/');\n\n// this/string/</code></pre>\n  <p></p>\n  <h4><code>is</code></h4>\n  <p>El <code>is</code>método determina si una determinada cadena coincide con un patrón determinado. Se pueden utilizar asteriscos para indicar comodines:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$matches = Str::of('foobar')-&gt;is('foo*');\n\n// true\n\n$matches = Str::of('foobar')-&gt;is('baz*');\n\n// false</code></pre>\n  <p></p>\n  <h4><code>isAscii</code></h4>\n  <p>El <code>isAscii</code>método determina si una cadena dada es una cadena ASCII:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('Taylor')-&gt;isAscii();\n\n// true\n\n$result = Str::of('ü')-&gt;isAscii();\n\n// false</code></pre>\n  <p></p>\n  <h4><code>isEmpty</code></h4>\n  <p>El <code>isEmpty</code>método determina si la cadena dada está vacía:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('  ')-&gt;trim()-&gt;isEmpty();\n\n// true\n\n$result = Str::of('Laravel')-&gt;trim()-&gt;isEmpty();\n\n// false</code></pre>\n  <p></p>\n  <h4><code>isNotEmpty</code></h4>\n  <p>El <code>isNotEmpty</code>método determina si la cadena dada no está vacía:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('  ')-&gt;trim()-&gt;isNotEmpty();\n\n// false\n\n$result = Str::of('Laravel')-&gt;trim()-&gt;isNotEmpty();\n\n// true</code></pre>\n  <p></p>\n  <h4><code>kebab</code></h4>\n  <p>El <code>kebab</code>método convierte la cadena dada a :<code>kebab-case</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::of('fooBar')-&gt;kebab();\n\n// foo-bar</code></pre>\n  <p></p>\n  <h4><code>length</code></h4>\n  <p>El <code>length</code>método devuelve la longitud de la cadena dada:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$length = Str::of('Laravel')-&gt;length();\n\n// 7</code></pre>\n  <p></p>\n  <h4><code>limit</code></h4>\n  <p>El <code>limit</code>método trunca la cadena dada en la longitud especificada:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$truncated = Str::of('The quick brown fox jumps over the lazy dog')-&gt;limit(20);\n\n// The quick brown fox...</code></pre>\n  <p>También puede pasar un segundo argumento para cambiar la cadena que se agregará al final:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$truncated = Str::of('The quick brown fox jumps over the lazy dog')-&gt;limit(20, ' (...)');\n\n// The quick brown fox (...)</code></pre>\n  <p></p>\n  <h4><code>lower</code></h4>\n  <p>El <code>lower</code>método convierte la cadena dada a minúsculas:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('LARAVEL')-&gt;lower();\n\n// 'laravel'</code></pre>\n  <p></p>\n  <h4><code>ltrim</code></h4>\n  <p>El <code>ltrim</code>método de la izquierda recorta la cadena dada:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('  Laravel  ')-&gt;ltrim();\n\n// 'Laravel  '\n\n$string = Str::of('/Laravel/')-&gt;ltrim('/');\n\n// 'Laravel/'</code></pre>\n  <p></p>\n  <h4><code>match</code></h4>\n  <p>El <code>match</code>método devolverá la parte de una cadena que coincide con un patrón de expresión regular determinado:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('foo bar')-&gt;match('/bar/');\n\n// 'bar'\n\n$result = Str::of('foo bar')-&gt;match('/foo (.*)/');\n\n// 'bar'</code></pre>\n  <p></p>\n  <h4><code>matchAll</code></h4>\n  <p>El <code>matchAll</code>método devolverá una colección que contiene las partes de una cadena que coinciden con un patrón de expresión regular dado:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('bar foo bar')-&gt;matchAll('/bar/');\n\n// collect(['bar', 'bar'])</code></pre>\n  <p>Si especifica un grupo coincidente dentro de la expresión, Laravel devolverá una colección de coincidencias de ese grupo:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('bar fun bar fly')-&gt;matchAll('/f(\\w*)/');\n\n// collect(['un', 'ly']);</code></pre>\n  <p>Si no se encuentran coincidencias, se devolverá una colección vacía.</p>\n  <p></p>\n  <h4><code>padBoth</code></h4>\n  <p>El <code>padBoth</code>método envuelve la <code>str_pad</code>función de PHP , rellenando ambos lados de una cadena con otra:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$padded = Str::of('James')-&gt;padBoth(10, '_');\n\n// '__James___'\n\n$padded = Str::of('James')-&gt;padBoth(10);\n\n// '  James   '</code></pre>\n  <p></p>\n  <h4><code>padLeft</code></h4>\n  <p>El <code>padLeft</code>método envuelve la <code>str_pad</code>función de PHP , rellenando el lado izquierdo de una cadena con otro:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$padded = Str::of('James')-&gt;padLeft(10, '-=');\n\n// '-=-=-James'\n\n$padded = Str::of('James')-&gt;padLeft(10);\n\n// '     James'</code></pre>\n  <p></p>\n  <h4><code>padRight</code></h4>\n  <p>El <code>padRight</code>método envuelve la <code>str_pad</code>función de PHP , rellenando el lado derecho de una cadena con otro:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$padded = Str::of('James')-&gt;padRight(10, '-');\n\n// 'James-----'\n\n$padded = Str::of('James')-&gt;padRight(10);\n\n// 'James     '</code></pre>\n  <p></p>\n  <h4><code>plural</code></h4>\n  <p>El <code>plural</code>método convierte una cadena de una sola palabra a su forma plural. Actualmente, esta función solo admite el idioma inglés:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$plural = Str::of('car')-&gt;plural();\n\n// cars\n\n$plural = Str::of('child')-&gt;plural();\n\n// children</code></pre>\n  <p>Puede proporcionar un número entero como segundo argumento a la función para recuperar la forma singular o plural de la cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$plural = Str::of('child')-&gt;plural(2);\n\n// children\n\n$plural = Str::of('child')-&gt;plural(1);\n\n// child</code></pre>\n  <p></p>\n  <h4><code>prepend</code></h4>\n  <p>El <code>prepend</code>método antepone los valores dados a la cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('Framework')-&gt;prepend('Laravel ');\n\n// Laravel Framework</code></pre>\n  <p></p>\n  <h4><code>replace</code></h4>\n  <p>El <code>replace</code>método reemplaza una cadena dada dentro de la cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$replaced = Str::of('Laravel 6.x')-&gt;replace('6.x', '7.x');\n\n// Laravel 7.x</code></pre>\n  <p></p>\n  <h4><code>replaceArray</code></h4>\n  <p>The <code>replaceArray</code> method replaces a given value in the string sequentially using an array:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = 'The event will take place between ? and ?';\n\n$replaced = Str::of($string)-&gt;replaceArray('?', ['8:30', '9:00']);\n\n// The event will take place between 8:30 and 9:00</code></pre>\n  <p></p>\n  <h4><code>replaceFirst</code></h4>\n  <p>The <code>replaceFirst</code> method replaces the first occurrence of a given value in a string:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$replaced = Str::of('the quick brown fox jumps over the lazy dog')-&gt;replaceFirst('the', 'a');\n\n// a quick brown fox jumps over the lazy dog</code></pre>\n  <p></p>\n  <h4><code>replaceLast</code></h4>\n  <p>The <code>replaceLast</code> method replaces the last occurrence of a given value in a string:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$replaced = Str::of('the quick brown fox jumps over the lazy dog')-&gt;replaceLast('the', 'a');\n\n// the quick brown fox jumps over a lazy dog</code></pre>\n  <p></p>\n  <h4><code>replaceMatches</code></h4>\n  <p>The <code>replaceMatches</code> method replaces all portions of a string matching a given pattern with the given replacement string:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$replaced = Str::of('(+1) 501-555-1000')-&gt;replaceMatches('/[^A-Za-z0-9]++/', '')\n\n// '15015551000'</code></pre>\n  <p>The <code>replaceMatches</code> method also accepts a Closure that will be invoked with each portion of the string matching the given party, allowing you to perform the replacement logic within the Closure and return the replaced value:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$replaced = Str::of('123')-&gt;replaceMatches('/\\d/', function ($match) {\n    return '['.$match[0].']';\n});\n\n// '[1][2][3]'</code></pre>\n  <p></p>\n  <h4><code>rtrim</code></h4>\n  <p>The <code>rtrim</code> method right trims the given string:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('  Laravel  ')-&gt;rtrim();\n\n// '  Laravel'\n\n$string = Str::of('/Laravel/')-&gt;rtrim('/');\n\n// '/Laravel'</code></pre>\n  <p></p>\n  <h4><code>singular</code></h4>\n  <p>The <code>singular</code> method converts a string to its singular form. This function currently only supports the English language:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$singular = Str::of('cars')-&gt;singular();\n\n// car\n\n$singular = Str::of('children')-&gt;singular();\n\n// child</code></pre>\n  <p></p>\n  <h4><code>slug</code></h4>\n  <p>El <code>slug</code>método genera un \"slug\" compatible con URL a partir de la cadena dada:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$slug = Str::of('Laravel Framework')-&gt;slug('-');\n\n// laravel-framework</code></pre>\n  <p></p>\n  <h4><code>snake</code></h4>\n  <p>El <code>snake</code>método convierte la cadena dada a <code>snake_case</code>:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::of('fooBar')-&gt;snake();\n\n// foo_bar</code></pre>\n  <p></p>\n  <h4><code>split</code></h4>\n  <p>El <code>split</code>método divide una cadena en una colección usando una expresión regular:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$segments = Str::of('one, two, three')-&gt;split('/[\\s,]+/');\n\n// collect([\"one\", \"two\", \"three\"])</code></pre>\n  <p></p>\n  <h4><code>start</code></h4>\n  <p>El <code>start</code>método agrega una única instancia del valor dado a una cadena si aún no comienza con el valor:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$adjusted = Str::of('this/string')-&gt;start('/');\n\n// /this/string\n\n$adjusted = Str::of('/this/string')-&gt;start('/');\n\n// /this/string</code></pre>\n  <p></p>\n  <h4><code>startsWith</code></h4>\n  <p>El <code>startsWith</code>método determina si la cadena dada comienza con el valor dado:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$result = Str::of('This is my name')-&gt;startsWith('This');\n\n// true</code></pre>\n  <p></p>\n  <h4><code>studly</code></h4>\n  <p>El <code>studly</code>método convierte la cadena dada a <code>StudlyCase</code>:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::of('foo_bar')-&gt;studly();\n\n// FooBar</code></pre>\n  <p></p>\n  <h4><code>substr</code></h4>\n  <p>El <code>substr</code>método devuelve la parte de la cadena especificada por los parámetros de inicio y longitud dados:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('Laravel Framework')-&gt;substr(8);\n\n// Framework\n\n$string = Str::of('Laravel Framework')-&gt;substr(8, 5);\n\n// Frame</code></pre>\n  <p></p>\n  <h4><code>title</code></h4>\n  <p>El <code>title</code>método convierte la cadena dada a :<code>Title Case</code></p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$converted = Str::of('a nice title uses the correct case')-&gt;title();\n\n// A Nice Title Uses The Correct Case</code></pre>\n  <p></p>\n  <h4><code>trim</code></h4>\n  <p>El <code>trim</code>método recorta la cadena dada:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('  Laravel  ')-&gt;trim();\n\n// 'Laravel'\n\n$string = Str::of('/Laravel/')-&gt;trim('/');\n\n// 'Laravel'</code></pre>\n  <p></p>\n  <h4><code>ucfirst</code></h4>\n  <p>El <code>ucfirst</code>método devuelve la cadena dada con el primer carácter en mayúscula:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('foo bar')-&gt;ucfirst();\n\n// Foo bar</code></pre>\n  <p></p>\n  <h4><code>upper</code></h4>\n  <p>El <code>upper</code>método convierte la cadena dada a mayúsculas:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$adjusted = Str::of('laravel')-&gt;upper();\n\n// LARAVEL</code></pre>\n  <p></p>\n  <h4><code>when</code></h4>\n  <p>El <code>when</code>método invoca el Closure dado si una condición dada es verdadera. El cierre recibirá la instancia de cadena fluida:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('Taylor')\n                -&gt;when(true, function ($string) {\n                    return $string-&gt;append(' Otwell');\n                });\n\n// 'Taylor Otwell'</code></pre>\n  <p>Si es necesario, puede pasar otro Closure como tercer parámetro del <code>when</code>método. Este cierre se ejecutará si el parámetro de condición se evalúa como <code>false</code>.</p>\n  <p></p>\n  <h4><code>whenEmpty</code></h4>\n  <p>El <code>whenEmpty</code>método invoca el Closure dado si la cadena está vacía. Si el cierre devuelve un valor, el <code>whenEmpty</code>método también devolverá ese valor . Si el cierre no devuelve un valor, se devolverá la instancia de cadena fluida:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('  ')-&gt;whenEmpty(function ($string) {\n    return $string-&gt;trim()-&gt;prepend('Laravel');\n});\n\n// 'Laravel'</code></pre>\n  <p></p>\n  <h4><code>words</code></h4>\n  <p>El <code>words</code>método limita la cantidad de palabras en una cadena:</p>\n  <pre><code>use Illuminate\\Support\\Str;\n\n$string = Str::of('Perfectly balanced, as all things should be.')-&gt;words(3, ' &gt;&gt;&gt;');\n\n// Perfectly balanced, as &gt;&gt;&gt;</code></pre>\n  <p></p>\n  <h2>URLs</h2>\n  <p></p>\n  <h4><code>action()</code></h4>\n  <p>La <code>action</code>función genera una URL para la acción del controlador dada:</p>\n  <pre><code>$url = action([HomeController::class, 'index']);</code></pre>\n  <p>Si el método acepta parámetros de ruta, puede pasarlos como segundo argumento del método:</p>\n  <pre><code>$url = action([UserController::class, 'profile'], ['id' =&gt; 1]);</code></pre>\n  <p></p>\n  <h4><code>asset()</code></h4>\n  <p>La <code>asset</code>función genera una URL para un activo utilizando el esquema actual de la solicitud (HTTP o HTTPS):</p>\n  <pre><code>$url = asset('img/photo.jpg');</code></pre>\n  <p>Puede configurar el host de la URL del activo configurando la <code>ASSET_URL</code>variable en su <code>.env</code>archivo. Esto puede resultar útil si aloja sus activos en un servicio externo como Amazon S3:</p>\n  <pre><code>// ASSET_URL=http://example.com/assets\n\n$url = asset('img/photo.jpg'); // http://example.com/assets/img/photo.jpg</code></pre>\n  <p></p>\n  <h4><code>route()</code></h4>\n  <p>La <code>route</code>función genera una URL para la ruta con nombre dada:</p>\n  <pre><code>$url = route('routeName');</code></pre>\n  <p>Si la ruta acepta parámetros, puede pasarlos como segundo argumento del método:</p>\n  <pre><code>$url = route('routeName', ['id' =&gt; 1]);</code></pre>\n  <p>De forma predeterminada, la <code>route</code>función genera una URL absoluta. Si desea generar una URL relativa, puede pasar <code>false</code>como tercer argumento:</p>\n  <pre><code>$url = route('routeName', ['id' =&gt; 1], false);</code></pre>\n  <p></p>\n  <h4><code>secure_asset()</code></h4>\n  <p>La <code>secure_asset</code>función genera una URL para un activo usando HTTPS:</p>\n  <pre><code>$url = secure_asset('img/photo.jpg');</code></pre>\n  <p></p>\n  <h4><code>secure_url()</code></h4>\n  <p>La <code>secure_url</code>función genera una URL HTTPS completamente calificada para la ruta dada:</p>\n  <pre><code>$url = secure_url('user/profile');\n\n$url = secure_url('user/profile', [1]);</code></pre>\n  <p></p>\n  <h4><code>url()</code></h4>\n  <p>La <code>url</code>función genera una URL completamente calificada para la ruta dada:</p>\n  <pre><code>$url = url('user/profile');\n\n$url = url('user/profile', [1]);</code></pre>\n  <p>Si no se proporciona una ruta, se devuelve una instancia:<code>Illuminate\\Routing\\UrlGenerator</code></p>\n  <pre><code>$current = url()-&gt;current();\n\n$full = url()-&gt;full();\n\n$previous = url()-&gt;previous();</code></pre>\n  <p></p>\n  <h2>Diverso</h2>\n  <p></p>\n  <h4><code>abort()</code></h4>\n  <p>La <code>abort</code>función lanza una excepción HTTP que será procesada por el manejador de excepciones :</p>\n  <pre><code>abort(403);</code></pre>\n  <p>También puede proporcionar el mensaje de la excepción y los encabezados de respuesta personalizados que deben enviarse al navegador:</p>\n  <pre><code>abort(403, 'Unauthorized.', $headers);</code></pre>\n  <p></p>\n  <h4><code>abort_if()</code></h4>\n  <p>La <code>abort_if</code>función lanza una excepción HTTP si una expresión booleana dada se evalúa como <code>true</code>:</p>\n  <pre><code>abort_if(! Auth::user()-&gt;isAdmin(), 403);</code></pre>\n  <p>Al igual que el <code>abort</code>método, también puede proporcionar el texto de respuesta de la excepción como tercer argumento y una matriz de encabezados de respuesta personalizados como cuarto argumento.</p>\n  <p></p>\n  <h4><code>abort_unless()</code></h4>\n  <p>La <code>abort_unless</code>función lanza una excepción HTTP si una expresión booleana dada se evalúa como <code>false</code>:</p>\n  <pre><code>abort_unless(Auth::user()-&gt;isAdmin(), 403);</code></pre>\n  <p>Al igual que el <code>abort</code>método, también puede proporcionar el texto de respuesta de la excepción como tercer argumento y una matriz de encabezados de respuesta personalizados como cuarto argumento.</p>\n  <p></p>\n  <h4><code>app()</code></h4>\n  <p>La <code>app</code>función devuelve la instancia del contenedor de servicios :</p>\n  <pre><code>$container = app();</code></pre>\n  <p>Puede pasar un nombre de clase o interfaz para resolverlo desde el contenedor:</p>\n  <pre><code>$api = app('HelpSpot\\API');</code></pre>\n  <p></p>\n  <h4><code>auth()</code></h4>\n  <p>La <code>auth</code>función devuelve una instancia de autenticador . Puede usarlo en lugar de la <code>Auth</code>fachada por conveniencia:</p>\n  <pre><code>$user = auth()-&gt;user();</code></pre>\n  <p>Si es necesario, puede especificar a qué instancia de guardia le gustaría acceder:</p>\n  <pre><code>$user = auth('admin')-&gt;user();</code></pre>\n  <p></p>\n  <h4><code>back()</code></h4>\n  <p>La <code>back</code>función genera una respuesta HTTP de redireccionamiento a la ubicación anterior del usuario:</p>\n  <pre><code>return back($status = 302, $headers = [], $fallback = false);\n\nreturn back();</code></pre>\n  <p></p>\n  <h4><code>bcrypt()</code></h4>\n  <p>La <code>bcrypt</code>función calcula el valor dado mediante Bcrypt. Puede utilizarlo como alternativa a la <code>Hash</code>fachada:</p>\n  <pre><code>$password = bcrypt('my-secret-password');</code></pre>\n  <p></p>\n  <h4><code>blank()</code></h4>\n  <p>La <code>blank</code>función devuelve si el valor dado está \"en blanco\":</p>\n  <pre><code>blank('');\nblank('   ');\nblank(null);\nblank(collect());\n\n// true\n\nblank(0);\nblank(true);\nblank(false);\n\n// false</code></pre>\n  <p>Para el inverso de <code>blank</code>, vea el <code>filled</code>método.</p>\n  <p></p>\n  <h4><code>broadcast()</code></h4>\n  <p>La <code>broadcast</code>función transmite el evento dado a sus oyentes:</p>\n  <pre><code>broadcast(new UserRegistered($user));</code></pre>\n  <p></p>\n  <h4><code>cache()</code></h4>\n  <p>La <code>cache</code>función puede usarse para obtener valores de la caché . Si la clave dada no existe en la caché, se devolverá un valor predeterminado opcional:</p>\n  <pre><code>$value = cache('key');\n\n$value = cache('key', 'default');</code></pre>\n  <p>Puede agregar elementos a la caché pasando una matriz de pares clave / valor a la función. También debe pasar la cantidad de segundos o la duración del valor en caché debe considerarse válido:</p>\n  <pre><code>cache(['key' =&gt; 'value'], 300);\n\ncache(['key' =&gt; 'value'], now()-&gt;addSeconds(10));</code></pre>\n  <p></p>\n  <h4><code>class_uses_recursive()</code></h4>\n  <p>La <code>class_uses_recursive</code>función devuelve todos los rasgos usados \u200B\u200Bpor una clase, incluidos los rasgos usados \u200B\u200Bpor todas sus clases principales:</p>\n  <pre><code>$traits = class_uses_recursive(App\\Models\\User::class);</code></pre>\n  <p></p>\n  <h4><code>collect()</code></h4>\n  <p>La <code>collect</code>función crea una instancia de colección a partir del valor dado:</p>\n  <pre><code>$collection = collect(['taylor', 'abigail']);</code></pre>\n  <p></p>\n  <h4><code>config()</code></h4>\n  <p>La <code>config</code>función obtiene el valor de una variable de configuración . Se puede acceder a los valores de configuración usando la sintaxis de \"punto\", que incluye el nombre del archivo y la opción a la que desea acceder. Se puede especificar un valor predeterminado y se devuelve si la opción de configuración no existe:</p>\n  <pre><code>$value = config('app.timezone');\n\n$value = config('app.timezone', $default);</code></pre>\n  <p>Puede establecer variables de configuración en tiempo de ejecución pasando una matriz de pares clave / valor:</p>\n  <pre><code>config(['app.debug' =&gt; true]);</code></pre>\n  <p></p>\n  <h4><code>cookie()</code></h4>\n  <p>La <code>cookie</code>función crea una nueva instancia de cookie :</p>\n  <pre><code>$cookie = cookie('name', 'value', $minutes);</code></pre>\n  <p></p>\n  <h4><code>csrf_field()</code></h4>\n  <p>La <code>csrf_field</code>función genera un <code>hidden</code>campo de entrada HTML que contiene el valor del token CSRF. Por ejemplo, usando la sintaxis Blade :</p>\n  <pre><code>{{ csrf_field() }}</code></pre>\n  <p></p>\n  <h4><code>csrf_token()</code></h4>\n  <p>La <code>csrf_token</code>función recupera el valor del token CSRF actual:</p>\n  <pre><code>$token = csrf_token();</code></pre>\n  <p></p>\n  <h4><code>dd()</code></h4>\n  <p>La <code>dd</code>función vuelca las variables dadas y finaliza la ejecución del script:</p>\n  <pre><code>dd($value);\n\ndd($value1, $value2, $value3, ...);</code></pre>\n  <p>Si no desea detener la ejecución de su script, use la <code>dump</code>función en su lugar.</p>\n  <p></p>\n  <h4><code>dispatch()</code></h4>\n  <p>La <code>dispatch</code>función empuja el trabajo dado a la cola de trabajos de Laravel :</p>\n  <pre><code>dispatch(new App\\Jobs\\SendEmails);</code></pre>\n  <p></p>\n  <h4><code>dispatch_now()</code></h4>\n  <p>La <code>dispatch_now</code>función ejecuta el trabajo dado inmediatamente y devuelve el valor de su <code>handle</code>método:</p>\n  <pre><code>$result = dispatch_now(new App\\Jobs\\SendEmails);</code></pre>\n  <p></p>\n  <h4><code>dump()</code></h4>\n  <p>La <code>dump</code>función vuelca las variables dadas:</p>\n  <pre><code>dump($value);\n\ndump($value1, $value2, $value3, ...);</code></pre>\n  <p>Si desea dejar de ejecutar el script después de volcar las variables, use la <code>dd</code>función en su lugar.</p>\n  <p></p>\n  <h4><code>env()</code></h4>\n  <p>La <code>env</code>función recupera el valor de una variable de entorno o devuelve un valor predeterminado:</p>\n  <pre><code>$env = env('APP_ENV');\n\n// Returns 'production' if APP_ENV is not set...\n$env = env('APP_ENV', 'production');</code></pre>\n  <blockquote>\n    <div><div></div><p>Si ejecuta el comando durante su proceso de implementación, debe asegurarse de que solo está llamando a la función desde sus archivos de configuración. Una vez que la configuración se haya almacenado en caché, el archivo no se cargará y todas las llamadas a la función volverán .<code>config:cache</code><code>env</code><code>.env</code><code>env</code><code>null</code></p></div>\n  </blockquote>\n  <p></p>\n  <h4><code>event()</code></h4>\n  <p>La <code>event</code>función envía el evento dado a sus oyentes:</p>\n  <pre><code>event(new UserRegistered($user));</code></pre>\n  <p></p>\n  <h4><code>filled()</code></h4>\n  <p>La <code>filled</code>función devuelve si el valor dado no está \"en blanco\":</p>\n  <pre><code>filled(0);\nfilled(true);\nfilled(false);\n\n// true\n\nfilled('');\nfilled('   ');\nfilled(null);\nfilled(collect());\n\n// false</code></pre>\n  <p>Para el inverso de <code>filled</code>, vea el <code>blank</code>método.</p>\n  <p></p>\n  <h4><code>info()</code></h4>\n  <p>La <code>info</code>función escribirá información en el registro :</p>\n  <pre><code>info('Some helpful information!');</code></pre>\n  <p>También se puede pasar una matriz de datos contextuales a la función:</p>\n  <pre><code>info('User login attempt failed.', ['id' =&gt; $user-&gt;id]);</code></pre>\n  <p></p>\n  <h4><code>logger()</code></h4>\n  <p>La <code>logger</code>función se puede utilizar para escribir un <code>debug</code>mensaje de nivel en el registro :</p>\n  <pre><code>logger('Debug message');</code></pre>\n  <p>También se puede pasar una matriz de datos contextuales a la función:</p>\n  <pre><code>logger('User has logged in.', ['id' =&gt; $user-&gt;id]);</code></pre>\n  <p>Se devolverá una instancia de registrador si no se pasa ningún valor a la función:</p>\n  <pre><code>logger()-&gt;error('You are not allowed here.');</code></pre>\n  <p></p>\n  <h4><code>method_field()</code></h4>\n  <p>La <code>method_field</code>función genera un <code>hidden</code>campo de entrada HTML que contiene el valor falsificado del verbo HTTP del formulario. Por ejemplo, usando la sintaxis Blade :</p>\n  <pre><code>&lt;form method=\"POST\"&gt;\n    {{ method_field('DELETE') }}\n&lt;/form&gt;</code></pre>\n  <p></p>\n  <h4><code>now()</code></h4>\n  <p>La <code>now</code>función crea una nueva instancia para la hora actual:<code>Illuminate\\Support\\Carbon</code></p>\n  <pre><code>$now = now();</code></pre>\n  <p></p>\n  <h4><code>old()</code></h4>\n  <p>La <code>old</code>función recupera un valor de entrada antiguo que apareció en la sesión:</p>\n  <pre><code>$value = old('value');\n\n$value = old('value', 'default');</code></pre>\n  <p></p>\n  <h4><code>optional()</code></h4>\n  <p>La <code>optional</code>función acepta cualquier argumento y le permite acceder a propiedades o llamar a métodos en ese objeto. Si el objeto dado es <code>null</code>, las propiedades y los métodos regresarán en <code>null</code>lugar de causar un error:</p>\n  <pre><code>return optional($user-&gt;address)-&gt;street;\n\n{!! old('name', optional($user)-&gt;name) !!}</code></pre>\n  <p>La <code>optional</code>función también acepta un cierre como segundo argumento. El cierre se invocará si el valor proporcionado como primer argumento no es nulo:</p>\n  <pre><code>return optional(User::find($id), function ($user) {\n    return new DummyUser;\n});</code></pre>\n  <p></p>\n  <h4><code>policy()</code></h4>\n  <p>El <code>policy</code>método recupera una instancia de política para una clase determinada:</p>\n  <pre><code>$policy = policy(App\\Models\\User::class);</code></pre>\n  <p></p>\n  <h4><code>redirect()</code></h4>\n  <p>La <code>redirect</code>función devuelve una respuesta HTTP de redireccionamiento o devuelve la instancia del redirector si se llama sin argumentos:</p>\n  <pre><code>return redirect($to = null, $status = 302, $headers = [], $secure = null);\n\nreturn redirect('/home');\n\nreturn redirect()-&gt;route('route.name');</code></pre>\n  <p></p>\n  <h4><code>report()</code></h4>\n  <p>La <code>report</code>función informará una excepción utilizando su controlador de excepciones :</p>\n  <pre><code>report($e);</code></pre>\n  <p></p>\n  <h4><code>request()</code></h4>\n  <p>La <code>request</code>función devuelve la instancia de solicitud actual u obtiene un elemento de entrada:</p>\n  <pre><code>$request = request();\n\n$value = request('key', $default);</code></pre>\n  <p></p>\n  <h4><code>rescue()</code></h4>\n  <p>La <code>rescue</code>función ejecuta el Closure dado y detecta cualquier excepción que ocurra durante su ejecución. Todas las excepciones que se detectan se enviarán a su controlador de excepciones ; sin embargo, la solicitud continuará procesándose:</p>\n  <pre><code>return rescue(function () {\n    return $this-&gt;method();\n});</code></pre>\n  <p>También puede pasar un segundo argumento a la <code>rescue</code>función. Este argumento será el valor \"predeterminado\" que se debe devolver si ocurre una excepción al ejecutar el cierre:</p>\n  <pre><code>return rescue(function () {\n    return $this-&gt;method();\n}, false);\n\nreturn rescue(function () {\n    return $this-&gt;method();\n}, function () {\n    return $this-&gt;failure();\n});</code></pre>\n  <p></p>\n  <h4><code>resolve()</code></h4>\n  <p>La <code>resolve</code>función resuelve una clase determinada o un nombre de interfaz en su instancia mediante el contenedor de servicios :</p>\n  <pre><code>$api = resolve('HelpSpot\\API');</code></pre>\n  <p></p>\n  <h4><code>response()</code></h4>\n  <p>La <code>response</code>función crea una instancia de respuesta u obtiene una instancia de la fábrica de respuestas:</p>\n  <pre><code>return response('Hello World', 200, $headers);\n\nreturn response()-&gt;json(['foo' =&gt; 'bar'], 200, $headers);</code></pre>\n  <p></p>\n  <h4><code>retry()</code></h4>\n  <p>La <code>retry</code>función intenta ejecutar la devolución de llamada dada hasta que se alcanza el umbral de intento máximo dado. Si la devolución de llamada no arroja una excepción, se devolverá su valor de retorno. Si la devolución de llamada arroja una excepción, se reintentará automáticamente. Si se excede el recuento máximo de intentos, se lanzará la excepción:</p>\n  <pre><code>return retry(5, function () {\n    // Attempt 5 times while resting 100ms in between attempts...\n}, 100);</code></pre>\n  <p></p>\n  <h4><code>session()</code></h4>\n  <p>La <code>session</code>función puede usarse para obtener o establecer valores de sesión :</p>\n  <pre><code>$value = session('key');</code></pre>\n  <p>Puede establecer valores pasando una matriz de pares clave / valor a la función:</p>\n  <pre><code>session(['chairs' =&gt; 7, 'instruments' =&gt; 3]);</code></pre>\n  <p>El almacén de sesiones se devolverá si no se pasa ningún valor a la función:</p>\n  <pre><code>$value = session()-&gt;get('key');\n\nsession()-&gt;put('key', $value);</code></pre>\n  <p></p>\n  <h4><code>tap()</code></h4>\n  <p>La <code>tap</code>función acepta dos argumentos: un arbitrario <code>$value</code>y un cierre. Se <code>$value</code>pasará al cierre y luego la <code>tap</code>función lo devolverá . El valor de retorno del cierre es irrelevante:</p>\n  <pre><code>$user = tap(User::first(), function ($user) {\n    $user-&gt;name = 'taylor';\n\n    $user-&gt;save();\n});</code></pre>\n  <p>Si no se pasa ningún Closure a la <code>tap</code>función, puede llamar a cualquier método en el dado <code>$value</code>. El valor de retorno del método al que llama siempre será <code>$value</code>, independientemente de lo que el método realmente devuelva en su definición. Por ejemplo, el <code>update</code>método Eloquent generalmente devuelve un número entero. Sin embargo, podemos forzar al método a que devuelva el modelo en sí encadenando la <code>update</code>llamada al método a través de la <code>tap</code>función:</p>\n  <pre><code>$user = tap($user)-&gt;update([\n    'name' =&gt; $name,\n    'email' =&gt; $email,\n]);</code></pre>\n  <p>Para agregar un <code>tap</code>método a una clase, puede agregar el rasgo a la clase. El método de este rasgo acepta un cierre como su único argumento. La instancia del objeto en sí se pasará al cierre y luego será devuelta por el método:<code>Illuminate\\Support\\Traits\\Tappable</code><code>tap</code><code>tap</code></p>\n  <pre><code>return $user-&gt;tap(function ($user) {\n    //\n});</code></pre>\n  <p></p>\n  <h4><code>throw_if()</code></h4>\n  <p>La <code>throw_if</code>función lanza la excepción dada si una expresión booleana dada se evalúa como <code>true</code>:</p>\n  <pre><code>throw_if(! Auth::user()-&gt;isAdmin(), AuthorizationException::class);\n\nthrow_if(\n    ! Auth::user()-&gt;isAdmin(),\n    AuthorizationException::class,\n    'You are not allowed to access this page'\n);</code></pre>\n  <p></p>\n  <h4><code>throw_unless()</code></h4>\n  <p>La <code>throw_unless</code>función lanza la excepción dada si una expresión booleana dada se evalúa como <code>false</code>:</p>\n  <pre><code>throw_unless(Auth::user()-&gt;isAdmin(), AuthorizationException::class);\n\nthrow_unless(\n    Auth::user()-&gt;isAdmin(),\n    AuthorizationException::class,\n    'You are not allowed to access this page'\n);</code></pre>\n  <p></p>\n  <h4><code>today()</code></h4>\n  <p>La <code>today</code>función crea una nueva instancia para la fecha actual:<code>Illuminate\\Support\\Carbon</code></p>\n  <pre><code>$today = today();</code></pre>\n  <p></p>\n  <h4><code>trait_uses_recursive()</code></h4>\n  <p>La <code>trait_uses_recursive</code>función devuelve todos los rasgos utilizados por un rasgo:</p>\n  <pre><code>$traits = trait_uses_recursive(\\Illuminate\\Notifications\\Notifiable::class);</code></pre>\n  <p></p>\n  <h4><code>transform()</code></h4>\n  <p>La <code>transform</code>función ejecuta un <code>Closure</code>en un valor dado si el valor no está en blanco y devuelve el resultado de <code>Closure</code>:</p>\n  <pre><code>$callback = function ($value) {\n    return $value * 2;\n};\n\n$result = transform(5, $callback);\n\n// 10</code></pre>\n  <p>Un valor predeterminado o <code>Closure</code>también se puede pasar como tercer parámetro del método. Este valor se devolverá si el valor dado está en blanco:</p>\n  <pre><code>$result = transform(null, $callback, 'The value is blank');\n\n// The value is blank</code></pre>\n  <p></p>\n  <h4><code>validator()</code></h4>\n  <p>La <code>validator</code>función crea una nueva instancia de validador con los argumentos dados. Puede usarlo en lugar de la <code>Validator</code>fachada por conveniencia:</p>\n  <pre><code>$validator = validator($data, $rules, $messages);</code></pre>\n  <p></p>\n  <h4><code>value()</code></h4>\n  <p>La <code>value</code>función devuelve el valor que se le da. Sin embargo, si pasa un <code>Closure</code>a la función, <code>Closure</code>se ejecutará y se devolverá su resultado:</p>\n  <pre><code>$result = value(true);\n\n// true\n\n$result = value(function () {\n    return false;\n});\n\n// false</code></pre>\n  <p></p>\n  <h4><code>view()</code></h4>\n  <p>La <code>view</code>función recupera una instancia de vista :</p>\n  <pre><code>return view('auth.login');</code></pre>\n  <p></p>\n  <h4><code>with()</code></h4>\n  <p>La <code>with</code>función devuelve el valor que se le da. Si <code>Closure</code>se pasa a como segundo argumento de la función, <code>Closure</code>se ejecutará y se devolverá su resultado:</p>\n  <pre><code>$callback = function ($value) {\n    return (is_numeric($value)) ? $value * 2 : 0;\n};\n\n$result = with(5, $callback);\n\n// 10\n\n$result = with(null, $callback);\n\n// 0\n\n$result = with(5, null);\n\n// 5</code></pre>\n</section>"
      },
      {
        "titulo": "6.7 Cliente HTTP",
        "contenido": "<section>\n  <h1>Cliente HTTP</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Haciendo peticiones\n      <ul>\n        <li>Solicitar datos</li>\n        <li>Encabezados</li>\n        <li>Autenticación</li>\n        <li>Se acabó el tiempo</li>\n        <li>Reintentos</li>\n        <li>Manejo de errores</li>\n        <li>Opciones de Guzzle</li>\n      </ul></li>\n    <li>Pruebas\n      <ul>\n        <li>Respuestas falsas</li>\n        <li>Inspección de solicitudes</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel proporciona una API mínima y expresiva alrededor del cliente HTTP Guzzle , lo que le permite realizar rápidamente solicitudes HTTP salientes para comunicarse con otras aplicaciones web. El envoltorio de Laravel en torno a Guzzle se centra en sus casos de uso más comunes y en una maravillosa experiencia de desarrollador.</p>\n  <p>Antes de comenzar, debe asegurarse de haber instalado el paquete Guzzle como una dependencia de su aplicación. De forma predeterminada, Laravel incluye automáticamente esta dependencia:</p>\n  <pre><code>composer require guzzlehttp/guzzle</code></pre>\n  <p></p>\n  <h2>Haciendo peticiones</h2>\n  <p>Para realizar solicitudes, es posible utilizar los <code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>, y <code>delete</code>métodos. Primero, examinemos cómo hacer una <code>GET</code>solicitud básica :</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Http;\n\n$response = Http::get('http://test.com');</code></pre>\n  <p>El <code>get</code>método devuelve una instancia de , que proporciona una variedad de métodos que pueden usarse para inspeccionar la respuesta:<code>Illuminate\\Http\\Client\\Response</code></p>\n  <pre><code>$response-&gt;body() : string;\n$response-&gt;json() : array|mixed;\n$response-&gt;status() : int;\n$response-&gt;ok() : bool;\n$response-&gt;successful() : bool;\n$response-&gt;failed() : bool;\n$response-&gt;serverError() : bool;\n$response-&gt;clientError() : bool;\n$response-&gt;header($header) : string;\n$response-&gt;headers() : array;</code></pre>\n  <p>El objeto también implementa la interfaz PHP , lo que le permite acceder a los datos de respuesta JSON directamente en la respuesta:<code>Illuminate\\Http\\Client\\Response</code><code>ArrayAccess</code></p>\n  <pre><code>return Http::get('http://test.com/users/1')['name'];</code></pre>\n  <p></p>\n  <h3>Solicitar datos</h3>\n  <p>Por supuesto, es común cuando se utiliza <code>POST</code>, <code>PUT</code>y <code>PATCH</code>para enviar datos adicionales con su solicitud. Entonces, estos métodos aceptan una matriz de datos como segundo argumento. De forma predeterminada, los datos se enviarán utilizando el tipo de contenido:<code>application/json</code></p>\n  <pre><code>$response = Http::post('http://test.com/users', [\n    'name' =&gt; 'Steve',\n    'role' =&gt; 'Network Administrator',\n]);</code></pre>\n  <h4>Parámetros de consulta de solicitud GET</h4>\n  <p>Al realizar <code>GET</code>solicitudes, puede agregar una cadena de consulta a la URL directamente o pasar una matriz de pares clave / valor como segundo argumento del <code>get</code>método:</p>\n  <pre><code>$response = Http::get('http://test.com/users', [\n    'name' =&gt; 'Taylor',\n    'page' =&gt; 1,\n]);</code></pre>\n  <h4>Envío de solicitudes codificadas con URL de formulario</h4>\n  <p>Si desea enviar datos utilizando el tipo de contenido, debe llamar al método antes de realizar su solicitud:<code>application/x-www-form-urlencoded</code><code>asForm</code></p>\n  <pre><code>$response = Http::asForm()-&gt;post('http://test.com/users', [\n    'name' =&gt; 'Sara',\n    'role' =&gt; 'Privacy Consultant',\n]);</code></pre>\n  <h4>Envío de un cuerpo de solicitud sin procesar</h4>\n  <p>Puede usar el <code>withBody</code>método si desea proporcionar un cuerpo de solicitud sin procesar al realizar una solicitud:</p>\n  <pre><code>$response = Http::withBody(\n    base64_encode($photo), 'image/jpeg'\n)-&gt;post('http://test.com/photo');</code></pre>\n  <h4>Solicitudes de varias partes</h4>\n  <p>Si desea enviar archivos como solicitudes de varias partes, debe llamar al <code>attach</code>método antes de realizar su solicitud. Este método acepta el nombre del archivo y su contenido. Opcionalmente, puede proporcionar un tercer argumento que se considerará el nombre de archivo del archivo:</p>\n  <pre><code>$response = Http::attach(\n    'attachment', file_get_contents('photo.jpg'), 'photo.jpg'\n)-&gt;post('http://test.com/attachments');</code></pre>\n  <p>En lugar de pasar el contenido sin procesar de un archivo, también puede pasar un recurso de transmisión:</p>\n  <pre><code>$photo = fopen('photo.jpg', 'r');\n\n$response = Http::attach(\n    'attachment', $photo, 'photo.jpg'\n)-&gt;post('http://test.com/attachments');</code></pre>\n  <p></p>\n  <h3>Encabezados</h3>\n  <p>Se pueden agregar encabezados a las solicitudes usando el <code>withHeaders</code>método. Este <code>withHeaders</code>método acepta una matriz de pares clave / valor:</p>\n  <pre><code>$response = Http::withHeaders([\n    'X-First' =&gt; 'foo',\n    'X-Second' =&gt; 'bar'\n])-&gt;post('http://test.com/users', [\n    'name' =&gt; 'Taylor',\n]);</code></pre>\n  <p></p>\n  <h3>Autenticación</h3>\n  <p>Puede especificar las credenciales de autenticación básicas y resumidas utilizando los métodos <code>withBasicAuth</code>y <code>withDigestAuth</code>, respectivamente:</p>\n  <pre><code>// Basic authentication...\n$response = Http::withBasicAuth('taylor@laravel.com', 'secret')-&gt;post(...);\n\n// Digest authentication...\n$response = Http::withDigestAuth('taylor@laravel.com', 'secret')-&gt;post(...);</code></pre>\n  <h4>Fichas de portador</h4>\n  <p>Si desea agregar rápidamente un <code>Authorization</code>encabezado de token de portador a la solicitud, puede usar el <code>withToken</code>método:</p>\n  <pre><code>$response = Http::withToken('token')-&gt;post(...);</code></pre>\n  <p></p>\n  <h3>Se acabó el tiempo</h3>\n  <p>El <code>timeout</code>método se puede utilizar para especificar el número máximo de segundos para esperar una respuesta:</p>\n  <pre><code>$response = Http::timeout(3)-&gt;get(...);</code></pre>\n  <p>Si se excede el tiempo de espera dado, se lanzará una instancia de .<code>Illuminate\\Http\\Client\\ConnectionException</code></p>\n  <p></p>\n  <h3>Reintentos</h3>\n  <p>Si desea que el cliente HTTP vuelva a intentar automáticamente la solicitud si se produce un error de cliente o servidor, puede utilizar el <code>retry</code>método. El <code>retry</code>método acepta dos argumentos: la cantidad de veces que se debe intentar la solicitud y la cantidad de milisegundos que Laravel debe esperar entre intentos:</p>\n  <pre><code>$response = Http::retry(3, 100)-&gt;post(...);</code></pre>\n  <p>Si todas las solicitudes fallan, se lanzará una instancia de .<code>Illuminate\\Http\\Client\\RequestException</code></p>\n  <p></p>\n  <h3>Manejo de errores</h3>\n  <p>A diferencia del comportamiento predeterminado de Guzzle, el contenedor del cliente HTTP de Laravel no arroja excepciones en los errores del cliente o del servidor ( <code>400</code>y <code>500</code>respuestas de nivel de los servidores). Es posible determinar si uno de estos errores fue devuelto con el <code>successful</code>, <code>clientError</code>, o <code>serverError</code>métodos:</p>\n  <pre><code>// Determine if the status code was &gt;= 200 and &lt; 300...\n$response-&gt;successful();\n\n// Determine if the status code was &gt;= 400...\n$response-&gt;failed();\n\n// Determine if the response has a 400 level status code...\n$response-&gt;clientError();\n\n// Determine if the response has a 500 level status code...\n$response-&gt;serverError();</code></pre>\n  <h4>Lanzar excepciones</h4>\n  <p>Si tiene una instancia de respuesta y le gustaría lanzar una instancia de si la respuesta es un error del cliente o del servidor, puede usar el método:<code>Illuminate\\Http\\Client\\RequestException</code><code>throw</code></p>\n  <pre><code>$response = Http::post(...);\n\n// Throw an exception if a client or server error occurred...\n$response-&gt;throw();\n\nreturn $response['user']['id'];</code></pre>\n  <p>La instancia tiene una propiedad pública que le permitirá inspeccionar la respuesta devuelta.<code>Illuminate\\Http\\Client\\RequestException</code><code>$response</code></p>\n  <p>El <code>throw</code>método devuelve la instancia de respuesta si no se produjo ningún error, lo que le permite encadenar otras operaciones en el <code>throw</code>método:</p>\n  <pre><code>return Http::post(...)-&gt;throw()-&gt;json();</code></pre>\n  <p></p>\n  <h3>Opciones de Guzzle</h3>\n  <p>Puede especificar opciones adicionales de solicitud de Guzzle utilizando el <code>withOptions</code>método. El <code>withOptions</code>método acepta una matriz de pares clave / valor:</p>\n  <pre><code>$response = Http::withOptions([\n    'debug' =&gt; true,\n])-&gt;get('http://test.com/users');</code></pre>\n  <p></p>\n  <h2>Pruebas</h2>\n  <p>Muchos servicios de Laravel brindan funcionalidad para ayudarlo a escribir pruebas de manera fácil y expresiva, y el contenedor HTTP de Laravel no es una excepción. El método de <code>Http</code>la fachada le <code>fake</code>permite instruir al cliente HTTP para que devuelva respuestas falsas / ficticias cuando se realizan solicitudes.</p>\n  <p></p>\n  <h3>Respuestas falsas</h3>\n  <p>Por ejemplo, para indicarle al cliente HTTP que devuelva <code>200</code>respuestas de código de estado vacías para cada solicitud, puede llamar al <code>fake</code>método sin argumentos:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Http;\n\nHttp::fake();\n\n$response = Http::post(...);</code></pre>\n  <h4>Falsificación de URL específicas</h4>\n  <p>Alternativamente, puede pasar una matriz al <code>fake</code>método. Las claves de la matriz deben representar patrones de URL que desea falsificar y sus respuestas asociadas. El <code>*</code>carácter se puede utilizar como carácter comodín. Todas las solicitudes realizadas a URL que no hayan sido falsificadas se ejecutarán. Puede utilizar el <code>response</code>método para construir respuestas stub / fake para estos puntos finales:</p>\n  <pre><code>Http::fake([\n    // Stub a JSON response for GitHub endpoints...\n    'github.com/*' =&gt; Http::response(['foo' =&gt; 'bar'], 200, ['Headers']),\n\n    // Stub a string response for Google endpoints...\n    'google.com/*' =&gt; Http::response('Hello World', 200, ['Headers']),\n]);</code></pre>\n  <p>Si desea especificar un patrón de URL de respaldo que eliminará todas las URL no coincidentes, puede usar un solo <code>*</code>carácter:</p>\n  <pre><code>Http::fake([\n    // Stub a JSON response for GitHub endpoints...\n    'github.com/*' =&gt; Http::response(['foo' =&gt; 'bar'], 200, ['Headers']),\n\n    // Stub a string response for all other endpoints...\n    '*' =&gt; Http::response('Hello World', 200, ['Headers']),\n]);</code></pre>\n  <h4>Secuencias de respuesta falsas</h4>\n  <p>A veces, es posible que deba especificar que una única URL debe devolver una serie de respuestas falsas en un orden específico. Puede lograr esto usando el método para construir las respuestas:<code>Http::sequence</code></p>\n  <pre><code>Http::fake([\n    // Stub a series of responses for GitHub endpoints...\n    'github.com/*' =&gt; Http::sequence()\n                            -&gt;push('Hello World', 200)\n                            -&gt;push(['foo' =&gt; 'bar'], 200)\n                            -&gt;pushStatus(404),\n]);</code></pre>\n  <p>Cuando se hayan consumido todas las respuestas en una secuencia de respuesta, cualquier solicitud adicional hará que la secuencia de respuesta arroje una excepción. Si desea especificar una respuesta predeterminada que debe devolverse cuando una secuencia está vacía, puede usar el <code>whenEmpty</code>método:</p>\n  <pre><code>Http::fake([\n    // Stub a series of responses for GitHub endpoints...\n    'github.com/*' =&gt; Http::sequence()\n                            -&gt;push('Hello World', 200)\n                            -&gt;push(['foo' =&gt; 'bar'], 200)\n                            -&gt;whenEmpty(Http::response()),\n]);</code></pre>\n  <p>Si desea falsificar una secuencia de respuestas pero no necesita especificar un patrón de URL específico que deba falsificarse, puede usar el método:<code>Http::fakeSequence</code></p>\n  <pre><code>Http::fakeSequence()\n        -&gt;push('Hello World', 200)\n        -&gt;whenEmpty(Http::response());</code></pre>\n  <h4>Devolución de llamada falsa</h4>\n  <p>Si necesita una lógica más complicada para determinar qué respuestas devolver para ciertos puntos finales, puede pasar una devolución de llamada al <code>fake</code>método. Esta devolución de llamada recibirá una instancia de y debería devolver una instancia de respuesta:<code>Illuminate\\Http\\Client\\Request</code></p>\n  <pre><code>Http::fake(function ($request) {\n    return Http::response('Hello World', 200);\n});</code></pre>\n  <p></p>\n  <h3>Inspección de solicitudes</h3>\n  <p>Al falsificar respuestas, es posible que ocasionalmente desee inspeccionar las solicitudes que recibe el cliente para asegurarse de que su aplicación envíe los datos o encabezados correctos. Puede lograr esto llamando al método después de llamar .<code>Http::assertSent</code><code>Http::fake</code></p>\n  <p>El <code>assertSent</code>método acepta una devolución de llamada a la que se le dará una instancia y debería devolver un valor booleano que indique si la solicitud coincide con sus expectativas. Para que la prueba pase, se debe haber emitido al menos una solicitud que coincida con las expectativas dadas:<code>Illuminate\\Http\\Client\\Request</code></p>\n  <pre><code>Http::fake();\n\nHttp::withHeaders([\n    'X-First' =&gt; 'foo',\n])-&gt;post('http://test.com/users', [\n    'name' =&gt; 'Taylor',\n    'role' =&gt; 'Developer',\n]);\n\nHttp::assertSent(function ($request) {\n    return $request-&gt;hasHeader('X-First', 'foo') &amp;&amp;\n           $request-&gt;url() == 'http://test.com/users' &amp;&amp;\n           $request['name'] == 'Taylor' &amp;&amp;\n           $request['role'] == 'Developer';\n});</code></pre>\n  <p>Si es necesario, puede afirmar que no se envió una solicitud específica utilizando el <code>assertNotSent</code>método:</p>\n  <pre><code>Http::fake();\n\nHttp::post('http://test.com/users', [\n    'name' =&gt; 'Taylor',\n    'role' =&gt; 'Developer',\n]);\n\nHttp::assertNotSent(function (Request $request) {\n    return $request-&gt;url() === 'http://test.com/posts';\n});</code></pre>\n  <p>O, si desea afirmar que no se enviaron solicitudes, puede usar el <code>assertNothingSent</code>método:</p>\n  <pre><code>Http::fake();\n\nHttp::assertNothingSent();</code></pre>\n</section>"
      },
      {
        "titulo": "6.8 Correo",
        "contenido": "<section>\n  <h1>Correo</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Configuración</li>\n        <li>Requisitos previos del controlador</li>\n      </ul></li>\n    <li>Generación de mailables</li>\n    <li>Escribir por correo\n      <ul>\n        <li>Configurar el remitente</li>\n        <li>Configurar la vista</li>\n        <li>Ver datos</li>\n        <li>Archivos adjuntos</li>\n        <li>Adjuntos en línea</li>\n        <li>Personalización del mensaje de SwiftMailer</li>\n      </ul></li>\n    <li>Mailables con descuento\n      <ul>\n        <li>Generación de envíos con descuento</li>\n        <li>Escribir mensajes de Markdown</li>\n        <li>Personalización de los componentes</li>\n      </ul></li>\n    <li>Enviando correo\n      <ul>\n        <li>Cola de correo</li>\n      </ul></li>\n    <li>Renderizado de mailables\n      <ul>\n        <li>Vista previa de envíos postales en el navegador</li>\n      </ul></li>\n    <li>Localización de envíos por correo</li>\n    <li>Correo y desarrollo local</li>\n    <li>Eventos</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel proporciona una API limpia y simple sobre la popular biblioteca SwiftMailer con controladores para SMTP, Mailgun, Postmark, Amazon SES y <code>sendmail</code>, lo que le permite comenzar rápidamente a enviar correo a través de un servicio local o basado en la nube de su elección.</p>\n  <p></p>\n  <h3>Configuración</h3>\n  <p>Los servicios de correo electrónico de Laravel se pueden configurar a través del <code>mail</code>archivo de configuración. Cada correo configurado dentro de este archivo puede tener sus propias opciones e incluso su propio \"transporte\" único, lo que permite que su aplicación utilice diferentes servicios de correo electrónico para enviar ciertos mensajes de correo electrónico. Por ejemplo, su aplicación puede usar Postmark para enviar correo transaccional mientras usa Amazon SES para enviar correo masivo.</p>\n  <p></p>\n  <h3>Requisitos previos del controlador</h3>\n  <p>Los controladores basados \u200B\u200Ben API, como Mailgun y Postmark, suelen ser más sencillos y rápidos que los servidores SMTP. Si es posible, debe utilizar uno de estos controladores. Todos los controladores de API requieren la biblioteca HTTP Guzzle, que se puede instalar a través del administrador de paquetes Composer:</p>\n  <pre><code>composer require guzzlehttp/guzzle</code></pre>\n  <h4>Conductor de Mailgun</h4>\n  <p>Para usar el controlador Mailgun, primero instale Guzzle, luego configure la <code>default</code>opción en su archivo de configuración en . A continuación, verifique que su archivo de configuración contenga las siguientes opciones:<code>config/mail.php</code><code>mailgun</code><code>config/services.php</code></p>\n  <pre><code>'mailgun' =&gt; [\n    'domain' =&gt; 'your-mailgun-domain',\n    'secret' =&gt; 'your-mailgun-key',\n],</code></pre>\n  <p>Si no está utilizando la región Mailgun \"EE. UU.\" , Puede definir el punto final de su región en el <code>services</code>archivo de configuración:</p>\n  <pre><code>'mailgun' =&gt; [\n    'domain' =&gt; 'your-mailgun-domain',\n    'secret' =&gt; 'your-mailgun-key',\n    'endpoint' =&gt; 'api.eu.mailgun.net',\n],</code></pre>\n  <h4>Controlador de matasellos</h4>\n  <p>Para utilizar el controlador Postmark, instale el transporte SwiftMailer de Postmark a través de Composer:</p>\n  <pre><code>composer require wildbit/swiftmailer-postmark</code></pre>\n  <p>A continuación, instale Guzzle y establezca la <code>default</code>opción en su archivo de configuración en . Finalmente, verifique que su archivo de configuración contenga las siguientes opciones:<code>config/mail.php</code><code>postmark</code><code>config/services.php</code></p>\n  <pre><code>'postmark' =&gt; [\n    'token' =&gt; 'your-postmark-token',\n],</code></pre>\n  <h4>Conductor SES</h4>\n  <p>Para utilizar el controlador de Amazon SES, primero debe instalar el SDK de Amazon AWS para PHP. Puede instalar esta biblioteca agregando la siguiente línea a la sección de su archivo y ejecutando el comando:<code>composer.json</code><code>require</code><code>composer update</code></p>\n  <pre><code>\"aws/aws-sdk-php\": \"~3.0\"</code></pre>\n  <p>A continuación, establezca la <code>default</code>opción en su archivo de configuración y verifique que su archivo de configuración contenga las siguientes opciones:<code>config/mail.php</code><code>ses</code><code>config/services.php</code></p>\n  <pre><code>'ses' =&gt; [\n    'key' =&gt; 'your-ses-key',\n    'secret' =&gt; 'your-ses-secret',\n    'region' =&gt; 'ses-region',  // e.g. us-east-1\n],</code></pre>\n  <p>Si necesita incluir opciones adicionales al ejecutar la <code>SendRawEmail</code>solicitud SES , puede definir una <code>options</code>matriz dentro de su <code>ses</code>configuración:</p>\n  <pre><code>'ses' =&gt; [\n    'key' =&gt; 'your-ses-key',\n    'secret' =&gt; 'your-ses-secret',\n    'region' =&gt; 'ses-region',  // e.g. us-east-1\n    'options' =&gt; [\n        'ConfigurationSetName' =&gt; 'MyConfigurationSet',\n        'Tags' =&gt; [\n            [\n                'Name' =&gt; 'foo',\n                'Value' =&gt; 'bar',\n            ],\n        ],\n    ],\n],</code></pre>\n  <p></p>\n  <h2>Generación de mailables</h2>\n  <p>En Laravel, cada tipo de correo electrónico enviado por su aplicación se representa como una clase \"mailable\". Estas clases se almacenan en el directorio. No se preocupe si no ve este directorio en su aplicación, ya que se generará cuando cree su primera clase mailable usando el comando:<code>app/Mail</code><code>make:mail</code></p>\n  <pre><code>php artisan make:mail OrderShipped</code></pre>\n  <p></p>\n  <h2>Escribir por correo</h2>\n  <p>Toda la configuración de una clase mailable se realiza en el <code>build</code>método. Dentro de este método, puede llamar a varios métodos tales como <code>from</code>, <code>subject</code>, <code>view</code>, y <code>attach</code>para configurar la presentación y entrega del correo electrónico.</p>\n  <p></p>\n  <h3>Configurar el remitente</h3>\n  <h4>Usando el <code>from</code>método</h4>\n  <p>Primero, exploremos la configuración del remitente del correo electrónico. O, en otras palabras, de quién \"será\" el correo electrónico. Hay dos formas de configurar el remitente. Primero, puede usar el <code>from</code>método dentro del método de su clase mailable <code>build</code>:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n    return $this-&gt;from('example@example.com')\n                -&gt;view('emails.orders.shipped');\n}</code></pre>\n  <h4>Usar una <code>from</code>dirección global</h4>\n  <p>Sin embargo, si su aplicación usa la misma dirección \"de\" para todos sus correos electrónicos, puede resultar engorroso llamar al <code>from</code>método en cada clase de correo que genere. En su lugar, puede especificar una dirección global \"de\" en su archivo de configuración. Esta dirección se utilizará si no se especifica ninguna otra dirección \"de\" dentro de la clase que se puede enviar por correo:<code>config/mail.php</code></p>\n  <pre><code>'from' =&gt; ['address' =&gt; 'example@example.com', 'name' =&gt; 'App Name'],</code></pre>\n  <p>Además, puede definir una dirección global \"reply_to\" dentro de su archivo de configuración:<code>config/mail.php</code></p>\n  <pre><code>'reply_to' =&gt; ['address' =&gt; 'example@example.com', 'name' =&gt; 'App Name'],</code></pre>\n  <p></p>\n  <h3>Configurar la vista</h3>\n  <p>Dentro del <code>build</code>método de una clase que se puede enviar por correo , puede usar el <code>view</code>método para especificar qué plantilla debe usarse al representar el contenido del correo electrónico. Dado que cada correo electrónico generalmente usa una plantilla Blade para representar su contenido, tiene todo el poder y la conveniencia del motor de plantillas Blade al crear el HTML de su correo electrónico:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n    return $this-&gt;view('emails.orders.shipped');\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Es posible que desee crear un directorio para albergar todas sus plantillas de correo electrónico; sin embargo, puede colocarlos donde desee dentro de su directorio.<code>resources/views/emails</code><code>resources/views</code></p></div>\n  </blockquote>\n  <h4>Correos electrónicos de texto sin formato</h4>\n  <p>Si desea definir una versión de texto sin formato de su correo electrónico, puede utilizar el <code>text</code>método. Al igual que el <code>view</code>método, el <code>text</code>método acepta un nombre de plantilla que se utilizará para representar el contenido del correo electrónico. Eres libre de definir tanto una versión HTML como una versión de texto plano de tu mensaje:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n    return $this-&gt;view('emails.orders.shipped')\n                -&gt;text('emails.orders.shipped_plain');\n}</code></pre>\n  <p></p>\n  <h3>Ver datos</h3>\n  <h4>A través de propiedades públicas</h4>\n  <p>Por lo general, querrá pasar algunos datos a su vista que puede utilizar al procesar el HTML del correo electrónico. Hay dos formas de hacer que los datos estén disponibles para su vista. Primero, cualquier propiedad pública definida en su clase mailable automáticamente estará disponible para la vista. Entonces, por ejemplo, puede pasar datos al constructor de su clase mailable y establecer esos datos en propiedades públicas definidas en la clase:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Mail;\n\nuse App\\Models\\Order;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Mail\\Mailable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass OrderShipped extends Mailable\n{\n    use Queueable, SerializesModels;\n\n    /**\n     * The order instance.\n     *\n     * @var Order\n     */\n    public $order;\n\n    /**\n     * Create a new message instance.\n     *\n     * @param  \\App\\Models\\Order  $order\n     * @return void\n     */\n    public function __construct(Order $order)\n    {\n        $this-&gt;order = $order;\n    }\n\n    /**\n     * Build the message.\n     *\n     * @return $this\n     */\n    public function build()\n    {\n        return $this-&gt;view('emails.orders.shipped');\n    }\n}</code></pre>\n  <p>Una vez que los datos se hayan configurado en una propiedad pública, estarán disponibles automáticamente en su vista, por lo que puede acceder a ellos como lo haría con cualquier otro dato en sus plantillas Blade:</p>\n  <pre><code>&lt;div&gt;\n    Price: {{ $order-&gt;price }}\n&lt;/div&gt;</code></pre>\n  <h4>A través del <code>with</code>método:</h4>\n  <p>Si desea personalizar el formato de los datos de su correo electrónico antes de que se envíen a la plantilla, puede pasar manualmente sus datos a la vista a través del <code>with</code>método. Normalmente, todavía pasará datos a través del constructor de la clase mailable; sin embargo, debe establecer estos datos en <code>protected</code>o <code>private</code>propiedades para que los datos no estén disponibles automáticamente en la plantilla. Luego, al llamar al <code>with</code>método, pase una matriz de datos que desee poner a disposición de la plantilla:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Mail;\n\nuse App\\Models\\Order;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Mail\\Mailable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass OrderShipped extends Mailable\n{\n    use Queueable, SerializesModels;\n\n    /**\n     * The order instance.\n     *\n     * @var \\App\\Models\\Order\n     */\n    protected $order;\n\n    /**\n     * Create a new message instance.\n     *\n     * @param  \\App\\Models\\Order $order\n     * @return void\n     */\n    public function __construct(Order $order)\n    {\n        $this-&gt;order = $order;\n    }\n\n    /**\n     * Build the message.\n     *\n     * @return $this\n     */\n    public function build()\n    {\n        return $this-&gt;view('emails.orders.shipped')\n                    -&gt;with([\n                        'orderName' =&gt; $this-&gt;order-&gt;name,\n                        'orderPrice' =&gt; $this-&gt;order-&gt;price,\n                    ]);\n    }\n}</code></pre>\n  <p>Una vez que los datos se hayan pasado al <code>with</code>método, estarán disponibles automáticamente en su vista, por lo que puede acceder a ellos como lo haría con cualquier otro dato en sus plantillas Blade:</p>\n  <pre><code>&lt;div&gt;\n    Price: {{ $orderPrice }}\n&lt;/div&gt;</code></pre>\n  <p></p>\n  <h3>Archivos adjuntos</h3>\n  <p>Para agregar archivos adjuntos a un correo electrónico, use el <code>attach</code>método dentro del método de la clase que se puede enviar por correo <code>build</code>. El <code>attach</code>método acepta la ruta completa al archivo como primer argumento:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n    return $this-&gt;view('emails.orders.shipped')\n                -&gt;attach('/path/to/file');\n}</code></pre>\n  <p>Al adjuntar archivos a un mensaje, también puede especificar el nombre para mostrar y / o el tipo MIME pasando un <code>array</code>como segundo argumento al <code>attach</code>método:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n    return $this-&gt;view('emails.orders.shipped')\n                -&gt;attach('/path/to/file', [\n                    'as' =&gt; 'name.pdf',\n                    'mime' =&gt; 'application/pdf',\n                ]);\n}</code></pre>\n  <h4>Adjuntar archivos desde el disco</h4>\n  <p>Si ha almacenado un archivo en uno de los discos de su sistema de archivos , puede adjuntarlo al correo electrónico usando el <code>attachFromStorage</code>método:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n   return $this-&gt;view('emails.orders.shipped')\n               -&gt;attachFromStorage('/path/to/file');\n}</code></pre>\n  <p>Si es necesario, puede especificar el nombre del archivo adjunto y las opciones adicionales utilizando el segundo y tercer argumento del <code>attachFromStorage</code>método:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n   return $this-&gt;view('emails.orders.shipped')\n               -&gt;attachFromStorage('/path/to/file', 'name.pdf', [\n                   'mime' =&gt; 'application/pdf'\n               ]);\n}</code></pre>\n  <p>El <code>attachFromStorageDisk</code>método se puede utilizar si necesita especificar un disco de almacenamiento que no sea el predeterminado:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n   return $this-&gt;view('emails.orders.shipped')\n               -&gt;attachFromStorageDisk('s3', '/path/to/file');\n}</code></pre>\n  <h4>Adjuntos de datos brutos</h4>\n  <p>El <code>attachData</code>método se puede utilizar para adjuntar una cadena de bytes sin procesar como adjunto. Por ejemplo, puede utilizar este método si ha generado un PDF en la memoria y desea adjuntarlo al correo electrónico sin escribirlo en el disco. El <code>attachData</code>método acepta los bytes de datos sin procesar como primer argumento, el nombre del archivo como segundo argumento y una matriz de opciones como tercer argumento:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n    return $this-&gt;view('emails.orders.shipped')\n                -&gt;attachData($this-&gt;pdf, 'name.pdf', [\n                    'mime' =&gt; 'application/pdf',\n                ]);\n}</code></pre>\n  <p></p>\n  <h3>Adjuntos en línea</h3>\n  <p>Incrustar imágenes en línea en sus correos electrónicos suele ser engorroso; sin embargo, Laravel proporciona una forma conveniente de adjuntar imágenes a sus correos electrónicos y recuperar el CID apropiado. Para incrustar una imagen en línea, use el <code>embed</code>método en la <code>$message</code>variable dentro de su plantilla de correo electrónico. Laravel automáticamente hace que la <code>$message</code>variable esté disponible para todas sus plantillas de correo electrónico, por lo que no necesita preocuparse por pasarla manualmente:</p>\n  <pre><code>&lt;body&gt;\n    Here is an image:\n\n    &lt;img src=\"{{ $message-&gt;embed($pathToImage) }}\"&gt;\n&lt;/body&gt;</code></pre>\n  <blockquote>\n    <div><div></div><p> <code>$message</code> La variable no está disponible en mensajes de texto sin formato, ya que los mensajes de texto sin formato no utilizan archivos adjuntos en línea.</p></div>\n  </blockquote>\n  <h4>Incorporación de adjuntos de datos sin procesar</h4>\n  <p>Si ya tiene una cadena de datos sin procesar que desea incrustar en una plantilla de correo electrónico, puede usar el <code>embedData</code>método en la <code>$message</code>variable:</p>\n  <pre><code>&lt;body&gt;\n    Here is an image from raw data:\n\n    &lt;img src=\"{{ $message-&gt;embedData($data, $name) }}\"&gt;\n&lt;/body&gt;</code></pre>\n  <p></p>\n  <h3>Personalización del mensaje de SwiftMailer</h3>\n  <p>El <code>withSwiftMessage</code>método de la <code>Mailable</code>clase base le permite registrar una devolución de llamada que se invocará con la instancia del mensaje SwiftMailer sin procesar antes de enviar el mensaje. Esto le brinda la oportunidad de personalizar el mensaje antes de que se entregue:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n    $this-&gt;view('emails.orders.shipped');\n\n    $this-&gt;withSwiftMessage(function ($message) {\n        $message-&gt;getHeaders()\n                -&gt;addTextHeader('Custom-Header', 'HeaderValue');\n    });\n}</code></pre>\n  <p></p>\n  <h2>Mailables con descuento</h2>\n  <p>Los mensajes de Markdown que se pueden enviar por correo le permiten aprovechar las plantillas y los componentes prediseñados de las notificaciones por correo en sus correos. Dado que los mensajes están escritos en Markdown, Laravel puede representar hermosas plantillas HTML receptivas para los mensajes y, al mismo tiempo, generar automáticamente una contraparte de texto sin formato.</p>\n  <p></p>\n  <h3>Generación de envíos con descuento</h3>\n  <p>Para generar un correo con una plantilla de Markdown correspondiente, puede usar la <code>--markdown</code>opción del comando Artisan:<code>make:mail</code></p>\n  <pre><code>php artisan make:mail OrderShipped --markdown=emails.orders.shipped</code></pre>\n  <p>Luego, al configurar el mailable dentro de su <code>build</code>método, llame al <code>markdown</code>método en lugar del <code>view</code>método. El <code>markdown</code>método acepta el nombre de la plantilla de Markdown y una matriz opcional de datos para poner a disposición de la plantilla:</p>\n  <pre><code>/**\n * Build the message.\n *\n * @return $this\n */\npublic function build()\n{\n    return $this-&gt;from('example@example.com')\n                -&gt;markdown('emails.orders.shipped');\n}</code></pre>\n  <p></p>\n  <h3>Escribir mensajes de Markdown</h3>\n  <p>Los mailables Markdown utilizan una combinación de componentes Blade y sintaxis Markdown que le permiten construir fácilmente mensajes de correo mientras aprovecha los componentes prediseñados de Laravel:</p>\n  <pre><code>@component('mail::message')\n# Order Shipped\n\nYour order has been shipped!\n\n@component('mail::button', ['url' =&gt; $url])\nView Order\n@endcomponent\n\nThanks,&lt;br&gt;\n{{ config('app.name') }}\n@endcomponent</code></pre>\n  <blockquote>\n    <div><div></div><p>No use sangría excesiva al escribir correos electrónicos de Markdown. Los analizadores de Markdown mostrarán el contenido con sangría como bloques de código.</p></div>\n  </blockquote>\n  <h4>Componente de botón</h4>\n  <p>El componente de botón representa un vínculo de botón centrado. El componente acepta dos argumentos, uno <code>url</code>y un opcional <code>color</code>. Los colores son soportados <code>primary</code>, <code>success</code>y <code>error</code>. Puede agregar tantos componentes de botones a un mensaje como desee:</p>\n  <pre><code>@component('mail::button', ['url' =&gt; $url, 'color' =&gt; 'success'])\nView Order\n@endcomponent</code></pre>\n  <h4>Componente del panel</h4>\n  <p>El componente de panel representa el bloque de texto dado en un panel que tiene un color de fondo ligeramente diferente al del resto del mensaje. Esto le permite llamar la atención sobre un bloque de texto determinado:</p>\n  <pre><code>@component('mail::panel')\nThis is the panel content.\n@endcomponent</code></pre>\n  <h4>Componente de tabla</h4>\n  <p>El componente de tabla le permite transformar una tabla de Markdown en una tabla HTML. El componente acepta la tabla de Markdown como contenido. La alineación de la columna de la tabla es compatible con la sintaxis de alineación de la tabla de Markdown predeterminada:</p>\n  <pre><code>@component('mail::table')\n| Laravel       | Table         | Example  |\n| ------------- |:-------------:| --------:|\n| Col 2 is      | Centered      | $10      |\n| Col 3 is      | Right-Aligned | $20      |\n@endcomponent</code></pre>\n  <p></p>\n  <h3>Personalización de los componentes</h3>\n  <p>Puede exportar todos los componentes de correo de Markdown a su propia aplicación para personalizarlos. Para exportar los componentes, use el comando Artisan para publicar la etiqueta de activo:<code>vendor:publish</code><code>laravel-mail</code></p>\n  <pre><code>php artisan vendor:publish --tag=laravel-mail</code></pre>\n  <p>Este comando publicará los componentes de correo de Markdown en el directorio. El directorio contendrá un directorio y un directorio, cada uno con sus respectivas representaciones de cada componente disponible. Puede personalizar estos componentes como desee.<code>resources/views/vendor/mail</code><code>mail</code><code>html</code><code>text</code></p>\n  <h4>Personalizando el CSS</h4>\n  <p>Después de exportar los componentes, el directorio contendrá un archivo. Puede personalizar el CSS en este archivo y sus estilos se alinearán automáticamente dentro de las representaciones HTML de sus mensajes de correo Markdown.<code>resources/views/vendor/mail/html/themes</code><code>default.css</code></p>\n  <p>Si desea construir un tema completamente nuevo para los componentes Markdown de Laravel, puede colocar un archivo CSS dentro del directorio. Después de nombrar y guardar su archivo CSS, actualice la opción del archivo de configuración para que coincida con el nombre de su nuevo tema.<code>html/themes</code><code>theme</code><code>mail</code></p>\n  <p>Para personalizar el tema para un <code>$theme</code>envío por correo individual, puede establecer la propiedad de la clase de envío por correo al nombre del tema que se debe usar al enviar ese envío por correo.</p>\n  <p></p>\n  <h2>Enviando correo</h2>\n  <p>Para enviar un mensaje, use el <code>to</code>método en la <code>Mail</code> fachada . El <code>to</code>método acepta una dirección de correo electrónico, una instancia de usuario o una colección de usuarios. Si pasa un objeto o una colección de objetos, el remitente usará automáticamente sus propiedades <code>email</code>y <code>name</code>al configurar los destinatarios del correo electrónico, así que asegúrese de que estos atributos estén disponibles en sus objetos. Una vez que haya especificado sus destinatarios, puede pasar una instancia de su clase mailable al <code>send</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Mail\\OrderShipped;\nuse App\\Models\\Order;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Mail;\n\nclass OrderController extends Controller\n{\n    /**\n     * Ship the given order.\n     *\n     * @param  Request  $request\n     * @param  int  $orderId\n     * @return Response\n     */\n    public function ship(Request $request, $orderId)\n    {\n        $order = Order::findOrFail($orderId);\n\n        // Ship order...\n\n        Mail::to($request-&gt;user())-&gt;send(new OrderShipped($order));\n    }\n}</code></pre>\n  <p>No está limitado a especificar los destinatarios \"para\" al enviar un mensaje. Puede configurar los destinatarios \"a\", \"cc\" y \"bcc\", todo dentro de una única llamada de método encadenada:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Mail;\n\nMail::to($request-&gt;user())\n    -&gt;cc($moreUsers)\n    -&gt;bcc($evenMoreUsers)\n    -&gt;send(new OrderShipped($order));</code></pre>\n  <h4>Bucle sobre destinatarios</h4>\n  <p>Occasionally, you may need to send a mailable to a list of recipients by iterating over an array of recipients / email addresses. Since the <code>to</code> method appends email addresses to the mailable's list of recipients, you should always re-create the mailable instance for each recipient:</p>\n  <pre><code>foreach (['taylor@example.com', 'dries@example.com'] as $recipient) {\n    Mail::to($recipient)-&gt;send(new OrderShipped($order));\n}</code></pre>\n  <h4>Sending Mail Via A Specific Mailer</h4>\n  <p>By default, Laravel will use the mailer configured as the <code>default</code> mailer in your <code>mail</code> configuration file. However, you may use the <code>mailer</code> method to send a message using a specific mailer configuration:</p>\n  <pre><code>Mail::mailer('postmark')\n        -&gt;to($request-&gt;user())\n        -&gt;send(new OrderShipped($order));</code></pre>\n  <p></p>\n  <h3>Queueing Mail</h3>\n  <h4>Queueing A Mail Message</h4>\n  <p>Since sending email messages can drastically lengthen the response time of your application, many developers choose to queue email messages for background sending. Laravel makes this easy using its built-in unified queue API. To queue a mail message, use the <code>queue</code> method on the <code>Mail</code> facade after specifying the message's recipients:</p>\n  <pre><code>Mail::to($request-&gt;user())\n    -&gt;cc($moreUsers)\n    -&gt;bcc($evenMoreUsers)\n    -&gt;queue(new OrderShipped($order));</code></pre>\n  <p>This method will automatically take care of pushing a job onto the queue so the message is sent in the background. You will need to configure your queues before using this feature.</p>\n  <h4>Delayed Message Queueing</h4>\n  <p>If you wish to delay the delivery of a queued email message, you may use the <code>later</code> method. As its first argument, the <code>later</code> method accepts a <code>DateTime</code> instance indicating when the message should be sent:</p>\n  <pre><code>$when = now()-&gt;addMinutes(10);\n\nMail::to($request-&gt;user())\n    -&gt;cc($moreUsers)\n    -&gt;bcc($evenMoreUsers)\n    -&gt;later($when, new OrderShipped($order));</code></pre>\n  <h4>Empujar a colas específicas</h4>\n  <p>Dado que todas las clases que se pueden enviar por correo generadas mediante el comando hacen uso del rasgo, puede llamar a los métodos y en cualquier instancia de la clase que se puede enviar por correo, lo que le permite especificar la conexión y el nombre de la cola del mensaje:<code>make:mail</code><code>Illuminate\\Bus\\Queueable</code><code>onQueue</code><code>onConnection</code></p>\n  <pre><code>$message = (new OrderShipped($order))\n                -&gt;onConnection('sqs')\n                -&gt;onQueue('emails');\n\nMail::to($request-&gt;user())\n    -&gt;cc($moreUsers)\n    -&gt;bcc($evenMoreUsers)\n    -&gt;queue($message);</code></pre>\n  <h4>Cola por defecto</h4>\n  <p>Si tiene clases que se pueden enviar por correo y desea que siempre estén en cola, puede implementar el <code>ShouldQueue</code>contrato en la clase. Ahora, incluso si llama al <code>send</code>método al enviar un correo, el correo seguirá en cola ya que implementa el contrato:</p>\n  <pre><code>use Illuminate\\Contracts\\Queue\\ShouldQueue;\n\nclass OrderShipped extends Mailable implements ShouldQueue\n{\n    //\n}</code></pre>\n  <p></p>\n  <h2>Renderizado de mailables</h2>\n  <p>A veces, es posible que desee capturar el contenido HTML de un envío por correo sin enviarlo. Para lograr esto, puede llamar al <code>render</code>método mailable. Este método devolverá el contenido evaluado del mailable como una cadena:</p>\n  <pre><code>$invoice = App\\Models\\Invoice::find(1);\n\nreturn (new App\\Mail\\InvoicePaid($invoice))-&gt;render();</code></pre>\n  <p></p>\n  <h3>Vista previa de envíos postales en el navegador</h3>\n  <p>Al diseñar la plantilla de un mailable, es conveniente obtener una vista previa rápida del mailable renderizado en su navegador como una plantilla Blade típica. Por esta razón, Laravel le permite devolver cualquier envío por correo directamente desde un cierre de ruta o controlador. Cuando se devuelve un envío por correo, se procesará y mostrará en el navegador, lo que le permitirá obtener una vista previa rápida de su diseño sin necesidad de enviarlo a una dirección de correo electrónico real:</p>\n  <pre><code>Route::get('mailable', function () {\n    $invoice = App\\Models\\Invoice::find(1);\n\n    return new App\\Mail\\InvoicePaid($invoice);\n});</code></pre>\n  <p></p>\n  <h2>Localización de envíos por correo</h2>\n  <p>Laravel le permite enviar mensajes de correo en una configuración regional distinta al idioma actual, e incluso recordará esta configuración regional si el correo está en cola.</p>\n  <p>Para lograr esto, la <code>Mail</code>fachada ofrece un <code>locale</code>método para establecer el idioma deseado. La aplicación cambiará a esta configuración regional cuando se formatee el envío por correo y luego volverá a la configuración regional anterior cuando se complete el formateo:</p>\n  <pre><code>Mail::to($request-&gt;user())-&gt;locale('es')-&gt;send(\n    new OrderShipped($order)\n);</code></pre>\n  <h3>Locales preferidos por el usuario</h3>\n  <p>A veces, las aplicaciones almacenan la configuración regional preferida de cada usuario. Al implementar el <code>HasLocalePreference</code>contrato en uno o más de sus modelos, puede indicarle a Laravel que use esta configuración regional almacenada al enviar correo:</p>\n  <pre><code>use Illuminate\\Contracts\\Translation\\HasLocalePreference;\n\nclass User extends Model implements HasLocalePreference\n{\n    /**\n     * Get the user's preferred locale.\n     *\n     * @return string\n     */\n    public function preferredLocale()\n    {\n        return $this-&gt;locale;\n    }\n}</code></pre>\n  <p>Una vez que haya implementado la interfaz, Laravel usará automáticamente la configuración regional preferida al enviar correos electrónicos y notificaciones al modelo. Por lo tanto, no es necesario llamar al <code>locale</code>método cuando se usa esta interfaz:</p>\n  <pre><code>Mail::to($request-&gt;user())-&gt;send(new OrderShipped($order));</code></pre>\n  <p></p>\n  <h2>Correo y desarrollo local</h2>\n  <p>Al desarrollar una aplicación que envía correo electrónico, probablemente no desee enviar correos electrónicos a direcciones de correo electrónico activas. Laravel proporciona varias formas de \"deshabilitar\" el envío real de correos electrónicos durante el desarrollo local.</p>\n  <h4>Controlador de registro</h4>\n  <p>En lugar de enviar sus correos electrónicos, el <code>log</code>controlador de correo escribirá todos los mensajes de correo electrónico en sus archivos de registro para su inspección. Para obtener más información sobre cómo configurar su aplicación por entorno, consulte la documentación de configuración .</p>\n  <h4>Universal para</h4>\n  <p>Otra solución proporcionada por Laravel es establecer un destinatario universal de todos los correos electrónicos enviados por el marco. De esta forma, todos los correos electrónicos generados por su aplicación se enviarán a una dirección específica, en lugar de la dirección realmente especificada al enviar el mensaje. Esto se puede hacer a través de la <code>to</code>opción en su archivo de configuración:<code>config/mail.php</code></p>\n  <pre><code>'to' =&gt; [\n    'address' =&gt; 'example@example.com',\n    'name' =&gt; 'Example'\n],</code></pre>\n  <h4>Mailtrap</h4>\n  <p>Finalmente, puede usar un servicio como Mailtrap y el <code>smtp</code>controlador para enviar sus mensajes de correo electrónico a un buzón \"ficticio\" donde puede verlos en un verdadero cliente de correo electrónico. Este enfoque tiene la ventaja de permitirle inspeccionar los correos electrónicos finales en el visor de mensajes de Mailtrap.</p>\n  <p></p>\n  <h2>Eventos</h2>\n  <p>Laravel dispara dos eventos durante el proceso de envío de mensajes de correo. El <code>MessageSending</code>evento se activa antes de que se envíe un mensaje, mientras que el <code>MessageSent</code>evento se activa después de que se haya enviado un mensaje. Recuerde, estos eventos se activan cuando está siendo el correo <em>enviado</em> , no cuando se pone en cola. Puede registrar un detector de eventos para este evento en su <code>EventServiceProvider</code>:</p>\n  <pre><code>/**\n * The event listener mappings for the application.\n *\n * @var array\n */\nprotected $listen = [\n    'Illuminate\\Mail\\Events\\MessageSending' =&gt; [\n        'App\\Listeners\\LogSendingMessage',\n    ],\n    'Illuminate\\Mail\\Events\\MessageSent' =&gt; [\n        'App\\Listeners\\LogSentMessage',\n    ],\n];</code></pre>\n</section>"
      },
      {
        "titulo": "6.9 Notificaciones",
        "contenido": "<section>\n  <h1>Notificaciones</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Crear notificaciones</li>\n    <li>Envío de notificaciones\n      <ul>\n        <li>Usando el rasgo notificable</li>\n        <li>Uso de la fachada de notificaciones</li>\n        <li>Especificar canales de entrega</li>\n        <li>Cola de notificaciones</li>\n        <li>Notificaciones bajo demanda</li>\n      </ul></li>\n    <li>Notificaciones por correo\n      <ul>\n        <li>Formateo de mensajes de correo</li>\n        <li>Personalización del remitente</li>\n        <li>Personalización del destinatario</li>\n        <li>Personalización del tema</li>\n        <li>Personalización del Mailer</li>\n        <li>Personalizar las plantillas</li>\n        <li>Vista previa de notificaciones por correo</li>\n      </ul></li>\n    <li>Notificaciones de Markdown Mail\n      <ul>\n        <li>Generando el mensaje</li>\n        <li>Escribiendo el mensaje</li>\n        <li>Personalización de los componentes</li>\n      </ul></li>\n    <li>Notificaciones de base de datos\n      <ul>\n        <li>Prerrequisitos</li>\n        <li>Dar formato a las notificaciones de la base de datos</li>\n        <li>Acceder a las notificaciones</li>\n        <li>Marcar notificaciones como leídas</li>\n      </ul></li>\n    <li>Notificaciones de transmisión\n      <ul>\n        <li>Prerrequisitos</li>\n        <li>Formateo de notificaciones de difusión</li>\n        <li>Escuchar notificaciones</li>\n      </ul></li>\n    <li>Notificaciones por SMS\n      <ul>\n        <li>Prerrequisitos</li>\n        <li>Formateo de notificaciones por SMS</li>\n        <li>Formateo de notificaciones de shortcode</li>\n        <li>Personalización del número \"De\"</li>\n        <li>Enrutamiento de notificaciones por SMS</li>\n      </ul></li>\n    <li>Notificaciones de holgura\n      <ul>\n        <li>Prerrequisitos</li>\n        <li>Dar formato a las notificaciones de Slack</li>\n        <li>Archivos adjuntos flojos</li>\n        <li>Enrutamiento de notificaciones de holgura</li>\n      </ul></li>\n    <li>Localización de notificaciones</li>\n    <li>Eventos de notificación</li>\n    <li>Canales personalizados</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Además del soporte para enviar correos electrónicos , Laravel brinda soporte para enviar notificaciones a través de una variedad de canales de entrega, incluidos correo, SMS (a través de Vonage , anteriormente conocido como Nexmo) y Slack . Las notificaciones también se pueden almacenar en una base de datos para que se muestren en su interfaz web.</p>\n  <p>Por lo general, las notificaciones deben ser mensajes breves e informativos que notifiquen a los usuarios sobre algo que ocurrió en su aplicación. Por ejemplo, si está escribiendo una aplicación de facturación, puede enviar una notificación de \"Factura pagada\" a sus usuarios a través de los canales de correo electrónico y SMS.</p>\n  <p></p>\n  <h2>Crear notificaciones</h2>\n  <p>En Laravel, cada notificación está representada por una sola clase (normalmente almacenada en el directorio). No se preocupe si no ve este directorio en su aplicación, se creará cuando ejecute el comando Artisan:<code>app/Notifications</code><code>make:notification</code></p>\n  <pre><code>php artisan make:notification InvoicePaid</code></pre>\n  <p>Este comando colocará una nueva clase de notificación en su directorio. Cada clase de notificación contiene un método y un número variable de métodos de creación de mensajes (como o ) que convierten la notificación en un mensaje optimizado para ese canal en particular.<code>app/Notifications</code><code>via</code><code>toMail</code><code>toDatabase</code></p>\n  <p></p>\n  <h2>Envío de notificaciones</h2>\n  <p></p>\n  <h3>Usando el rasgo notificable</h3>\n  <p>Las notificaciones se pueden enviar de dos formas: utilizando el <code>notify</code>método del <code>Notifiable</code>rasgo o utilizando la <code>Notification</code> fachada . Primero, exploremos el uso del rasgo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Notifications\\Notifiable;\n\nclass User extends Authenticatable\n{\n    use Notifiable;\n}</code></pre>\n  <p>Este rasgo es utilizado por el defecto modelo y contiene un método que puede ser utilizado para enviar notificaciones: . El método espera recibir una instancia de notificación:<code>App\\Models\\User</code><code>notify</code><code>notify</code></p>\n  <pre><code>use App\\Notifications\\InvoicePaid;\n\n$user-&gt;notify(new InvoicePaid($invoice));</code></pre>\n  <blockquote>\n    <div><div></div><p>Recuerde, puede usar el rasgo en cualquiera de sus modelos. No está limitado a incluirlo solo en su modelo.<code>Illuminate\\Notifications\\Notifiable</code><code>User</code></p></div>\n  </blockquote>\n  <p></p>\n  <h3>Uso de la fachada de notificaciones</h3>\n  <p>Alternativamente, puede enviar notificaciones a través de la <code>Notification</code> fachada . Esto es útil principalmente cuando necesita enviar una notificación a varias entidades notificables, como una colección de usuarios. Para enviar notificaciones usando la fachada, pase todas las entidades notificables y la instancia de notificación al <code>send</code>método:</p>\n  <pre><code>Notification::send($users, new InvoicePaid($invoice));</code></pre>\n  <p></p>\n  <h3>Especificar canales de entrega</h3>\n  <p>Cada clase de notificación tiene un <code>via</code>método que determina en qué canales se entregará la notificación. Las notificaciones pueden ser enviadas en los <code>mail</code>, <code>database</code>, <code>broadcast</code>, <code>nexmo</code>, y <code>slack</code>canales.</p>\n  <blockquote>\n    <div><div></div><p>Si desea utilizar otros canales de entrega como Telegram o Pusher, consulte el sitio web de Canales de notificación de Laravel impulsado por la comunidad .</p></div>\n  </blockquote>\n  <p>El <code>via</code>método recibe una <code>$notifiable</code>instancia, que será una instancia de la clase a la que se envía la notificación. Puede utilizar <code>$notifiable</code>para determinar en qué canales se debe enviar la notificación:</p>\n  <pre><code>/**\n * Get the notification's delivery channels.\n *\n * @param  mixed  $notifiable\n * @return array\n */\npublic function via($notifiable)\n{\n    return $notifiable-&gt;prefers_sms ? ['nexmo'] : ['mail', 'database'];\n}</code></pre>\n  <p></p>\n  <h3>Cola de notificaciones</h3>\n  <blockquote>\n    <div><div></div><p>Antes de poner en cola las notificaciones, debe configurar su cola e iniciar un trabajador .</p></div>\n  </blockquote>\n  <p>El envío de notificaciones puede llevar tiempo, especialmente si el canal necesita una llamada API externa para entregar la notificación. Para acelerar el tiempo de respuesta de su aplicación, deje que su notificación se ponga en cola agregando la <code>ShouldQueue</code>interfaz y el <code>Queueable</code>rasgo a su clase. La interfaz y el rasgo ya están importados para todas las notificaciones generadas mediante , por lo que puede agregarlos inmediatamente a su clase de notificación:<code>make:notification</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Notifications;\n\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Notifications\\Notification;\n\nclass InvoicePaid extends Notification implements ShouldQueue\n{\n    use Queueable;\n\n    // ...\n}</code></pre>\n  <p>Una vez <code>ShouldQueue</code>que se haya agregado la interfaz a su notificación, puede enviar la notificación como de costumbre. Laravel detectará la <code>ShouldQueue</code>interfaz en la clase y automáticamente pondrá en cola la entrega de la notificación:</p>\n  <pre><code>$user-&gt;notify(new InvoicePaid($invoice));</code></pre>\n  <p>Si desea retrasar la entrega de la notificación, puede encadenar el <code>delay</code>método a su instanciación de notificación:</p>\n  <pre><code>$when = now()-&gt;addMinutes(10);\n\n$user-&gt;notify((new InvoicePaid($invoice))-&gt;delay($when));</code></pre>\n  <h4>Personalización de las colas de los canales de notificación</h4>\n  <p>Si desea especificar una cola específica que debe usarse para cada canal de notificación admitido por la notificación, puede definir un <code>viaQueues</code>método en su notificación. Este método debe devolver una matriz de pares de nombre de canal / nombre de cola:</p>\n  <pre><code>/**\n * Determine which queues should be used for each notification channel.\n *\n * @return array\n */\npublic function viaQueues()\n{\n    return [\n        'mail' =&gt; 'mail-queue',\n        'slack' =&gt; 'slack-queue',\n    ];\n}</code></pre>\n  <p></p>\n  <h3>Notificaciones bajo demanda</h3>\n  <p>A veces, es posible que deba enviar una notificación a alguien que no esté almacenado como \"usuario\" de su aplicación. Con el método de fachada, puede especificar información de enrutamiento de notificación ad-hoc antes de enviar la notificación:<code>Notification::route</code></p>\n  <pre><code>Notification::route('mail', 'taylor@example.com')\n            -&gt;route('nexmo', '5555555555')\n            -&gt;route('slack', 'https://hooks.slack.com/services/...')\n            -&gt;notify(new InvoicePaid($invoice));</code></pre>\n  <p></p>\n  <h2>Notificaciones por correo</h2>\n  <p></p>\n  <h3>Formateo de mensajes de correo</h3>\n  <p>Si una notificación admite que se envíe como correo electrónico, debe definir un <code>toMail</code>método en la clase de notificación. Este método recibirá una <code>$notifiable</code>entidad y debería devolver una instancia. Los mensajes de correo pueden contener líneas de texto, así como una \"llamada a la acción\". Echemos un vistazo a un método de ejemplo :<code>Illuminate\\Notifications\\Messages\\MailMessage</code><code>toMail</code></p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n */\npublic function toMail($notifiable)\n{\n    $url = url('/invoice/'.$this-&gt;invoice-&gt;id);\n\n    return (new MailMessage)\n                -&gt;greeting('Hello!')\n                -&gt;line('One of your invoices has been paid!')\n                -&gt;action('View Invoice', $url)\n                -&gt;line('Thank you for using our application!');\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Tenga en cuenta que estamos usando en nuestro método. Puede pasar cualquier dato que necesite su notificación para generar su mensaje en el constructor de la notificación.<code>$this-&gt;invoice-&gt;id</code><code>toMail</code></p></div>\n  </blockquote>\n  <p>En este ejemplo, registramos un saludo, una línea de texto, una llamada a la acción y luego otra línea de texto. Estos métodos proporcionados por el <code>MailMessage</code>objeto hacen que sea sencillo y rápido formatear pequeños correos electrónicos transaccionales. El canal de correo luego traducirá los componentes del mensaje en una plantilla de correo electrónico HTML agradable y receptiva con una contraparte de texto sin formato. A continuación, se muestra un ejemplo de un correo electrónico generado por el <code>mail</code>canal:</p>\n  \n  <blockquote>\n    <div><div></div><p>Al enviar notificaciones por correo, asegúrese de establecer el <code>name</code>valor en su archivo de configuración. Este valor se utilizará en el encabezado y pie de página de sus mensajes de notificación por correo.<code>config/app.php</code></p></div>\n  </blockquote>\n  <h4>Otras opciones de formato de notificación</h4>\n  <p>En lugar de definir las \"líneas\" de texto en la clase de notificación, puede usar el <code>view</code>método para especificar una plantilla personalizada que debe usarse para representar el correo electrónico de notificación:</p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n */\npublic function toMail($notifiable)\n{\n    return (new MailMessage)-&gt;view(\n        'emails.name', ['invoice' =&gt; $this-&gt;invoice]\n    );\n}</code></pre>\n  <p>Puede especificar una vista de texto sin formato para el mensaje de correo pasando el nombre de la vista como el segundo elemento de una matriz que se le da al <code>view</code>método de <code>MailMessage</code>:</p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n */\npublic function toMail($notifiable)\n{\n    return (new MailMessage)-&gt;view(\n        ['emails.name.html', 'emails.name.plain'],\n        ['invoice' =&gt; $this-&gt;invoice]\n    );\n}</code></pre>\n  <p>Además, puede devolver un objeto mailable completo del <code>toMail</code>método:</p>\n  <pre><code>use App\\Mail\\InvoicePaid as Mailable;\n\n/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return Mailable\n */\npublic function toMail($notifiable)\n{\n    return (new Mailable($this-&gt;invoice))-&gt;to($notifiable-&gt;email);\n}</code></pre>\n  <p></p>\n  <h4>Error de mensajes</h4>\n  <p>Algunas notificaciones informan a los usuarios de errores, como un pago de factura fallido. Puede indicar que un mensaje de correo está relacionado con un error llamando al <code>error</code>método al crear su mensaje. Al usar el <code>error</code>método en un mensaje de correo, el botón de llamada a la acción será rojo en lugar de azul:</p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Message\n */\npublic function toMail($notifiable)\n{\n    return (new MailMessage)\n                -&gt;error()\n                -&gt;subject('Notification Subject')\n                -&gt;line('...');\n}</code></pre>\n  <p></p>\n  <h3>Personalización del remitente</h3>\n  <p>De forma predeterminada, la dirección del remitente / remitente del correo electrónico se define en el archivo de configuración. Sin embargo, puede especificar la dirección de remitente para una notificación específica utilizando el método:<code>config/mail.php</code><code>from</code></p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n */\npublic function toMail($notifiable)\n{\n    return (new MailMessage)\n                -&gt;from('test@example.com', 'Example')\n                -&gt;line('...');\n}</code></pre>\n  <p></p>\n  <h3>Personalización del destinatario</h3>\n  <p>Al enviar notificaciones a través del <code>mail</code>canal, el sistema de notificaciones buscará automáticamente una <code>email</code>propiedad en su entidad notificable. Puede personalizar qué dirección de correo electrónico se utiliza para enviar la notificación definiendo un <code>routeNotificationForMail</code>método en la entidad:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Notifications\\Notifiable;\n\nclass User extends Authenticatable\n{\n    use Notifiable;\n\n    /**\n     * Route notifications for the mail channel.\n     *\n     * @param  \\Illuminate\\Notifications\\Notification  $notification\n     * @return array|string\n     */\n    public function routeNotificationForMail($notification)\n    {\n        // Return email address only...\n        return $this-&gt;email_address;\n\n        // Return name and email address...\n        return [$this-&gt;email_address =&gt; $this-&gt;name];\n    }\n}</code></pre>\n  <p></p>\n  <h3>Personalización del tema</h3>\n  <p>De forma predeterminada, el asunto del correo electrónico es el nombre de la clase de la notificación formateada como \"caso de título\". Entonces, si se nombra su clase de notificación <code>InvoicePaid</code>, el asunto del correo electrónico será <code>Invoice Paid</code>. Si desea especificar un asunto explícito para el mensaje, puede llamar al <code>subject</code>método al crear su mensaje:</p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n */\npublic function toMail($notifiable)\n{\n    return (new MailMessage)\n                -&gt;subject('Notification Subject')\n                -&gt;line('...');\n}</code></pre>\n  <p></p>\n  <h3>Personalización del Mailer</h3>\n  <p>De forma predeterminada, la notificación por correo electrónico se enviará utilizando el controlador predeterminado definido en el archivo de configuración. Sin embargo, puede especificar un envío de correo diferente en tiempo de ejecución llamando al método al crear su mensaje:<code>config/mail.php</code><code>mailer</code></p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n */\npublic function toMail($notifiable)\n{\n    return (new MailMessage)\n                -&gt;mailer('postmark')\n                -&gt;line('...');\n}</code></pre>\n  <p></p>\n  <h3>Personalizar las plantillas</h3>\n  <p>Puede modificar la plantilla HTML y de texto sin formato que utilizan las notificaciones por correo publicando los recursos del paquete de notificaciones. Después de ejecutar este comando, las plantillas de notificación por correo se ubicarán en el directorio:<code>resources/views/vendor/notifications</code></p>\n  <pre><code>php artisan vendor:publish --tag=laravel-notifications</code></pre>\n  <p></p>\n  <h3>Vista previa de notificaciones por correo</h3>\n  <p>Al diseñar una plantilla de notificación de correo, es conveniente obtener una vista previa rápida del mensaje de correo renderizado en su navegador como una plantilla Blade típica. Por esta razón, Laravel le permite devolver cualquier mensaje de correo generado por una notificación de correo directamente desde un cierre de ruta o controlador. Cuando <code>MailMessage</code>se devuelve un, se procesará y se mostrará en el navegador, lo que le permitirá obtener una vista previa rápida de su diseño sin necesidad de enviarlo a una dirección de correo electrónico real:</p>\n  <pre><code>Route::get('mail', function () {\n    $invoice = App\\Invoice::find(1);\n\n    return (new App\\Notifications\\InvoicePaid($invoice))\n                -&gt;toMail($invoice-&gt;user);\n});</code></pre>\n  <p></p>\n  <h2>Notificaciones de Markdown Mail</h2>\n  <p>Markdown mail notifications allow you to take advantage of the pre-built templates of mail notifications, while giving you more freedom to write longer, customized messages. Since the messages are written in Markdown, Laravel is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart.</p>\n  <p></p>\n  <h3>Generating The Message</h3>\n  <p>To generate a notification with a corresponding Markdown template, you may use the <code>--markdown</code> option of the <code>make:notification</code> Artisan command:</p>\n  <pre><code>php artisan make:notification InvoicePaid --markdown=mail.invoice.paid</code></pre>\n  <p>Como todas las demás notificaciones por correo, las notificaciones que usan plantillas de Markdown deben definir un <code>toMail</code>método en su clase de notificación. Sin embargo, en lugar de usar los métodos <code>line</code>y <code>action</code>para construir la notificación, use el <code>markdown</code>método para especificar el nombre de la plantilla de Markdown que debe usarse:</p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n */\npublic function toMail($notifiable)\n{\n    $url = url('/invoice/'.$this-&gt;invoice-&gt;id);\n\n    return (new MailMessage)\n                -&gt;subject('Invoice Paid')\n                -&gt;markdown('mail.invoice.paid', ['url' =&gt; $url]);\n}</code></pre>\n  <p></p>\n  <h3>Escribiendo el mensaje</h3>\n  <p>Las notificaciones de correo de Markdown utilizan una combinación de componentes Blade y sintaxis de Markdown que le permiten crear fácilmente notificaciones mientras aprovecha los componentes de notificación prediseñados de Laravel:</p>\n  <pre><code>@component('mail::message')\n# Invoice Paid\n\nYour invoice has been paid!\n\n@component('mail::button', ['url' =&gt; $url])\nView Invoice\n@endcomponent\n\nThanks,&lt;br&gt;\n{{ config('app.name') }}\n@endcomponent</code></pre>\n  <h4>Componente de botón</h4>\n  <p>El componente de botón representa un vínculo de botón centrado. El componente acepta dos argumentos, uno <code>url</code>y un opcional <code>color</code>. Los colores son soportados <code>blue</code>, <code>green</code>y <code>red</code>. Puede agregar tantos componentes de botón a una notificación como desee:</p>\n  <pre><code>@component('mail::button', ['url' =&gt; $url, 'color' =&gt; 'green'])\nView Invoice\n@endcomponent</code></pre>\n  <h4>Componente del panel</h4>\n  <p>El componente de panel representa el bloque de texto dado en un panel que tiene un color de fondo ligeramente diferente al del resto de la notificación. Esto le permite llamar la atención sobre un bloque de texto determinado:</p>\n  <pre><code>@component('mail::panel')\nThis is the panel content.\n@endcomponent</code></pre>\n  <h4>Componente de tabla</h4>\n  <p>El componente de tabla le permite transformar una tabla de Markdown en una tabla HTML. El componente acepta la tabla de Markdown como contenido. La alineación de la columna de la tabla es compatible con la sintaxis de alineación de la tabla de Markdown predeterminada:</p>\n  <pre><code>@component('mail::table')\n| Laravel       | Table         | Example  |\n| ------------- |:-------------:| --------:|\n| Col 2 is      | Centered      | $10      |\n| Col 3 is      | Right-Aligned | $20      |\n@endcomponent</code></pre>\n  <p></p>\n  <h3>Personalización de los componentes</h3>\n  <p>Puede exportar todos los componentes de notificación de Markdown a su propia aplicación para personalizarlos. Para exportar los componentes, use el comando Artisan para publicar la etiqueta de activo:<code>vendor:publish</code><code>laravel-mail</code></p>\n  <pre><code>php artisan vendor:publish --tag=laravel-mail</code></pre>\n  <p>This command will publish the Markdown mail components to the <code>resources/views/vendor/mail</code> directory. The <code>mail</code> directory will contain an <code>html</code> and a <code>text</code> directory, each containing their respective representations of every available component. You are free to customize these components however you like.</p>\n  <h4>Customizing The CSS</h4>\n  <p>After exporting the components, the <code>resources/views/vendor/mail/html/themes</code> directory will contain a <code>default.css</code> file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown notifications.</p>\n  <p>Si desea construir un tema completamente nuevo para los componentes Markdown de Laravel, puede colocar un archivo CSS dentro del directorio. Después de nombrar y guardar su archivo CSS, actualice la opción del archivo de configuración para que coincida con el nombre de su nuevo tema.<code>html/themes</code><code>theme</code><code>mail</code></p>\n  <p>Para personalizar el tema para una notificación individual, puede llamar al <code>theme</code>método mientras crea el mensaje de correo de la notificación. El <code>theme</code>método acepta el nombre del tema que se debe utilizar al enviar la notificación:</p>\n  <pre><code>/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n */\npublic function toMail($notifiable)\n{\n    return (new MailMessage)\n                -&gt;theme('invoice')\n                -&gt;subject('Invoice Paid')\n                -&gt;markdown('mail.invoice.paid', ['url' =&gt; $url]);\n}</code></pre>\n  <p></p>\n  <h2>Notificaciones de base de datos</h2>\n  <p></p>\n  <h3>Prerrequisitos</h3>\n  <p>El <code>database</code>canal de notificación almacena la información de notificación en una tabla de base de datos. Esta tabla contendrá información como el tipo de notificación, así como datos JSON personalizados que describen la notificación.</p>\n  <p>Puede consultar la tabla para mostrar las notificaciones en la interfaz de usuario de su aplicación. Pero, antes de que pueda hacer eso, deberá crear una tabla de base de datos para contener sus notificaciones. Puede usar el comando para generar una migración con el esquema de tabla adecuado:<code>notifications:table</code></p>\n  <pre><code>php artisan notifications:table\n\nphp artisan migrate</code></pre>\n  <p></p>\n  <h3>Dar formato a las notificaciones de la base de datos</h3>\n  <p>Si una notificación admite que se almacene en una tabla de base de datos, debe definir un método <code>toDatabase</code>o <code>toArray</code>en la clase de notificación. Este método recibirá una <code>$notifiable</code>entidad y debería devolver una matriz PHP simple. La matriz devuelta se codificará como JSON y se almacenará en la <code>data</code>columna de su <code>notifications</code>tabla. Echemos un vistazo a un <code>toArray</code>método de ejemplo :</p>\n  <pre><code>/**\n * Get the array representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return array\n */\npublic function toArray($notifiable)\n{\n    return [\n        'invoice_id' =&gt; $this-&gt;invoice-&gt;id,\n        'amount' =&gt; $this-&gt;invoice-&gt;amount,\n    ];\n}</code></pre>\n  <h4><code>toDatabase</code> Vs. <code>toArray</code></h4>\n  <p>El canal <code>toArray</code>también utiliza el método <code>broadcast</code>para determinar qué datos transmitir a su cliente JavaScript. Si desea tener dos representaciones de matriz diferentes para los canales <code>database</code>y <code>broadcast</code>, debe definir un <code>toDatabase</code>método en lugar de un <code>toArray</code>método.</p>\n  <p></p>\n  <h3>Acceder a las notificaciones</h3>\n  <p>Una vez que las notificaciones se almacenan en la base de datos, necesita una forma conveniente de acceder a ellas desde sus entidades notificables. El rasgo, que se incluye en el modelo predeterminado de Laravel , incluye una relación Eloquent que devuelve las notificaciones de la entidad. Para obtener notificaciones, puede acceder a este método como cualquier otra relación de Eloquent. De forma predeterminada, las notificaciones se ordenarán por la marca de tiempo:<code>Illuminate\\Notifications\\Notifiable</code><code>App\\Models\\User</code><code>notifications</code><code>created_at</code></p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nforeach ($user-&gt;notifications as $notification) {\n    echo $notification-&gt;type;\n}</code></pre>\n  <p>If you want to retrieve only the \"unread\" notifications, you may use the <code>unreadNotifications</code> relationship. Again, these notifications will be sorted by the <code>created_at</code> timestamp:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nforeach ($user-&gt;unreadNotifications as $notification) {\n    echo $notification-&gt;type;\n}</code></pre>\n  <blockquote>\n    <div><div></div><p> To access your notifications from your JavaScript client, you should define a notification controller for your application which returns the notifications for a notifiable entity, such as the current user. You may then make an HTTP request to that controller's URI from your JavaScript client.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Marking Notifications As Read</h3>\n  <p>Typically, you will want to mark a notification as \"read\" when a user views it. The <code>Illuminate\\Notifications\\Notifiable</code> trait provides a <code>markAsRead</code> method, which updates the <code>read_at</code> column on the notification's database record:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nforeach ($user-&gt;unreadNotifications as $notification) {\n    $notification-&gt;markAsRead();\n}</code></pre>\n  <p>However, instead of looping through each notification, you may use the <code>markAsRead</code> method directly on a collection of notifications:</p>\n  <pre><code>$user-&gt;unreadNotifications-&gt;markAsRead();</code></pre>\n  <p>You may also use a mass-update query to mark all of the notifications as read without retrieving them from the database:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;unreadNotifications()-&gt;update(['read_at' =&gt; now()]);</code></pre>\n  <p>You may <code>delete</code> the notifications to remove them from the table entirely:</p>\n  <pre><code>$user-&gt;notifications()-&gt;delete();</code></pre>\n  <p></p>\n  <h2>Broadcast Notifications</h2>\n  <p></p>\n  <h3>Prerequisites</h3>\n  <p>Before broadcasting notifications, you should configure and be familiar with Laravel's event broadcasting services. Event broadcasting provides a way to react to server-side fired Laravel events from your JavaScript client.</p>\n  <p></p>\n  <h3>Formatting Broadcast Notifications</h3>\n  <p>The <code>broadcast</code> channel broadcasts notifications using Laravel's event broadcasting services, allowing your JavaScript client to catch notifications in realtime. If a notification supports broadcasting, you can define a <code>toBroadcast</code> method on the notification class. This method will receive a <code>$notifiable</code> entity and should return a <code>BroadcastMessage</code> instance. If the <code>toBroadcast</code> method does not exist, the <code>toArray</code> method will be used to gather the data that should be broadcast. The returned data will be encoded as JSON and broadcast to your JavaScript client. Let's take a look at an example <code>toBroadcast</code> method:</p>\n  <pre><code>use Illuminate\\Notifications\\Messages\\BroadcastMessage;\n\n/**\n * Get the broadcastable representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return BroadcastMessage\n */\npublic function toBroadcast($notifiable)\n{\n    return new BroadcastMessage([\n        'invoice_id' =&gt; $this-&gt;invoice-&gt;id,\n        'amount' =&gt; $this-&gt;invoice-&gt;amount,\n    ]);\n}</code></pre>\n  <h4>Broadcast Queue Configuration</h4>\n  <p>All broadcast notifications are queued for broadcasting. If you would like to configure the queue connection or queue name that is used to queue the broadcast operation, you may use the <code>onConnection</code> and <code>onQueue</code> methods of the <code>BroadcastMessage</code>:</p>\n  <pre><code>return (new BroadcastMessage($data))\n                -&gt;onConnection('sqs')\n                -&gt;onQueue('broadcasts');</code></pre>\n  <h4>Customizing The Notification Type</h4>\n  <p>In addition to the data you specify, all broadcast notifications also have a <code>type</code> field containing the full class name of the notification. If you would like to customize the notification <code>type</code> that is provided to your JavaScript client, you may define a <code>broadcastType</code> method on the notification class:</p>\n  <pre><code>use Illuminate\\Notifications\\Messages\\BroadcastMessage;\n\n/**\n * Get the type of the notification being broadcast.\n *\n * @return string\n */\npublic function broadcastType()\n{\n    return 'broadcast.message';\n}</code></pre>\n  <p></p>\n  <h3>Listening For Notifications</h3>\n  <p>Las notificaciones se transmitirán en un canal privado formateado usando una convención. Entonces, si está enviando una notificación a una instancia con un ID de , la notificación se transmitirá en el canal privado. Al usar Laravel Echo , puede escuchar fácilmente las notificaciones en un canal usando el método auxiliar:<code>{notifiable}.{id}</code><code>App\\Models\\User</code><code>1</code><code>App.User.1</code><code>notification</code></p>\n  <pre><code>Echo.private('App.User.' + userId)\n    .notification((notification) =&gt; {\n        console.log(notification.type);\n    });</code></pre>\n  <h4>Personalización del canal de notificación</h4>\n  <p>Si desea personalizar los canales en los que una entidad notificable recibe sus notificaciones de transmisión, puede definir un <code>receivesBroadcastNotificationsOn</code>método en la entidad notificable:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Broadcasting\\PrivateChannel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Notifications\\Notifiable;\n\nclass User extends Authenticatable\n{\n    use Notifiable;\n\n    /**\n     * The channels the user receives notification broadcasts on.\n     *\n     * @return string\n     */\n    public function receivesBroadcastNotificationsOn()\n    {\n        return 'users.'.$this-&gt;id;\n    }\n}</code></pre>\n  <p></p>\n  <h2>Notificaciones por SMS</h2>\n  <p></p>\n  <h3>Prerrequisitos</h3>\n  <p>El envío de notificaciones por SMS en Laravel funciona con Nexmo . Antes de poder enviar notificaciones a través de Nexmo, debe instalar el paquete Composer:<code>laravel/nexmo-notification-channel</code></p>\n  <pre><code>composer require laravel/nexmo-notification-channel</code></pre>\n  <p>Esto también instalará el paquete. Este paquete incluye su propio archivo de configuración . Puede usar las variables de entorno y para configurar su clave pública y secreta de Nexmo.<code>nexmo/laravel</code><code>NEXMO_KEY</code><code>NEXMO_SECRET</code></p>\n  <p>A continuación, deberá agregar una opción de configuración a su archivo de configuración. Puede copiar la configuración de ejemplo a continuación para comenzar:<code>config/services.php</code></p>\n  <pre><code>'nexmo' =&gt; [\n    'sms_from' =&gt; '15556666666',\n],</code></pre>\n  <p>La <code>sms_from</code>opción es el número de teléfono desde el que se enviarán sus mensajes SMS. Debe generar un número de teléfono para su aplicación en el panel de control de Nexmo.</p>\n  <p></p>\n  <h3>Formateo de notificaciones por SMS</h3>\n  <p>Si una notificación admite que se envíe como un SMS, debe definir un <code>toNexmo</code>método en la clase de notificación. Este método recibirá una <code>$notifiable</code>entidad y debería devolver una instancia:<code>Illuminate\\Notifications\\Messages\\NexmoMessage</code></p>\n  <pre><code>/**\n * Get the Nexmo / SMS representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return NexmoMessage\n */\npublic function toNexmo($notifiable)\n{\n    return (new NexmoMessage)\n                -&gt;content('Your SMS message content');\n}</code></pre>\n  <p></p>\n  <h3>Formateo de notificaciones de shortcode</h3>\n  <p>Laravel también admite el envío de notificaciones de código corto, que son plantillas de mensajes predefinidas en su cuenta de Nexmo. Puede especificar el tipo de notificación ( <code>alert</code>, <code>2fa</code>o <code>marketing</code>), así como los valores personalizados que llenarán la plantilla:</p>\n  <pre><code>/**\n * Get the Nexmo / Shortcode representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return array\n */\npublic function toShortcode($notifiable)\n{\n    return [\n        'type' =&gt; 'alert',\n        'custom' =&gt; [\n            'code' =&gt; 'ABC123',\n        ];\n    ];\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Al igual que el enrutamiento de notificaciones por SMS , debe implementar el <code>routeNotificationForShortcode</code>método en su modelo notificable.</p></div>\n  </blockquote>\n  <h4>Contenido Unicode</h4>\n  <p>Si su mensaje SMS contendrá caracteres Unicode, debe llamar al <code>unicode</code>método al construir la <code>NexmoMessage</code>instancia:</p>\n  <pre><code>/**\n * Get the Nexmo / SMS representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return NexmoMessage\n */\npublic function toNexmo($notifiable)\n{\n    return (new NexmoMessage)\n                -&gt;content('Your unicode message')\n                -&gt;unicode();\n}</code></pre>\n  <p></p>\n  <h3>Personalización del número \"De\"</h3>\n  <p>Si desea enviar algunas notificaciones desde un número de teléfono que es diferente del número de teléfono especificado en su archivo, puede usar el método en una instancia:<code>config/services.php</code><code>from</code><code>NexmoMessage</code></p>\n  <pre><code>/**\n * Get the Nexmo / SMS representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return NexmoMessage\n */\npublic function toNexmo($notifiable)\n{\n    return (new NexmoMessage)\n                -&gt;content('Your SMS message content')\n                -&gt;from('15554443333');\n}</code></pre>\n  <p></p>\n  <h3>Enrutamiento de notificaciones por SMS</h3>\n  <p>Para enrutar las notificaciones de Nexmo al número de teléfono adecuado, defina un <code>routeNotificationForNexmo</code>método en su entidad notificable:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Notifications\\Notifiable;\n\nclass User extends Authenticatable\n{\n    use Notifiable;\n\n    /**\n     * Route notifications for the Nexmo channel.\n     *\n     * @param  \\Illuminate\\Notifications\\Notification  $notification\n     * @return string\n     */\n    public function routeNotificationForNexmo($notification)\n    {\n        return $this-&gt;phone_number;\n    }\n}</code></pre>\n  <p></p>\n  <h2>Notificaciones de holgura</h2>\n  <p></p>\n  <h3>Prerrequisitos</h3>\n  <p>Antes de poder enviar notificaciones a través de Slack, debe instalar el canal de notificación a través de Composer:</p>\n  <pre><code>composer require laravel/slack-notification-channel</code></pre>\n  <p>También necesitará configurar una integración de \"Webhook entrante\" para su equipo de Slack. Esta integración le proporcionará una URL que puede utilizar al enrutar notificaciones de Slack .</p>\n  <p></p>\n  <h3>Dar formato a las notificaciones de Slack</h3>\n  <p>Si una notificación admite que se envíe como un mensaje de Slack, debe definir un <code>toSlack</code>método en la clase de notificación. Este método recibirá una <code>$notifiable</code>entidad y debería devolver una instancia. Los mensajes de Slack pueden contener contenido de texto, así como un \"archivo adjunto\" que formatea texto adicional o una serie de campos. Echemos un vistazo a un ejemplo básico :<code>Illuminate\\Notifications\\Messages\\SlackMessage</code><code>toSlack</code></p>\n  <pre><code>/**\n * Get the Slack representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return SlackMessage\n */\npublic function toSlack($notifiable)\n{\n    return (new SlackMessage)\n                -&gt;content('One of your invoices has been paid!');\n}</code></pre>\n  <p>En este ejemplo, solo estamos enviando una sola línea de texto a Slack, lo que creará un mensaje con el siguiente aspecto:</p>\n  \n  <h4>Personalizar el remitente y el destinatario</h4>\n  <p>Puede utilizar los métodos <code>from</code>y <code>to</code>para personalizar el remitente y el destinatario. El <code>from</code>método acepta un nombre de usuario y un identificador de emoji, mientras que el <code>to</code>método acepta un canal o nombre de usuario:</p>\n  <pre><code>/**\n * Get the Slack representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return SlackMessage\n */\npublic function toSlack($notifiable)\n{\n    return (new SlackMessage)\n                -&gt;from('Ghost', ':ghost:')\n                -&gt;to('#other')\n                -&gt;content('This will be sent to #other');\n}</code></pre>\n  <p>También puede utilizar una imagen como logotipo en lugar de un emoji:</p>\n  <pre><code>/**\n * Get the Slack representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return SlackMessage\n */\npublic function toSlack($notifiable)\n{\n    return (new SlackMessage)\n                -&gt;from('Laravel')\n                -&gt;image('https://laravel.com/img/favicon/favicon.ico')\n                -&gt;content('This will display the Laravel logo next to the message');\n}</code></pre>\n  <p></p>\n  <h3>Archivos adjuntos flojos</h3>\n  <p>También puede agregar \"archivos adjuntos\" a los mensajes de Slack. Los archivos adjuntos proporcionan opciones de formato más completas que los mensajes de texto simples. En este ejemplo, enviaremos una notificación de error sobre una excepción que ocurrió en una aplicación, incluido un enlace para ver más detalles sobre la excepción:</p>\n  <pre><code>/**\n * Get the Slack representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return SlackMessage\n */\npublic function toSlack($notifiable)\n{\n    $url = url('/exceptions/'.$this-&gt;exception-&gt;id);\n\n    return (new SlackMessage)\n                -&gt;error()\n                -&gt;content('Whoops! Something went wrong.')\n                -&gt;attachment(function ($attachment) use ($url) {\n                    $attachment-&gt;title('Exception: File Not Found', $url)\n                               -&gt;content('File [background.jpg] was not found.');\n                });\n}</code></pre>\n  <p>El ejemplo anterior generará un mensaje de Slack con el siguiente aspecto:</p>\n  \n  <p>Los archivos adjuntos también le permiten especificar una serie de datos que se deben presentar al usuario. Los datos proporcionados se presentarán en un formato de estilo de tabla para facilitar la lectura:</p>\n  <pre><code>/**\n * Get the Slack representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return SlackMessage\n */\npublic function toSlack($notifiable)\n{\n    $url = url('/invoices/'.$this-&gt;invoice-&gt;id);\n\n    return (new SlackMessage)\n                -&gt;success()\n                -&gt;content('One of your invoices has been paid!')\n                -&gt;attachment(function ($attachment) use ($url) {\n                    $attachment-&gt;title('Invoice 1322', $url)\n                               -&gt;fields([\n                                    'Title' =&gt; 'Server Expenses',\n                                    'Amount' =&gt; '$1,234',\n                                    'Via' =&gt; 'American Express',\n                                    'Was Overdue' =&gt; ':-1:',\n                                ]);\n                });\n}</code></pre>\n  <p>El ejemplo anterior creará un mensaje de Slack con el siguiente aspecto:</p>\n  \n  <h4>Contenido adjunto de rebajas</h4>\n  <p>Si algunos de los campos de los archivos adjuntos contienen Markdown, puede usar el <code>markdown</code>método para indicarle a Slack que analice y muestre los campos adjuntos dados como texto con formato Markdown. Los valores aceptados por este método son: <code>pretext</code>, <code>text</code>y / o <code>fields</code>. Para obtener más información sobre el formato de los archivos adjuntos de Slack, consulte la documentación de la API de Slack :</p>\n  <pre><code>/**\n * Get the Slack representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return SlackMessage\n */\npublic function toSlack($notifiable)\n{\n    $url = url('/exceptions/'.$this-&gt;exception-&gt;id);\n\n    return (new SlackMessage)\n                -&gt;error()\n                -&gt;content('Whoops! Something went wrong.')\n                -&gt;attachment(function ($attachment) use ($url) {\n                    $attachment-&gt;title('Exception: File Not Found', $url)\n                               -&gt;content('File [background.jpg] was *not found*.')\n                               -&gt;markdown(['text']);\n                });\n}</code></pre>\n  <p></p>\n  <h3>Enrutamiento de notificaciones de holgura</h3>\n  <p>Para enrutar las notificaciones de Slack a la ubicación adecuada, defina un <code>routeNotificationForSlack</code>método en su entidad notificable. Esto debería devolver la URL del webhook a la que se debe enviar la notificación. Las URL de webhook se pueden generar agregando un servicio de \"Webhook entrante\" a su equipo de Slack:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Notifications\\Notifiable;\n\nclass User extends Authenticatable\n{\n    use Notifiable;\n\n    /**\n     * Route notifications for the Slack channel.\n     *\n     * @param  \\Illuminate\\Notifications\\Notification  $notification\n     * @return string\n     */\n    public function routeNotificationForSlack($notification)\n    {\n        return 'https://hooks.slack.com/services/...';\n    }\n}</code></pre>\n  <p></p>\n  <h2>Localización de notificaciones</h2>\n  <p>Laravel le permite enviar notificaciones en una configuración regional diferente al idioma actual, e incluso recordará esta configuración regional si la notificación está en cola.</p>\n  <p>Para lograr esto, la clase ofrece un método para configurar el idioma deseado. La aplicación cambiará a esta configuración regional cuando se formatee la notificación y luego volverá a la configuración regional anterior cuando se complete el formateo:<code>Illuminate\\Notifications\\Notification</code><code>locale</code></p>\n  <pre><code>$user-&gt;notify((new InvoicePaid($invoice))-&gt;locale('es'));</code></pre>\n  <p>La localización de múltiples entradas notificables también se puede lograr a través de la <code>Notification</code>fachada:</p>\n  <pre><code>Notification::locale('es')-&gt;send($users, new InvoicePaid($invoice));</code></pre>\n  <h3>Locales preferidos por el usuario</h3>\n  <p>A veces, las aplicaciones almacenan la configuración regional preferida de cada usuario. Al implementar el <code>HasLocalePreference</code>contrato en su modelo notificable, puede indicar a Laravel que use esta configuración regional almacenada al enviar una notificación:</p>\n  <pre><code>use Illuminate\\Contracts\\Translation\\HasLocalePreference;\n\nclass User extends Model implements HasLocalePreference\n{\n    /**\n     * Get the user's preferred locale.\n     *\n     * @return string\n     */\n    public function preferredLocale()\n    {\n        return $this-&gt;locale;\n    }\n}</code></pre>\n  <p>Una vez que haya implementado la interfaz, Laravel usará automáticamente la configuración regional preferida al enviar notificaciones y mensajes de correo electrónico al modelo. Por lo tanto, no es necesario llamar al <code>locale</code>método cuando se usa esta interfaz:</p>\n  <pre><code>$user-&gt;notify(new InvoicePaid($invoice));</code></pre>\n  <p></p>\n  <h2>Eventos de notificación</h2>\n  <p>Cuando se envía una notificación, el sistema de notificación activa el evento. Contiene la entidad \"notificable\" y la propia instancia de notificación. Puede registrar oyentes para este evento en su :<code>Illuminate\\Notifications\\Events\\NotificationSent</code><code>EventServiceProvider</code></p>\n  <pre><code>/**\n * The event listener mappings for the application.\n *\n * @var array\n */\nprotected $listen = [\n    'Illuminate\\Notifications\\Events\\NotificationSent' =&gt; [\n        'App\\Listeners\\LogNotification',\n    ],\n];</code></pre>\n  <blockquote>\n    <div><div></div><p>Después de registrar oyentes en su <code>EventServiceProvider</code>, use el comando Artisan para generar rápidamente clases de oyentes.<code>event:generate</code></p></div>\n  </blockquote>\n  <p>Dentro de un detector de eventos, es posible acceder a los <code>notifiable</code>, <code>notification</code>y <code>channel</code>propiedades en el evento para obtener más información sobre el destinatario de la notificación o de la propia notificación:</p>\n  <pre><code>/**\n * Handle the event.\n *\n * @param  NotificationSent  $event\n * @return void\n */\npublic function handle(NotificationSent $event)\n{\n    // $event-&gt;channel\n    // $event-&gt;notifiable\n    // $event-&gt;notification\n    // $event-&gt;response\n}</code></pre>\n  <p></p>\n  <h2>Canales personalizados</h2>\n  <p>Laravel se envía con un puñado de canales de notificación, pero es posible que desee escribir sus propios controladores para enviar notificaciones a través de otros canales. Laravel lo hace simple. Para comenzar, defina una clase que contenga un <code>send</code>método. El método debe recibir dos argumentos: ay <code>$notifiable</code>a <code>$notification</code>:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Channels;\n\nuse Illuminate\\Notifications\\Notification;\n\nclass VoiceChannel\n{\n    /**\n     * Send the given notification.\n     *\n     * @param  mixed  $notifiable\n     * @param  \\Illuminate\\Notifications\\Notification  $notification\n     * @return void\n     */\n    public function send($notifiable, Notification $notification)\n    {\n        $message = $notification-&gt;toVoice($notifiable);\n\n        // Send notification to the $notifiable instance...\n    }\n}</code></pre>\n  <p>Una vez que se ha definido su clase de canal de notificación, puede devolver el nombre de la clase del <code>via</code>método de cualquiera de sus notificaciones:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Notifications;\n\nuse App\\Channels\\Messages\\VoiceMessage;\nuse App\\Channels\\VoiceChannel;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Notifications\\Notification;\n\nclass InvoicePaid extends Notification\n{\n    use Queueable;\n\n    /**\n     * Get the notification channels.\n     *\n     * @param  mixed  $notifiable\n     * @return array|string\n     */\n    public function via($notifiable)\n    {\n        return [VoiceChannel::class];\n    }\n\n    /**\n     * Get the voice representation of the notification.\n     *\n     * @param  mixed  $notifiable\n     * @return VoiceMessage\n     */\n    public function toVoice($notifiable)\n    {\n        // ...\n    }\n}</code></pre>\n</section>"
      },
      {
        "titulo": "6.10 Desarrollo de paquetes",
        "contenido": "<section>\n  <h1>Desarrollo de paquetes</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Una nota sobre las fachadas</li>\n      </ul></li>\n    <li>Descubrimiento de paquetes</li>\n    <li>Proveedores de servicio</li>\n    <li>Recursos\n      <ul>\n        <li>Configuración</li>\n        <li>Migraciones</li>\n        <li>Rutas</li>\n        <li>Traducciones</li>\n        <li>Puntos de vista</li>\n        <li>Ver componentes</li>\n      </ul></li>\n    <li>Comandos</li>\n    <li>Activos públicos</li>\n    <li>Publicar grupos de archivos</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Los paquetes son la forma principal de agregar funcionalidad a Laravel. Los paquetes pueden ser cualquier cosa, desde una excelente manera de trabajar con fechas como Carbon , o todo un marco de pruebas BDD como Behat .</p>\n  <p>Existen diferentes tipos de paquetes. Algunos paquetes son independientes, lo que significa que funcionan con cualquier marco PHP. Carbon y Behat son ejemplos de paquetes independientes. Cualquiera de estos paquetes se puede usar con Laravel solicitándolos en su archivo.<code>composer.json</code></p>\n  <p>Por otro lado, otros paquetes están diseñados específicamente para usarse con Laravel. Estos paquetes pueden tener rutas, controladores, vistas y configuraciones destinadas específicamente a mejorar una aplicación de Laravel. Esta guía cubre principalmente el desarrollo de aquellos paquetes que son específicos de Laravel.</p>\n  <p></p>\n  <h3>Una nota sobre las fachadas</h3>\n  <p>Al escribir una aplicación Laravel, generalmente no importa si usa contratos o fachadas, ya que ambos proporcionan niveles esencialmente iguales de probabilidad. Sin embargo, al escribir paquetes, su paquete normalmente no tendrá acceso a todos los ayudantes de prueba de Laravel. Si desea poder escribir las pruebas de su paquete como si existieran dentro de una aplicación típica de Laravel, puede usar el paquete Orchestral Testbench .</p>\n  <p></p>\n  <h2>Descubrimiento de paquetes</h2>\n  <p>En el archivo de configuración de una aplicación de Laravel , la opción define una lista de proveedores de servicios que Laravel debería cargar. Cuando alguien instala su paquete, normalmente querrá que su proveedor de servicios esté incluido en esta lista. En lugar de solicitar a los usuarios que agreguen manualmente su proveedor de servicios a la lista, puede definir el proveedor en la sección del archivo de su paquete . Además de los proveedores de servicios, también puede enumerar las fachadas que le gustaría registrar:<code>config/app.php</code><code>providers</code><code>extra</code><code>composer.json</code></p>\n  <pre><code>\"extra\": {\n    \"laravel\": {\n        \"providers\": [\n            \"Barryvdh\\\\Debugbar\\\\ServiceProvider\"\n        ],\n        \"aliases\": {\n            \"Debugbar\": \"Barryvdh\\\\Debugbar\\\\Facade\"\n        }\n    }\n},</code></pre>\n  <p>Una vez que su paquete se haya configurado para el descubrimiento, Laravel registrará automáticamente sus proveedores de servicios y fachadas cuando se instale, creando una experiencia de instalación conveniente para los usuarios de su paquete.</p>\n  <h3>Optar por no participar en el descubrimiento de paquetes</h3>\n  <p>Si usted es el consumidor de un paquete y desea deshabilitar el descubrimiento de paquetes para un paquete, puede incluir el nombre del paquete en la <code>extra</code>sección del archivo de su aplicación :<code>composer.json</code></p>\n  <pre><code>\"extra\": {\n    \"laravel\": {\n        \"dont-discover\": [\n            \"barryvdh/laravel-debugbar\"\n        ]\n    }\n},</code></pre>\n  <p>Puede deshabilitar el descubrimiento de paquetes para todos los paquetes usando el <code>*</code>carácter dentro de la directiva de su aplicación :<code>dont-discover</code></p>\n  <pre><code>\"extra\": {\n    \"laravel\": {\n        \"dont-discover\": [\n            \"*\"\n        ]\n    }\n},</code></pre>\n  <p></p>\n  <h2>Proveedores de servicio</h2>\n  <p>Los proveedores de servicios son los puntos de conexión entre su paquete y Laravel. Un proveedor de servicios es responsable de vincular cosas en el contenedor de servicios de Laravel e informar a Laravel dónde cargar los recursos del paquete, como vistas, configuración y archivos de localización.</p>\n  <p>Un proveedor de servicios extiende la clase y contiene dos métodos: y . La clase base se encuentra en el paquete Composer, que debe agregar a las dependencias de su propio paquete. Para obtener más información sobre la estructura y el propósito de los proveedores de servicios, consulte su documentación .<code>Illuminate\\Support\\ServiceProvider</code><code>register</code><code>boot</code><code>ServiceProvider</code><code>illuminate/support</code></p>\n  <p></p>\n  <h2>Recursos</h2>\n  <p></p>\n  <h3>Configuración</h3>\n  <p>Por lo general, deberá publicar el archivo de configuración de su paquete en el <code>config</code>directorio propio de la aplicación . Esto permitirá a los usuarios de su paquete anular fácilmente sus opciones de configuración predeterminadas. Para permitir que se publiquen sus archivos de configuración, llame al <code>publishes</code>método desde el <code>boot</code>método de su proveedor de servicios:</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;publishes([\n        __DIR__.'/path/to/config/courier.php' =&gt; config_path('courier.php'),\n    ]);\n}</code></pre>\n  <p>Ahora, cuando los usuarios de su paquete ejecuten el comando de Laravel , su archivo se copiará en la ubicación de publicación especificada. Una vez que se ha publicado su configuración, se puede acceder a sus valores como cualquier otro archivo de configuración:<code>vendor:publish</code></p>\n  <pre><code>$value = config('courier.option');</code></pre>\n  <blockquote>\n    <div><div></div><p>No debe definir cierres en sus archivos de configuración. No se pueden serializar correctamente cuando los usuarios ejecutan el comando Artisan.<code>config:cache</code></p></div>\n  </blockquote>\n  <h4>Configuración de paquete predeterminada</h4>\n  <p>También puede fusionar su propio archivo de configuración de paquete con la copia publicada de la aplicación. Esto permitirá a sus usuarios definir solo las opciones que realmente quieren anular en la copia publicada de la configuración. Para fusionar las configuraciones, use el <code>mergeConfigFrom</code>método dentro del método de su proveedor de servicios <code>register</code>:</p>\n  <pre><code>/**\n * Register any application services.\n *\n * @return void\n */\npublic function register()\n{\n    $this-&gt;mergeConfigFrom(\n        __DIR__.'/path/to/config/courier.php', 'courier'\n    );\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Este método solo fusiona el primer nivel de la matriz de configuración. Si sus usuarios definen parcialmente una matriz de configuración multidimensional, las opciones que faltan no se fusionarán.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Rutas</h3>\n  <p>Si su paquete contiene rutas, puede cargarlas usando el <code>loadRoutesFrom</code>método. Este método determinará automáticamente si las rutas de la aplicación están almacenadas en caché y no cargará su archivo de rutas si las rutas ya se han almacenado en caché:</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;loadRoutesFrom(__DIR__.'/routes.php');\n}</code></pre>\n  <p></p>\n  <h3>Migraciones</h3>\n  <p>Si su paquete contiene migraciones de base de datos , puede usar el <code>loadMigrationsFrom</code>método para informar a Laravel cómo cargarlas. El <code>loadMigrationsFrom</code>método acepta la ruta a las migraciones de su paquete como su único argumento:</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;loadMigrationsFrom(__DIR__.'/path/to/migrations');\n}</code></pre>\n  <p>Una vez que se hayan registrado las migraciones de su paquete, se ejecutarán automáticamente cuando se ejecute el <code>php artisan migrate</code>comando. No es necesario exportarlos al directorio principal de la aplicación .<code>database/migrations</code></p>\n  <p></p>\n  <h3>Traducciones</h3>\n  <p>Si su paquete contiene archivos de traducción , puede usar el <code>loadTranslationsFrom</code>método para informar a Laravel cómo cargarlos. Por ejemplo, si su paquete tiene un nombre <code>courier</code>, debe agregar lo siguiente al <code>boot</code>método de su proveedor de servicios :</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;loadTranslationsFrom(__DIR__.'/path/to/translations', 'courier');\n}</code></pre>\n  <p>Se hace referencia a las traducciones de paquetes mediante la convención de sintaxis. Por lo tanto, puede cargar la línea del paquete desde el archivo así:<code>package::file.line</code><code>courier</code><code>welcome</code><code>messages</code></p>\n  <pre><code>echo trans('courier::messages.welcome');</code></pre>\n  <h4>Publicación de traducciones</h4>\n  <p>Si desea publicar las traducciones de su paquete en el directorio de la aplicación , puede utilizar el método del proveedor de servicios . El método acepta una serie de rutas de paquetes y sus ubicaciones de publicación deseadas. Por ejemplo, para publicar los archivos de traducción del paquete, puede hacer lo siguiente:<code>resources/lang/vendor</code><code>publishes</code><code>publishes</code><code>courier</code></p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;loadTranslationsFrom(__DIR__.'/path/to/translations', 'courier');\n\n    $this-&gt;publishes([\n        __DIR__.'/path/to/translations' =&gt; resource_path('lang/vendor/courier'),\n    ]);\n}</code></pre>\n  <p>Ahora, cuando los usuarios de su paquete ejecuten el comando Artisan de Laravel , las traducciones de su paquete se publicarán en la ubicación de publicación especificada.<code>vendor:publish</code></p>\n  <p></p>\n  <h3>Puntos de vista</h3>\n  <p>Para registrar las vistas de su paquete con Laravel, debe decirle a Laravel dónde se encuentran las vistas. Puede hacer esto usando el <code>loadViewsFrom</code>método del proveedor de servicios . El <code>loadViewsFrom</code>método acepta dos argumentos: la ruta a sus plantillas de vista y el nombre de su paquete. Por ejemplo, si el nombre de su paquete es <code>courier</code>, agregaría lo siguiente al <code>boot</code>método de su proveedor de servicios :</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;loadViewsFrom(__DIR__.'/path/to/views', 'courier');\n}</code></pre>\n  <p>Se hace referencia a las vistas de paquetes utilizando la convención de sintaxis. Entonces, una vez que su ruta de vista esté registrada en un proveedor de servicios, puede cargar la vista desde el paquete de la siguiente manera:<code>package::view</code><code>admin</code><code>courier</code></p>\n  <pre><code>Route::get('admin', function () {\n    return view('courier::admin');\n});</code></pre>\n  <h4>Anulación de vistas de paquetes</h4>\n  <p>Cuando usa el <code>loadViewsFrom</code>método, Laravel registra dos ubicaciones para sus vistas: el directorio de la aplicación y el directorio que usted especifica. Entonces, usando el ejemplo, Laravel primero verificará si el desarrollador ha proporcionado una versión personalizada de la vista en . Luego, si la vista no se ha personalizado, Laravel buscará en el directorio de vista del paquete que especificó en su llamada . Esto hace que sea fácil para los usuarios de paquetes personalizar / anular las vistas de su paquete.<code>resources/views/vendor</code><code>courier</code><code>resources/views/vendor/courier</code><code>loadViewsFrom</code></p>\n  <h4>Publicar vistas</h4>\n  <p>Si desea que sus vistas estén disponibles para su publicación en el directorio de la aplicación , puede utilizar el método del proveedor de servicios . El método acepta una variedad de rutas de vista de paquetes y sus ubicaciones de publicación deseadas:<code>resources/views/vendor</code><code>publishes</code><code>publishes</code></p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;loadViewsFrom(__DIR__.'/path/to/views', 'courier');\n\n    $this-&gt;publishes([\n        __DIR__.'/path/to/views' =&gt; resource_path('views/vendor/courier'),\n    ]);\n}</code></pre>\n  <p>Ahora, cuando los usuarios de su paquete ejecuten el comando Artisan de Laravel , las vistas de su paquete se copiarán en la ubicación de publicación especificada.<code>vendor:publish</code></p>\n  <p></p>\n  <h3>Ver componentes</h3>\n  <p>Si su paquete contiene componentes de vista , puede usar el <code>loadViewComponentsAs</code>método para informar a Laravel cómo cargarlos. El <code>loadViewComponentsAs</code>método acepta dos argumentos: el prefijo de etiqueta para sus componentes de vista y una matriz de su clase de componentes de vista. Por ejemplo, si el prefijo de su paquete es <code>courier</code>y tiene <code>Alert</code>y <code>Button</code>ve componentes, agregaría lo siguiente al <code>boot</code>método de su proveedor de servicios :</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;loadViewComponentsAs('courier', [\n        Alert::class,\n        Button::class,\n    ]);\n}</code></pre>\n  <p>Una vez que los componentes de su vista estén registrados en un proveedor de servicios, puede hacer referencia a ellos en su vista de la siguiente manera:</p>\n  <pre><code>&lt;x-courier-alert /&gt;\n\n&lt;x-courier-button /&gt;</code></pre>\n  <h4>Componentes anónimos</h4>\n  <p>Si su paquete contiene componentes anónimos, deben colocarse dentro de un <code>components</code>directorio del directorio \"vistas\" de su paquete (como lo especifica <code>loadViewsFrom</code>). Luego, puede representarlos prefijando el nombre del componente con el espacio de nombres de la vista del paquete:</p>\n  <pre><code>&lt;x-courier::alert /&gt;</code></pre>\n  <p></p>\n  <h2>Comandos</h2>\n  <p>Para registrar los comandos Artisan de su paquete con Laravel, puede usar el <code>commands</code>método. Este método espera una matriz de nombres de clases de comandos. Una vez registrados los comandos, puede ejecutarlos utilizando la CLI de Artisan :</p>\n  <pre><code>/**\n * Bootstrap the application services.\n *\n * @return void\n */\npublic function boot()\n{\n    if ($this-&gt;app-&gt;runningInConsole()) {\n        $this-&gt;commands([\n            FooCommand::class,\n            BarCommand::class,\n        ]);\n    }\n}</code></pre>\n  <p></p>\n  <h2>Activos públicos</h2>\n  <p>Su paquete puede tener activos como JavaScript, CSS e imágenes. Para publicar estos activos en el <code>public</code>directorio de la aplicación , utilice el <code>publishes</code>método del proveedor de servicios . En este ejemplo, también agregaremos una <code>public</code>etiqueta de grupo de activos, que se puede usar para publicar grupos de activos relacionados:</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;publishes([\n        __DIR__.'/path/to/assets' =&gt; public_path('vendor/courier'),\n    ], 'public');\n}</code></pre>\n  <p>Ahora, cuando los usuarios de su paquete ejecuten el comando, sus activos se copiarán en la ubicación de publicación especificada. Dado que normalmente necesitará sobrescribir los activos cada vez que se actualice el paquete, puede usar la marca:<code>vendor:publish</code><code>--force</code></p>\n  <pre><code>php artisan vendor:publish --tag=public --force</code></pre>\n  <p></p>\n  <h2>Publicar grupos de archivos</h2>\n  <p>Es posible que desee publicar grupos de activos y recursos de paquetes por separado. Por ejemplo, es posible que desee permitir que sus usuarios publiquen los archivos de configuración de su paquete sin verse obligados a publicar los activos de su paquete. Puede hacer esto \"etiquetándolos\" cuando llame al <code>publishes</code>método del proveedor de servicios de un paquete. Por ejemplo, usemos etiquetas para definir dos grupos de publicación en el <code>boot</code>método de un proveedor de servicios de paquetes:</p>\n  <pre><code>/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    $this-&gt;publishes([\n        __DIR__.'/../config/package.php' =&gt; config_path('package.php')\n    ], 'config');\n\n    $this-&gt;publishes([\n        __DIR__.'/../database/migrations/' =&gt; database_path('migrations')\n    ], 'migrations');\n}</code></pre>\n  <p>Ahora sus usuarios pueden publicar estos grupos por separado haciendo referencia a su etiqueta al ejecutar el comando:<code>vendor:publish</code></p>\n  <pre><code>php artisan vendor:publish --tag=config</code></pre>\n</section>"
      },
      {
        "titulo": "6.11 Colas",
        "contenido": "<section>\n  <h1>Colas</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Conexiones vs. Colas</li>\n        <li>Notas y requisitos previos del controlador</li>\n      </ul></li>\n    <li>Creando trabajos\n      <ul>\n        <li>Generación de clases de trabajo</li>\n        <li>Estructura de clase</li>\n        <li>Middleware de trabajo</li>\n      </ul></li>\n    <li>Envío de trabajos\n      <ul>\n        <li>Envío retrasado</li>\n        <li>Despacho sincrónico</li>\n        <li>Encadenamiento laboral</li>\n        <li>Personalizar la cola y la conexión</li>\n        <li>Especificación de valores máximos de intentos de trabajo / tiempo de espera</li>\n        <li>Limitación de tasa</li>\n        <li>Manejo de errores</li>\n      </ul></li>\n    <li>Trabajo por lotes\n      <ul>\n        <li>Definición de trabajos por lotes</li>\n        <li>Envío de lotes</li>\n        <li>Adición de trabajos a lotes</li>\n        <li>Inspección de lotes</li>\n        <li>Cancelación de lotes</li>\n        <li>Fallos de lote</li>\n      </ul></li>\n    <li>Cierres de colas</li>\n    <li>Ejecutar el trabajador de cola\n      <ul>\n        <li>Prioridades de cola</li>\n        <li>Trabajadores de cola e implementación</li>\n        <li>Caducidad de trabajos y tiempos de espera</li>\n      </ul></li>\n    <li>Configuración del supervisor</li>\n    <li>Manejo de trabajos fallidos\n      <ul>\n        <li>Limpieza después de trabajos fallidos</li>\n        <li>Eventos de trabajo fallidos</li>\n        <li>Reintentar trabajos fallidos</li>\n        <li>Ignorar modelos faltantes</li>\n      </ul></li>\n    <li>Borrar trabajos de las colas</li>\n    <li>Eventos laborales</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <blockquote>\n    <div><div></div><p>Laravel ahora ofrece Horizon, un hermoso panel de control y un sistema de configuración para sus colas impulsadas por Redis. Consulte la documentación completa de Horizon para obtener más información.</p></div>\n  </blockquote>\n  <p>Las colas de Laravel proporcionan una API unificada en una variedad de backends de cola diferentes, como Beanstalk, Amazon SQS, Redis o incluso una base de datos relacional. Las colas le permiten aplazar el procesamiento de una tarea que requiere mucho tiempo, como enviar un correo electrónico, hasta más adelante. Aplazar estas tareas que consumen mucho tiempo acelera drásticamente las solicitudes web a su aplicación.</p>\n  <p>El archivo de configuración de la cola se almacena en . En este archivo encontrará configuraciones de conexión para cada uno de los controladores de cola que se incluyen con el marco, que incluye una base de datos, Beanstalkd , Amazon SQS , Redis y un controlador síncrono que ejecutará los trabajos de inmediato (para uso local). También se incluye un controlador de cola que descarta los trabajos en cola.<code>config/queue.php</code><code>null</code></p>\n  <p></p>\n  <h3>Conexiones vs. Colas</h3>\n  <p>Antes de comenzar con las colas de Laravel, es importante comprender la distinción entre \"conexiones\" y \"colas\". En su archivo de configuración, hay una opción de configuración. Esta opción define una conexión particular a un servicio de backend como Amazon SQS, Beanstalk o Redis. Sin embargo, cualquier conexión de cola determinada puede tener varias \"colas\" que pueden considerarse como diferentes pilas o pilas de trabajos en cola.<code>config/queue.php</code><code>connections</code></p>\n  <p>Tenga en cuenta que cada ejemplo de configuración de conexión en el <code>queue</code>archivo de configuración contiene un <code>queue</code>atributo. Esta es la cola predeterminada a la que se enviarán los trabajos cuando se envíen a una conexión determinada. En otras palabras, si envía un trabajo sin definir explícitamente a qué cola se debe enviar, el trabajo se colocará en la cola que se define en el <code>queue</code>atributo de la configuración de la conexión:</p>\n  <pre><code>// This job is sent to the default queue...\nJob::dispatch();\n\n// This job is sent to the \"emails\" queue...\nJob::dispatch()-&gt;onQueue('emails');</code></pre>\n  <p>Es posible que algunas aplicaciones no necesiten enviar trabajos a varias colas, sino que prefieren tener una cola simple. Sin embargo, enviar trabajos a múltiples colas puede ser especialmente útil para aplicaciones que desean priorizar o segmentar cómo se procesan los trabajos, ya que el trabajador de cola de Laravel le permite especificar qué colas debe procesar por prioridad. Por ejemplo, si envía trabajos a una <code>high</code>cola, puede ejecutar un trabajador que les dé mayor prioridad de procesamiento:</p>\n  <pre><code>php artisan queue:work --queue=high,default</code></pre>\n  <p></p>\n  <h3>Notas y requisitos previos del controlador</h3>\n  <h4>Base de datos</h4>\n  <p>Para utilizar el <code>database</code>controlador de cola, necesitará una tabla de base de datos para contener los trabajos. Para generar una migración que cree esta tabla, ejecute el comando Artisan. Una vez que se ha creado la migración, puede migrar su base de datos usando el comando:<code>queue:table</code><code>migrate</code></p>\n  <pre><code>php artisan queue:table\n\nphp artisan migrate</code></pre>\n  <h4>Redis</h4>\n  <p>Para utilizar el <code>redis</code>controlador de cola, debe configurar una conexión de base de datos de Redis en su archivo de configuración.<code>config/database.php</code></p>\n  <p><strong>Clúster de Redis</strong></p>\n  <p>Si su conexión de cola de Redis utiliza un clúster de Redis, sus nombres de cola deben contener una etiqueta hash clave . Esto es necesario para garantizar que todas las claves de Redis para una cola determinada se coloquen en la misma ranura hash:</p>\n  <pre><code>'redis' =&gt; [\n    'driver' =&gt; 'redis',\n    'connection' =&gt; 'default',\n    'queue' =&gt; '{default}',\n    'retry_after' =&gt; 90,\n],</code></pre>\n  <p><strong>Bloqueo</strong></p>\n  <p>Al usar la cola de Redis, puede usar la <code>block_for</code>opción de configuración para especificar cuánto tiempo debe esperar el controlador para que un trabajo esté disponible antes de recorrer el ciclo de trabajo y volver a sondear la base de datos de Redis.</p>\n  <p>Ajustar este valor en función de la carga de la cola puede ser más eficiente que sondear continuamente la base de datos de Redis en busca de nuevos trabajos. Por ejemplo, puede establecer el valor en <code>5</code>para indicar que el controlador debe bloquearse durante cinco segundos mientras espera que un trabajo esté disponible:</p>\n  <pre><code>'redis' =&gt; [\n    'driver' =&gt; 'redis',\n    'connection' =&gt; 'default',\n    'queue' =&gt; 'default',\n    'retry_after' =&gt; 90,\n    'block_for' =&gt; 5,\n],</code></pre>\n  <blockquote>\n    <div><div></div><p>Si se establece <code>block_for</code>en <code>0</code>, los trabajadores de la cola se bloquearán indefinidamente hasta que haya un trabajo disponible. Esto también evitará que <code>SIGTERM</code>se manejen señales como, por ejemplo, hasta que se haya procesado el siguiente trabajo.</p></div>\n  </blockquote>\n  <h4>Otros requisitos previos del controlador</h4>\n  <p>Las siguientes dependencias son necesarias para los controladores de cola enumerados:</p>\n  <div>\n    <ul>\n      <li>Amazon SQS: <code>aws/aws-sdk-php ~3.0</code></li>\n      <li>Beanstalkd: <code>pda/pheanstalk ~4.0</code></li>\n      <li>Redis: o extensión PHP phpredis<code>predis/predis ~1.0</code></li>\n    </ul>\n  </div>\n  <p></p>\n  <h2>Creando trabajos</h2>\n  <p></p>\n  <h3>Generación de clases de trabajo</h3>\n  <p>De forma predeterminada, todos los trabajos que se pueden poner en cola para su aplicación se almacenan en el directorio. Si el directorio no existe, se creará cuando ejecute el comando Artisan. Puede generar un nuevo trabajo en cola utilizando Artisan CLI:<code>app/Jobs</code><code>app/Jobs</code><code>make:job</code></p>\n  <pre><code>php artisan make:job ProcessPodcast</code></pre>\n  <p>La clase generada implementará la interfaz, indicando a Laravel que el trabajo debe ser empujado a la cola para que se ejecute de forma asincrónica.<code>Illuminate\\Contracts\\Queue\\ShouldQueue</code></p>\n  <blockquote>\n    <div><div></div><p>Los resguardos de trabajos se pueden personalizar mediante la publicación de resguardos</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Estructura de clase</h3>\n  <p>Las clases de trabajos son muy simples, normalmente contienen solo un <code>handle</code>método que se llama cuando el trabajo es procesado por la cola. Para comenzar, echemos un vistazo a una clase de trabajo de ejemplo. En este ejemplo, pretendemos que administramos un servicio de publicación de podcasts y necesitamos procesar los archivos de podcast cargados antes de que se publiquen:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\Podcast;\nuse App\\Services\\AudioProcessor;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass ProcessPodcast implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n    protected $podcast;\n\n    /**\n     * Create a new job instance.\n     *\n     * @param  Podcast  $podcast\n     * @return void\n     */\n    public function __construct(Podcast $podcast)\n    {\n        $this-&gt;podcast = $podcast;\n    }\n\n    /**\n     * Execute the job.\n     *\n     * @param  AudioProcessor  $processor\n     * @return void\n     */\n    public function handle(AudioProcessor $processor)\n    {\n        // Process uploaded podcast...\n    }\n}</code></pre>\n  <p>En este ejemplo, observe que pudimos pasar un modelo Eloquent directamente al constructor del trabajo en cola. Debido al <code>SerializesModels</code>rasgo que está usando el trabajo, los modelos Eloquent y sus relaciones cargadas serán serializados y no serializados elegantemente cuando se procese el trabajo. Si su trabajo en cola acepta un modelo Eloquent en su constructor, solo el identificador del modelo se serializará en la cola. Cuando el trabajo se gestiona realmente, el sistema de colas volverá a recuperar automáticamente la instancia completa del modelo y sus relaciones cargadas de la base de datos. Todo es totalmente transparente para su aplicación y evita los problemas que pueden surgir al serializar instancias del modelo Eloquent completo.</p>\n  <p>The <code>handle</code> method is called when the job is processed by the queue. Note that we are able to type-hint dependencies on the <code>handle</code> method of the job. The Laravel service container automatically injects these dependencies.</p>\n  <p>If you would like to take total control over how the container injects dependencies into the <code>handle</code> method, you may use the container's <code>bindMethod</code> method. The <code>bindMethod</code> method accepts a callback which receives the job and the container. Within the callback, you are free to invoke the <code>handle</code> method however you wish. Typically, you should call this method from a service provider:</p>\n  <pre><code>use App\\Jobs\\ProcessPodcast;\n\n$this-&gt;app-&gt;bindMethod(ProcessPodcast::class.'@handle', function ($job, $app) {\n    return $job-&gt;handle($app-&gt;make(AudioProcessor::class));\n});</code></pre>\n  <blockquote>\n    <div><div></div><p>Los datos binarios, como el contenido de imágenes sin procesar, se deben pasar a través de la <code>base64_encode</code>función antes de pasar a un trabajo en cola. De lo contrario, es posible que el trabajo no se serialice correctamente en JSON cuando se coloca en la cola.</p></div>\n  </blockquote>\n  <h4>Manejo de relaciones</h4>\n  <p>Dado que las relaciones cargadas también se serializan, la cadena de trabajo serializada puede llegar a ser bastante grande. Para evitar que las relaciones se serialicen, puede llamar al <code>withoutRelations</code>método en el modelo al establecer un valor de propiedad. Este método devolverá una instancia del modelo sin relaciones cargadas:</p>\n  <pre><code>/**\n * Create a new job instance.\n *\n * @param  \\App\\Models\\Podcast  $podcast\n * @return void\n */\npublic function __construct(Podcast $podcast)\n{\n    $this-&gt;podcast = $podcast-&gt;withoutRelations();\n}</code></pre>\n  <p></p>\n  <h3>Middleware de trabajo</h3>\n  <p>El middleware de trabajos le permite envolver la lógica personalizada en torno a la ejecución de trabajos en cola, reduciendo el texto estándar en los trabajos mismos. Por ejemplo, considere el siguiente <code>handle</code>método que aprovecha las funciones de limitación de velocidad de Redis de Laravel para permitir que solo se procese un trabajo cada cinco segundos:</p>\n  <pre><code>/**\n * Execute the job.\n *\n * @return void\n */\npublic function handle()\n{\n    Redis::throttle('key')-&gt;block(0)-&gt;allow(1)-&gt;every(5)-&gt;then(function () {\n        info('Lock obtained...');\n\n        // Handle job...\n    }, function () {\n        // Could not obtain lock...\n\n        return $this-&gt;release(5);\n    });\n}</code></pre>\n  <p>Si bien este código es válido, la estructura del <code>handle</code>método se vuelve ruidosa ya que está abarrotada de lógica de limitación de velocidad de Redis. Además, esta lógica de limitación de velocidad debe duplicarse para cualquier otro trabajo que queramos limitar.</p>\n  <p>En lugar de limitar la velocidad en el método de control, podríamos definir un middleware de trabajo que maneje la limitación de velocidad. Laravel no tiene una ubicación predeterminada para el middleware de trabajos, por lo que puede colocar el middleware de trabajos en cualquier lugar de su aplicación. En este ejemplo, colocaremos el middleware en un directorio:<code>app/Jobs/Middleware</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Jobs\\Middleware;\n\nuse Illuminate\\Support\\Facades\\Redis;\n\nclass RateLimited\n{\n    /**\n     * Process the queued job.\n     *\n     * @param  mixed  $job\n     * @param  callable  $next\n     * @return mixed\n     */\n    public function handle($job, $next)\n    {\n        Redis::throttle('key')\n                -&gt;block(0)-&gt;allow(1)-&gt;every(5)\n                -&gt;then(function () use ($job, $next) {\n                    // Lock obtained...\n\n                    $next($job);\n                }, function () use ($job) {\n                    // Could not obtain lock...\n\n                    $job-&gt;release(5);\n                });\n    }\n}</code></pre>\n  <p>Como puede ver, al igual que el middleware de ruta , el middleware de trabajos recibe el trabajo que se está procesando y una devolución de llamada que debe invocarse para continuar procesando el trabajo.</p>\n  <p>Después de crear el middleware de trabajos, se pueden adjuntar a un trabajo devolviéndolos desde el <code>middleware</code>método del trabajo . Este método no existe en los trabajos con scaffolding por el comando Artisan, por lo que deberá agregarlo a su propia definición de clase de trabajo:<code>make:job</code></p>\n  <pre><code>use App\\Jobs\\Middleware\\RateLimited;\n\n/**\n * Get the middleware the job should pass through.\n *\n * @return array\n */\npublic function middleware()\n{\n    return [new RateLimited];\n}</code></pre>\n  <p></p>\n  <h2>Envío de trabajos</h2>\n  <p>Una vez que haya escrito su clase de trabajo, puede enviarla utilizando el <code>dispatch</code>método del trabajo en sí. Los argumentos pasados \u200B\u200Bal <code>dispatch</code>método se entregarán al constructor del trabajo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Jobs\\ProcessPodcast;\nuse Illuminate\\Http\\Request;\n\nclass PodcastController extends Controller\n{\n    /**\n     * Store a new podcast.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        // Create podcast...\n\n        ProcessPodcast::dispatch($podcast);\n    }\n}</code></pre>\n  <p>Si desea enviar un trabajo condicionalmente, puede usar los métodos <code>dispatchIf</code>y <code>dispatchUnless</code>:</p>\n  <pre><code>ProcessPodcast::dispatchIf($accountActive === true, $podcast);\n\nProcessPodcast::dispatchUnless($accountSuspended === false, $podcast);</code></pre>\n  <p></p>\n  <h3>Envío retrasado</h3>\n  <p>Si desea retrasar la ejecución de un trabajo en cola, puede utilizar el <code>delay</code>método al enviar un trabajo. Por ejemplo, especifiquemos que un trabajo no debe estar disponible para su procesamiento hasta 10 minutos después de que se haya enviado:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Jobs\\ProcessPodcast;\nuse Illuminate\\Http\\Request;\n\nclass PodcastController extends Controller\n{\n    /**\n     * Store a new podcast.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        // Create podcast...\n\n        ProcessPodcast::dispatch($podcast)\n                -&gt;delay(now()-&gt;addMinutes(10));\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p> El servicio de cola de Amazon SQS tiene un tiempo de retraso máximo de 15 minutos.</p></div>\n  </blockquote>\n  <h4>Envío después de que la respuesta se envía al navegador</h4>\n  <p>Alternatively, the <code>dispatchAfterResponse</code> method delays dispatching a job until after the response is sent to the user's browser. This will still allow the user to begin using the application even though a queued job is still executing. This should typically only be used for jobs that take about a second, such as sending an email:</p>\n  <pre><code>use App\\Jobs\\SendNotification;\n\nSendNotification::dispatchAfterResponse();</code></pre>\n  <p>You may <code>dispatch</code> a Closure and chain the <code>afterResponse</code> method onto the helper to execute a Closure after the response has been sent to the browser:</p>\n  <pre><code>use App\\Mail\\WelcomeMessage;\nuse Illuminate\\Support\\Facades\\Mail;\n\ndispatch(function () {\n    Mail::to('taylor@laravel.com')-&gt;send(new WelcomeMessage);\n})-&gt;afterResponse();</code></pre>\n  <p></p>\n  <h3>Synchronous Dispatching</h3>\n  <p>If you would like to dispatch a job immediately (synchronously), you may use the <code>dispatchSync</code> method. When using this method, the job will not be queued and will be run immediately within the current process:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Jobs\\ProcessPodcast;\nuse Illuminate\\Http\\Request;\n\nclass PodcastController extends Controller\n{\n    /**\n     * Store a new podcast.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        // Create podcast...\n\n        ProcessPodcast::dispatchSync($podcast);\n    }\n}</code></pre>\n  <p></p>\n  <h3>Job Chaining</h3>\n  <p>El encadenamiento de trabajos le permite especificar una lista de trabajos en cola que deben ejecutarse en secuencia después de que el trabajo principal se haya ejecutado correctamente. Si un trabajo de la secuencia falla, el resto de los trabajos no se ejecutarán. Para ejecutar una cadena de trabajos en cola, puede utilizar el <code>chain</code>método proporcionado por la <code>Bus</code>fachada:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Bus;\n\nBus::chain([\n    new ProcessPodcast,\n    new OptimizePodcast,\n    new ReleasePodcast,\n])-&gt;dispatch();</code></pre>\n  <p>Además de encadenar instancias de clases de trabajo, también puede encadenar cierres:</p>\n  <pre><code>Bus::chain([\n    new ProcessPodcast,\n    new OptimizePodcast,\n    function () {\n        Podcast::update(...);\n    },\n])-&gt;dispatch();</code></pre>\n  <blockquote>\n    <div><div></div><p>La eliminación de trabajos con el método no evitará que se procesen los trabajos encadenados. La cadena solo dejará de ejecutarse si falla un trabajo en la cadena.<code>$this-&gt;delete()</code></p></div>\n  </blockquote>\n  <h4>Conexión en cadena y cola</h4>\n  <p>Si desea especificar la conexión y la cola que deben usarse para los trabajos encadenados, puede usar los métodos <code>onConnection</code>y <code>onQueue</code>. Estos métodos especifican la conexión de la cola y el nombre de la cola que se deben usar a menos que al trabajo en cola se le asigne explícitamente una conexión / cola diferente:</p>\n  <pre><code>Bus::chain([\n    new ProcessPodcast,\n    new OptimizePodcast,\n    new ReleasePodcast,\n])-&gt;onConnection('redis')-&gt;onQueue('podcasts')-&gt;dispatch();</code></pre>\n  <h4>Fallos de cadena</h4>\n  <p>Al encadenar trabajos, puede usar el <code>chain</code>método para especificar un cierre que debe invocarse si falla un trabajo dentro de la cadena. La devolución de llamada dada recibirá la instancia de excepción que causó la falla del trabajo:</p>\n  <pre><code>use Illuminate\\Support\\Facades\\Bus;\nuse Throwable;\n\nBus::chain([\n    new ProcessPodcast,\n    new OptimizePodcast,\n    new ReleasePodcast,\n])-&gt;catch(function (Throwable $e) {\n    // A job within the chain has failed...\n})-&gt;dispatch();</code></pre>\n  <p></p>\n  <h3>Personalizar la cola y la conexión</h3>\n  <h4>Envío a una cola particular</h4>\n  <p>Al enviar trabajos a diferentes colas, puede \"categorizar\" sus trabajos en cola e incluso priorizar cuántos trabajadores asigna a varias colas. Tenga en cuenta que esto no envía trabajos a diferentes \"conexiones\" de cola según lo definido por su archivo de configuración de cola, sino solo a colas específicas dentro de una sola conexión. Para especificar la cola, use el <code>onQueue</code>método al enviar el trabajo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Jobs\\ProcessPodcast;\nuse Illuminate\\Http\\Request;\n\nclass PodcastController extends Controller\n{\n    /**\n     * Store a new podcast.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        // Create podcast...\n\n        ProcessPodcast::dispatch($podcast)-&gt;onQueue('processing');\n    }\n}</code></pre>\n  <h4>Envío a una conexión particular</h4>\n  <p>Si está trabajando con varias conexiones de cola, puede especificar a qué conexión enviar un trabajo. Para especificar la conexión, use el <code>onConnection</code>método al enviar el trabajo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Jobs\\ProcessPodcast;\nuse Illuminate\\Http\\Request;\n\nclass PodcastController extends Controller\n{\n    /**\n     * Store a new podcast.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        // Create podcast...\n\n        ProcessPodcast::dispatch($podcast)-&gt;onConnection('sqs');\n    }\n}</code></pre>\n  <p>Puede encadenar los métodos <code>onConnection</code>y <code>onQueue</code>para especificar la conexión y la cola de un trabajo:</p>\n  <pre><code>ProcessPodcast::dispatch($podcast)\n              -&gt;onConnection('sqs')\n              -&gt;onQueue('processing');</code></pre>\n  <p></p>\n  <h3>Especificación de valores máximos de intentos de trabajo / tiempo de espera</h3>\n  <h4>Intentos máximos</h4>\n  <p>Un método para especificar el número máximo de veces que se puede intentar un trabajo es a través del <code>--tries</code>interruptor en la línea de comando de Artisan:</p>\n  <pre><code>php artisan queue:work --tries=3</code></pre>\n  <p>Sin embargo, puede adoptar un enfoque más granular definiendo el número máximo de intentos en la clase de trabajo en sí. Si se especifica el número máximo de intentos en el trabajo, tendrá prioridad sobre el valor proporcionado en la línea de comando:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Jobs;\n\nclass ProcessPodcast implements ShouldQueue\n{\n    /**\n     * The number of times the job may be attempted.\n     *\n     * @var int\n     */\n    public $tries = 5;\n}</code></pre>\n  <p></p>\n  <h4>Intentos basados \u200B\u200Ben el tiempo</h4>\n  <p>Como alternativa a la definición de cuántas veces se puede intentar un trabajo antes de que falle, puede definir un momento en el que el trabajo debe expirar. Esto permite que un trabajo se intente tantas veces como desee dentro de un período de tiempo determinado. Para definir el tiempo en el que un trabajo debe expirar, agregue un <code>retryUntil</code>método a su clase de trabajo:</p>\n  <pre><code>/**\n * Determine the time at which the job should timeout.\n *\n * @return \\DateTime\n */\npublic function retryUntil()\n{\n    return now()-&gt;addSeconds(5);\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>También puede definir un <code>retryUntil</code>método en sus oyentes de eventos en cola.</p></div>\n  </blockquote>\n  <h4>Excepciones máximas</h4>\n  <p>Sometimes you may wish to specify that a job may be attempted many times, but should fail if the retries are triggered by a given number of exceptions. To accomplish this, you may define a <code>maxExceptions</code> property on your job class:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Jobs;\n\nclass ProcessPodcast implements ShouldQueue\n{\n    /**\n     * The number of times the job may be attempted.\n     *\n     * @var int\n     */\n    public $tries = 25;\n\n    /**\n     * The maximum number of exceptions to allow before failing.\n     *\n     * @var int\n     */\n    public $maxExceptions = 3;\n\n    /**\n     * Execute the job.\n     *\n     * @return void\n     */\n    public function handle()\n    {\n        Redis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () {\n            // Lock obtained, process the podcast...\n        }, function () {\n            // Unable to obtain lock...\n            return $this-&gt;release(10);\n        });\n    }\n}</code></pre>\n  <p>In this example, the job is released for ten seconds if the application is unable to obtain a Redis lock and will continue to be retried up to 25 times. However, the job will fail if three unhandled exceptions are thrown by the job.</p>\n  <h4>Timeout</h4>\n  <blockquote>\n    <div><div></div><p> The <code>pcntl</code> PHP extension must be installed in order to specify job timeouts.</p></div>\n  </blockquote>\n  <p>Likewise, the maximum number of seconds that jobs can run may be specified using the <code>--timeout</code> switch on the Artisan command line:</p>\n  <pre><code>php artisan queue:work --timeout=30</code></pre>\n  <p>Sin embargo, también puede definir el número máximo de segundos que debe permitirse que un trabajo se ejecute en la clase de trabajo en sí. Si el tiempo de espera se especifica en el trabajo, tendrá prioridad sobre cualquier tiempo de espera especificado en la línea de comando:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Jobs;\n\nclass ProcessPodcast implements ShouldQueue\n{\n    /**\n     * The number of seconds the job can run before timing out.\n     *\n     * @var int\n     */\n    public $timeout = 120;\n}</code></pre>\n  <p>A veces, los procesos de bloqueo de E / S, como sockets o conexiones HTTP salientes, pueden no respetar el tiempo de espera especificado. Por lo tanto, al usar estas funciones, siempre debe intentar especificar un tiempo de espera utilizando también sus API. Por ejemplo, al usar Guzzle, siempre debe especificar una conexión y solicitar un valor de tiempo de espera.</p>\n  <p></p>\n  <h3>Limitación de tasa</h3>\n  <blockquote>\n    <div><div></div><p>Esta función requiere que su aplicación pueda interactuar con un servidor Redis .</p></div>\n  </blockquote>\n  <p>Si su aplicación interactúa con Redis, puede acelerar sus trabajos en cola por tiempo o simultaneidad. Esta función puede ser útil cuando sus trabajos en cola interactúan con API que también tienen una tasa limitada.</p>\n  <p>Por ejemplo, con el <code>throttle</code>método, puede limitar un tipo de trabajo determinado para que solo se ejecute 10 veces cada 60 segundos. Si no se puede obtener un bloqueo, normalmente debe volver a poner el trabajo en la cola para que pueda volver a intentarlo más tarde:</p>\n  <pre><code>Redis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () {\n    // Job logic...\n}, function () {\n    // Could not obtain lock...\n\n    return $this-&gt;release(10);\n});</code></pre>\n  <blockquote>\n    <div><div></div><p>En el ejemplo anterior, <code>key</code>puede ser cualquier cadena que identifique de forma exclusiva el tipo de trabajo que le gustaría limitar. Por ejemplo, es posible que desee construir la clave basándose en el nombre de la clase del trabajo y los ID de los modelos Eloquent en los que opera.</p></div>\n    <div><div></div><p>  La liberación de un trabajo limitado de nuevo a la cola aumentará el número total de <code>attempts</code>.</p></div>\n  </blockquote>\n  <p>Alternativamente, puede especificar el número máximo de trabajadores que pueden procesar simultáneamente un trabajo determinado. Esto puede resultar útil cuando un trabajo en cola está modificando un recurso que solo debe ser modificado por un trabajo a la vez. Por ejemplo, con el <code>funnel</code>método, puede limitar los trabajos de un tipo determinado para que solo los procese un trabajador a la vez:</p>\n  <pre><code>Redis::funnel('key')-&gt;limit(1)-&gt;then(function () {\n    // Job logic...\n}, function () {\n    // Could not obtain lock...\n\n    return $this-&gt;release(10);\n});</code></pre>\n  <blockquote>\n    <div><div></div><p>Cuando se utiliza la limitación de velocidad, la cantidad de intentos que necesitará su trabajo para ejecutarse correctamente puede ser difícil de determinar. Por lo tanto, es útil combinar la limitación de frecuencia con intentos basados \u200B\u200Ben el tiempo .</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Manejo de errores</h3>\n  <p>If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the <code>--tries</code> switch used on the <code>queue:work</code> Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker can be found below.</p>\n  <p></p>\n  <h2>Job Batching</h2>\n  <p>Laravel's job batching feature allows you to easily execute a batch of jobs and then perform some action when the batch of jobs has completed executing. Before getting started, you should create a database migration to build a table that will contain your job batch meta information. This migration may be generated using the <code>queue:batches-table</code> Artisan command:</p>\n  <pre><code>php artisan queue:batches-table\n\nphp artisan migrate</code></pre>\n  <p></p>\n  <h3>Defining Batchable Jobs</h3>\n  <p>To build a batchable job, you should create a queueable job as normal; however, you should add the <code>Illuminate\\Bus\\Batchable</code> trait to the job class. This trait provides access to a <code>batch</code> method which may be used to retrieve the current batch that the job is executing in:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\Podcast;\nuse App\\Services\\AudioProcessor;\nuse Illuminate\\Bus\\Batchable;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass ProcessPodcast implements ShouldQueue\n{\n    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n    /**\n     * Execute the job.\n     *\n     * @return void\n     */\n    public function handle()\n    {\n        if ($this-&gt;batch()-&gt;cancelled()) {\n            // Detected cancelled batch...\n\n            return;\n        }\n\n        // Batched job executing...\n    }\n}</code></pre>\n  <p></p>\n  <h3>Dispatching Batches</h3>\n  <p>To dispatch a batch of jobs, you should use <code>batch</code> method of the <code>Bus</code> facade. Of course, batching is primarily useful when combined with completion callbacks. So, you may use the <code>then</code>, <code>catch</code>, and <code>finally</code> methods to define completion callbacks for the batch. Each of these callbacks will receive an <code>Illuminate\\Bus\\Batch</code> instance when they are invoked:</p>\n  <pre><code>use App\\Jobs\\ProcessPodcast;\nuse App\\Podcast;\nuse Illuminate\\Bus\\Batch;\nuse Illuminate\\Support\\Facades\\Bus;\nuse Throwable;\n\n$batch = Bus::batch([\n    new ProcessPodcast(Podcast::find(1)),\n    new ProcessPodcast(Podcast::find(2)),\n    new ProcessPodcast(Podcast::find(3)),\n    new ProcessPodcast(Podcast::find(4)),\n    new ProcessPodcast(Podcast::find(5)),\n])-&gt;then(function (Batch $batch) {\n    // All jobs completed successfully...\n})-&gt;catch(function (Batch $batch, Throwable $e) {\n    // First batch job failure detected...\n})-&gt;finally(function (Batch $batch) {\n    // The batch has finished executing...\n})-&gt;dispatch();\n\nreturn $batch-&gt;id;</code></pre>\n  <h4>Naming Batches</h4>\n  <p>Some tools such as Laravel Horizon and Laravel Telescope may provide more user-friendly debug information for batches if batches are named. To assign an arbitrary name to a batch, you may call the <code>name</code> method while defining the batch:</p>\n  <pre><code>$batch = Bus::batch([\n    // ...\n])-&gt;then(function (Batch $batch) {\n    // All jobs completed successfully...\n})-&gt;name('Process Podcasts')-&gt;dispatch();</code></pre>\n  <h4>Batch Connection &amp; Queue</h4>\n  <p>If you would like to specify the connection and queue that should be used for the batched jobs, you may use the <code>onConnection</code> and <code>onQueue</code> methods:</p>\n  <pre><code>$batch = Bus::batch([\n    // ...\n])-&gt;then(function (Batch $batch) {\n    // All jobs completed successfully...\n})-&gt;onConnection('redis')-&gt;onQueue('podcasts')-&gt;dispatch();</code></pre>\n  <p></p>\n  <h3>Adding Jobs To Batches</h3>\n  <p>Sometimes it may be useful to add additional jobs to a batch from within a batched job. This pattern can be useful when you need to batch thousands of jobs which may take too long to dispatch during a web request. So, instead, you may wish to dispatch an initial batch of \"loader\" jobs that hydrate the batch with more jobs:</p>\n  <pre><code>$batch = Bus::batch([\n    new LoadImportBatch,\n    new LoadImportBatch,\n    new LoadImportBatch,\n])-&gt;then(function (Batch $batch) {\n    // All jobs completed successfully...\n})-&gt;name('Import Contacts')-&gt;dispatch();</code></pre>\n  <p>In this example, we will use the <code>LoadImportBatch</code> job to hydrate the batch with additional jobs. To accomplish this, we may use the <code>add</code> method on the batch instance that can be accessed within the job:</p>\n  <pre><code>use App\\Jobs\\ImportContacts;\nuse Illuminate\\Support\\Collection;\n\n/**\n * Execute the job.\n *\n * @return void\n */\npublic function handle()\n{\n    if ($this-&gt;batch()-&gt;cancelled()) {\n        return;\n    }\n\n    $this-&gt;batch()-&gt;add(Collection::times(1000, function () {\n        return new ImportContacts;\n    }));\n}</code></pre>\n  <blockquote>\n    <div><div></div><p> You may only add jobs to a batch from within a job that belongs to the same batch.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Inspecting Batches</h3>\n  <p>The <code>Illuminate\\Bus\\Batch</code> method that is provided to batch completion callbacks has a variety of properties and methods to assist you in interacting with and inspecting a given batch of jobs.</p>\n  <pre><code>// The UUID of the batch...\n$batch-&gt;id;\n\n// The name of the batch (if applicable)...\n$batch-&gt;name;\n\n// The number of jobs assigned to the batch...\n$batch-&gt;totalJobs;\n\n// The number of jobs that have not been processed by the queue...\n$batch-&gt;pendingJobs;\n\n// The number of jobs that have failed...\n$batch-&gt;failedJobs;\n\n// The number of jobs that have been processed thus far...\n$batch-&gt;processedJobs();\n\n// The completion percentage of the batch (0-100)...\n$batch-&gt;progress();\n\n// Indicates if the batch has finished executing...\n$batch-&gt;finished();\n\n// Cancel the execution of the batch...\n$batch-&gt;cancel();\n\n// Indicates if the batch has been cancelled...\n$batch-&gt;cancelled();</code></pre>\n  <h4>Devolución de lotes de rutas</h4>\n  <p>Todas las instancias son serializables JSON, lo que significa que puede devolverlas directamente desde una de las rutas de su aplicación para recuperar una carga útil JSON que contiene información sobre el lote, incluido su progreso de finalización. Para recuperar un lote por su ID, puede usar el método de la fachada :<code>Illuminate\\Bus\\Batch</code><code>Bus</code><code>findBatch</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Bus;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('/batch/{batchId}', function (string $batchId) {\n    return Bus::findBatch($batchId);\n});</code></pre>\n  <p></p>\n  <h3>Cancelación de lotes</h3>\n  <p>A veces, es posible que deba cancelar la ejecución de un lote determinado. Esto se puede lograr llamando al <code>cancel</code>método en la instancia:<code>Illuminate\\Bus\\Batch</code></p>\n  <pre><code>/**\n * Execute the job.\n *\n * @return void\n */\npublic function handle()\n{\n    if ($this-&gt;user-&gt;exceedsImportLimit()) {\n        return $this-&gt;batch()-&gt;cancel();\n    }\n\n    if ($this-&gt;batch()-&gt;cancelled()) {\n        return;\n    }\n}</code></pre>\n  <p></p>\n  <h3>Fallos de lote</h3>\n  <p>Cuando un trabajo por lotes falla, <code>catch</code>se invocará la devolución de llamada (si está asignada). Esta devolución de llamada solo se invoca para el trabajo que falla dentro del lote.</p>\n  <h4>Permitir fallas</h4>\n  <p>Cuando un trabajo dentro de un lote falla, Laravel marcará automáticamente el lote como \"cancelado\". Si lo desea, puede desactivar este comportamiento para que una falla en el trabajo no marque automáticamente el lote como cancelado. Esto se puede lograr llamando al <code>allowFailures</code>método mientras se envía el lote:</p>\n  <pre><code>$batch = Bus::batch([\n    // ...\n])-&gt;then(function (Batch $batch) {\n    // All jobs completed successfully...\n})-&gt;allowFailures()-&gt;dispatch();</code></pre>\n  <h4>Reintentar trabajos por lotes fallidos</h4>\n  <p>Para mayor comodidad, Laravel proporciona un comando Artisan que le permite reintentar fácilmente todos los trabajos fallidos para un lote determinado. El comando acepta el UUID del lote cuyos trabajos fallidos deben reintentarse:<code>queue:retry-batch</code><code>queue:retry-batch</code></p>\n  <pre><code>php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5</code></pre>\n  <p></p>\n  <h2>Cierres de colas</h2>\n  <p>Instead of dispatching a job class to the queue, you may also dispatch a Closure. This is great for quick, simple tasks that need to be executed outside of the current request cycle. When dispatching Closures to the queue, the Closure's code contents is cryptographically signed so it can not be modified in transit:</p>\n  <pre><code>$podcast = App\\Podcast::find(1);\n\ndispatch(function () use ($podcast) {\n    $podcast-&gt;publish();\n});</code></pre>\n  <p>Using the <code>catch</code> method, you may provide a Closure that should be executed if the queued Closure fails to complete successfully after exhausting all of your queue's configured retry attempts:</p>\n  <pre><code>use Throwable;\n\ndispatch(function () use ($podcast) {\n    $podcast-&gt;publish();\n})-&gt;catch(function (Throwable $e) {\n    // This job has failed...\n});</code></pre>\n  <p></p>\n  <h2>Running The Queue Worker</h2>\n  <p>Laravel includes a queue worker that will process new jobs as they are pushed onto the queue. You may run the worker using the <code>queue:work</code> Artisan command. Note that once the <code>queue:work</code> command has started, it will continue to run until it is manually stopped or you close your terminal:</p>\n  <pre><code>php artisan queue:work</code></pre>\n  <blockquote>\n    <div><div></div><p> To keep the <code>queue:work</code> process running permanently in the background, you should use a process monitor such as Supervisor to ensure that the queue worker does not stop running.</p></div>\n  </blockquote>\n  <p>Remember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to restart your queue workers. In addition, remember that any static state created or modified by your application will not be automatically reset between jobs.</p>\n  <p>Alternatively, you may run the <code>queue:listen</code> command. When using the <code>queue:listen</code> command, you don't have to manually restart the worker when you want to reload your updated code or reset the application state; however, this command is not as efficient as <code>queue:work</code>:</p>\n  <pre><code>php artisan queue:listen</code></pre>\n  <h4>Specifying The Connection &amp; Queue</h4>\n  <p>You may also specify which queue connection the worker should utilize. The connection name passed to the <code>work</code> command should correspond to one of the connections defined in your <code>config/queue.php</code> configuration file:</p>\n  <pre><code>php artisan queue:work redis</code></pre>\n  <p>Puede personalizar aún más su trabajador de cola procesando solo colas particulares para una conexión determinada. Por ejemplo, si todos sus correos electrónicos se procesan en una <code>emails</code>cola en su <code>redis</code>conexión de cola, puede emitir el siguiente comando para iniciar un trabajador que solo procesa esa cola:</p>\n  <pre><code>php artisan queue:work redis --queue=emails</code></pre>\n  <h4>Procesamiento de un número específico de trabajos</h4>\n  <p>La <code>--once</code>opción se puede usar para indicar al trabajador que solo procese un único trabajo de la cola:</p>\n  <pre><code>php artisan queue:work --once</code></pre>\n  <p>La opción puede usarse para indicar al trabajador que procese el número de trabajos dado y luego salga. Esta opción puede ser útil cuando se combina con Supervisor para que sus trabajadores se reinicien automáticamente después de procesar una cantidad determinada de trabajos:<code>--max-jobs</code></p>\n  <pre><code>php artisan queue:work --max-jobs=1000</code></pre>\n  <h4>Procesar todos los trabajos en cola y luego salir</h4>\n  <p>La opción se puede usar para indicar al trabajador que procese todos los trabajos y luego salga sin problemas. Esta opción puede ser útil al trabajar con colas de Laravel dentro de un contenedor Docker si desea cerrar el contenedor después de que la cola esté vacía:<code>--stop-when-empty</code></p>\n  <pre><code>php artisan queue:work --stop-when-empty</code></pre>\n  <h4>Procesamiento de trabajos durante un número determinado de segundos</h4>\n  <p>La opción se puede utilizar para indicar al trabajador que procese trabajos durante el número de segundos especificado y luego salga. Esta opción puede ser útil cuando se combina con Supervisor para que sus trabajadores se reinicien automáticamente después de procesar trabajos durante un período de tiempo determinado:<code>--max-time</code></p>\n  <pre><code>// Process jobs for one hour and then exit...\nphp artisan queue:work --max-time=3600</code></pre>\n  <h4>Consideraciones de recursos</h4>\n  <p>Los trabajadores de la cola del demonio no \"reinician\" el marco antes de procesar cada trabajo. Por lo tanto, debe liberar los recursos pesados \u200B\u200Bdespués de que se complete cada trabajo. Por ejemplo, si está manipulando imágenes con la biblioteca GD, debe liberar la memoria <code>imagedestroy</code>cuando haya terminado.</p>\n  <p></p>\n  <h3>Prioridades de cola</h3>\n  <p>A veces, es posible que desee priorizar cómo se procesan sus colas. Por ejemplo, en su puede establecer el valor predeterminado para su conexión a . Sin embargo, en ocasiones, es posible que desee enviar un trabajo a una cola de prioridad como esta:<code>config/queue.php</code><code>queue</code><code>redis</code><code>low</code><code>high</code></p>\n  <pre><code>dispatch((new Job)-&gt;onQueue('high'));</code></pre>\n  <p>Para iniciar un trabajador que verifique que todos los <code>high</code>trabajos de la cola se procesan antes de continuar con cualquier trabajo en la <code>low</code>cola, pase una lista delimitada por comas de nombres de cola al <code>work</code>comando:</p>\n  <pre><code>php artisan queue:work --queue=high,low</code></pre>\n  <p></p>\n  <h3>Trabajadores de cola e implementación</h3>\n  <p>Since queue workers are long-lived processes, they will not pick up changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the <code>queue:restart</code> command:</p>\n  <pre><code>php artisan queue:restart</code></pre>\n  <p>This command will instruct all queue workers to gracefully \"die\" after they finish processing their current job so that no existing jobs are lost. Since the queue workers will die when the <code>queue:restart</code> command is executed, you should be running a process manager such as Supervisor to automatically restart the queue workers.</p>\n  <blockquote>\n    <div><div></div><p> The queue uses the cache to store restart signals, so you should verify a cache driver is properly configured for your application before using this feature.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Job Expirations &amp; Timeouts</h3>\n  <h4>Job Expiration</h4>\n  <p>In your <code>config/queue.php</code> configuration file, each queue connection defines a <code>retry_after</code> option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of <code>retry_after</code> is set to <code>90</code>, the job will be released back onto the queue if it has been processing for 90 seconds without being deleted. Typically, you should set the <code>retry_after</code> value to the maximum number of seconds your jobs should reasonably take to complete processing.</p>\n  <blockquote>\n    <div><div></div><p>La única conexión de cola que no contiene un <code>retry_after</code>valor es Amazon SQS. SQS volverá a intentar el trabajo según el tiempo de espera de visibilidad predeterminado que se administra dentro de la consola de AWS.</p></div>\n  </blockquote>\n  <h4>Tiempos de espera del trabajador</h4>\n  <p>El comando Artisan expone una opción. La opción especifica cuánto tiempo esperará el proceso maestro de cola de Laravel antes de eliminar a un trabajador de cola secundario que está procesando un trabajo. A veces, un proceso de cola secundaria se puede \"congelar\" por varias razones. La opción elimina los procesos congelados que han excedido ese límite de tiempo especificado:<code>queue:work</code><code>--timeout</code><code>--timeout</code><code>--timeout</code></p>\n  <pre><code>php artisan queue:work --timeout=60</code></pre>\n  <p>La <code>retry_after</code>opción de configuración y la <code>--timeout</code>opción CLI son diferentes, pero funcionan juntas para garantizar que los trabajos no se pierdan y que los trabajos solo se procesen correctamente una vez.</p>\n  <blockquote>\n    <div><div></div><p>El <code>--timeout</code>valor siempre debe ser al menos varios segundos más corto que su <code>retry_after</code>valor de configuración. Esto garantizará que un trabajador que procesa un trabajo determinado siempre se mata antes de que se vuelva a intentar. Si su <code>--timeout</code>opción es más larga que su <code>retry_after</code>valor de configuración, sus trabajos pueden procesarse dos veces.</p></div>\n  </blockquote>\n  <h4>Duración del sueño del trabajador</h4>\n  <p>Cuando hay trabajos disponibles en la cola, el trabajador seguirá procesando trabajos sin demora entre ellos. Sin embargo, la <code>sleep</code>opción determina cuánto tiempo (en segundos) el trabajador \"dormirá\" si no hay nuevos trabajos disponibles. Mientras duerme, el trabajador no procesará ningún trabajo nuevo; los trabajos se procesarán después de que el trabajador se despierte nuevamente.</p>\n  <pre><code>php artisan queue:work --sleep=3</code></pre>\n  <p></p>\n  <h2>Configuración del supervisor</h2>\n  <h4>Supervisor de instalación</h4>\n  <p>Supervisor es un monitor de procesos para el sistema operativo Linux y reiniciará automáticamente su proceso si falla. Para instalar Supervisor en Ubuntu, puede usar el siguiente comando:<code>queue:work</code></p>\n  <pre><code>sudo apt-get install supervisor</code></pre>\n  <blockquote>\n    <div><div></div><p>Si configurar Supervisor usted mismo suena abrumador, considere usar Laravel Forge , que instalará y configurará Supervisor automáticamente para sus proyectos de Laravel.</p></div>\n  </blockquote>\n  <h4>Configurar supervisor</h4>\n  <p>Los archivos de configuración del supervisor generalmente se almacenan en el directorio. Dentro de este directorio, puede crear cualquier número de archivos de configuración que indiquen al supervisor cómo se deben monitorear sus procesos. Por ejemplo, creemos un archivo que inicia y monitorea un proceso:<code>/etc/supervisor/conf.d</code><code>laravel-worker.conf</code><code>queue:work</code></p>\n  <pre><code>[program:laravel-worker]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3\nautostart=true\nautorestart=true\nuser=forge\nnumprocs=8\nredirect_stderr=true\nstdout_logfile=/home/forge/app.com/worker.log\nstopwaitsecs=3600</code></pre>\n  <p>In this example, the <code>numprocs</code> directive will instruct Supervisor to run 8 <code>queue:work</code> processes and monitor all of them, automatically restarting them if they fail. You should change the <code>queue:work sqs</code> portion of the <code>command</code> directive to reflect your desired queue connection.</p>\n  <blockquote>\n    <div><div></div><p> You should ensure that the value of <code>stopwaitsecs</code> is greater than the number of seconds consumed by your longest running job. Otherwise, Supervisor may kill the job before it is finished processing.</p></div>\n  </blockquote>\n  <h4>Starting Supervisor</h4>\n  <p>Once the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands:</p>\n  <pre><code>sudo supervisorctl reread\n\nsudo supervisorctl update\n\nsudo supervisorctl start laravel-worker:*</code></pre>\n  <p>For more information on Supervisor, consult the Supervisor documentation.</p>\n  <p></p>\n  <h2>Dealing With Failed Jobs</h2>\n  <p>A veces, sus trabajos en cola fallarán. No se preocupe, ¡las cosas no siempre salen según lo planeado! Laravel incluye una forma conveniente de especificar el número máximo de veces que se debe intentar un trabajo. Una vez que un trabajo ha superado esta cantidad de intentos, se insertará en la <code>failed_jobs</code>tabla de la base de datos. Para crear una migración para la <code>failed_jobs</code>tabla, puede usar el comando:<code>queue:failed-table</code></p>\n  <pre><code>php artisan queue:failed-table\n\nphp artisan migrate</code></pre>\n  <p>Luego, cuando ejecute su trabajador de cola , puede especificar el número máximo de veces que se debe intentar un trabajo usando el <code>--tries</code>interruptor del comando. Si no especifica un valor para la opción, los trabajos solo se intentarán una vez:<code>queue:work</code><code>--tries</code></p>\n  <pre><code>php artisan queue:work redis --tries=3</code></pre>\n  <p>Además, puede especificar cuántos segundos Laravel debe esperar antes de volver a intentar un trabajo que ha fallado usando la <code>--backoff</code>opción. De forma predeterminada, un trabajo se reintenta inmediatamente:</p>\n  <pre><code>php artisan queue:work redis --tries=3 --backoff=3</code></pre>\n  <p>Si desea configurar la demora de reintento de trabajos fallidos por trabajo, puede hacerlo definiendo una <code>backoff</code>propiedad en su clase de trabajo en cola:</p>\n  <pre><code>/**\n * The number of seconds to wait before retrying the job.\n *\n * @var int\n */\npublic $backoff = 3;</code></pre>\n  <p>Si necesita una lógica más compleja para determinar el retraso de reintento, puede definir un <code>backoff</code>método en su clase de trabajo en cola:</p>\n  <pre><code>/**\n* Calculate the number of seconds to wait before retrying the job.\n*\n* @return int\n*/\npublic function backoff()\n{\n    return 3;\n}</code></pre>\n  <p>Puede configurar fácilmente retrocesos \"exponenciales\" devolviendo una matriz de valores de retroceso del <code>backoff</code>método. En este ejemplo, la demora de reintento será de 1 segundo para el primer reintento, 5 segundos para el segundo reintento y 10 segundos para el tercer reintento:</p>\n  <pre><code>/**\n* Calculate the number of seconds to wait before retrying the job.\n*\n* @return array\n*/\npublic function backoff()\n{\n    return [1, 5, 10];\n}</code></pre>\n  <p></p>\n  <h3>Limpieza después de trabajos fallidos</h3>\n  <p>Puede definir un <code>failed</code>método directamente en su clase de trabajo, lo que le permite realizar una limpieza específica del trabajo cuando ocurre una falla. Esta es la ubicación perfecta para enviar una alerta a sus usuarios o revertir cualquier acción realizada por el trabajo. La <code>Throwable</code>excepción que provocó la falla del trabajo se pasará al <code>failed</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\Podcast;\nuse App\\Services\\AudioProcessor;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Throwable;\n\nclass ProcessPodcast implements ShouldQueue\n{\n    use InteractsWithQueue, Queueable, SerializesModels;\n\n    protected $podcast;\n\n    /**\n     * Create a new job instance.\n     *\n     * @param  \\App\\Models\\Podcast  $podcast\n     * @return void\n     */\n    public function __construct(Podcast $podcast)\n    {\n        $this-&gt;podcast = $podcast;\n    }\n\n    /**\n     * Execute the job.\n     *\n     * @param  \\App\\Services\\AudioProcessor  $processor\n     * @return void\n     */\n    public function handle(AudioProcessor $processor)\n    {\n        // Process uploaded podcast...\n    }\n\n    /**\n     * Handle a job failure.\n     *\n     * @param  \\Throwable  $exception\n     * @return void\n     */\n    public function failed(Throwable $exception)\n    {\n        // Send user notification of failure, etc...\n    }\n}</code></pre>\n  <p></p>\n  <h3>Eventos de trabajo fallidos</h3>\n  <p>Si desea registrar un evento al que se llamará cuando falle un trabajo, puede utilizar el método. Este evento es una gran oportunidad para notificar a su equipo por correo electrónico o Slack . Por ejemplo, podemos adjuntar una devolución de llamada a este evento desde el que se incluye con Laravel:<code>Queue::failing</code><code>AppServiceProvider</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\Queue;\nuse Illuminate\\Support\\ServiceProvider;\nuse Illuminate\\Queue\\Events\\JobFailed;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Queue::failing(function (JobFailed $event) {\n            // $event-&gt;connectionName\n            // $event-&gt;job\n            // $event-&gt;exception\n        });\n    }\n}</code></pre>\n  <p></p>\n  <h3>Reintentar trabajos fallidos</h3>\n  <p>Para ver todos los trabajos fallidos que se han insertado en la <code>failed_jobs</code>tabla de su base de datos, puede usar el comando Artisan:<code>queue:failed</code></p>\n  <pre><code>php artisan queue:failed</code></pre>\n  <p>El comando mostrará la identificación del trabajo, la conexión, la cola, el tiempo de falla y otra información sobre el trabajo. La ID del trabajo se puede utilizar para reintentar el trabajo fallido. Por ejemplo, para volver a intentar un trabajo fallido que tiene un ID de , emita el siguiente comando:<code>queue:failed</code><code>5</code></p>\n  <pre><code>php artisan queue:retry 5</code></pre>\n  <p>Si es necesario, puede pasar varios ID o un rango de ID (cuando utilice ID numéricos) al comando:</p>\n  <pre><code>php artisan queue:retry 5 6 7 8 9 10\n\nphp artisan queue:retry --range=5-10</code></pre>\n  <p>Para volver a intentar todos los trabajos fallidos, ejecute el comando y pase como ID:<code>queue:retry</code><code>all</code></p>\n  <pre><code>php artisan queue:retry all</code></pre>\n  <p>Si desea eliminar un trabajo fallido, puede usar el comando:<code>queue:forget</code></p>\n  <pre><code>php artisan queue:forget 5</code></pre>\n  <p>Para eliminar todos sus trabajos fallidos, puede usar el comando:<code>queue:flush</code></p>\n  <pre><code>php artisan queue:flush</code></pre>\n  <p></p>\n  <h3>Ignorar modelos faltantes</h3>\n  <p>Cuando se inyecta un modelo Eloquent en un trabajo, se serializa automáticamente antes de colocarse en la cola y se restaura cuando se procesa el trabajo. Sin embargo, si el modelo se eliminó mientras el trabajo estaba esperando a ser procesado por un trabajador, su trabajo puede fallar con un <code>ModelNotFoundException</code>.</p>\n  <p>Para mayor comodidad, puede optar por eliminar automáticamente los trabajos con modelos faltantes configurando la <code>deleteWhenMissingModels</code>propiedad de su trabajo en <code>true</code>:</p>\n  <pre><code>/**\n * Delete the job if its models no longer exist.\n *\n * @var bool\n */\npublic $deleteWhenMissingModels = true;</code></pre>\n  <p></p>\n  <h2>Borrar trabajos de las colas</h2>\n  <p>Si desea eliminar todos los trabajos de la cola predeterminada de la conexión predeterminada, puede hacerlo usando el comando Artisan:<code>queue:clear</code></p>\n  <pre><code>php artisan queue:clear</code></pre>\n  <p>También puede proporcionar el <code>connection</code>argumento y la <code>queue</code>opción para eliminar trabajos de una conexión y cola específicas:</p>\n  <pre><code>php artisan queue:clear redis --queue=emails</code></pre>\n  <blockquote>\n    <div><div></div><p>La eliminación de trabajos de las colas solo está disponible para los controladores de cola de base de datos, SQS y Redis. Además, el proceso de eliminación de mensajes SQS tarda hasta 60 segundos, por lo que los trabajos enviados a la cola SQS hasta 60 segundos después de borrar la cola también pueden eliminarse.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Eventos laborales</h2>\n  <p>Con los métodos <code>before</code>y <code>after</code>en la <code>Queue</code> fachada , puede especificar devoluciones de llamada para que se ejecuten antes o después de que se procese un trabajo en cola. Estas devoluciones de llamada son una gran oportunidad para realizar un registro adicional o incrementar las estadísticas de un tablero. Por lo general, debe llamar a estos métodos desde un proveedor de servicios . Por ejemplo, podemos usar el <code>AppServiceProvider</code>que se incluye con Laravel:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\Queue;\nuse Illuminate\\Support\\ServiceProvider;\nuse Illuminate\\Queue\\Events\\JobProcessed;\nuse Illuminate\\Queue\\Events\\JobProcessing;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Queue::before(function (JobProcessing $event) {\n            // $event-&gt;connectionName\n            // $event-&gt;job\n            // $event-&gt;job-&gt;payload()\n        });\n\n        Queue::after(function (JobProcessed $event) {\n            // $event-&gt;connectionName\n            // $event-&gt;job\n            // $event-&gt;job-&gt;payload()\n        });\n    }\n}</code></pre>\n  <p>Usando el <code>looping</code>método en la <code>Queue</code> fachada , puede especificar devoluciones de llamada que se ejecutan antes de que el trabajador intente obtener un trabajo de una cola. Por ejemplo, puede registrar un cierre para revertir las transacciones que quedaron abiertas por un trabajo fallido anteriormente:</p>\n  <pre><code>Queue::looping(function () {\n    while (DB::transactionLevel() &gt; 0) {\n        DB::rollBack();\n    }\n});</code></pre>\n</section>"
      },
      {
        "titulo": "6.12 Programación de tareas",
        "contenido": "<section>\n  <h1>Programación de tareas</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Definición de horarios\n      <ul>\n        <li>Programación de comandos artesanales</li>\n        <li>Programación de trabajos en cola</li>\n        <li>Programación de comandos de shell</li>\n        <li>Opciones de frecuencia de programación</li>\n        <li>Zonas horarias</li>\n        <li>Prevención de superposiciones de tareas</li>\n        <li>Ejecución de tareas en un servidor</li>\n        <li>Tarea en segundo plano</li>\n        <li>Modo de mantenimiento</li>\n      </ul></li>\n    <li>Salida de tarea</li>\n    <li>Ganchos de tareas</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>En el pasado, es posible que haya generado una entrada Cron para cada tarea que necesitaba programar en su servidor. Sin embargo, esto puede convertirse rápidamente en un problema, porque su programa de tareas ya no está en el control de código fuente y debe SSH en su servidor para agregar entradas Cron adicionales.</p>\n  <p>El programador de comandos de Laravel le permite definir de manera fluida y expresiva su programa de comandos dentro de Laravel. Al usar el programador, solo se necesita una única entrada Cron en su servidor. Su horario de tareas se define en el método del archivo . Para ayudarlo a comenzar, se define un ejemplo simple dentro del método.<code>app/Console/Kernel.php</code><code>schedule</code></p>\n  <h3>Iniciar el programador</h3>\n  <p>Al usar el programador, solo necesita agregar la siguiente entrada Cron a su servidor. Si no sabe cómo agregar entradas Cron a su servidor, considere usar un servicio como Laravel Forge que puede administrar las entradas Cron por usted:</p>\n  <pre><code>* * * * * cd /path-to-your-project &amp;&amp; php artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</code></pre>\n  <p>Este Cron llamará al programador de comandos de Laravel cada minuto. Cuando se ejecuta el comando, Laravel evaluará sus tareas programadas y ejecutará las tareas pendientes.<code>schedule:run</code></p>\n  <p></p>\n  <h2>Definición de horarios</h2>\n  <p>Puede definir todas sus tareas programadas en el <code>schedule</code>método de la clase. Para comenzar, veamos un ejemplo de programación de una tarea. En este ejemplo, programaremos una llamada todos los días a la medianoche. Dentro del , ejecutaremos una consulta a la base de datos para borrar una tabla:<code>App\\Console\\Kernel</code><code>Closure</code><code>Closure</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Console;\n\nuse Illuminate\\Console\\Scheduling\\Schedule;\nuse Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel;\nuse Illuminate\\Support\\Facades\\DB;\n\nclass Kernel extends ConsoleKernel\n{\n    /**\n     * The Artisan commands provided by your application.\n     *\n     * @var array\n     */\n    protected $commands = [\n        //\n    ];\n\n    /**\n     * Define the application's command schedule.\n     *\n     * @param  \\Illuminate\\Console\\Scheduling\\Schedule  $schedule\n     * @return void\n     */\n    protected function schedule(Schedule $schedule)\n    {\n        $schedule-&gt;call(function () {\n            DB::table('recent_users')-&gt;delete();\n        })-&gt;daily();\n    }\n}</code></pre>\n  <p>Además de programar mediante cierres, también puede utilizar objetos invocables . Los objetos invocables son clases PHP simples que contienen un <code>__invoke</code>método:</p>\n  <pre><code>$schedule-&gt;call(new DeleteRecentUsers)-&gt;daily();</code></pre>\n  <p></p>\n  <h3>Programación de comandos artesanales</h3>\n  <p>Además de programar llamadas de cierre, también puede programar comandos Artisan y comandos del sistema operativo. Por ejemplo, puede usar el <code>command</code>método para programar un comando Artisan usando el nombre o la clase del comando:</p>\n  <pre><code>$schedule-&gt;command('emails:send Taylor --force')-&gt;daily();\n\n$schedule-&gt;command(EmailsCommand::class, ['Taylor', '--force'])-&gt;daily();</code></pre>\n  <p></p>\n  <h3>Programación de trabajos en cola</h3>\n  <p>El <code>job</code>método se puede utilizar para programar un trabajo en cola . Este método proporciona una manera conveniente de programar trabajos sin utilizar el <code>call</code>método para crear cierres manualmente para poner en cola el trabajo:</p>\n  <pre><code>$schedule-&gt;job(new Heartbeat)-&gt;everyFiveMinutes();\n\n// Dispatch the job to the \"heartbeats\" queue...\n$schedule-&gt;job(new Heartbeat, 'heartbeats')-&gt;everyFiveMinutes();</code></pre>\n  <p></p>\n  <h3>Programación de comandos de shell</h3>\n  <p>El <code>exec</code>método se puede utilizar para emitir un comando al sistema operativo:</p>\n  <pre><code>$schedule-&gt;exec('node /home/forge/script.js')-&gt;daily();</code></pre>\n  <p></p>\n  <h3>Opciones de frecuencia de programación</h3>\n  <p>Hay una variedad de horarios que puede asignar a su tarea:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Método</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>-&gt;cron('* * * * *');</code></td>\n      <td>Ejecute la tarea en un horario Cron personalizado</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyMinute();</code></td>\n      <td>Ejecuta la tarea cada minuto</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyTwoMinutes();</code></td>\n      <td>Ejecute la tarea cada dos minutos</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyThreeMinutes();</code></td>\n      <td>Ejecute la tarea cada tres minutos</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyFourMinutes();</code></td>\n      <td>Ejecute la tarea cada cuatro minutos</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyFiveMinutes();</code></td>\n      <td>Ejecute la tarea cada cinco minutos</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyTenMinutes();</code></td>\n      <td>Ejecute la tarea cada diez minutos</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyFifteenMinutes();</code></td>\n      <td>Ejecute la tarea cada quince minutos</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyThirtyMinutes();</code></td>\n      <td>Ejecute la tarea cada treinta minutos</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;hourly();</code></td>\n      <td>Ejecuta la tarea cada hora</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;hourlyAt(17);</code></td>\n      <td>Ejecute la tarea cada hora a los 17 minutos después de la hora</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyTwoHours();</code></td>\n      <td>Ejecute la tarea cada dos horas</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyThreeHours();</code></td>\n      <td>Ejecute la tarea cada tres horas</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everyFourHours();</code></td>\n      <td>Ejecute la tarea cada cuatro horas</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;everySixHours();</code></td>\n      <td>Ejecute la tarea cada seis horas</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;daily();</code></td>\n      <td>Ejecute la tarea todos los días a la medianoche</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;dailyAt('13:00');</code></td>\n      <td>Ejecute la tarea todos los días a las 13:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;twiceDaily(1, 13);</code></td>\n      <td>Ejecute la tarea todos los días a la 1:00 y a las 13:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;weekly();</code></td>\n      <td>Ejecuta la tarea todos los domingos a las 00:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;weeklyOn(1, '8:00');</code></td>\n      <td>Ejecute la tarea cada semana el lunes a las 8:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;monthly();</code></td>\n      <td>Ejecute la tarea el primer día de cada mes a las 00:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;monthlyOn(4, '15:00');</code></td>\n      <td>Ejecute la tarea todos los meses el día 4 a las 15:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;lastDayOfMonth('15:00');</code></td>\n      <td>Ejecute la tarea el último día del mes a las 15:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;quarterly();</code></td>\n      <td>Ejecute la tarea el primer día de cada trimestre a las 00:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;yearly();</code></td>\n      <td>Ejecute la tarea el primer día de cada año a las 00:00</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;timezone('America/New_York');</code></td>\n      <td>Establecer la zona horaria</td>\n    </tr>\n    </tbody>\n  </table>\n  <p>Estos métodos se pueden combinar con restricciones adicionales para crear horarios aún más ajustados que solo se ejecutan en ciertos días de la semana. Por ejemplo, para programar un comando para que se ejecute semanalmente el lunes:</p>\n  <pre><code>// Run once per week on Monday at 1 PM...\n$schedule-&gt;call(function () {\n    //\n})-&gt;weekly()-&gt;mondays()-&gt;at('13:00');\n\n// Run hourly from 8 AM to 5 PM on weekdays...\n$schedule-&gt;command('foo')\n          -&gt;weekdays()\n          -&gt;hourly()\n          -&gt;timezone('America/Chicago')\n          -&gt;between('8:00', '17:00');</code></pre>\n  <p>A continuación se muestra una lista de las restricciones de programación adicionales:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Método</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>-&gt;weekdays();</code></td>\n      <td>Limite la tarea a los días de la semana</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;weekends();</code></td>\n      <td>Limita la tarea a los fines de semana</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;sundays();</code></td>\n      <td>Limita la tarea al domingo</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;mondays();</code></td>\n      <td>Limita la tarea al lunes</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;tuesdays();</code></td>\n      <td>Limita la tarea al martes</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;wednesdays();</code></td>\n      <td>Limita la tarea al miércoles</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;thursdays();</code></td>\n      <td>Limita la tarea al jueves</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;fridays();</code></td>\n      <td>Limita la tarea al viernes</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;saturdays();</code></td>\n      <td>Limita la tarea al sábado</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;days(array|mixed);</code></td>\n      <td>Limita la tarea a días específicos</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;between($start, $end);</code></td>\n      <td>Limite la tarea para que se ejecute entre las horas de inicio y finalización</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;when(Closure);</code></td>\n      <td>Limite la tarea basándose en una prueba de verdad</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;environments($env);</code></td>\n      <td>Limite la tarea a entornos específicos</td>\n    </tr>\n    </tbody>\n  </table>\n  <h4>Restricciones del día</h4>\n  <p>El <code>days</code>método se puede usar para limitar la ejecución de una tarea a días específicos de la semana. Por ejemplo, puede programar un comando para que se ejecute cada hora los domingos y miércoles:</p>\n  <pre><code>$schedule-&gt;command('reminders:send')\n                -&gt;hourly()\n                -&gt;days([0, 3]);</code></pre>\n  <h4>Entre restricciones de tiempo</h4>\n  <p>El <code>between</code>método se puede utilizar para limitar la ejecución de una tarea en función de la hora del día:</p>\n  <pre><code>$schedule-&gt;command('reminders:send')\n                    -&gt;hourly()\n                    -&gt;between('7:00', '22:00');</code></pre>\n  <p>Del mismo modo, el <code>unlessBetween</code>método se puede utilizar para excluir la ejecución de una tarea durante un período de tiempo:</p>\n  <pre><code>$schedule-&gt;command('reminders:send')\n                    -&gt;hourly()\n                    -&gt;unlessBetween('23:00', '4:00');</code></pre>\n  <h4>Restricciones de la prueba de verdad</h4>\n  <p>El <code>when</code>método se puede utilizar para limitar la ejecución de una tarea en función del resultado de una prueba de verdad determinada. En otras palabras, si los dados <code>Closure</code>rendimientos <code>true</code>, la tarea se ejecutará siempre y cuando no hay otras condiciones limitantes impiden que la tarea se ejecute:</p>\n  <pre><code>$schedule-&gt;command('emails:send')-&gt;daily()-&gt;when(function () {\n    return true;\n});</code></pre>\n  <p>El <code>skip</code>método puede verse como el inverso de <code>when</code>. Si el <code>skip</code>método regresa <code>true</code>, la tarea programada no se ejecutará:</p>\n  <pre><code>$schedule-&gt;command('emails:send')-&gt;daily()-&gt;skip(function () {\n    return true;\n});</code></pre>\n  <p>Al usar <code>when</code>métodos encadenados , el comando programado solo se ejecutará si <code>when</code>regresan todas las condiciones <code>true</code>.</p>\n  <h4>Restricciones ambientales</h4>\n  <p>El <code>environments</code>método puede usarse para ejecutar tareas solo en los entornos dados:</p>\n  <pre><code>$schedule-&gt;command('emails:send')\n            -&gt;daily()\n            -&gt;environments(['staging', 'production']);</code></pre>\n  <p></p>\n  <h3>Zonas horarias</h3>\n  <p>Con el <code>timezone</code>método, puede especificar que la hora de una tarea programada debe interpretarse dentro de una zona horaria determinada:</p>\n  <pre><code>$schedule-&gt;command('report:generate')\n         -&gt;timezone('America/New_York')\n         -&gt;at('02:00')</code></pre>\n  <p>Si está asignando la misma zona horaria a todas sus tareas programadas, es posible que desee definir un <code>scheduleTimezone</code>método en su archivo. Este método debería devolver la zona horaria predeterminada que debería asignarse a todas las tareas programadas:<code>app/Console/Kernel.php</code></p>\n  <pre><code>/**\n * Get the timezone that should be used by default for scheduled events.\n *\n * @return \\DateTimeZone|string|null\n */\nprotected function scheduleTimezone()\n{\n    return 'America/Chicago';\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Recuerde que algunas zonas horarias utilizan el horario de verano. Cuando se producen cambios en el horario de verano, su tarea programada puede ejecutarse dos veces o incluso no ejecutarse en absoluto. Por esta razón, recomendamos evitar la programación de zonas horarias cuando sea posible.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Prevención de superposiciones de tareas</h3>\n  <p>De forma predeterminada, las tareas programadas se ejecutarán incluso si la instancia anterior de la tarea aún se está ejecutando. Para evitar esto, puede utilizar el <code>withoutOverlapping</code>método:</p>\n  <pre><code>$schedule-&gt;command('emails:send')-&gt;withoutOverlapping();</code></pre>\n  <p>En este ejemplo, el comando Artisan se ejecutará cada minuto si aún no se está ejecutando. El método es especialmente útil si tiene tareas que varían drásticamente en su tiempo de ejecución, lo que le impide predecir exactamente cuánto tiempo llevará una tarea determinada.<code>emails:send</code> <code>withoutOverlapping</code></p>\n  <p>Si es necesario, puede especificar cuántos minutos deben pasar antes de que expire el bloqueo \"sin superposición\". De forma predeterminada, el bloqueo caducará después de 24 horas:</p>\n  <pre><code>$schedule-&gt;command('emails:send')-&gt;withoutOverlapping(10);</code></pre>\n  <p></p>\n  <h3>Ejecución de tareas en un servidor</h3>\n  <blockquote>\n    <div><div></div><p>Para utilizar esta función, la aplicación debe ser mediante el <code>database</code>, <code>memcached</code>o <code>redis</code>controlador de caché como controlador predeterminado de la caché de la aplicación. Además, todos los servidores deben comunicarse con el mismo servidor de caché central.</p></div>\n  </blockquote>\n  <p>Si su aplicación se ejecuta en varios servidores, puede limitar un trabajo programado para que solo se ejecute en un único servidor. Por ejemplo, suponga que tiene una tarea programada que genera un nuevo informe todos los viernes por la noche. Si el programador de tareas se ejecuta en tres servidores de trabajo, la tarea programada se ejecutará en los tres servidores y generará el informe tres veces. ¡No está bien!</p>\n  <p>Para indicar que la tarea debe ejecutarse en un solo servidor, utilice el <code>onOneServer</code>método al definir la tarea programada. El primer servidor en obtener la tarea asegurará un bloqueo atómico en el trabajo para evitar que otros servidores ejecuten la misma tarea al mismo tiempo:</p>\n  <pre><code>$schedule-&gt;command('report:generate')\n                -&gt;fridays()\n                -&gt;at('17:00')\n                -&gt;onOneServer();</code></pre>\n  <p></p>\n  <h3>Tarea en segundo plano</h3>\n  <p>De forma predeterminada, varios comandos programados al mismo tiempo se ejecutarán secuencialmente. Si tiene comandos de larga duración, esto puede provocar que los comandos posteriores se inicien mucho más tarde de lo previsto. Si desea ejecutar comandos en segundo plano para que todos puedan ejecutarse simultáneamente, puede usar el <code>runInBackground</code>método:</p>\n  <pre><code>$schedule-&gt;command('analytics:report')\n         -&gt;daily()\n         -&gt;runInBackground();</code></pre>\n  <blockquote>\n    <div><div></div><p>El <code>runInBackground</code>método solo se puede utilizar al programar tareas a través de los métodos <code>command</code>y <code>exec</code>.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Modo de mantenimiento</h3>\n  <p>Las tareas programadas de Laravel no se ejecutarán cuando Laravel esté en modo de mantenimiento , ya que no queremos que sus tareas interfieran con cualquier mantenimiento sin terminar que pueda estar realizando en su servidor. Sin embargo, si desea forzar la ejecución de una tarea incluso en modo de mantenimiento, puede usar el <code>evenInMaintenanceMode</code>método:</p>\n  <pre><code>$schedule-&gt;command('emails:send')-&gt;evenInMaintenanceMode();</code></pre>\n  <p></p>\n  <h2>Salida de tarea</h2>\n  <p>El programador de Laravel proporciona varios métodos convenientes para trabajar con la salida generada por las tareas programadas. Primero, usando el <code>sendOutputTo</code>método, puede enviar la salida a un archivo para una inspección posterior:</p>\n  <pre><code>$schedule-&gt;command('emails:send')\n         -&gt;daily()\n         -&gt;sendOutputTo($filePath);</code></pre>\n  <p>Si desea agregar la salida a un archivo determinado, puede usar el <code>appendOutputTo</code>método:</p>\n  <pre><code>$schedule-&gt;command('emails:send')\n         -&gt;daily()\n         -&gt;appendOutputTo($filePath);</code></pre>\n  <p>Con el <code>emailOutputTo</code>método, puede enviar la salida por correo electrónico a una dirección de correo electrónico de su elección. Antes de enviar por correo electrónico la salida de una tarea, debe configurar los servicios de correo electrónico de Laravel :</p>\n  <pre><code>$schedule-&gt;command('foo')\n         -&gt;daily()\n         -&gt;sendOutputTo($filePath)\n         -&gt;emailOutputTo('foo@example.com');</code></pre>\n  <p>Si solo desea enviar la salida por correo electrónico si el comando falla, use el <code>emailOutputOnFailure</code>método:</p>\n  <pre><code>$schedule-&gt;command('foo')\n         -&gt;daily()\n         -&gt;emailOutputOnFailure('foo@example.com');</code></pre>\n  <blockquote>\n    <div><div></div><p>Los <code>emailOutputTo</code>, <code>emailOutputOnFailure</code>, <code>sendOutputTo</code>y <code>appendOutputTo</code>Métodos son exclusivos de la <code>command</code>y <code>exec</code>métodos.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Ganchos de tareas</h2>\n  <p>Con los métodos <code>before</code>y <code>after</code>, puede especificar el código que se ejecutará antes y después de que se complete la tarea programada:</p>\n  <pre><code>$schedule-&gt;command('emails:send')\n         -&gt;daily()\n         -&gt;before(function () {\n             // Task is about to start...\n         })\n         -&gt;after(function () {\n             // Task is complete...\n         });</code></pre>\n  <p>Los métodos <code>onSuccess</code>y le <code>onFailure</code>permiten especificar el código que se ejecutará si la tarea programada tiene éxito o falla:</p>\n  <pre><code>$schedule-&gt;command('emails:send')\n         -&gt;daily()\n         -&gt;onSuccess(function () {\n             // The task succeeded...\n         })\n         -&gt;onFailure(function () {\n             // The task failed...\n         });</code></pre>\n  <p>Si la salida está disponible desde su comando, puede acceder a ella en su <code>after</code>, <code>onSuccess</code>o <code>onFailure</code>ganchos al escribir una sugerencia de una instancia como en la definición de cierre de su gancho:<code>Illuminate\\Support\\Stringable</code><code>$output</code></p>\n  <pre><code>use Illuminate\\Support\\Stringable;\n\n$schedule-&gt;command('emails:send')\n         -&gt;daily()\n         -&gt;onSuccess(function (Stringable $output) {\n             // The task succeeded...\n         })\n         -&gt;onFailure(function (Stringable $output) {\n             // The task failed...\n         });</code></pre>\n  <h4>Hacer ping a las URL</h4>\n  <p>Con los métodos <code>pingBefore</code>y <code>thenPing</code>, el programador puede hacer ping automáticamente a una URL determinada antes o después de que se complete una tarea. Este método es útil para notificar a un servicio externo, como Laravel Envoyer , que su tarea programada está comenzando o ha finalizado su ejecución:</p>\n  <pre><code>$schedule-&gt;command('emails:send')\n         -&gt;daily()\n         -&gt;pingBefore($url)\n         -&gt;thenPing($url);</code></pre>\n  <p>Los métodos <code>pingBeforeIf</code>y <code>thenPingIf</code>se pueden usar para hacer ping a una URL determinada solo si la condición dada es <code>true</code>:</p>\n  <pre><code>$schedule-&gt;command('emails:send')\n         -&gt;daily()\n         -&gt;pingBeforeIf($condition, $url)\n         -&gt;thenPingIf($condition, $url);</code></pre>\n  <p>Los métodos <code>pingOnSuccess</code>y <code>pingOnFailure</code>se pueden usar para hacer ping a una URL determinada solo si la tarea tiene éxito o falla:</p>\n  <pre><code>$schedule-&gt;command('emails:send')\n         -&gt;daily()\n         -&gt;pingOnSuccess($successUrl)\n         -&gt;pingOnFailure($failureUrl);</code></pre>\n  <p>Todos los métodos de ping requieren la biblioteca HTTP Guzzle. Puede agregar Guzzle a su proyecto usando el administrador de paquetes Composer:</p>\n  <pre><code>composer require guzzlehttp/guzzle</code></pre>\n</section>"
      }
    ]
  },
  {
    "titulo": "Base de datos",
    "subtitulo": "",
    "items": [
      {
        "titulo": "7.1 Empezando",
        "contenido": "<section>\n  <h1>Base de datos: introducción</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Configuración</li>\n        <li>Conexiones de lectura y escritura</li>\n        <li>Uso de múltiples conexiones de bases de datos</li>\n      </ul></li>\n    <li>Ejecución de consultas SQL sin formato</li>\n    <li>Escuchar eventos de consulta</li>\n    <li>Transacciones de base de datos</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel hace que la interacción con bases de datos sea extremadamente simple a través de una variedad de backends de bases de datos utilizando SQL sin procesar, el generador de consultas fluido y el ORM de Eloquent . Actualmente, Laravel admite cuatro bases de datos:</p>\n  <div>\n    <ul>\n      <li>MySQL 5.6+ ( Política de versiones )</li>\n      <li>PostgreSQL 9.4+ ( Política de versiones )</li>\n      <li>SQLite 3.8.8+</li>\n      <li>SQL Server 2017+ ( política de versiones )</li>\n    </ul>\n  </div>\n  <p></p>\n  <h3>Configuración</h3>\n  <p>La configuración de la base de datos para su aplicación se encuentra en . En este archivo puede definir todas las conexiones de su base de datos, así como especificar qué conexión se debe utilizar de forma predeterminada. En este archivo se proporcionan ejemplos para la mayoría de los sistemas de bases de datos compatibles.<code>config/database.php</code></p>\n  <p>De forma predeterminada, la configuración del entorno de muestra de Laravel está lista para usar con Laravel Homestead , que es una máquina virtual conveniente para realizar el desarrollo de Laravel en su máquina local. Puede modificar esta configuración según sea necesario para su base de datos local.</p>\n  <h4>Configuración de SQLite</h4>\n  <p>Después de crear una nueva base de datos SQLite usando un comando como , puede configurar fácilmente sus variables de entorno para apuntar a esta base de datos recién creada usando la ruta absoluta de la base de datos:<code>touch database/database.sqlite</code></p>\n  <pre><code>DB_CONNECTION=sqlite\nDB_DATABASE=/absolute/path/to/database.sqlite</code></pre>\n  <p>Para habilitar restricciones de clave externa para conexiones SQLite, debe establecer la <code>DB_FOREIGN_KEYS</code>variable de entorno en <code>true</code>:</p>\n  <pre><code>DB_FOREIGN_KEYS=true</code></pre>\n  <h4>Configuración mediante URL</h4>\n  <p>Típicamente, las conexiones de base de datos se configuran utilizando varios valores de configuración, tales como <code>host</code>, <code>database</code>, <code>username</code>, <code>password</code>, etc. Cada uno de estos valores de configuración tiene su propia variable de entorno correspondiente. Esto significa que al configurar la información de conexión de su base de datos en un servidor de producción, debe administrar varias variables de entorno.</p>\n  <p>Algunos proveedores de bases de datos administradas como Heroku proporcionan una única \"URL\" de base de datos que contiene toda la información de conexión para la base de datos en una sola cadena. Una URL de base de datos de ejemplo puede tener el siguiente aspecto:</p>\n  <pre><code>mysql://root:password@127.0.0.1/forge?charset=UTF-8</code></pre>\n  <p>Estas URL suelen seguir una convención de esquema estándar:</p>\n  <pre><code>driver://username:password@host:port/database?options</code></pre>\n  <p>Para mayor comodidad, Laravel admite estas URL como una alternativa a la configuración de su base de datos con múltiples opciones de configuración. Si la opción de configuración <code>url</code>(o <code>DATABASE_URL</code>la variable de entorno correspondiente ) está presente, se utilizará para extraer la conexión de la base de datos y la información de credenciales.</p>\n  <p></p>\n  <h3>Conexiones de lectura y escritura</h3>\n  <p>A veces, es posible que desee utilizar una conexión de base de datos para las instrucciones SELECT y otra para las instrucciones INSERT, UPDATE y DELETE. Laravel hace que esto sea muy sencillo, y siempre se usarán las conexiones adecuadas, ya sea que esté utilizando consultas sin formato, el generador de consultas o el ORM de Eloquent.</p>\n  <p>Para ver cómo se deben configurar las conexiones de lectura / escritura, veamos este ejemplo:</p>\n  <pre><code>'mysql' =&gt; [\n    'read' =&gt; [\n        'host' =&gt; [\n            '192.168.1.1',\n            '196.168.1.2',\n        ],\n    ],\n    'write' =&gt; [\n        'host' =&gt; [\n            '196.168.1.3',\n        ],\n    ],\n    'sticky' =&gt; true,\n    'driver' =&gt; 'mysql',\n    'database' =&gt; 'database',\n    'username' =&gt; 'root',\n    'password' =&gt; '',\n    'charset' =&gt; 'utf8mb4',\n    'collation' =&gt; 'utf8mb4_unicode_ci',\n    'prefix' =&gt; '',\n],</code></pre>\n  <p>Tenga en cuenta que tres teclas se han añadido a la matriz de configuración: <code>read</code>, <code>write</code>y <code>sticky</code>. El <code>read</code>y <code>write</code>teclas tienen valores de matriz que contienen una sola tecla: <code>host</code>. El resto de las opciones de la base de datos para las conexiones <code>read</code>y <code>write</code>se fusionarán desde la <code>mysql</code>matriz principal .</p>\n  <p>Solo necesita colocar elementos en las matrices <code>read</code>y <code>write</code>si desea anular los valores de la matriz principal. Entonces, en este caso, se usará como host para la conexión de \"lectura\", mientras que se usará para la conexión de \"escritura\". Las credenciales de la base de datos, el prefijo, el juego de caracteres y todas las demás opciones de la matriz principal se compartirán entre ambas conexiones.<code>192.168.1.1</code><code>192.168.1.3</code><code>mysql</code></p>\n  <h4>La <code>sticky</code>Opcion</h4>\n  <p>La <code>sticky</code>opción es un valor <em>opcional</em> que se puede utilizar para permitir la lectura inmediata de registros que se han escrito en la base de datos durante el ciclo de solicitud actual. Si la <code>sticky</code>opción está habilitada y se ha realizado una operación de \"escritura\" en la base de datos durante el ciclo de solicitud actual, cualquier otra operación de \"lectura\" utilizará la conexión de \"escritura\". Esto asegura que cualquier dato escrito durante el ciclo de solicitud pueda leerse inmediatamente desde la base de datos durante esa misma solicitud. Depende de usted decidir si este es el comportamiento deseado para su aplicación.</p>\n  <p></p>\n  <h3>Uso de múltiples conexiones de bases de datos</h3>\n  <p>Cuando utilice múltiples conexiones, puede acceder a cada conexión a través del <code>connection</code>método en la <code>DB</code>fachada. El <code>name</code>paso al <code>connection</code>método debe corresponder a una de las conexiones enumeradas en su archivo de configuración:<code>config/database.php</code></p>\n  <pre><code>$users = DB::connection('foo')-&gt;select(...);</code></pre>\n  <p>También puede acceder a la instancia de PDO subyacente sin procesar mediante el <code>getPdo</code>método en una instancia de conexión:</p>\n  <pre><code>$pdo = DB::connection()-&gt;getPdo();</code></pre>\n  <p></p>\n  <h2>Ejecución de consultas SQL sin formato</h2>\n  <p>Una vez que haya configurado la conexión de su base de datos, puede ejecutar consultas usando la <code>DB</code>fachada. La <code>DB</code>fachada proporciona métodos para cada tipo de consulta: <code>select</code>, <code>update</code>, <code>insert</code>, <code>delete</code>, y <code>statement</code>.</p>\n  <h4>Ejecución de una consulta de selección</h4>\n  <p>Para ejecutar una consulta básica, puede usar el <code>select</code>método en la <code>DB</code>fachada:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Support\\Facades\\DB;\n\nclass UserController extends Controller\n{\n    /**\n     * Show a list of all of the application's users.\n     *\n     * @return Response\n     */\n    public function index()\n    {\n        $users = DB::select('select * from users where active = ?', [1]);\n\n        return view('user.index', ['users' =&gt; $users]);\n    }\n}</code></pre>\n  <p>El primer argumento que se pasa al <code>select</code>método es la consulta SQL sin formato, mientras que el segundo argumento es cualquier enlace de parámetro que deba vincularse a la consulta. Normalmente, estos son los valores de las <code>where</code>restricciones de cláusula. El enlace de parámetros proporciona protección contra la inyección de SQL.</p>\n  <p>El <code>select</code>método siempre devolverá una cantidad <code>array</code>de resultados. Cada resultado dentro de la matriz será un <code>stdClass</code>objeto PHP , lo que le permitirá acceder a los valores de los resultados:</p>\n  <pre><code>foreach ($users as $user) {\n    echo $user-&gt;name;\n}</code></pre>\n  <h4>Usar enlaces con nombre</h4>\n  <p>En lugar de usar <code>?</code>para representar sus enlaces de parámetros, puede ejecutar una consulta usando enlaces con nombre:</p>\n  <pre><code>$results = DB::select('select * from users where id = :id', ['id' =&gt; 1]);</code></pre>\n  <h4>Ejecución de una declaración de inserción</h4>\n  <p>Para ejecutar una <code>insert</code>declaración, puede utilizar el <code>insert</code>método en la <code>DB</code>fachada. Al igual que <code>select</code>, este método toma la consulta SQL sin formato como su primer argumento y los enlaces como su segundo argumento:</p>\n  <pre><code>DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);</code></pre>\n  <h4>Ejecución de una declaración de actualización</h4>\n  <p>El <code>update</code>método debe utilizarse para actualizar los registros existentes en la base de datos. Se devolverá el número de filas afectadas por la declaración:</p>\n  <pre><code>$affected = DB::update('update users set votes = 100 where name = ?', ['John']);</code></pre>\n  <h4>Ejecución de una declaración de eliminación</h4>\n  <p>El <code>delete</code>método debe usarse para eliminar registros de la base de datos. Como <code>update</code>, se devolverá el número de filas afectadas:</p>\n  <pre><code>$deleted = DB::delete('delete from users');</code></pre>\n  <h4>Ejecución de una declaración general</h4>\n  <p>Algunas declaraciones de la base de datos no devuelven ningún valor. Para este tipo de operaciones, puede utilizar el <code>statement</code>método en la <code>DB</code>fachada:</p>\n  <pre><code>DB::statement('drop table users');</code></pre>\n  <p></p>\n  <h2>Escuchar eventos de consulta</h2>\n  <p>Si desea recibir cada consulta SQL ejecutada por su aplicación, puede usar el <code>listen</code>método. Este método es útil para registrar consultas o depurar. Puede registrar su escucha de consultas en un proveedor de servicios :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        DB::listen(function ($query) {\n            // $query-&gt;sql\n            // $query-&gt;bindings\n            // $query-&gt;time\n        });\n    }\n}</code></pre>\n  <p></p>\n  <h2>Transacciones de base de datos</h2>\n  <p>Puede usar el <code>transaction</code>método en la <code>DB</code>fachada para ejecutar un conjunto de operaciones dentro de una transacción de base de datos. Si se lanza una excepción dentro de la transacción <code>Closure</code>, la transacción se revertirá automáticamente. Si se <code>Closure</code>ejecuta correctamente, la transacción se confirmará automáticamente. No necesita preocuparse por retroceder o comprometerse manualmente mientras usa el <code>transaction</code>método:</p>\n  <pre><code>DB::transaction(function () {\n    DB::table('users')-&gt;update(['votes' =&gt; 1]);\n\n    DB::table('posts')-&gt;delete();\n});</code></pre>\n  <h4>Manejo de interbloqueos</h4>\n  <p>El <code>transaction</code>método acepta un segundo argumento opcional que define el número de veces que se debe volver a intentar una transacción cuando se produce un punto muerto. Una vez que se hayan agotado estos intentos, se lanzará una excepción:</p>\n  <pre><code>DB::transaction(function () {\n    DB::table('users')-&gt;update(['votes' =&gt; 1]);\n\n    DB::table('posts')-&gt;delete();\n}, 5);</code></pre>\n  <h4>Uso manual de transacciones</h4>\n  <p>Si desea comenzar una transacción manualmente y tener un control completo sobre las reversiones y confirmaciones, puede usar el <code>beginTransaction</code>método en la <code>DB</code>fachada:</p>\n  <pre><code>DB::beginTransaction();</code></pre>\n  <p>Puede revertir la transacción a través del <code>rollBack</code>método:</p>\n  <pre><code>DB::rollBack();</code></pre>\n  <p>Por último, puede confirmar una transacción a través del <code>commit</code>método:</p>\n  <pre><code>DB::commit();</code></pre>\n  <blockquote>\n    <div><div></div><p>Los <code>DB</code>métodos de transacción de la fachada controlan las transacciones tanto para el generador de consultas como para Eloquent ORM .</p></div>\n  </blockquote>\n</section>"
      },
      {
        "titulo": "7.2 Consultor de construcción",
        "contenido": "<section>\n  <h1>Base de datos: generador de consultas</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Recuperando resultados\n      <ul>\n        <li>Resultados de fragmentación</li>\n        <li>Agregados</li>\n      </ul></li>\n    <li>Selecciona</li>\n    <li>Expresiones crudas</li>\n    <li>Uniones</li>\n    <li>Sindicatos</li>\n    <li>Donde las cláusulas\n      <ul>\n        <li>Agrupación de parámetros</li>\n        <li>Dónde existen cláusulas</li>\n        <li>Subconsultas Where Cláusulas</li>\n        <li>JSON Where Cláusulas</li>\n      </ul></li>\n    <li>Ordenar, agrupar, limitar y compensar</li>\n    <li>Clausulas condicionales</li>\n    <li>Inserta</li>\n    <li>Actualizaciones\n      <ul>\n        <li>Actualización de columnas JSON</li>\n        <li>Incremento y decremento</li>\n      </ul></li>\n    <li>Elimina</li>\n    <li>Bloqueo pesimista</li>\n    <li>Depuración</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>El generador de consultas de base de datos de Laravel proporciona una interfaz cómoda y fluida para crear y ejecutar consultas de base de datos. Se puede utilizar para realizar la mayoría de las operaciones de base de datos en su aplicación y funciona en todos los sistemas de base de datos compatibles.</p>\n  <p>El generador de consultas de Laravel utiliza el enlace de parámetros PDO para proteger su aplicación contra ataques de inyección SQL. No es necesario limpiar las cadenas que se pasan como enlaces.</p>\n  <blockquote>\n    <div><div></div><p>PDO no admite nombres de columna vinculantes. Por lo tanto, nunca debe permitir que la entrada del usuario dicte los nombres de las columnas a las que hacen referencia sus consultas, incluidas las columnas \"ordenar por\", etc. Si debe permitir que el usuario seleccione ciertas columnas para consultar, siempre valide los nombres de las columnas contra un blanco- lista de columnas permitidas.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Recuperando resultados</h2>\n  <h4>Recuperar todas las filas de una tabla</h4>\n  <p>Puede usar el <code>table</code>método en la <code>DB</code>fachada para comenzar una consulta. El <code>table</code>método devuelve una instancia de generador de consultas fluida para la tabla dada, lo que le permite encadenar más restricciones en la consulta y finalmente obtener los resultados utilizando el <code>get</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Support\\Facades\\DB;\n\nclass UserController extends Controller\n{\n    /**\n     * Show a list of all of the application's users.\n     *\n     * @return Response\n     */\n    public function index()\n    {\n        $users = DB::table('users')-&gt;get();\n\n        return view('user.index', ['users' =&gt; $users]);\n    }\n}</code></pre>\n  <p>El <code>get</code>método devuelve un que contiene los resultados donde cada resultado es una instancia del objeto PHP . Puede acceder al valor de cada columna accediendo a la columna como una propiedad del objeto:<code>Illuminate\\Support\\Collection</code><code>stdClass</code></p>\n  <pre><code>foreach ($users as $user) {\n    echo $user-&gt;name;\n}</code></pre>\n  <h4>Recuperar una sola fila / columna de una tabla</h4>\n  <p>Si solo necesita recuperar una sola fila de la tabla de la base de datos, puede usar el <code>first</code>método. Este método devolverá un solo <code>stdClass</code>objeto:</p>\n  <pre><code>$user = DB::table('users')-&gt;where('name', 'John')-&gt;first();\n\necho $user-&gt;name;</code></pre>\n  <p>Si ni siquiera necesita una fila completa, puede extraer un solo valor de un registro usando el <code>value</code>método. Este método devolverá el valor de la columna directamente:</p>\n  <pre><code>$email = DB::table('users')-&gt;where('name', 'John')-&gt;value('email');</code></pre>\n  <p>Para recuperar una sola fila por su <code>id</code>valor de columna, use el <code>find</code>método:</p>\n  <pre><code>$user = DB::table('users')-&gt;find(3);</code></pre>\n  <h4>Recuperar una lista de valores de columna</h4>\n  <p>Si desea recuperar una colección que contiene los valores de una sola columna, puede utilizar el <code>pluck</code>método. En este ejemplo, recuperaremos una colección de títulos de roles:</p>\n  <pre><code>$titles = DB::table('roles')-&gt;pluck('title');\n\nforeach ($titles as $title) {\n    echo $title;\n}</code></pre>\n  <p>También puede especificar una columna de clave personalizada para la colección devuelta:</p>\n  <pre><code>$roles = DB::table('roles')-&gt;pluck('title', 'name');\n\nforeach ($roles as $name =&gt; $title) {\n    echo $title;\n}</code></pre>\n  <p></p>\n  <h3>Resultados de fragmentación</h3>\n  <p>Si necesita trabajar con miles de registros de bases de datos, considere usar el <code>chunk</code>método. Este método recupera una pequeña parte de los resultados a la vez y alimenta cada parte en un archivo <code>Closure</code>para su procesamiento. Este método es muy útil para escribir comandos Artisan que procesan miles de registros. Por ejemplo, trabajemos con toda la <code>users</code>tabla en fragmentos de 100 registros a la vez:</p>\n  <pre><code>DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) {\n    foreach ($users as $user) {\n        //\n    }\n});</code></pre>\n  <p>Puede evitar que se procesen más fragmentos volviendo <code>false</code>de <code>Closure</code>:</p>\n  <pre><code>DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) {\n    // Process the records...\n\n    return false;\n});</code></pre>\n  <p>Si actualiza los registros de la base de datos mientras fragmenta los resultados, los resultados de fragmentos pueden cambiar de formas inesperadas. Por lo tanto, al actualizar registros mientras se fragmentan, siempre es mejor utilizar el <code>chunkById</code>método. Este método paginará automáticamente los resultados según la clave principal del registro:</p>\n  <pre><code>DB::table('users')-&gt;where('active', false)\n    -&gt;chunkById(100, function ($users) {\n        foreach ($users as $user) {\n            DB::table('users')\n                -&gt;where('id', $user-&gt;id)\n                -&gt;update(['active' =&gt; true]);\n        }\n    });</code></pre>\n  <blockquote>\n    <div><div></div><p>Al actualizar o eliminar registros dentro de la devolución de llamada del fragmento, cualquier cambio en la clave principal o en las claves externas podría afectar la consulta del fragmento. Esto podría provocar que los registros no se incluyan en los resultados fragmentados.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Agregados</h3>\n  <p>El generador de consultas también proporciona una variedad de métodos agregados tales como <code>count</code>, <code>max</code>, <code>min</code>, <code>avg</code>, y <code>sum</code>. Puede llamar a cualquiera de estos métodos después de construir su consulta:</p>\n  <pre><code>$users = DB::table('users')-&gt;count();\n\n$price = DB::table('orders')-&gt;max('price');</code></pre>\n  <p>Puede combinar estos métodos con otras cláusulas:</p>\n  <pre><code>$price = DB::table('orders')\n                -&gt;where('finalized', 1)\n                -&gt;avg('price');</code></pre>\n  <h4>Determinar si existen registros</h4>\n  <p>En lugar de usar el <code>count</code>método para determinar si existen registros que coincidan con las restricciones de su consulta, puede usar los métodos <code>exists</code>y <code>doesntExist</code>:</p>\n  <pre><code>return DB::table('orders')-&gt;where('finalized', 1)-&gt;exists();\n\nreturn DB::table('orders')-&gt;where('finalized', 1)-&gt;doesntExist();</code></pre>\n  <p></p>\n  <h2>Selecciona</h2>\n  <h4>Especificar una cláusula de selección</h4>\n  <p>Es posible que no siempre desee seleccionar todas las columnas de una tabla de base de datos. Con el <code>select</code>método, puede especificar una <code>select</code>cláusula personalizada para la consulta:</p>\n  <pre><code>$users = DB::table('users')-&gt;select('name', 'email as user_email')-&gt;get();</code></pre>\n  <p>El <code>distinct</code>método le permite forzar la consulta para que devuelva resultados distintos:</p>\n  <pre><code>$users = DB::table('users')-&gt;distinct()-&gt;get();</code></pre>\n  <p>Si ya tiene una instancia del generador de consultas y desea agregar una columna a su cláusula de selección existente, puede usar el <code>addSelect</code>método:</p>\n  <pre><code>$query = DB::table('users')-&gt;select('name');\n\n$users = $query-&gt;addSelect('age')-&gt;get();</code></pre>\n  <p></p>\n  <h2>Expresiones crudas</h2>\n  <p>A veces, es posible que deba utilizar una expresión sin formato en una consulta. Para crear una expresión sin formato, puede usar el método:<code>DB::raw</code></p>\n  <pre><code>$users = DB::table('users')\n                     -&gt;select(DB::raw('count(*) as user_count, status'))\n                     -&gt;where('status', '&lt;&gt;', 1)\n                     -&gt;groupBy('status')\n                     -&gt;get();</code></pre>\n  <blockquote>\n    <div><div></div><p> Las declaraciones sin procesar se inyectarán en la consulta como cadenas, por lo que debe tener mucho cuidado de no crear vulnerabilidades de inyección SQL.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Métodos crudos</h3>\n  <p>En lugar de usar , también puede usar los siguientes métodos para insertar una expresión sin formato en varias partes de su consulta.<code>DB::raw</code></p>\n  <h4><code>selectRaw</code></h4>\n  <p>El <code>selectRaw</code>método se puede utilizar en lugar de . Este método acepta una matriz opcional de enlaces como segundo argumento:<code>addSelect(DB::raw(...))</code></p>\n  <pre><code>$orders = DB::table('orders')\n                -&gt;selectRaw('price * ? as price_with_tax', [1.0825])\n                -&gt;get();</code></pre>\n  <h4><code>whereRaw / orWhereRaw</code></h4>\n  <p>Los métodos <code>whereRaw</code>y <code>orWhereRaw</code>se pueden utilizar para inyectar una <code>where</code>cláusula sin formato en su consulta. Estos métodos aceptan una matriz opcional de enlaces como segundo argumento:</p>\n  <pre><code>$orders = DB::table('orders')\n                -&gt;whereRaw('price &gt; IF(state = \"TX\", ?, 100)', [200])\n                -&gt;get();</code></pre>\n  <h4><code>havingRaw / orHavingRaw</code></h4>\n  <p>Los métodos <code>havingRaw</code>y <code>orHavingRaw</code>pueden usarse para establecer una cadena sin formato como el valor de la <code>having</code>cláusula. Estos métodos aceptan una matriz opcional de enlaces como segundo argumento:</p>\n  <pre><code>$orders = DB::table('orders')\n                -&gt;select('department', DB::raw('SUM(price) as total_sales'))\n                -&gt;groupBy('department')\n                -&gt;havingRaw('SUM(price) &gt; ?', [2500])\n                -&gt;get();</code></pre>\n  <h4><code>orderByRaw</code></h4>\n  <p>El <code>orderByRaw</code>método se puede utilizar para establecer una cadena sin formato como valor de la <code>order by</code>cláusula:</p>\n  <pre><code>$orders = DB::table('orders')\n                -&gt;orderByRaw('updated_at - created_at DESC')\n                -&gt;get();</code></pre>\n  <h3><code>groupByRaw</code></h3>\n  <p>El <code>groupByRaw</code>método se puede utilizar para establecer una cadena sin formato como valor de la <code>group by</code>cláusula:</p>\n  <pre><code>$orders = DB::table('orders')\n                -&gt;select('city', 'state')\n                -&gt;groupByRaw('city, state')\n                -&gt;get();</code></pre>\n  <p></p>\n  <h2>Uniones</h2>\n  <h4>Cláusula de unión interna</h4>\n  <p>El generador de consultas también se puede utilizar para escribir sentencias de combinación. Para realizar una \"unión interna\" básica, puede utilizar el <code>join</code>método en una instancia del generador de consultas. El primer argumento que se pasa al <code>join</code>método es el nombre de la tabla a la que necesita unirse, mientras que los argumentos restantes especifican las restricciones de columna para la combinación. Incluso puede unirse a varias tablas en una sola consulta:</p>\n  <pre><code>$users = DB::table('users')\n            -&gt;join('contacts', 'users.id', '=', 'contacts.user_id')\n            -&gt;join('orders', 'users.id', '=', 'orders.user_id')\n            -&gt;select('users.*', 'contacts.phone', 'orders.price')\n            -&gt;get();</code></pre>\n  <h4>Cláusula de unión izquierda / unión derecha</h4>\n  <p>Si desea realizar una \"combinación izquierda\" o \"combinación derecha\" en lugar de una \"combinación interna\", utilice los métodos <code>leftJoin</code>o <code>rightJoin</code>. Estos métodos tienen la misma firma que el <code>join</code>método:</p>\n  <pre><code>$users = DB::table('users')\n            -&gt;leftJoin('posts', 'users.id', '=', 'posts.user_id')\n            -&gt;get();\n\n$users = DB::table('users')\n            -&gt;rightJoin('posts', 'users.id', '=', 'posts.user_id')\n            -&gt;get();</code></pre>\n  <h4>Cláusula de unión cruzada</h4>\n  <p>Para realizar una \"unión cruzada\", utilice el <code>crossJoin</code>método con el nombre de la tabla a la que desea realizar la unión cruzada. Las uniones cruzadas generan un producto cartesiano entre la primera tabla y la tabla unida:</p>\n  <pre><code>$sizes = DB::table('sizes')\n            -&gt;crossJoin('colors')\n            -&gt;get();</code></pre>\n  <h4>Cláusulas de unión avanzadas</h4>\n  <p>También puede especificar cláusulas de unión más avanzadas. Para comenzar, pase a <code>Closure</code>como segundo argumento en el <code>join</code>método. El <code>Closure</code>recibirá un <code>JoinClause</code>objeto que le permite especificar restricciones en la <code>join</code>cláusula:</p>\n  <pre><code>DB::table('users')\n        -&gt;join('contacts', function ($join) {\n            $join-&gt;on('users.id', '=', 'contacts.user_id')-&gt;orOn(...);\n        })\n        -&gt;get();</code></pre>\n  <p>Si desea utilizar una cláusula de estilo \"where\" en sus combinaciones, puede utilizar los métodos <code>where</code>y <code>orWhere</code>en una combinación. En lugar de comparar dos columnas, estos métodos compararán la columna con un valor:</p>\n  <pre><code>DB::table('users')\n        -&gt;join('contacts', function ($join) {\n            $join-&gt;on('users.id', '=', 'contacts.user_id')\n                 -&gt;where('contacts.user_id', '&gt;', 5);\n        })\n        -&gt;get();</code></pre>\n  <h4>Uniones de subconsultas</h4>\n  <p>Es posible utilizar los <code>joinSub</code>, <code>leftJoinSub</code>y <code>rightJoinSub</code>métodos para unirse a una consulta para una subconsulta. Cada uno de estos métodos recibe tres argumentos: la subconsulta, su alias de tabla y un cierre que define las columnas relacionadas:</p>\n  <pre><code>$latestPosts = DB::table('posts')\n                   -&gt;select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))\n                   -&gt;where('is_published', true)\n                   -&gt;groupBy('user_id');\n\n$users = DB::table('users')\n        -&gt;joinSub($latestPosts, 'latest_posts', function ($join) {\n            $join-&gt;on('users.id', '=', 'latest_posts.user_id');\n        })-&gt;get();</code></pre>\n  <p></p>\n  <h2>Sindicatos</h2>\n  <p>El generador de consultas también proporciona una forma rápida de \"unir\" dos consultas. Por ejemplo, puede crear una consulta inicial y usar el <code>union</code>método para unirla con una segunda consulta:</p>\n  <pre><code>$first = DB::table('users')\n            -&gt;whereNull('first_name');\n\n$users = DB::table('users')\n            -&gt;whereNull('last_name')\n            -&gt;union($first)\n            -&gt;get();</code></pre>\n  <blockquote>\n    <div><div></div><p>El <code>unionAll</code>método también está disponible y tiene la misma firma de método que <code>union</code>.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Donde las cláusulas</h2>\n  <h4>Cláusulas Where simples</h4>\n  <p>Puede utilizar el <code>where</code>método en una instancia del generador de consultas para agregar <code>where</code>cláusulas a la consulta. La llamada más básica a <code>where</code>requiere tres argumentos. El primer argumento es el nombre de la columna. El segundo argumento es un operador, que puede ser cualquiera de los operadores admitidos por la base de datos. Finalmente, el tercer argumento es el valor a evaluar contra la columna.</p>\n  <p>Por ejemplo, aquí hay una consulta que verifica que el valor de la columna \"votos\" sea igual a 100:</p>\n  <pre><code>$users = DB::table('users')-&gt;where('votes', '=', 100)-&gt;get();</code></pre>\n  <p>Por conveniencia, si desea verificar que una columna es igual a un valor dado, puede pasar el valor directamente como segundo argumento del <code>where</code>método:</p>\n  <pre><code>$users = DB::table('users')-&gt;where('votes', 100)-&gt;get();</code></pre>\n  <p>Puede utilizar una variedad de otros operadores al escribir una <code>where</code>cláusula:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;where('votes', '&gt;=', 100)\n                -&gt;get();\n\n$users = DB::table('users')\n                -&gt;where('votes', '&lt;&gt;', 100)\n                -&gt;get();\n\n$users = DB::table('users')\n                -&gt;where('name', 'like', 'T%')\n                -&gt;get();</code></pre>\n  <p>También puede pasar una serie de condiciones a la <code>where</code>función:</p>\n  <pre><code>$users = DB::table('users')-&gt;where([\n    ['status', '=', '1'],\n    ['subscribed', '&lt;&gt;', '1'],\n])-&gt;get();</code></pre>\n  <h4>O declaraciones</h4>\n  <p>Puede encadenar las restricciones donde, así como agregar <code>or</code>cláusulas a la consulta. El <code>orWhere</code>método acepta los mismos argumentos que el <code>where</code>método:</p>\n  <pre><code>$users = DB::table('users')\n                    -&gt;where('votes', '&gt;', 100)\n                    -&gt;orWhere('name', 'John')\n                    -&gt;get();</code></pre>\n  <p>Si necesita agrupar una condición \"o\" entre paréntesis, puede pasar un Closure como primer argumento del <code>orWhere</code>método:</p>\n  <pre><code>$users = DB::table('users')\n            -&gt;where('votes', '&gt;', 100)\n            -&gt;orWhere(function($query) {\n                $query-&gt;where('name', 'Abigail')\n                      -&gt;where('votes', '&gt;', 50);\n            })\n            -&gt;get();\n\n// SQL: select * from users where votes &gt; 100 or (name = 'Abigail' and votes &gt; 50)</code></pre>\n  <h4>Cláusulas adicionales Where</h4>\n  <p><strong>whereBetween / orWhereBetween</strong></p>\n  <p>El <code>whereBetween</code>método verifica que el valor de una columna esté entre dos valores:</p>\n  <pre><code>$users = DB::table('users')\n           -&gt;whereBetween('votes', [1, 100])\n           -&gt;get();</code></pre>\n  <p><strong>whereNotBetween / orWhereNotBetween</strong></p>\n  <p>El <code>whereNotBetween</code>método verifica que el valor de una columna esté fuera de dos valores:</p>\n  <pre><code>$users = DB::table('users')\n                    -&gt;whereNotBetween('votes', [1, 100])\n                    -&gt;get();</code></pre>\n  <p><strong>whereIn / whereNotIn / orWhereIn / orWhereNotIn</strong></p>\n  <p>El <code>whereIn</code>método verifica que el valor de una columna dada esté contenido dentro de la matriz dada:</p>\n  <pre><code>$users = DB::table('users')\n                    -&gt;whereIn('id', [1, 2, 3])\n                    -&gt;get();</code></pre>\n  <p>El <code>whereNotIn</code>método verifica que el valor de la columna dada <strong>no</strong> esté contenido en la matriz dada:</p>\n  <pre><code>$users = DB::table('users')\n                    -&gt;whereNotIn('id', [1, 2, 3])\n                    -&gt;get();</code></pre>\n  <blockquote>\n    <div><div></div><p>Si está agregando una gran variedad de enlaces de enteros a su consulta, los métodos <code>whereIntegerInRaw</code>o <code>whereIntegerNotInRaw</code>pueden usarse para reducir en gran medida el uso de memoria.</p></div>\n  </blockquote>\n  <p><strong>whereNull / whereNotNull / oWhereNull / oWhereNotNull</strong></p>\n  <p>El <code>whereNull</code>método verifica que el valor de la columna dada es <code>NULL</code>:</p>\n  <pre><code>$users = DB::table('users')\n                    -&gt;whereNull('updated_at')\n                    -&gt;get();</code></pre>\n  <p>El <code>whereNotNull</code>método verifica que el valor de la columna no sea <code>NULL</code>:</p>\n  <pre><code>$users = DB::table('users')\n                    -&gt;whereNotNull('updated_at')\n                    -&gt;get();</code></pre>\n  <p><strong>whereDate / whereMonth / whereDay / whereYear / whereTime</strong></p>\n  <p>El <code>whereDate</code>método puede usarse para comparar el valor de una columna con una fecha:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereDate('created_at', '2016-12-31')\n                -&gt;get();</code></pre>\n  <p>El <code>whereMonth</code>método se puede usar para comparar el valor de una columna con un mes específico de un año:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereMonth('created_at', '12')\n                -&gt;get();</code></pre>\n  <p>El <code>whereDay</code>método se puede usar para comparar el valor de una columna con un día específico de un mes:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereDay('created_at', '31')\n                -&gt;get();</code></pre>\n  <p>El <code>whereYear</code>método se puede utilizar para comparar el valor de una columna con un año específico:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereYear('created_at', '2016')\n                -&gt;get();</code></pre>\n  <p>El <code>whereTime</code>método puede usarse para comparar el valor de una columna con un tiempo específico:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereTime('created_at', '=', '11:20:45')\n                -&gt;get();</code></pre>\n  <p><strong>whereColumn / orWhereColumn</strong></p>\n  <p>El <code>whereColumn</code>método se puede utilizar para verificar que dos columnas sean iguales:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereColumn('first_name', 'last_name')\n                -&gt;get();</code></pre>\n  <p>También puede pasar un operador de comparación al método:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereColumn('updated_at', '&gt;', 'created_at')\n                -&gt;get();</code></pre>\n  <p>El <code>whereColumn</code>método también puede pasar una serie de múltiples condiciones. Estas condiciones se unirán utilizando el <code>and</code>operador:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereColumn([\n                    ['first_name', '=', 'last_name'],\n                    ['updated_at', '&gt;', 'created_at'],\n                ])-&gt;get();</code></pre>\n  <p></p>\n  <h3>Agrupación de parámetros</h3>\n  <p>A veces, es posible que deba crear cláusulas where más avanzadas, como cláusulas \"dónde existe\" o agrupaciones de parámetros anidadas. El generador de consultas de Laravel también puede manejarlos. Para comenzar, veamos un ejemplo de agrupación de restricciones entre paréntesis:</p>\n  <pre><code>$users = DB::table('users')\n           -&gt;where('name', '=', 'John')\n           -&gt;where(function ($query) {\n               $query-&gt;where('votes', '&gt;', 100)\n                     -&gt;orWhere('title', '=', 'Admin');\n           })\n           -&gt;get();</code></pre>\n  <p>Como puede ver, pasar un <code>Closure</code>al <code>where</code>método indica al constructor de consultas que comience un grupo de restricciones. El <code>Closure</code>recibirá una instancia del generador de consultas que puede usar para establecer las restricciones que deben estar contenidas dentro del grupo de paréntesis. El ejemplo anterior producirá el siguiente SQL:</p>\n  <pre><code>select * from users where name = 'John' and (votes &gt; 100 or title = 'Admin')</code></pre>\n  <blockquote>\n    <div><div></div><p>Siempre debe agrupar las <code>orWhere</code>llamadas para evitar comportamientos inesperados cuando se aplican alcances globales.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Dónde existen cláusulas</h3>\n  <p>El <code>whereExists</code>método le permite escribir <code>where exists</code>cláusulas SQL. El <code>whereExists</code>método acepta un <code>Closure</code>argumento, que recibirá una instancia del generador de consultas que le permitirá definir la consulta que debe colocarse dentro de la cláusula \"existe\":</p>\n  <pre><code>$users = DB::table('users')\n           -&gt;whereExists(function ($query) {\n               $query-&gt;select(DB::raw(1))\n                     -&gt;from('orders')\n                     -&gt;whereRaw('orders.user_id = users.id');\n           })\n           -&gt;get();</code></pre>\n  <p>La consulta anterior producirá el siguiente SQL:</p>\n  <pre><code>select * from users\nwhere exists (\n    select 1 from orders where orders.user_id = users.id\n)</code></pre>\n  <p></p>\n  <h3>Subconsultas Where Cláusulas</h3>\n  <p>A veces, es posible que deba construir una cláusula where que compare los resultados de una subconsulta con un valor dado. Puede lograr esto pasando un Closure y un valor al <code>where</code>método. Por ejemplo, la siguiente consulta recuperará todos los usuarios que tengan una \"membresía\" reciente de un tipo determinado;</p>\n  <pre><code>use App\\Models\\User;\n\n$users = User::where(function ($query) {\n    $query-&gt;select('type')\n        -&gt;from('membership')\n        -&gt;whereColumn('user_id', 'users.id')\n        -&gt;orderByDesc('start_date')\n        -&gt;limit(1);\n}, 'Pro')-&gt;get();</code></pre>\n  <p></p>\n  <h3>JSON Where Cláusulas</h3>\n  <p>Laravel también admite la consulta de tipos de columnas JSON en bases de datos que brindan soporte para tipos de columnas JSON. Actualmente, esto incluye MySQL 5.7, PostgreSQL, SQL Server 2016 y SQLite 3.9.0 (con la extensión JSON1 ). Para consultar una columna JSON, use el operador:<code>-&gt;</code></p>\n  <pre><code>$users = DB::table('users')\n                -&gt;where('options-&gt;language', 'en')\n                -&gt;get();\n\n$users = DB::table('users')\n                -&gt;where('preferences-&gt;dining-&gt;meal', 'salad')\n                -&gt;get();</code></pre>\n  <p>Puede usar <code>whereJsonContains</code>para consultar matrices JSON (no es compatible con SQLite):</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereJsonContains('options-&gt;languages', 'en')\n                -&gt;get();</code></pre>\n  <p>Soporte de MySQL y PostgreSQL <code>whereJsonContains</code>con múltiples valores:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereJsonContains('options-&gt;languages', ['en', 'de'])\n                -&gt;get();</code></pre>\n  <p>Puede usar <code>whereJsonLength</code>para consultar matrices JSON por su longitud:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;whereJsonLength('options-&gt;languages', 0)\n                -&gt;get();\n\n$users = DB::table('users')\n                -&gt;whereJsonLength('options-&gt;languages', '&gt;', 1)\n                -&gt;get();</code></pre>\n  <p></p>\n  <h2>Ordenar, agrupar, limitar y compensar</h2>\n  <h4>orderBy</h4>\n  <p>El <code>orderBy</code>método le permite ordenar el resultado de la consulta por una columna determinada. El primer argumento del <code>orderBy</code>método debe ser la columna por la que desea ordenar, mientras que el segundo argumento controla la dirección de la ordenación y puede ser <code>asc</code>o <code>desc</code>:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;orderBy('name', 'desc')\n                -&gt;get();</code></pre>\n  <p>Si necesita ordenar por varias columnas, puede invocar <code>orderBy</code>tantas veces como sea necesario:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;orderBy('name', 'desc')\n                -&gt;orderBy('email', 'asc')\n                -&gt;get();</code></pre>\n  <h4>último / más antiguo</h4>\n  <p>Los métodos <code>latest</code>y le <code>oldest</code>permiten ordenar fácilmente los resultados por fecha. De forma predeterminada, el resultado se ordenará por <code>created_at</code>columna. O puede pasar el nombre de la columna por la que desea ordenar:</p>\n  <pre><code>$user = DB::table('users')\n                -&gt;latest()\n                -&gt;first();</code></pre>\n  <h4>En orden aleatorio</h4>\n  <p>El <code>inRandomOrder</code>método se puede utilizar para ordenar los resultados de la consulta al azar. Por ejemplo, puede utilizar este método para buscar un usuario aleatorio:</p>\n  <pre><code>$randomUser = DB::table('users')\n                -&gt;inRandomOrder()\n                -&gt;first();</code></pre>\n  <h4>reordenar</h4>\n  <p>El <code>reorder</code>método le permite eliminar todos los pedidos existentes y, opcionalmente, aplicar un nuevo pedido. Por ejemplo, puede eliminar todos los pedidos existentes:</p>\n  <pre><code>$query = DB::table('users')-&gt;orderBy('name');\n\n$unorderedUsers = $query-&gt;reorder()-&gt;get();</code></pre>\n  <p>Para eliminar todos los pedidos existentes y aplicar un nuevo pedido, proporcione la columna y la dirección como argumentos del método:</p>\n  <pre><code>$query = DB::table('users')-&gt;orderBy('name');\n\n$usersOrderedByEmail = $query-&gt;reorder('email', 'desc')-&gt;get();</code></pre>\n  <h4>groupBy / teniendo</h4>\n  <p>Los métodos <code>groupBy</code>y <code>having</code>se pueden utilizar para agrupar los resultados de la consulta. La <code>having</code>firma del método es similar a la del <code>where</code>método:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;groupBy('account_id')\n                -&gt;having('account_id', '&gt;', 100)\n                -&gt;get();</code></pre>\n  <p>Puede pasar varios argumentos al <code>groupBy</code>método para agrupar por varias columnas:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;groupBy('first_name', 'status')\n                -&gt;having('account_id', '&gt;', 100)\n                -&gt;get();</code></pre>\n  <p>Para <code>having</code>declaraciones más avanzadas , consulte el <code>havingRaw</code>método.</p>\n  <h4>saltar / tomar</h4>\n  <p>Para limitar la cantidad de resultados devueltos por la consulta, o para omitir una cantidad determinada de resultados en la consulta, puede usar los métodos <code>skip</code>y <code>take</code>:</p>\n  <pre><code>$users = DB::table('users')-&gt;skip(10)-&gt;take(5)-&gt;get();</code></pre>\n  <p>Alternativamente, puede utilizar los métodos <code>limit</code>y <code>offset</code>:</p>\n  <pre><code>$users = DB::table('users')\n                -&gt;offset(10)\n                -&gt;limit(5)\n                -&gt;get();</code></pre>\n  <p></p>\n  <h2>Clausulas condicionales</h2>\n  <p>A veces, es posible que desee que las cláusulas se apliquen a una consulta solo cuando algo más es verdadero. Por ejemplo, es posible que solo desee aplicar una <code>where</code>declaración si un valor de entrada determinado está presente en la solicitud entrante. Puede lograr esto usando el <code>when</code>método:</p>\n  <pre><code>$role = $request-&gt;input('role');\n\n$users = DB::table('users')\n                -&gt;when($role, function ($query, $role) {\n                    return $query-&gt;where('role_id', $role);\n                })\n                -&gt;get();</code></pre>\n  <p>El <code>when</code>método solo ejecuta el Closure dado cuando el primer parámetro es <code>true</code>. Si el primer parámetro es <code>false</code>, no se ejecutará el cierre.</p>\n  <p>Puede pasar otro Closure como tercer parámetro del <code>when</code>método. Este cierre se ejecutará si el primer parámetro se evalúa como <code>false</code>. Para ilustrar cómo se puede usar esta función, la usaremos para configurar la clasificación predeterminada de una consulta:</p>\n  <pre><code>$sortBy = null;\n\n$users = DB::table('users')\n                -&gt;when($sortBy, function ($query, $sortBy) {\n                    return $query-&gt;orderBy($sortBy);\n                }, function ($query) {\n                    return $query-&gt;orderBy('name');\n                })\n                -&gt;get();</code></pre>\n  <p></p>\n  <h2>Inserta</h2>\n  <p>El generador de consultas también proporciona un <code>insert</code>método para insertar registros en la tabla de la base de datos. El <code>insert</code>método acepta una matriz de nombres y valores de columna:</p>\n  <pre><code>DB::table('users')-&gt;insert(\n    ['email' =&gt; 'john@example.com', 'votes' =&gt; 0]\n);</code></pre>\n  <p>Incluso puede insertar varios registros en la tabla con una sola llamada <code>insert</code>pasando una matriz de matrices. Cada matriz representa una fila que se insertará en la tabla:</p>\n  <pre><code>DB::table('users')-&gt;insert([\n    ['email' =&gt; 'taylor@example.com', 'votes' =&gt; 0],\n    ['email' =&gt; 'dayle@example.com', 'votes' =&gt; 0],\n]);</code></pre>\n  <p>El <code>insertOrIgnore</code>método ignorará los errores de registros duplicados al insertar registros en la base de datos:</p>\n  <pre><code>DB::table('users')-&gt;insertOrIgnore([\n    ['id' =&gt; 1, 'email' =&gt; 'taylor@example.com'],\n    ['id' =&gt; 2, 'email' =&gt; 'dayle@example.com'],\n]);</code></pre>\n  <h4>ID de incremento automático</h4>\n  <p>Si la tabla tiene un ID de incremento automático, use el <code>insertGetId</code>método para insertar un registro y luego recupere el ID:</p>\n  <pre><code>$id = DB::table('users')-&gt;insertGetId(\n    ['email' =&gt; 'john@example.com', 'votes' =&gt; 0]\n);</code></pre>\n  <blockquote>\n    <div><div></div><p>Cuando se usa PostgreSQL, el <code>insertGetId</code>método espera que se nombre la columna de incremento automático <code>id</code>. Si desea recuperar el ID de una \"secuencia\" diferente, puede pasar el nombre de la columna como segundo parámetro del <code>insertGetId</code>método.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Actualizaciones</h2>\n  <p>Además de insertar registros en la base de datos, el generador de consultas también puede actualizar los registros existentes mediante el <code>update</code>método. El <code>update</code>método, al igual que el <code>insert</code>método, acepta una matriz de pares de columnas y valores que contienen las columnas que se actualizarán. Puede restringir la <code>update</code>consulta mediante <code>where</code>cláusulas:</p>\n  <pre><code>$affected = DB::table('users')\n              -&gt;where('id', 1)\n              -&gt;update(['votes' =&gt; 1]);</code></pre>\n  <h4>Actualizar o insertar</h4>\n  <p>A veces, es posible que desee actualizar un registro existente en la base de datos o crearlo si no existe ningún registro coincidente. En este escenario, <code>updateOrInsert</code>se puede utilizar el método. El <code>updateOrInsert</code>método acepta dos argumentos: una matriz de condiciones mediante las cuales se encuentra el registro y una matriz de pares de columnas y valores que contienen las columnas que se actualizarán.</p>\n  <p>El <code>updateOrInsert</code>método primero intentará localizar un registro de base de datos coincidente utilizando la columna y los pares de valor del primer argumento. Si el registro existe, se actualizará con los valores del segundo argumento. Si no se puede encontrar el registro, se insertará un nuevo registro con los atributos combinados de ambos argumentos:</p>\n  <pre><code>DB::table('users')\n    -&gt;updateOrInsert(\n        ['email' =&gt; 'john@example.com', 'name' =&gt; 'John'],\n        ['votes' =&gt; '2']\n    );</code></pre>\n  <p></p>\n  <h3>Actualización de columnas JSON</h3>\n  <p>Al actualizar una columna JSON, debe usar la sintaxis para acceder a la clave adecuada en el objeto JSON. Esta operación es compatible con MySQL 5.7+ y PostgreSQL 9.5+:<code>-&gt;</code></p>\n  <pre><code>$affected = DB::table('users')\n              -&gt;where('id', 1)\n              -&gt;update(['options-&gt;enabled' =&gt; true]);</code></pre>\n  <p></p>\n  <h3>Incremento y decremento</h3>\n  <p>El generador de consultas también proporciona métodos convenientes para incrementar o disminuir el valor de una columna determinada. Este es un atajo, que proporciona una interfaz más expresiva y concisa en comparación con escribir manualmente la <code>update</code>declaración.</p>\n  <p>Ambos métodos aceptan al menos un argumento: la columna a modificar. Opcionalmente, se puede pasar un segundo argumento para controlar la cantidad en la que la columna debe incrementarse o disminuirse:</p>\n  <pre><code>DB::table('users')-&gt;increment('votes');\n\nDB::table('users')-&gt;increment('votes', 5);\n\nDB::table('users')-&gt;decrement('votes');\n\nDB::table('users')-&gt;decrement('votes', 5);</code></pre>\n  <p>También puede especificar columnas adicionales para actualizar durante la operación:</p>\n  <pre><code>DB::table('users')-&gt;increment('votes', 1, ['name' =&gt; 'John']);</code></pre>\n  <blockquote>\n    <div><div></div><p>Los eventos de modelo no se activan cuando se utilizan los métodos <code>increment</code>y <code>decrement</code>.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Elimina</h2>\n  <p>El generador de consultas también se puede utilizar para eliminar registros de la tabla a través del <code>delete</code>método. Puede restringir <code>delete</code>declaraciones agregando <code>where</code>cláusulas antes de llamar al <code>delete</code>método:</p>\n  <pre><code>DB::table('users')-&gt;delete();\n\nDB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;delete();</code></pre>\n  <p>Si desea truncar toda la tabla, lo que eliminará todas las filas y restablecerá el ID de incremento automático a cero, puede usar el <code>truncate</code>método:</p>\n  <pre><code>DB::table('users')-&gt;truncate();</code></pre>\n  <p></p>\n  <h2>Bloqueo pesimista</h2>\n  <p>El generador de consultas también incluye algunas funciones para ayudarlo a realizar un \"bloqueo pesimista\" en sus <code>select</code>declaraciones. Para ejecutar la declaración con un \"bloqueo compartido\", puede utilizar el <code>sharedLock</code>método en una consulta. Un bloqueo compartido evita que las filas seleccionadas se modifiquen hasta que su transacción se confirme:</p>\n  <pre><code>DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;sharedLock()-&gt;get();</code></pre>\n  <p>Alternativamente, puede utilizar el <code>lockForUpdate</code>método. Un bloqueo \"para actualización\" evita que las filas se modifiquen o se seleccionen con otro bloqueo compartido:</p>\n  <pre><code>DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;lockForUpdate()-&gt;get();</code></pre>\n  <p></p>\n  <h2>Depuración</h2>\n  <p>Puede utilizar los métodos <code>dd</code>o <code>dump</code>al crear una consulta para volcar los enlaces de consulta y SQL. El <code>dd</code>método mostrará la información de depuración y luego dejará de ejecutar la solicitud. El <code>dump</code>método mostrará la información de depuración pero permitirá que la solicitud se siga ejecutando:</p>\n  <pre><code>DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;dd();\n\nDB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;dump();</code></pre>\n</section>"
      },
      {
        "titulo": "7.2 Paginación",
        "contenido": "<section>\n  <h1>Base de datos: paginación</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Uso básico\n      <ul>\n        <li>Paginación de resultados del generador de consultas</li>\n        <li>Paginación de resultados elocuentes</li>\n        <li>Crear manualmente un paginador</li>\n      </ul></li>\n    <li>Visualización de resultados de paginación\n      <ul>\n        <li>Conversión de resultados a JSON</li>\n      </ul></li>\n    <li>Personalizar la vista de paginación\n      <ul>\n        <li>Usando Bootstrap</li>\n      </ul></li>\n    <li>Métodos de instancia de Paginator</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>En otros marcos, la paginación puede ser muy dolorosa. El paginador de Laravel está integrado con el generador de consultas y Eloquent ORM y proporciona una paginación conveniente y fácil de usar de los resultados de la base de datos de inmediato. Por defecto, el HTML generado por el paginador es compatible con el marco CSS Tailwind ; sin embargo, las vistas Bootstrap también están disponibles.</p>\n  <p></p>\n  <h2>Uso básico</h2>\n  <p></p>\n  <h3>Paginación de resultados del generador de consultas</h3>\n  <p>Hay varias formas de paginar elementos. La más simple es usar el <code>paginate</code>método en el generador de consultas o una consulta Eloquent . El <code>paginate</code>método se encarga automáticamente de establecer el límite y el desplazamiento adecuados en función de la página actual que está viendo el usuario. De forma predeterminada, la página actual es detectada por el valor del <code>page</code>argumento de la cadena de consulta en la solicitud HTTP. Este valor es detectado automáticamente por Laravel y también se inserta automáticamente en los enlaces generados por el paginador.</p>\n  <p>En este ejemplo, el único argumento que se pasa al <code>paginate</code>método es el número de elementos que le gustaría que se mostraran \"por página\". En este caso, especifiquemos que nos gustaría mostrar <code>15</code>elementos por página:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Support\\Facades\\DB;\n\nclass UserController extends Controller\n{\n    /**\n     * Show all of the users for the application.\n     *\n     * @return Response\n     */\n    public function index()\n    {\n        $users = DB::table('users')-&gt;paginate(15);\n\n        return view('user.index', ['users' =&gt; $users]);\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Actualmente, las operaciones de paginación que usan una <code>groupBy</code>declaración no pueden ser ejecutadas de manera eficiente por Laravel. Si necesita utilizar un <code>groupBy</code>con un conjunto de resultados paginados, se recomienda que consulte la base de datos y cree un paginador manualmente.</p></div>\n  </blockquote>\n  <h4>\"Paginación simple\"</h4>\n  <p>Si solo necesita mostrar enlaces simples \"Siguiente\" y \"Anterior\" en su vista de paginación, puede usar el <code>simplePaginate</code>método para realizar una consulta más eficiente. Esto es muy útil para grandes conjuntos de datos cuando no necesita mostrar un enlace para cada número de página al renderizar su vista:</p>\n  <pre><code>$users = DB::table('users')-&gt;simplePaginate(15);</code></pre>\n  <p></p>\n  <h3>Paginación de resultados elocuentes</h3>\n  <p>También puede paginar consultas de Eloquent . En este ejemplo, paginaremos el <code>User</code>modelo con <code>15</code>elementos por página. Como puede ver, la sintaxis es casi idéntica a la paginación de los resultados del generador de consultas:</p>\n  <pre><code>$users = App\\Models\\User::paginate(15);</code></pre>\n  <p>Puede llamar <code>paginate</code>después de establecer otras restricciones en la consulta, como <code>where</code>cláusulas:</p>\n  <pre><code>$users = User::where('votes', '&gt;', 100)-&gt;paginate(15);</code></pre>\n  <p>También puede utilizar el <code>simplePaginate</code>método al paginar modelos Eloquent:</p>\n  <pre><code>$users = User::where('votes', '&gt;', 100)-&gt;simplePaginate(15);</code></pre>\n  <p></p>\n  <h3>Crear manualmente un paginador</h3>\n  <p>A veces, es posible que desee crear una instancia de paginación manualmente, pasándole una matriz de elementos. Puede hacerlo creando una instancia o , según sus necesidades.<code>Illuminate\\Pagination\\Paginator</code><code>Illuminate\\Pagination\\LengthAwarePaginator</code></p>\n  <p>La <code>Paginator</code>clase no necesita conocer el número total de elementos en el conjunto de resultados; sin embargo, debido a esto, la clase no tiene métodos para recuperar el índice de la última página. El <code>LengthAwarePaginator</code>acepta casi los mismos argumentos que la <code>Paginator</code>; sin embargo, requiere un recuento del número total de elementos en el conjunto de resultados.</p>\n  <p>En otras palabras, <code>Paginator</code>corresponde al <code>simplePaginate</code>método en el generador de consultas y Eloquent, mientras que <code>LengthAwarePaginator</code>corresponde al <code>paginate</code>método.</p>\n  <blockquote>\n    <div><div></div><p>Al crear manualmente una instancia de paginador, debe \"dividir\" manualmente la matriz de resultados que pasa al paginador. Si no está seguro de cómo hacer esto, consulte la función PHP array_slice .</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Visualización de resultados de paginación</h2>\n  <p>Al llamar al <code>paginate</code>método, recibirá una instancia de . Al llamar al método, recibirá una instancia de . Estos objetos proporcionan varios métodos que describen el conjunto de resultados. Además de estos métodos auxiliares, las instancias del paginador son iteradores y se pueden enlazar como una matriz. Entonces, una vez que haya recuperado los resultados, puede mostrar los resultados y representar los enlaces de la página usando Blade :<code>Illuminate\\Pagination\\LengthAwarePaginator</code><code>simplePaginate</code><code>Illuminate\\Pagination\\Paginator</code></p>\n  <pre><code>&lt;div class=\"container\"&gt;\n    @foreach ($users as $user)\n        {{ $user-&gt;name }}\n    @endforeach\n&lt;/div&gt;\n\n{{ $users-&gt;links() }}</code></pre>\n  <p>El <code>links</code>método mostrará los enlaces al resto de las páginas del conjunto de resultados. Cada uno de estos enlaces ya contendrá la <code>page</code>variable de cadena de consulta adecuada . Recuerde, el HTML generado por el <code>links</code>método es compatible con el marco CSS Tailwind .</p>\n  <h4>Personalización del URI del paginador</h4>\n  <p>El <code>withPath</code>método le permite personalizar la URI utilizada por el paginador al generar enlaces. Por ejemplo, si desea que el paginador genere enlaces como , debe pasar al método:<code>http://example.com/custom/url?page=N</code><code>custom/url</code><code>withPath</code></p>\n  <pre><code>Route::get('users', function () {\n    $users = App\\Models\\User::paginate(15);\n\n    $users-&gt;withPath('custom/url');\n\n    //\n});</code></pre>\n  <h4>Agregar a enlaces de paginación</h4>\n  <p>Puede agregar a la cadena de consulta de enlaces de paginación utilizando el <code>appends</code>método. Por ejemplo, para agregar a cada enlace de paginación, debe realizar la siguiente llamada a :<code>sort=votes</code><code>appends</code></p>\n  <pre><code>{{ $users-&gt;appends(['sort' =&gt; 'votes'])-&gt;links() }}</code></pre>\n  <p>Si desea agregar todos los valores actuales de la cadena de consulta a los enlaces de paginación, puede usar el <code>withQueryString</code>método:</p>\n  <pre><code>{{ $users-&gt;withQueryString()-&gt;links() }}</code></pre>\n  <p>Si desea agregar un \"fragmento hash\" a las URL del paginador, puede utilizar el <code>fragment</code>método. Por ejemplo, para agregar <code>#foo</code>al final de cada enlace de paginación, realice la siguiente llamada al <code>fragment</code>método:</p>\n  <pre><code>{{ $users-&gt;fragment('foo')-&gt;links() }}</code></pre>\n  <h4>Ajustar la ventana del enlace de paginación</h4>\n  <p>Puede controlar cuántos enlaces adicionales se muestran en cada lado de la \"ventana\" de URL del paginador. De forma predeterminada, se muestran tres enlaces a cada lado de los enlaces del paginador principal. Sin embargo, puede controlar este número usando el <code>onEachSide</code>método:</p>\n  <pre><code>{{ $users-&gt;onEachSide(5)-&gt;links() }}</code></pre>\n  <p></p>\n  <h3>Conversión de resultados a JSON</h3>\n  <p>Las clases de resultados del paginador de Laravel implementan el contrato de interfaz y exponen el método, por lo que es muy fácil convertir los resultados de la paginación a JSON. También puede convertir una instancia de paginador a JSON devolviéndola desde una ruta o acción de controlador:<code>Illuminate\\Contracts\\Support\\Jsonable</code><code>toJson</code></p>\n  <pre><code>Route::get('users', function () {\n    return App\\Models\\User::paginate();\n});</code></pre>\n  <p>El JSON desde el paginador incluirá información de metadatos, tales como <code>total</code>, <code>current_page</code>, <code>last_page</code>, y mucho más. Los objetos de resultado reales estarán disponibles a través de la <code>data</code>clave en la matriz JSON. Aquí hay un ejemplo del JSON creado al devolver una instancia de paginador de una ruta:</p>\n  <pre><code>{\n   \"total\": 50,\n   \"per_page\": 15,\n   \"current_page\": 1,\n   \"last_page\": 4,\n   \"first_page_url\": \"http://laravel.app?page=1\",\n   \"last_page_url\": \"http://laravel.app?page=4\",\n   \"next_page_url\": \"http://laravel.app?page=2\",\n   \"prev_page_url\": null,\n   \"path\": \"http://laravel.app\",\n   \"from\": 1,\n   \"to\": 15,\n   \"data\":[\n        {\n            // Result Object\n        },\n        {\n            // Result Object\n        }\n   ]\n}</code></pre>\n  <p></p>\n  <h2>Personalizar la vista de paginación</h2>\n  <p>De forma predeterminada, las vistas renderizadas para mostrar los enlaces de paginación son compatibles con el marco CSS Tailwind. Sin embargo, si no está utilizando Tailwind, puede definir sus propias vistas para representar estos enlaces. Al llamar al <code>links</code>método en una instancia del paginador, pase el nombre de la vista como primer argumento del método:</p>\n  <pre><code>{{ $paginator-&gt;links('view.name') }}\n\n// Passing data to the view...\n{{ $paginator-&gt;links('view.name', ['foo' =&gt; 'bar']) }}</code></pre>\n  <p>Sin embargo, la forma más fácil de personalizar las vistas de paginación es exportándolas a su directorio usando el comando:<code>resources/views/vendor</code><code>vendor:publish</code></p>\n  <pre><code>php artisan vendor:publish --tag=laravel-pagination</code></pre>\n  <p>Este comando colocará las vistas en el directorio. El archivo dentro de este directorio corresponde a la vista de paginación predeterminada. Puede editar este archivo para modificar el HTML de paginación.<code>resources/views/vendor/pagination</code><code>tailwind.blade.php</code></p>\n  <p>Si desea designar un archivo diferente como la vista de paginación predeterminada, puede usar los métodos del paginador <code>defaultView</code>y <code>defaultSimpleView</code>dentro de su <code>AppServiceProvider</code>:</p>\n  <pre><code>use Illuminate\\Pagination\\Paginator;\n\npublic function boot()\n{\n    Paginator::defaultView('view-name');\n\n    Paginator::defaultSimpleView('view-name');\n}</code></pre>\n  <p></p>\n  <h3>Usando Bootstrap</h3>\n  <p>Laravel incluye vistas de paginación creadas con Bootstrap CSS . Para usar estas vistas en lugar de las vistas Tailwind predeterminadas, puede llamar al <code>useBootstrap</code>método del paginador dentro de su <code>AppServiceProvider</code>:</p>\n  <pre><code>use Illuminate\\Pagination\\Paginator;\n\npublic function boot()\n{\n    Paginator::useBootstrap();\n}</code></pre>\n  <p></p>\n  <h2>Métodos de instancia de Paginator</h2>\n  <p>Cada instancia de paginador proporciona información de paginación adicional mediante los siguientes métodos:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Método</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$paginator-&gt;count()</code></td>\n      <td>Obtén el número de elementos de la página actual.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;currentPage()</code></td>\n      <td>Obtenga el número de página actual.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;firstItem()</code></td>\n      <td>Obtenga el número de resultado del primer elemento en los resultados.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;getOptions()</code></td>\n      <td>Obtén las opciones del paginador.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;getUrlRange($start, $end)</code></td>\n      <td>Crea un rango de URL de paginación.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;hasPages()</code></td>\n      <td>Determine si hay suficientes elementos para dividir en varias páginas.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;hasMorePages()</code></td>\n      <td>Determine si hay más elementos en el almacén de datos.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;items()</code></td>\n      <td>Obtenga los elementos de la página actual.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;lastItem()</code></td>\n      <td>Obtenga el número de resultado del último elemento en los resultados.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;lastPage()</code></td>\n      <td>Obtenga el número de página de la última página disponible. (No disponible cuando se usa <code>simplePaginate</code>).</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;nextPageUrl()</code></td>\n      <td>Obtenga la URL de la página siguiente.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;onFirstPage()</code></td>\n      <td>Determina si el paginador está en la primera página.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;perPage()</code></td>\n      <td>El número de elementos que se mostrarán por página.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;previousPageUrl()</code></td>\n      <td>Obtenga la URL de la página anterior.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;total()</code></td>\n      <td>Determine el número total de elementos coincidentes en el almacén de datos. (No disponible cuando se usa <code>simplePaginate</code>).</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;url($page)</code></td>\n      <td>Obtenga la URL de un número de página determinado.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;getPageName()</code></td>\n      <td>Obtiene la variable de cadena de consulta utilizada para almacenar la página.</td>\n    </tr>\n    <tr>\n      <td><code>$paginator-&gt;setPageName($name)</code></td>\n      <td>Establezca la variable de cadena de consulta utilizada para almacenar la página.</td>\n    </tr>\n    </tbody>\n  </table>\n</section>"
      },
      {
        "titulo": "7.3 Migraciones",
        "contenido": "<section>\n  <h1>Base de datos: Migraciones</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Generando migraciones\n      <ul>\n        <li>Aplastando migraciones</li>\n      </ul></li>\n    <li>Estructura de migración</li>\n    <li>Ejecución de migraciones\n      <ul>\n        <li>Revertir migraciones</li>\n      </ul></li>\n    <li>Mesas\n      <ul>\n        <li>Crear tablas</li>\n        <li>Cambio de nombre / eliminación de tablas</li>\n      </ul></li>\n    <li>Columnas\n      <ul>\n        <li>Creando columnas</li>\n        <li>Modificadores de columna</li>\n        <li>Modificar columnas</li>\n        <li>Dejar caer columnas</li>\n      </ul></li>\n    <li>Índices\n      <ul>\n        <li>Crear índices</li>\n        <li>Cambiar el nombre de los índices</li>\n        <li>Eliminando índices</li>\n        <li>Restricciones de clave externa</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Las migraciones son como el control de versiones de su base de datos, lo que le permite a su equipo modificar y compartir el esquema de la base de datos de la aplicación. Las migraciones generalmente se combinan con el generador de esquemas de Laravel para construir el esquema de la base de datos de su aplicación. Si alguna vez ha tenido que decirle a un compañero de equipo que agregue manualmente una columna a su esquema de base de datos local, se ha enfrentado al problema que resuelven las migraciones de base de datos.</p>\n  <p>La <code>Schema</code> fachada de Laravel proporciona soporte independiente de la base de datos para crear y manipular tablas en todos los sistemas de base de datos compatibles con Laravel.</p>\n  <p></p>\n  <h2>Generando migraciones</h2>\n  <p>Para crear una migración, use el comando Artisan :<code>make:migration</code> </p>\n  <pre><code>php artisan make:migration create_users_table</code></pre>\n  <p>La nueva migración se colocará en su directorio. Cada nombre de archivo de migración contiene una marca de tiempo, que permite a Laravel determinar el orden de las migraciones.<code>database/migrations</code></p>\n  <blockquote>\n    <div><div></div><p>Los stubs de migración se pueden personalizar mediante la publicación de stub</p></div>\n  </blockquote>\n  <p>Las opciones <code>--table</code>y <code>--create</code>también se pueden usar para indicar el nombre de la tabla y si la migración creará una nueva tabla o no. Estas opciones rellenan previamente el archivo de resguardo de migración generado con la tabla especificada:</p>\n  <pre><code>php artisan make:migration create_users_table --create=users\n\nphp artisan make:migration add_votes_to_users_table --table=users</code></pre>\n  <p>Si desea especificar una ruta de salida personalizada para la migración generada, puede usar la <code>--path</code>opción al ejecutar el comando. La ruta dada debe ser relativa a la ruta base de su aplicación.<code>make:migration</code></p>\n  <p></p>\n  <h3>Aplastando migraciones</h3>\n  <p>A medida que crea su aplicación, puede acumular más y más migraciones a lo largo del tiempo. Esto puede hacer que su directorio de migración se infle con potencialmente cientos de migraciones. Si lo desea, puede \"aplastar\" sus migraciones en un solo archivo SQL. Para comenzar, ejecute el comando:<code>schema:dump</code></p>\n  <pre><code>php artisan schema:dump\n\n// Dump the current database schema and prune all existing migrations...\nphp artisan schema:dump --prune</code></pre>\n  <p>Cuando ejecute este comando, Laravel escribirá un archivo \"esquema\" en su directorio. Ahora, cuando intente migrar su base de datos y no se hayan ejecutado otras migraciones, Laravel ejecutará primero el SQL del archivo de esquema. Después de ejecutar los comandos del archivo de esquema, Laravel ejecutará las migraciones restantes que no formaban parte del volcado de esquema.<code>database/schema</code></p>\n  <p>Debe enviar su archivo de esquema de base de datos al control de código fuente para que otros desarrolladores nuevos de su equipo puedan crear rápidamente la estructura de base de datos inicial de su aplicación.</p>\n  <blockquote>\n    <div><div></div><p>El aplastamiento de la migración solo está disponible para las bases de datos MySQL, PostgreSQL y SQLite. Por supuesto, no puede usar un volcado de base de datos MySQL / PostgreSQL en combinación con una base de datos SQLite en memoria durante la prueba.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Estructura de migración</h2>\n  <p>Una clase de migración contiene dos métodos: <code>up</code>y <code>down</code>. El <code>up</code>método se utiliza para agregar nuevas tablas, columnas o índices a su base de datos, mientras que el <code>down</code>método debe revertir las operaciones realizadas por el <code>up</code>método.</p>\n  <p>Dentro de estos dos métodos, puede utilizar el generador de esquemas de Laravel para crear y modificar tablas de forma expresiva. Para conocer todos los métodos disponibles en el <code>Schema</code>constructor, consulte su documentación . Por ejemplo, la siguiente migración crea una <code>flights</code>tabla:</p>\n  <pre><code>&lt;?php\n\nuse Illuminate\\Database\\Migrations\\Migration;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\Schema;\n\nclass CreateFlightsTable extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::create('flights', function (Blueprint $table) {\n            $table-&gt;id();\n            $table-&gt;string('name');\n            $table-&gt;string('airline');\n            $table-&gt;timestamps();\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::drop('flights');\n    }\n}</code></pre>\n  <p></p>\n  <h2>Ejecución de migraciones</h2>\n  <p>Para ejecutar todas sus migraciones pendientes, ejecute el <code>migrate</code>comando Artisan:</p>\n  <pre><code>php artisan migrate</code></pre>\n  <blockquote>\n    <div><div></div><p>Si está utilizando la máquina virtual de Homestead , debe ejecutar este comando desde su máquina virtual.</p></div>\n  </blockquote>\n  <h4>Obligación de que las migraciones se ejecuten en producción</h4>\n  <p>Algunas operaciones de migración son destructivas, lo que significa que pueden provocar la pérdida de datos. Para protegerlo de ejecutar estos comandos en su base de datos de producción, se le pedirá confirmación antes de que se ejecuten los comandos. Para forzar que los comandos se ejecuten sin un mensaje, use la <code>--force</code>bandera:</p>\n  <pre><code>php artisan migrate --force</code></pre>\n  <p></p>\n  <h3>Revertir migraciones</h3>\n  <p>Para revertir la última operación de migración, puede usar el <code>rollback</code>comando. Este comando revierte el último \"lote\" de migraciones, que puede incluir varios archivos de migración:</p>\n  <pre><code>php artisan migrate:rollback</code></pre>\n  <p>Puede revertir un número limitado de migraciones proporcionando la <code>step</code>opción al <code>rollback</code>comando. Por ejemplo, el siguiente comando revertirá las últimas cinco migraciones:</p>\n  <pre><code>php artisan migrate:rollback --step=5</code></pre>\n  <p>El comando revertirá todas las migraciones de su aplicación:<code>migrate:reset</code></p>\n  <pre><code>php artisan migrate:reset</code></pre>\n  <h4>Revertir y migrar con un solo comando</h4>\n  <p>El comando revertirá todas sus migraciones y luego ejecutará el comando. Este comando recrea efectivamente toda su base de datos:<code>migrate:refresh</code><code>migrate</code></p>\n  <pre><code>php artisan migrate:refresh\n\n// Refresh the database and run all database seeds...\nphp artisan migrate:refresh --seed</code></pre>\n  <p>Puede revertir y volver a migrar un número limitado de migraciones proporcionando la <code>step</code>opción al <code>refresh</code>comando. Por ejemplo, el siguiente comando revertirá y volverá a migrar las últimas cinco migraciones:</p>\n  <pre><code>php artisan migrate:refresh --step=5</code></pre>\n  <h4>Eliminar todas las tablas y migrar</h4>\n  <p>El comando eliminará todas las tablas de la base de datos y luego ejecutará el comando:<code>migrate:fresh</code><code>migrate</code></p>\n  <pre><code>php artisan migrate:fresh\n\nphp artisan migrate:fresh --seed</code></pre>\n  <p></p>\n  <h2>Mesas</h2>\n  <p></p>\n  <h3>Crear tablas</h3>\n  <p>Para crear una nueva tabla de base de datos, use el <code>create</code>método en la <code>Schema</code>fachada. El <code>create</code>método acepta dos argumentos: el primero es el nombre de la tabla, mientras que el segundo es un <code>Closure</code>que recibe un <code>Blueprint</code>objeto que puede usarse para definir la nueva tabla:</p>\n  <pre><code>Schema::create('users', function (Blueprint $table) {\n    $table-&gt;id();\n});</code></pre>\n  <p>Al crear la tabla, puede utilizar cualquiera de los métodos de columna del generador de esquemas para definir las columnas de la tabla.</p>\n  <h4>Comprobación de la existencia de una tabla / columna</h4>\n  <p>Puede verificar la existencia de una tabla o columna usando los métodos <code>hasTable</code>y <code>hasColumn</code>:</p>\n  <pre><code>if (Schema::hasTable('users')) {\n    //\n}\n\nif (Schema::hasColumn('users', 'email')) {\n    //\n}</code></pre>\n  <h4>Opciones de tabla y conexión de base de datos</h4>\n  <p>Si desea realizar una operación de esquema en una conexión de base de datos que no es su conexión predeterminada, use el <code>connection</code>método:</p>\n  <pre><code>Schema::connection('foo')-&gt;create('users', function (Blueprint $table) {\n    $table-&gt;id();\n});</code></pre>\n  <p>Puede utilizar los siguientes comandos en el generador de esquemas para definir las opciones de la tabla:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Mando</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$table-&gt;engine = 'InnoDB';</code></td>\n      <td>Especifique el motor de almacenamiento de tablas (MySQL).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;charset = 'utf8mb4';</code></td>\n      <td>Especifique un juego de caracteres predeterminado para la tabla (MySQL).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;collation = 'utf8mb4_unicode_ci';</code></td>\n      <td>Especifique una intercalación predeterminada para la tabla (MySQL).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;temporary();</code></td>\n      <td>Cree una tabla temporal (excepto SQL Server).</td>\n    </tr>\n    </tbody>\n  </table>\n  <p></p>\n  <h3>Cambio de nombre / eliminación de tablas</h3>\n  <p>Para cambiar el nombre de una tabla de base de datos existente, use el <code>rename</code>método:</p>\n  <pre><code>Schema::rename($from, $to);</code></pre>\n  <p>Para eliminar una tabla existente, puede utilizar los métodos <code>drop</code>o <code>dropIfExists</code>:</p>\n  <pre><code>Schema::drop('users');\n\nSchema::dropIfExists('users');</code></pre>\n  <h4>Cambio de nombre de tablas con claves externas</h4>\n  <p>Antes de cambiar el nombre de una tabla, debe verificar que cualquier restricción de clave externa en la tabla tenga un nombre explícito en sus archivos de migración en lugar de permitir que Laravel asigne un nombre basado en la convención. De lo contrario, el nombre de la restricción de clave externa se referirá al nombre de la tabla anterior.</p>\n  <p></p>\n  <h2>Columnas</h2>\n  <p></p>\n  <h3>Creando columnas</h3>\n  <p>El <code>table</code>método en la <code>Schema</code>fachada se puede utilizar para actualizar tablas existentes. Al igual que el <code>create</code>método, el <code>table</code>método acepta dos argumentos: el nombre de la tabla y un <code>Closure</code>que recibe una <code>Blueprint</code>instancia que puede usar para agregar columnas a la tabla:</p>\n  <pre><code>Schema::table('users', function (Blueprint $table) {\n    $table-&gt;string('email');\n});</code></pre>\n  <h4>Tipos de columna disponibles</h4>\n  <p>El constructor de esquemas contiene una variedad de tipos de columnas que puede especificar al crear sus tablas:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Mando</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$table-&gt;id();</code></td>\n      <td>Alias \u200B\u200Bde .<code>$table-&gt;bigIncrements('id')</code></td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;foreignId('user_id');</code></td>\n      <td>Alias \u200B\u200Bde .<code>$table-&gt;unsignedBigInteger('user_id')</code></td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;bigIncrements('id');</code></td>\n      <td>Columna equivalente SIN FIRMAR BIGINT (clave principal) de incremento automático.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;bigInteger('votes');</code></td>\n      <td>Columna equivalente a BIGINT.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;binary('data');</code></td>\n      <td>Columna equivalente a BLOB.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;boolean('confirmed');</code></td>\n      <td>Columna equivalente a BOOLEAN.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;char('name', 100);</code></td>\n      <td>CHAR columna equivalente con una longitud.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;date('created_at');</code></td>\n      <td>Columna equivalente a FECHA.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dateTime('created_at', 0);</code></td>\n      <td>Columna equivalente a DATETIME con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dateTimeTz('created_at', 0);</code></td>\n      <td>DATETIME (con zona horaria) columna equivalente con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;decimal('amount', 8, 2);</code></td>\n      <td>Columna equivalente DECIMAL con precisión (dígitos totales) y escala (dígitos decimales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;double('amount', 8, 2);</code></td>\n      <td>Columna DOBLE equivalente con precisión (dígitos totales) y escala (dígitos decimales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;enum('level', ['easy', 'hard']);</code></td>\n      <td>Columna equivalente ENUM.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;float('amount', 8, 2);</code></td>\n      <td>FLOAT columna equivalente con precisión (dígitos totales) y escala (dígitos decimales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;geometry('positions');</code></td>\n      <td>Columna equivalente a GEOMETRÍA.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;geometryCollection('positions');</code></td>\n      <td>Columna equivalente a GEOMETRYCOLLECTION.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;increments('id');</code></td>\n      <td>Columna equivalente de INTEGER SIN FIRMAR (clave principal) de incremento automático.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;integer('votes');</code></td>\n      <td>Columna equivalente a INTEGER.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;ipAddress('visitor');</code></td>\n      <td>Columna equivalente de dirección IP.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;json('options');</code></td>\n      <td>Columna equivalente a JSON.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;jsonb('options');</code></td>\n      <td>Columna equivalente a JSONB.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;lineString('positions');</code></td>\n      <td>Columna equivalente LINESTRING.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;longText('description');</code></td>\n      <td>Columna equivalente a LONGTEXT.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;macAddress('device');</code></td>\n      <td>Columna equivalente a la dirección MAC.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;mediumIncrements('id');</code></td>\n      <td>Columna equivalente MEDIUMINT SIN FIRMAR (clave primaria) de incremento automático.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;mediumInteger('votes');</code></td>\n      <td>Columna equivalente a MEDIUMINT.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;mediumText('description');</code></td>\n      <td>Columna equivalente a MEDIUMTEXT.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;morphs('taggable');</code></td>\n      <td>Agrega columnas equivalentes <code>taggable_id</code>BIGINT y <code>taggable_type</code>VARCHAR SIN FIRMAR .</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;uuidMorphs('taggable');</code></td>\n      <td>Agrega columnas equivalentes de UUID <code>taggable_id</code>CHAR (36) y <code>taggable_type</code>VARCHAR (255).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;multiLineString('positions');</code></td>\n      <td>Columna equivalente MULTILINESTRING.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;multiPoint('positions');</code></td>\n      <td>Columna equivalente MULTIPOINT.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;multiPolygon('positions');</code></td>\n      <td>Columna equivalente MULTIPOLYGON.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;nullableMorphs('taggable');</code></td>\n      <td>Agrega versiones de columnas que aceptan valores NULL .<code>morphs()</code></td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;nullableUuidMorphs('taggable');</code></td>\n      <td>Agrega versiones de columnas que aceptan valores NULL .<code>uuidMorphs()</code></td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;nullableTimestamps(0);</code></td>\n      <td>Alias \u200B\u200Bde método.<code>timestamps()</code></td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;point('position');</code></td>\n      <td>PUNTO columna equivalente.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;polygon('positions');</code></td>\n      <td>Columna equivalente POLYGON.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;rememberToken();</code></td>\n      <td>Agrega una <code>remember_token</code>columna equivalente a VARCHAR (100) que acepta valores NULL .</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;set('flavors', ['strawberry', 'vanilla']);</code></td>\n      <td>SET columna equivalente.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;smallIncrements('id');</code></td>\n      <td>Columna equivalente SIN FIRMAR SMALLINT (clave principal) de incremento automático.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;smallInteger('votes');</code></td>\n      <td>Columna equivalente SMALLINT.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;softDeletes('deleted_at', 0);</code></td>\n      <td>Agrega una <code>deleted_at</code>columna equivalente a TIMESTAMP que acepta valores NULL para eliminaciones suaves con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;softDeletesTz('deleted_at', 0);</code></td>\n      <td>Agrega una <code>deleted_at</code>columna equivalente TIMESTAMP (con zona horaria) que acepta valores NULL para eliminaciones suaves con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;string('name', 100);</code></td>\n      <td>VARCHAR columna equivalente con una longitud.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;text('description');</code></td>\n      <td>Columna equivalente a TEXTO.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;time('sunrise', 0);</code></td>\n      <td>Columna equivalente a TIEMPO con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;timeTz('sunrise', 0);</code></td>\n      <td>HORA (con zona horaria) columna equivalente con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;timestamp('added_on', 0);</code></td>\n      <td>Columna equivalente TIMESTAMP con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;timestampTz('added_on', 0);</code></td>\n      <td>TIMESTAMP (con zona horaria) columna equivalente con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;timestamps(0);</code></td>\n      <td>Agrega columnas equivalentes de TIMESTAMP <code>created_at</code>y que <code>updated_at</code>aceptan valores NULL con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;timestampsTz(0);</code></td>\n      <td>Agrega columnas equivalentes que aceptan valores NULL <code>created_at</code>y <code>updated_at</code>TIMESTAMP (con zona horaria) con precisión (dígitos totales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;tinyIncrements('id');</code></td>\n      <td>Columna equivalente de TINYINT SIN FIRMAR (clave principal) de incremento automático.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;tinyInteger('votes');</code></td>\n      <td>Columna equivalente a TINYINT.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;unsignedBigInteger('votes');</code></td>\n      <td>Columna equivalente BIGINT SIN FIRMAR.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;unsignedDecimal('amount', 8, 2);</code></td>\n      <td>Columna equivalente DECIMAL SIN FIRMAR con precisión (dígitos totales) y escala (dígitos decimales).</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;unsignedInteger('votes');</code></td>\n      <td>Columna equivalente de INTEGER SIN FIRMAR.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;unsignedMediumInteger('votes');</code></td>\n      <td>Columna equivalente a MEDIUMINT SIN FIRMAR.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;unsignedSmallInteger('votes');</code></td>\n      <td>Columna equivalente SMALLINT SIN FIRMAR.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;unsignedTinyInteger('votes');</code></td>\n      <td>Columna equivalente a TINYINT SIN FIRMAR.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;uuid('id');</code></td>\n      <td>Columna equivalente de UUID.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;year('birth_year');</code></td>\n      <td>Columna equivalente a AÑO.</td>\n    </tr>\n    </tbody>\n  </table>\n  <p></p>\n  <h3>Modificadores de columna</h3>\n  <p>Además de los tipos de columna enumerados anteriormente, hay varios \"modificadores\" de columna que puede usar al agregar una columna a una tabla de base de datos. Por ejemplo, para hacer que la columna sea \"anulable\", puede usar el <code>nullable</code>método:</p>\n  <pre><code>Schema::table('users', function (Blueprint $table) {\n    $table-&gt;string('email')-&gt;nullable();\n});</code></pre>\n  <p>La siguiente lista contiene todos los modificadores de columna disponibles. Esta lista no incluye los modificadores de índice :</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Modificador</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>-&gt;after('column')</code></td>\n      <td>Coloque la columna \"después\" de otra columna (MySQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;autoIncrement()</code></td>\n      <td>Establecer columnas INTEGER como incremento automático (clave principal)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;charset('utf8mb4')</code></td>\n      <td>Especifique un juego de caracteres para la columna (MySQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;collation('utf8mb4_unicode_ci')</code></td>\n      <td>Especifique una intercalación para la columna (MySQL / PostgreSQL / SQL Server)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;comment('my comment')</code></td>\n      <td>Agregar un comentario a una columna (MySQL / PostgreSQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;default($value)</code></td>\n      <td>Especifique un valor \"predeterminado\" para la columna</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;first()</code></td>\n      <td>Coloque la columna \"primero\" en la tabla (MySQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;from($integer)</code></td>\n      <td>Establecer el valor inicial de un campo de incremento automático (MySQL / PostgreSQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;nullable($value = true)</code></td>\n      <td>Permite (por defecto) insertar valores NULL en la columna</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;storedAs($expression)</code></td>\n      <td>Crear una columna generada almacenada (MySQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;unsigned()</code></td>\n      <td>Establecer columnas INTEGER como SIN FIRMAR (MySQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;useCurrent()</code></td>\n      <td>Configure las columnas TIMESTAMP para usar CURRENT_TIMESTAMP como valor predeterminado</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;virtualAs($expression)</code></td>\n      <td>Crea una columna virtual generada (MySQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;generatedAs($expression)</code></td>\n      <td>Cree una columna de identidad con opciones de secuencia especificadas (PostgreSQL)</td>\n    </tr>\n    <tr>\n      <td><code>-&gt;always()</code></td>\n      <td>Define la precedencia de los valores de secuencia sobre la entrada para una columna de identidad (PostgreSQL)</td>\n    </tr>\n    </tbody>\n  </table>\n  <h4>Expresiones predeterminadas</h4>\n  <p>El <code>default</code>modificador acepta un valor o una instancia. El uso de una instancia evitará envolver el valor entre comillas y le permitirá usar funciones específicas de la base de datos. Una situación en la que esto es particularmente útil es cuando necesita asignar valores predeterminados a las columnas JSON:<code>\\Illuminate\\Database\\Query\\Expression</code><code>Expression</code></p>\n  <pre><code>&lt;?php\n\nuse Illuminate\\Support\\Facades\\Schema;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Database\\Query\\Expression;\nuse Illuminate\\Database\\Migrations\\Migration;\n\nclass CreateFlightsTable extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::create('flights', function (Blueprint $table) {\n            $table-&gt;id();\n            $table-&gt;json('movies')-&gt;default(new Expression('(JSON_ARRAY())'));\n            $table-&gt;timestamps();\n        });\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>La compatibilidad con expresiones predeterminadas depende del controlador de la base de datos, la versión de la base de datos y el tipo de campo. Consulte la documentación correspondiente para conocer la compatibilidad. También tenga en cuenta que el uso de funciones específicas de la base de datos puede vincularlo estrechamente con un controlador específico.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Modificar columnas</h3>\n  <h4>Prerrequisitos</h4>\n  <p>Antes de modificar una columna, asegúrese de agregar la dependencia a su archivo. La biblioteca Doctrine DBAL se utiliza para determinar el estado actual de la columna y crear las consultas SQL necesarias para realizar los ajustes necesarios:<code>doctrine/dbal</code><code>composer.json</code></p>\n  <pre><code>composer require doctrine/dbal</code></pre>\n  <h4>Actualizar atributos de columna</h4>\n  <p>El <code>change</code>método le permite modificar el tipo y los atributos de las columnas existentes. Por ejemplo, es posible que desee aumentar el tamaño de una <code>string</code>columna. Para ver el <code>change</code>método en acción, aumentemos el tamaño de la <code>name</code>columna de 25 a 50:</p>\n  <pre><code>Schema::table('users', function (Blueprint $table) {\n    $table-&gt;string('name', 50)-&gt;change();\n});</code></pre>\n  <p>También podríamos modificar una columna para que sea anulable:</p>\n  <pre><code>Schema::table('users', function (Blueprint $table) {\n    $table-&gt;string('name', 50)-&gt;nullable()-&gt;change();\n});</code></pre>\n  <blockquote>\n    <div><div></div><p> Solo se pueden \"cambiar\" los siguientes tipos de columna: bigInteger, binary, boolean, date, dateTime, dateTimeTz, decimal, integer, json, longText, mediumText, smallInteger, string, text, time, unsignedBigInteger, unsignedInteger, unsignedSmallInteger y uuid.</p></div>\n  </blockquote>\n  <h4>Cambio de nombre de columnas</h4>\n  <p>Para cambiar el nombre de una columna, puede utilizar el <code>renameColumn</code>método del generador de esquemas. Antes de cambiar el nombre de una columna, asegúrese de agregar la dependencia a su archivo:<code>doctrine/dbal</code><code>composer.json</code></p>\n  <pre><code>Schema::table('users', function (Blueprint $table) {\n    $table-&gt;renameColumn('from', 'to');\n});</code></pre>\n  <blockquote>\n    <div><div></div><p><code>enum</code>Actualmente, no se admite el cambio de nombre de cualquier columna de una tabla que también tenga una columna de tipo .</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Dejar caer columnas</h3>\n  <p>Para eliminar una columna, use el <code>dropColumn</code>método del generador de esquemas. Antes de eliminar columnas de una base de datos SQLite, deberá agregar la dependencia a su archivo y ejecutar el comando en su terminal para instalar la biblioteca:<code>doctrine/dbal</code><code>composer.json</code><code>composer update</code></p>\n  <pre><code>Schema::table('users', function (Blueprint $table) {\n    $table-&gt;dropColumn('votes');\n});</code></pre>\n  <p>Puede eliminar varias columnas de una tabla pasando una matriz de nombres de columna al <code>dropColumn</code>método:</p>\n  <pre><code>Schema::table('users', function (Blueprint $table) {\n    $table-&gt;dropColumn(['votes', 'avatar', 'location']);\n});</code></pre>\n  <blockquote>\n    <div><div></div><p> No se admite eliminar o modificar varias columnas dentro de una sola migración mientras se usa una base de datos SQLite.</p></div>\n  </blockquote>\n  <h4>Alias \u200B\u200Bde comando disponibles</h4>\n  <table>\n    <thead>\n    <tr>\n      <th>Mando</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$table-&gt;dropMorphs('morphable');</code></td>\n      <td>Suelta las columnas <code>morphable_id</code>y <code>morphable_type</code>.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dropRememberToken();</code></td>\n      <td>Suelta la <code>remember_token</code>columna.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dropSoftDeletes();</code></td>\n      <td>Suelta la <code>deleted_at</code>columna.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dropSoftDeletesTz();</code></td>\n      <td>Alias \u200B\u200Bde método.<code>dropSoftDeletes()</code></td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dropTimestamps();</code></td>\n      <td>Suelta las columnas <code>created_at</code>y <code>updated_at</code>.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dropTimestampsTz();</code></td>\n      <td>Alias \u200B\u200Bde método.<code>dropTimestamps()</code></td>\n    </tr>\n    </tbody>\n  </table>\n  <p></p>\n  <h2>Índices</h2>\n  <p></p>\n  <h3>Crear índices</h3>\n  <p>El constructor de esquemas de Laravel admite varios tipos de índices. El siguiente ejemplo crea una nueva <code>email</code>columna y especifica que sus valores deben ser únicos. Para crear el índice, podemos encadenar el <code>unique</code>método a la definición de columna:</p>\n  <pre><code>$table-&gt;string('email')-&gt;unique();</code></pre>\n  <p>Alternativamente, puede crear el índice después de definir la columna. Por ejemplo:</p>\n  <pre><code>$table-&gt;unique('email');</code></pre>\n  <p>Incluso puede pasar una matriz de columnas a un método de índice para crear un índice compuesto (o compuesto):</p>\n  <pre><code>$table-&gt;index(['account_id', 'created_at']);</code></pre>\n  <p>Laravel generará automáticamente un nombre de índice basado en la tabla, los nombres de las columnas y el tipo de índice, pero puede pasar un segundo argumento al método para especificar el nombre del índice usted mismo:</p>\n  <pre><code>$table-&gt;unique('email', 'unique_email');</code></pre>\n  <h4>Tipos de índice disponibles</h4>\n  <p>Cada método de índice acepta un segundo argumento opcional para especificar el nombre del índice. Si se omite, el nombre se derivará de los nombres de la tabla y las columnas utilizadas para el índice, así como del tipo de índice.</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Mando</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$table-&gt;primary('id');</code></td>\n      <td>Agrega una clave principal.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;primary(['id', 'parent_id']);</code></td>\n      <td>Agrega claves compuestas.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;unique('email');</code></td>\n      <td>Agrega un índice único.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;index('state');</code></td>\n      <td>Agrega un índice simple.</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;spatialIndex('location');</code></td>\n      <td>Agrega un índice espacial. (excepto SQLite)</td>\n    </tr>\n    </tbody>\n  </table>\n  <h4>Longitudes de índice y MySQL / MariaDB</h4>\n  <p>Laravel usa el <code>utf8mb4</code>juego de caracteres por defecto, que incluye soporte para almacenar \"emojis\" en la base de datos. Si está ejecutando una versión de MySQL anterior a la versión 5.7.7 o MariaDB anterior a la versión 10.2.2, es posible que deba configurar manualmente la longitud de cadena predeterminada generada por las migraciones para que MySQL cree índices para ellas. Puede configurar esto llamando al método dentro de su :<code>Schema::defaultStringLength</code><code>AppServiceProvider</code></p>\n  <pre><code>use Illuminate\\Support\\Facades\\Schema;\n\n/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    Schema::defaultStringLength(191);\n}</code></pre>\n  <p>Alternativamente, puede habilitar la <code>innodb_large_prefix</code>opción para su base de datos. Consulte la documentación de su base de datos para obtener instrucciones sobre cómo habilitar correctamente esta opción.</p>\n  <p></p>\n  <h3>Cambiar el nombre de los índices</h3>\n  <p>Para cambiar el nombre de un índice, puede utilizar el <code>renameIndex</code>método. Este método acepta el nombre del índice actual como primer argumento y el nuevo nombre deseado como segundo argumento:</p>\n  <pre><code>$table-&gt;renameIndex('from', 'to')</code></pre>\n  <p></p>\n  <h3>Eliminando índices</h3>\n  <p>Para eliminar un índice, debe especificar el nombre del índice. De forma predeterminada, Laravel asigna automáticamente un nombre de índice basado en el nombre de la tabla, el nombre de la columna indexada y el tipo de índice. Aquí hay unos ejemplos:</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Mando</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$table-&gt;dropPrimary('users_id_primary');</code></td>\n      <td>Elimina una clave principal de la tabla \"usuarios\".</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dropUnique('users_email_unique');</code></td>\n      <td>Elimina un índice único de la tabla \"usuarios\".</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dropIndex('geo_state_index');</code></td>\n      <td>Suelta un índice básico de la tabla \"geo\".</td>\n    </tr>\n    <tr>\n      <td><code>$table-&gt;dropSpatialIndex('geo_location_spatialindex');</code></td>\n      <td>Elimina un índice espacial de la tabla \"geo\" (excepto SQLite).</td>\n    </tr>\n    </tbody>\n  </table>\n  <p>Si pasa una matriz de columnas a un método que elimina índices, el nombre de índice convencional se generará en función del nombre de la tabla, las columnas y el tipo de clave:</p>\n  <pre><code>Schema::table('geo', function (Blueprint $table) {\n    $table-&gt;dropIndex(['state']); // Drops index 'geo_state_index'\n});</code></pre>\n  <p></p>\n  <h3>Restricciones de clave externa</h3>\n  <p>Laravel también proporciona soporte para crear restricciones de clave externa, que se utilizan para forzar la integridad referencial en el nivel de la base de datos. Por ejemplo, definamos una <code>user_id</code>columna en la <code>posts</code>tabla que haga referencia a la <code>id</code>columna en una <code>users</code>tabla:</p>\n  <pre><code>Schema::table('posts', function (Blueprint $table) {\n    $table-&gt;unsignedBigInteger('user_id');\n\n    $table-&gt;foreign('user_id')-&gt;references('id')-&gt;on('users');\n});</code></pre>\n  <p>Dado que esta sintaxis es bastante detallada, Laravel proporciona métodos adicionales y más tersos que utilizan la convención para proporcionar una mejor experiencia de desarrollador. El ejemplo anterior podría escribirse así:</p>\n  <pre><code>Schema::table('posts', function (Blueprint $table) {\n    $table-&gt;foreignId('user_id')-&gt;constrained();\n});</code></pre>\n  <p>El <code>foreignId</code>método es un alias <code>unsignedBigInteger</code>mientras que el <code>constrained</code>método utilizará la convención para determinar la tabla y el nombre de la columna a la que se hace referencia. Si el nombre de su tabla no coincide con la convención, puede especificar el nombre de la tabla pasándolo como un argumento al <code>constrained</code>método:</p>\n  <pre><code>Schema::table('posts', function (Blueprint $table) {\n    $table-&gt;foreignId('user_id')-&gt;constrained('users');\n});</code></pre>\n  <p>También puede especificar la acción deseada para las propiedades \"al eliminar\" y \"al actualizar\" de la restricción:</p>\n  <pre><code>$table-&gt;foreignId('user_id')\n      -&gt;constrained()\n      -&gt;onDelete('cascade');</code></pre>\n  <p>Cualquier modificador de columna adicional debe llamarse antes <code>constrained</code>:</p>\n  <pre><code>$table-&gt;foreignId('user_id')\n      -&gt;nullable()\n      -&gt;constrained();</code></pre>\n  <p>Para eliminar una clave externa, puede utilizar el <code>dropForeign</code>método, pasando la restricción de clave externa para eliminarla como argumento. Las restricciones de clave externa utilizan la misma convención de nomenclatura que los índices, según el nombre de la tabla y las columnas de la restricción, seguidas de un sufijo \"_foreign\":</p>\n  <pre><code>$table-&gt;dropForeign('posts_user_id_foreign');</code></pre>\n  <p>Alternativamente, puede pasar una matriz que contenga el nombre de la columna que contiene la clave externa al <code>dropForeign</code>método. La matriz se convertirá automáticamente utilizando la convención de nombres de restricción utilizada por el constructor de esquemas de Laravel:</p>\n  <pre><code>$table-&gt;dropForeign(['user_id']);</code></pre>\n  <p>Puede habilitar o deshabilitar las restricciones de clave externa dentro de sus migraciones mediante los siguientes métodos:</p>\n  <pre><code>Schema::enableForeignKeyConstraints();\n\nSchema::disableForeignKeyConstraints();</code></pre>\n  <blockquote>\n    <div><div></div><p>SQLite deshabilita las restricciones de clave externa de forma predeterminada. Cuando utilice SQLite, asegúrese de habilitar la compatibilidad con claves externas en la configuración de su base de datos antes de intentar crearlas en sus migraciones. Además, SQLite solo admite claves externas al crear la tabla y no cuando se modifican las tablas .</p></div>\n  </blockquote>\n</section>"
      },
      {
        "titulo": "7.4 Siembra",
        "contenido": "<section>\n<h1>Base de datos: Siembra</h1>\n<ul>\n<li>Introducción</li>\n<li>Sembradoras de escritura\n<ul>\n<li>Usando las fábricas modelo</li>\n<li>Llamada a sembradoras adicionales</li>\n</ul></li>\n<li>Sembradoras en funcionamiento</li>\n</ul>\n<p></p>\n<h2>Introducción</h2>\n<p>Laravel incluye un método simple para sembrar su base de datos con datos de prueba utilizando clases de semillas. Todas las clases de semillas se almacenan en el directorio. Las clases de semillas pueden tener el nombre que desee, pero probablemente deberían seguir alguna convención sensata, como , etc. De forma predeterminada, se define una clase para usted. Desde esta clase, puede utilizar el método para ejecutar otras clases de inicialización, lo que le permite controlar el orden de inicialización.<code>database/seeders</code><code>UserSeeder</code><code>DatabaseSeeder</code><code>call</code></p>\n<p></p>\n<h2>Sembradoras de escritura</h2>\n<p>Para generar una sembradora, ejecute el comando Artisan . Todas las sembradoras generadas por el marco se colocarán en el directorio:<code>make:seeder</code> <code>database/seeders</code></p>\n<pre><code>php artisan make:seeder UserSeeder</code></pre>\n<p>Una clase sembradora sólo contiene un método por defecto: <code>run</code>. Este método se llama cuando se ejecuta el comando Artisan . Dentro del método, puede insertar datos en su base de datos como desee. Puede usar el generador de consultas para insertar datos manualmente o puede usar las fábricas de modelos Eloquent .<code>db:seed</code> <code>run</code></p>\n<blockquote>\n<div><div></div><p> La protección de asignación masiva se desactiva automáticamente durante la inicialización de la base de datos.</p></div>\n</blockquote>\n<p>Como ejemplo, modifiquemos la <code>DatabaseSeeder</code>clase predeterminada y agreguemos una declaración de inserción de base de datos al <code>run</code>método:</p>\n<pre><code>&lt;?php\n\nnamespace Database\\Seeders;\n\nuse Illuminate\\Database\\Seeder;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Str;\n\nclass DatabaseSeeder extends Seeder\n{\n    /**\n     * Run the database seeders.\n     *\n     * @return void\n     */\n    public function run()\n    {\n        DB::table('users')-&gt;insert([\n            'name' =&gt; Str::random(10),\n            'email' =&gt; Str::random(10).'@gmail.com',\n            'password' =&gt; Hash::make('password'),\n        ]);\n    }\n}</code></pre>\n<blockquote>\n<div><div></div><p>Puede escribir sugerencias sobre las dependencias que necesite dentro de la <code>run</code>firma del método. Se resolverán automáticamente a través del contenedor de servicios de Laravel .</p></div>\n</blockquote>\n<p></p>\n<h3>Usando las fábricas modelo</h3>\n<p>Por supuesto, especificar manualmente los atributos para cada semilla de modelo es engorroso. En su lugar, puede utilizar fábricas de modelos para generar de forma conveniente grandes cantidades de registros de bases de datos. Primero, revise la documentación de la fábrica modelo para aprender cómo definir sus fábricas.</p>\n<p>Por ejemplo, creemos 50 usuarios y adjuntemos una relación a cada usuario:</p>\n<pre><code>use App\\Models\\User;\n\n/**\n * Run the database seeders.\n *\n * @return void\n */\npublic function run()\n{\n    User::factory()\n            -&gt;times(50)\n            -&gt;hasPosts(1)\n            -&gt;create();\n}</code></pre>\n<p></p>\n<h3>Llamada a sembradoras adicionales</h3>\n<p>Dentro de la <code>DatabaseSeeder</code>clase, puede usar el <code>call</code>método para ejecutar clases semilla adicionales. El uso del <code>call</code>método le permite dividir la siembra de su base de datos en varios archivos para que ninguna clase de sembradora se vuelva abrumadoramente grande. Pase el nombre de la clase de sembradora que desea ejecutar:</p>\n<pre><code>/**\n * Run the database seeders.\n *\n * @return void\n */\npublic function run()\n{\n    $this-&gt;call([\n        UserSeeder::class,\n        PostSeeder::class,\n        CommentSeeder::class,\n    ]);\n}</code></pre>\n<p></p>\n<h2>Sembradoras en funcionamiento</h2>\n<p>Una vez que haya escrito su sembradora, es posible que deba regenerar el cargador automático de Composer usando el comando:<code>dump-autoload</code></p>\n<pre><code>composer dump-autoload</code></pre>\n<p>Ahora puede usar el comando Artisan para inicializar su base de datos. De forma predeterminada, el comando ejecuta la clase, que puede usarse para llamar a otras clases semilla. Sin embargo, puede usar la opción para especificar una clase de sembradora específica para ejecutar individualmente:<code>db:seed</code><code>db:seed</code><code>DatabaseSeeder</code><code>--class</code></p>\n<pre><code>php artisan db:seed\n\nphp artisan db:seed --class=UserSeeder</code></pre>\n<p>También puede sembrar su base de datos usando el comando, que eliminará todas las tablas y volverá a ejecutar todas sus migraciones. Este comando es útil para reconstruir completamente su base de datos:<code>migrate:fresh</code></p>\n<pre><code>php artisan migrate:fresh --seed</code></pre>\n<p></p>\n<h4>Obligar a las sembradoras a funcionar en producción</h4>\n<p>Algunas operaciones de inicialización pueden provocar que altere o pierda datos. Para protegerlo de ejecutar comandos de siembra en su base de datos de producción, se le pedirá confirmación antes de que se ejecuten las sembradoras. Para forzar a las sembradoras a correr sin un aviso, use la <code>--force</code>bandera:</p>\n<pre><code>php artisan db:seed --force</code></pre>\n</section>"
      },
      {
        "titulo": "7.5 Redis",
        "contenido": "<section>\n<h1>Redis</h1>\n<ul>\n<li>Introducción\n<ul>\n<li>Configuración</li>\n<li>Predis</li>\n<li>PhpRedis</li>\n</ul></li>\n<li>Interactuar con Redis\n<ul>\n<li>Comandos de canalización</li>\n</ul></li>\n<li>Pub / Sub</li>\n</ul>\n<p></p>\n<h2>Introducción</h2>\n<p>Redis es un almacén de clave-valor avanzado de código abierto. A menudo se lo denomina servidor de estructura de datos, ya que las claves pueden contener cadenas , hashes , listas , conjuntos y conjuntos ordenados .</p>\n<p>Antes de usar Redis con Laravel, le recomendamos que instale y use la extensión PHP PhpRedis a través de PECL. La extensión es más compleja de instalar, pero puede producir un mejor rendimiento para las aplicaciones que hacen un uso intensivo de Redis.</p>\n<p>Alternativamente, puede instalar el paquete a través de Composer:<code>predis/predis</code></p>\n<pre><code>composer require predis/predis</code></pre>\n<p></p>\n<h3>Configuración</h3>\n<p>La configuración de Redis para su aplicación se encuentra en el archivo de configuración. Dentro de este archivo, verá una matriz que contiene los servidores Redis utilizados por su aplicación:<code>config/database.php</code><code>redis</code></p>\n<pre><code>'redis' =&gt; [\n\n    'client' =&gt; env('REDIS_CLIENT', 'phpredis'),\n\n    'default' =&gt; [\n        'host' =&gt; env('REDIS_HOST', '127.0.0.1'),\n        'password' =&gt; env('REDIS_PASSWORD', null),\n        'port' =&gt; env('REDIS_PORT', 6379),\n        'database' =&gt; env('REDIS_DB', 0),\n    ],\n\n    'cache' =&gt; [\n        'host' =&gt; env('REDIS_HOST', '127.0.0.1'),\n        'password' =&gt; env('REDIS_PASSWORD', null),\n        'port' =&gt; env('REDIS_PORT', 6379),\n        'database' =&gt; env('REDIS_CACHE_DB', 1),\n    ],\n\n],</code></pre>\n<p>La configuración predeterminada del servidor debería ser suficiente para el desarrollo. Sin embargo, puede modificar esta matriz en función de su entorno. Cada servidor Redis definido en su archivo de configuración debe tener un nombre, host y puerto, a menos que defina una única URL para representar la conexión Redis:</p>\n<pre><code>'redis' =&gt; [\n\n    'client' =&gt; env('REDIS_CLIENT', 'phpredis'),\n\n    'default' =&gt; [\n        'url' =&gt; 'tcp://127.0.0.1:6379?database=0',\n    ],\n\n    'cache' =&gt; [\n        'url' =&gt; 'tls://user:password@127.0.0.1:6380?database=1',\n    ],\n\n],</code></pre>\n<h4>Configurar el esquema de conexión</h4>\n<p>De forma predeterminada, los clientes de Redis usarán el <code>tcp</code>esquema cuando se conecten a sus servidores de Reids; sin embargo, puede usar el cifrado TLS / SSL especificando una <code>scheme</code>opción de configuración en la configuración de su servidor Redis:</p>\n<pre><code>'redis' =&gt; [\n\n    'client' =&gt; env('REDIS_CLIENT', 'phpredis'),\n\n    'default' =&gt; [\n        'scheme' =&gt; 'tls',\n        'host' =&gt; env('REDIS_HOST', '127.0.0.1'),\n        'password' =&gt; env('REDIS_PASSWORD', null),\n        'port' =&gt; env('REDIS_PORT', 6379),\n        'database' =&gt; env('REDIS_DB', 0),\n    ],\n\n],</code></pre>\n<h4>Configuración de clústeres</h4>\n<p>Si su aplicación utiliza un clúster de servidores Redis, debe definir estos clústeres dentro de una <code>clusters</code>clave de su configuración de Redis:</p>\n<pre><code>'redis' =&gt; [\n\n    'client' =&gt; env('REDIS_CLIENT', 'phpredis'),\n\n    'clusters' =&gt; [\n        'default' =&gt; [\n            [\n                'host' =&gt; env('REDIS_HOST', 'localhost'),\n                'password' =&gt; env('REDIS_PASSWORD', null),\n                'port' =&gt; env('REDIS_PORT', 6379),\n                'database' =&gt; 0,\n            ],\n        ],\n    ],\n\n],</code></pre>\n<p>De forma predeterminada, los clústeres realizarán la fragmentación del lado del cliente en sus nodos, lo que le permitirá agrupar nodos y crear una gran cantidad de RAM disponible. Sin embargo, tenga en cuenta que la fragmentación del lado del cliente no maneja la conmutación por error; por lo tanto, es principalmente adecuado para datos almacenados en caché que están disponibles en otro almacén de datos principal. Si desea utilizar la agrupación en clústeres nativa de Redis, debe especificar esto en la <code>options</code>clave de su configuración de Redis:</p>\n<pre><code>'redis' =&gt; [\n\n    'client' =&gt; env('REDIS_CLIENT', 'phpredis'),\n\n    'options' =&gt; [\n        'cluster' =&gt; env('REDIS_CLUSTER', 'redis'),\n    ],\n\n    'clusters' =&gt; [\n        // ...\n    ],\n\n],</code></pre>\n<p></p>\n<h3>Predis</h3>\n<p>Para utilizar la extensión Predis, debe cambiar la <code>REDIS_CLIENT</code>variable de entorno de <code>phpredis</code>a <code>predis</code>:</p>\n<pre><code>'redis' =&gt; [\n\n    'client' =&gt; env('REDIS_CLIENT', 'predis'),\n\n    // Rest of Redis configuration...\n],</code></pre>\n<p>Además de los predeterminados <code>host</code>, <code>port</code>, <code>database</code>, y <code>password</code>opciones de configuración del servidor, Predis apoya adicionales parámetros de conexión que se pueden definir para cada uno de los servidores de Redis. Para utilizar estas opciones de configuración adicionales, agréguelas a la configuración de su servidor Redis en el archivo de configuración:<code>config/database.php</code></p>\n<pre><code>'default' =&gt; [\n    'host' =&gt; env('REDIS_HOST', 'localhost'),\n    'password' =&gt; env('REDIS_PASSWORD', null),\n    'port' =&gt; env('REDIS_PORT', 6379),\n    'database' =&gt; 0,\n    'read_write_timeout' =&gt; 60,\n],</code></pre>\n<p></p>\n<h3>PhpRedis</h3>\n<p>La extensión PhpRedis está configurada por defecto en <code>REDIS_CLIENT</code>env y en su :<code>config/database.php</code></p>\n<pre><code>'redis' =&gt; [\n\n    'client' =&gt; env('REDIS_CLIENT', 'phpredis'),\n\n    // Rest of Redis configuration...\n],</code></pre>\n<p>Si planea usar la extensión PhpRedis junto con el <code>Redis</code>alias de Facade, debe cambiarle el nombre por otro, como <code>RedisManager</code>, para evitar una colisión con la clase Redis. Puede hacerlo en la sección de alias de su archivo de configuración.<code>app.php</code></p>\n<pre><code>'RedisManager' =&gt; Illuminate\\Support\\Facades\\Redis::class,</code></pre>\n<p>Además de los predeterminados <code>host</code>, <code>port</code>, <code>database</code>, y <code>password</code>opciones de configuración del servidor, PhpRedis compatible con los siguientes parámetros de conexión adicionales: <code>persistent</code>, <code>prefix</code>, <code>read_timeout</code>, <code>timeout</code>, y <code>context</code>. Puede agregar cualquiera de estas opciones a la configuración de su servidor Redis en el archivo de configuración:<code>config/database.php</code></p>\n<pre><code>'default' =&gt; [\n    'host' =&gt; env('REDIS_HOST', 'localhost'),\n    'password' =&gt; env('REDIS_PASSWORD', null),\n    'port' =&gt; env('REDIS_PORT', 6379),\n    'database' =&gt; 0,\n    'read_timeout' =&gt; 60,\n    'context' =&gt; [\n        // 'auth' =&gt; ['username', 'secret'],\n        // 'stream' =&gt; ['verify_peer' =&gt; false],\n    ],\n],</code></pre>\n<h4>La fachada de Redis</h4>\n<p>Para evitar colisiones de nombres de clases con la extensión PHP de Redis, deberá eliminar o cambiar el nombre del alias de fachada de la matriz de su archivo de configuración . En general, debe eliminar este alias por completo y solo hacer referencia a la fachada por su nombre de clase completo mientras usa la extensión Redis PHP.<code>Illuminate\\Support\\Facades\\Redis</code><code>app</code><code>aliases</code></p>\n<p></p>\n<h2>Interactuar con Redis</h2>\n<p>Puede interactuar con Redis llamando a varios métodos en la <code>Redis</code> fachada . La <code>Redis</code>fachada admite métodos dinámicos, lo que significa que puede llamar a cualquier comando de Redis en la fachada y el comando se pasará directamente a Redis. En este ejemplo, llamaremos al <code>GET</code>comando Redis llamando al <code>get</code>método en la <code>Redis</code>fachada:</p>\n<pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Support\\Facades\\Redis;\n\nclass UserController extends Controller\n{\n    /**\n     * Show the profile for the given user.\n     *\n     * @param  int  $id\n     * @return Response\n     */\n    public function showProfile($id)\n    {\n        $user = Redis::get('user:profile:'.$id);\n\n        return view('user.profile', ['user' =&gt; $user]);\n    }\n}</code></pre>\n<p>Como se mencionó anteriormente, puede llamar a cualquiera de los comandos de Redis en la <code>Redis</code>fachada. Laravel usa métodos mágicos para pasar los comandos al servidor de Redis, así que pase los argumentos que espera el comando de Redis:</p>\n<pre><code>Redis::set('name', 'Taylor');\n\n$values = Redis::lrange('names', 5, 10);</code></pre>\n<p>Alternativamente, también puede pasar comandos al servidor usando el <code>command</code>método, que acepta el nombre del comando como su primer argumento y una matriz de valores como su segundo argumento:</p>\n<pre><code>$values = Redis::command('lrange', ['name', 5, 10]);</code></pre>\n<h4>Uso de múltiples conexiones de Redis</h4>\n<p>Puede obtener una instancia de Redis llamando al método:<code>Redis::connection</code></p>\n<pre><code>$redis = Redis::connection();</code></pre>\n<p>Esto le dará una instancia del servidor Redis predeterminado. También puede pasar la conexión o el nombre del clúster al <code>connection</code>método para obtener un servidor o clúster específico como se define en su configuración de Redis:</p>\n<pre><code>$redis = Redis::connection('my-connection');</code></pre>\n<p></p>\n<h3>Comandos de canalización</h3>\n<p>La canalización se debe utilizar cuando necesite enviar muchos comandos al servidor. El <code>pipeline</code>método acepta un argumento: a <code>Closure</code>que recibe una instancia de Redis. Puede enviar todos sus comandos a esta instancia de Redis y todos se transmitirán al servidor, proporcionando así un mejor rendimiento:</p>\n<pre><code>Redis::pipeline(function ($pipe) {\n    for ($i = 0; $i &lt; 1000; $i++) {\n        $pipe-&gt;set(\"key:$i\", $i);\n    }\n});</code></pre>\n<p></p>\n<h2>Pub / Sub</h2>\n<p>Laravel proporciona una interfaz conveniente para Redis <code>publish</code>y <code>subscribe</code>comandos. Estos comandos de Redis le permiten escuchar mensajes en un \"canal\" determinado. Puede publicar mensajes en el canal desde otra aplicación, o incluso utilizando otro lenguaje de programación, lo que permite una fácil comunicación entre aplicaciones y procesos.</p>\n<p>Primero, configuremos un oyente de canal usando el <code>subscribe</code>método. Colocaremos esta llamada al método dentro de un comando Artisan, ya que llamar al <code>subscribe</code>método comienza un proceso de larga ejecución:</p>\n<pre><code>&lt;?php\n\nnamespace App\\Console\\Commands;\n\nuse Illuminate\\Console\\Command;\nuse Illuminate\\Support\\Facades\\Redis;\n\nclass RedisSubscribe extends Command\n{\n    /**\n     * The name and signature of the console command.\n     *\n     * @var string\n     */\n    protected $signature = 'redis:subscribe';\n\n    /**\n     * The console command description.\n     *\n     * @var string\n     */\n    protected $description = 'Subscribe to a Redis channel';\n\n    /**\n     * Execute the console command.\n     *\n     * @return mixed\n     */\n    public function handle()\n    {\n        Redis::subscribe(['test-channel'], function ($message) {\n            echo $message;\n        });\n    }\n}</code></pre>\n<p>Ahora podemos publicar mensajes en el canal usando el <code>publish</code>método:</p>\n<pre><code>Route::get('publish', function () {\n    // Route logic...\n\n    Redis::publish('test-channel', json_encode(['foo' =&gt; 'bar']));\n});</code></pre>\n<h4>Suscripciones comodín</h4>\n<p>Con el <code>psubscribe</code>método, puede suscribirse a un canal comodín, que puede ser útil para capturar todos los mensajes en todos los canales. El <code>$channel</code>nombre se pasará como segundo argumento a la devolución de llamada proporcionada <code>Closure</code>:</p>\n<pre><code>Redis::psubscribe(['*'], function ($message, $channel) {\n    echo $message;\n});\n\nRedis::psubscribe(['users.*'], function ($message, $channel) {\n    echo $message;\n});</code></pre>\n</section>"
      }
    ]
  },
  {
    "titulo": "Eloquent ORM",
    "subtitulo": "",
    "items": [
      {
        "titulo": "8.1 Empezando",
        "contenido": "<section class=\"docs_main\">\n\n\n  <h1>Eloquent: Comenzando</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Definición de modelos\n      <ul>\n        <li>Convenciones de modelos elocuentes</li>\n        <li>Valores de atributo predeterminados</li>\n      </ul></li>\n    <li>Recuperando modelos\n      <ul>\n        <li>Colecciones</li>\n        <li>Resultados de fragmentación</li>\n        <li>Subconsultas avanzadas</li>\n      </ul></li>\n    <li>Recuperación de modelos / agregados individuales\n      <ul>\n        <li>Recuperando agregados</li>\n      </ul></li>\n    <li>Insertar y actualizar modelos\n      <ul>\n        <li>Inserta</li>\n        <li>Actualizaciones</li>\n        <li>Asignación masiva</li>\n        <li>Otros métodos de creación</li>\n      </ul></li>\n    <li>Eliminar modelos\n      <ul>\n        <li>Eliminación suave</li>\n        <li>Consultar modelos eliminados temporalmente</li>\n      </ul></li>\n    <li>Replicar modelos</li>\n    <li>Ámbitos de consulta\n      <ul>\n        <li>Ámbitos globales</li>\n        <li>Ámbitos locales</li>\n      </ul></li>\n    <li>Comparación de modelos</li>\n    <li>Eventos\n      <ul>\n        <li>Usando cierres</li>\n        <li>Observadores</li>\n        <li>Silenciar eventos</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>El ORM Eloquent incluido con Laravel proporciona una implementación de ActiveRecord hermosa y simple para trabajar con su base de datos. Cada tabla de la base de datos tiene un \"Modelo\" correspondiente que se utiliza para interactuar con esa tabla. Los modelos le permiten consultar datos en sus tablas, así como insertar nuevos registros en la tabla.</p>\n  <p>Antes de comenzar, asegúrese de configurar una conexión de base de datos en . Para obtener más información sobre cómo configurar su base de datos, consulte la documentación .<code>config/database.php</code></p>\n  <p></p>\n  <h2>Definición de modelos</h2>\n  <p>Para empezar, creemos un modelo Eloquent. Los modelos suelen vivir en el directorio, pero puede colocarlos en cualquier lugar que pueda cargarse automáticamente de acuerdo con su archivo. Todos los modelos Eloquent amplían su clase.<code>app\\Models</code><code>composer.json</code><code>Illuminate\\Database\\Eloquent\\Model</code></p>\n  <p>La forma más sencilla de crear una instancia de modelo es mediante el comando Artisan :<code>make:model</code> </p>\n  <pre><code>php artisan make:model Flight</code></pre>\n  <p>Si desea generar una migración de base de datos cuando genera el modelo, puede usar la opción <code>--migration</code>o <code>-m</code>:</p>\n  <pre><code>php artisan make:model Flight --migration\n\nphp artisan make:model Flight -m</code></pre>\n  <p></p>\n  <h3>Convenciones de modelos elocuentes</h3>\n  <p>Ahora, veamos un <code>Flight</code>modelo de ejemplo , que usaremos para recuperar y almacenar información de nuestra <code>flights</code>tabla de base de datos:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    //\n}</code></pre>\n  <h4>Nombres de tablas</h4>\n  <p>Tenga en cuenta que no le dijimos a Eloquent qué tabla usar para nuestro <code>Flight</code>modelo. Por convención, el \"caso de serpiente\", el nombre plural de la clase se utilizará como nombre de la tabla a menos que se especifique explícitamente otro nombre. Entonces, en este caso, Eloquent asumirá que el <code>Flight</code>modelo almacena registros en la <code>flights</code>tabla, mientras que un <code>AirTrafficController</code>modelo almacenaría registros en una <code>air_traffic_controllers</code>tabla.</p>\n  <p>Puede especificar manualmente un nombre de tabla definiendo una <code>table</code>propiedad en su modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    /**\n     * The table associated with the model.\n     *\n     * @var string\n     */\n    protected $table = 'my_flights';\n}</code></pre>\n  <h4>Claves primarias</h4>\n  <p>Eloquent también asumirá que cada tabla tiene una columna de clave primaria nombrada <code>id</code>. Puede definir una <code>$primaryKey</code>propiedad protegida para anular esta convención:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    /**\n     * The primary key associated with the table.\n     *\n     * @var string\n     */\n    protected $primaryKey = 'flight_id';\n}</code></pre>\n  <p>Además, Eloquent asume que la clave principal es un valor entero creciente, lo que significa que, de forma predeterminada, la clave principal se convertirá automáticamente en un <code>int</code>. Si desea utilizar una clave principal no incremental o no numérica, debe establecer la <code>$incrementing</code>propiedad pública en su modelo en <code>false</code>:</p>\n  <pre><code>&lt;?php\n\nclass Flight extends Model\n{\n    /**\n     * Indicates if the IDs are auto-incrementing.\n     *\n     * @var bool\n     */\n    public $incrementing = false;\n}</code></pre>\n  <p>Si su clave principal no es un número entero, debe establecer la <code>$keyType</code>propiedad protegida en su modelo en <code>string</code>:</p>\n  <pre><code>&lt;?php\n\nclass Flight extends Model\n{\n    /**\n     * The \"type\" of the auto-incrementing ID.\n     *\n     * @var string\n     */\n    protected $keyType = 'string';\n}</code></pre>\n  <h4>Marcas de tiempo</h4>\n  <p>Por defecto, espera que elocuentes <code>created_at</code>y <code>updated_at</code>columnas que existen en las tablas. Si no desea que Eloquent administre estas columnas automáticamente, configure la <code>$timestamps</code>propiedad de su modelo en <code>false</code>:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    /**\n     * Indicates if the model should be timestamped.\n     *\n     * @var bool\n     */\n    public $timestamps = false;\n}</code></pre>\n  <p>Si necesita personalizar el formato de sus marcas de tiempo, configure la <code>$dateFormat</code>propiedad en su modelo. Esta propiedad determina cómo se almacenan los atributos de fecha en la base de datos, así como su formato cuando el modelo se serializa en una matriz o JSON:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    /**\n     * The storage format of the model's date columns.\n     *\n     * @var string\n     */\n    protected $dateFormat = 'U';\n}</code></pre>\n  <p>Si necesita personalizar los nombres de las columnas utilizadas para almacenar las marcas de tiempo, puede establecer las constantes <code>CREATED_AT</code>y <code>UPDATED_AT</code>en su modelo:</p>\n  <pre><code>&lt;?php\n\nclass Flight extends Model\n{\n    const CREATED_AT = 'creation_date';\n    const UPDATED_AT = 'last_update';\n}</code></pre>\n  <h4>Conexión de base de datos</h4>\n  <p>De forma predeterminada, todos los modelos de Eloquent utilizarán la conexión de base de datos predeterminada configurada para su aplicación. Si desea especificar una conexión diferente para el modelo, use la <code>$connection</code>propiedad:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    /**\n     * The connection name for the model.\n     *\n     * @var string\n     */\n    protected $connection = 'connection-name';\n}</code></pre>\n  <p></p>\n  <h3>Valores de atributo predeterminados</h3>\n  <p>Si desea definir los valores predeterminados para algunos de los atributos de su modelo, puede definir una <code>$attributes</code>propiedad en su modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    /**\n     * The model's default values for attributes.\n     *\n     * @var array\n     */\n    protected $attributes = [\n        'delayed' =&gt; false,\n    ];\n}</code></pre>\n  <p></p>\n  <h2>Recuperando modelos</h2>\n  <p>Una vez que haya creado un modelo y su tabla de base de datos asociada , estará listo para comenzar a recuperar datos de su base de datos. Piense en cada modelo de Eloquent como un poderoso generador de consultas que le permite consultar con fluidez la tabla de la base de datos asociada con el modelo. Por ejemplo:</p>\n  <pre><code>&lt;?php\n\n$flights = App\\Models\\Flight::all();\n\nforeach ($flights as $flight) {\n    echo $flight-&gt;name;\n}</code></pre>\n  <h4>Agregar restricciones adicionales</h4>\n  <p>El <code>all</code>método Eloquent devolverá todos los resultados en la tabla del modelo. Dado que cada modelo de Eloquent sirve como generador de consultas , también puede agregar restricciones a las consultas y luego usar el <code>get</code>método para recuperar los resultados:</p>\n  <pre><code>$flights = App\\Models\\Flight::where('active', 1)\n               -&gt;orderBy('name', 'desc')\n               -&gt;take(10)\n               -&gt;get();</code></pre>\n  <blockquote>\n    <div><div></div><p class=\"content\">Dado que los modelos Eloquent son generadores de consultas, debe revisar todos los métodos disponibles en el generador de consultas . Puede utilizar cualquiera de estos métodos en sus consultas de Eloquent.</p></div>\n  </blockquote>\n  <h4>Modelos refrescantes</h4>\n  <p>Puede actualizar modelos utilizando los métodos <code>fresh</code>y <code>refresh</code>. El <code>fresh</code>método volverá a recuperar el modelo de la base de datos. La instancia del modelo existente no se verá afectada:</p>\n  <pre><code>$flight = App\\Models\\Flight::where('number', 'FR 900')-&gt;first();\n\n$freshFlight = $flight-&gt;fresh();</code></pre>\n  <p>El <code>refresh</code>método rehidratará el modelo existente utilizando datos nuevos de la base de datos. Además, todas sus relaciones cargadas también se actualizarán:</p>\n  <pre><code>$flight = App\\Models\\Flight::where('number', 'FR 900')-&gt;first();\n\n$flight-&gt;number = 'FR 456';\n\n$flight-&gt;refresh();\n\n$flight-&gt;number; // \"FR 900\"</code></pre>\n  <p></p>\n  <h3>Colecciones</h3>\n  <p>Para los métodos Eloquent como <code>all</code>y <code>get</code>que recuperan múltiples resultados, se devolverá una instancia de . La clase proporciona una variedad de métodos útiles para trabajar con sus resultados de Eloquent:<code>Illuminate\\Database\\Eloquent\\Collection</code><code>Collection</code></p>\n  <pre><code>$flights = $flights-&gt;reject(function ($flight) {\n    return $flight-&gt;cancelled;\n});</code></pre>\n  <p>También puede recorrer la colección como una matriz:</p>\n  <pre><code>foreach ($flights as $flight) {\n    echo $flight-&gt;name;\n}</code></pre>\n  <p></p>\n  <h3>Resultados de fragmentación</h3>\n  <p>Si necesita procesar miles de registros de Eloquent, use el <code>chunk</code>comando. El <code>chunk</code>método recuperará un \"trozo\" de modelos Eloquent, alimentándolos a un dado <code>Closure</code>para su procesamiento. El uso del <code>chunk</code>método conservará memoria al trabajar con conjuntos de resultados grandes:</p>\n  <pre><code>Flight::chunk(200, function ($flights) {\n    foreach ($flights as $flight) {\n        //\n    }\n});</code></pre>\n  <p>El primer argumento que se pasa al método es el número de registros que desea recibir por \"fragmento\". El cierre pasado como segundo argumento se llamará para cada fragmento que se recupere de la base de datos. Se ejecutará una consulta de la base de datos para recuperar cada fragmento de registros que se transfieran al cierre.</p>\n  <h4>Usando cursores</h4>\n  <p>El <code>cursor</code>método le permite recorrer los registros de su base de datos utilizando un cursor, que solo ejecutará una única consulta. Al procesar grandes cantidades de datos, el <code>cursor</code>método puede usarse para reducir en gran medida el uso de memoria:</p>\n  <pre><code>foreach (Flight::where('foo', 'bar')-&gt;cursor() as $flight) {\n    //\n}</code></pre>\n  <p>El <code>cursor</code>devuelve una instancia. Las colecciones perezosas le permiten usar muchos de los métodos de colección disponibles en las colecciones típicas de Laravel mientras solo carga un único modelo en la memoria a la vez:<code>Illuminate\\Support\\LazyCollection</code></p>\n  <pre><code>$users = App\\Models\\User::cursor()-&gt;filter(function ($user) {\n    return $user-&gt;id &gt; 500;\n});\n\nforeach ($users as $user) {\n    echo $user-&gt;id;\n}</code></pre>\n  <p></p>\n  <h3>Subconsultas avanzadas</h3>\n  <h4>Selección de subconsultas</h4>\n  <p>Eloquent también ofrece soporte avanzado para subconsultas, que le permite extraer información de tablas relacionadas en una sola consulta. Por ejemplo, imaginemos que tenemos una tabla de vuelos <code>destinations</code>y una tabla de <code>flights</code>destinos. La <code>flights</code>tabla contiene una <code>arrived_at</code>columna que indica cuándo llegó el vuelo a destino.</p>\n  <p>Usando la funcionalidad de subconsulta disponible para los métodos <code>select</code>y <code>addSelect</code>, podemos seleccionar todos los <code>destinations</code>y el nombre del vuelo que llegó más recientemente a ese destino usando una sola consulta:</p>\n  <pre><code>use App\\Models\\Destination;\nuse App\\Models\\Flight;\n\nreturn Destination::addSelect(['last_flight' =&gt; Flight::select('name')\n    -&gt;whereColumn('destination_id', 'destinations.id')\n    -&gt;orderBy('arrived_at', 'desc')\n    -&gt;limit(1)\n])-&gt;get();</code></pre>\n  <h4>Orden de subconsultas</h4>\n  <p>Además, la <code>orderBy</code>función del generador de consultas admite subconsultas. Podemos utilizar esta función para ordenar todos los destinos según la fecha en que llegó el último vuelo a ese destino. Nuevamente, esto se puede hacer mientras se ejecuta una sola consulta en la base de datos:</p>\n  <pre><code>return Destination::orderByDesc(\n    Flight::select('arrived_at')\n        -&gt;whereColumn('destination_id', 'destinations.id')\n        -&gt;orderBy('arrived_at', 'desc')\n        -&gt;limit(1)\n)-&gt;get();</code></pre>\n  <p></p>\n  <h2>Recuperación de modelos / agregados individuales</h2>\n  <p>Además de recuperar todos los registros de una tabla dada, también puede recuperar registros individuales usando <code>find</code>, <code>first</code>o <code>firstWhere</code>. En lugar de devolver una colección de modelos, estos métodos devuelven una única instancia de modelo:</p>\n  <pre><code>// Retrieve a model by its primary key...\n$flight = App\\Models\\Flight::find(1);\n\n// Retrieve the first model matching the query constraints...\n$flight = App\\Models\\Flight::where('active', 1)-&gt;first();\n\n// Shorthand for retrieving the first model matching the query constraints...\n$flight = App\\Models\\Flight::firstWhere('active', 1);</code></pre>\n  <p>También puede llamar al <code>find</code>método con una matriz de claves primarias, que devolverá una colección de los registros coincidentes:</p>\n  <pre><code>$flights = App\\Models\\Flight::find([1, 2, 3]);</code></pre>\n  <p>A veces, es posible que desee recuperar el primer resultado de una consulta o realizar alguna otra acción si no se encuentran resultados. El <code>firstOr</code>método devolverá el primer resultado que se encuentre o, si no se encuentran resultados, ejecutará la devolución de llamada dada. El resultado de la devolución de llamada se considerará el resultado del <code>firstOr</code>método:</p>\n  <pre><code>$model = App\\Models\\Flight::where('legs', '&gt;', 100)-&gt;firstOr(function () {\n        // ...\n});</code></pre>\n  <p>El <code>firstOr</code>método también acepta una matriz de columnas para recuperar:</p>\n  <pre><code>$model = App\\Models\\Flight::where('legs', '&gt;', 100)\n            -&gt;firstOr(['id', 'legs'], function () {\n                // ...\n            });</code></pre>\n  <h4>Excepciones no encontradas</h4>\n  <p>A veces, es posible que desee lanzar una excepción si no se encuentra un modelo. Esto es particularmente útil en rutas o controladores. Las <code>findOrFail</code>y <code>firstOrFail</code>los métodos recuperará el primer resultado de la consulta; sin embargo, si no se encuentra ningún resultado, se lanzará un :<code>Illuminate\\Database\\Eloquent\\ModelNotFoundException</code></p>\n  <pre><code>$model = App\\Models\\Flight::findOrFail(1);\n\n$model = App\\Models\\Flight::where('legs', '&gt;', 100)-&gt;firstOrFail();</code></pre>\n  <p>Si no se detecta la excepción, <code>404</code>se envía automáticamente una respuesta HTTP al usuario. No es necesario escribir comprobaciones explícitas para devolver <code>404</code>respuestas cuando se utilizan estos métodos:</p>\n  <pre><code>Route::get('/api/flights/{id}', function ($id) {\n    return App\\Models\\Flight::findOrFail($id);\n});</code></pre>\n  <p></p>\n  <h3>Recuperando agregados</h3>\n  <p>También puede utilizar los <code>count</code>, <code>sum</code>, <code>max</code>y otros métodos agregados proporcionados por el generador de consultas . Estos métodos devuelven el valor escalar apropiado en lugar de una instancia de modelo completa:</p>\n  <pre><code>$count = App\\Models\\Flight::where('active', 1)-&gt;count();\n\n$max = App\\Models\\Flight::where('active', 1)-&gt;max('price');</code></pre>\n  <p></p>\n  <h2>Insertar y actualizar modelos</h2>\n  <p></p>\n  <h3>Inserta</h3>\n  <p>Para crear un nuevo registro en la base de datos, cree una nueva instancia de modelo, establezca atributos en el modelo y luego llame al <code>save</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\Flight;\nuse Illuminate\\Http\\Request;\n\nclass FlightController extends Controller\n{\n    /**\n     * Create a new flight instance.\n     *\n     * @param  Request  $request\n     * @return Response\n     */\n    public function store(Request $request)\n    {\n        // Validate the request...\n\n        $flight = new Flight;\n\n        $flight-&gt;name = $request-&gt;name;\n\n        $flight-&gt;save();\n    }\n}</code></pre>\n  <p>En este ejemplo, asignamos el <code>name</code>parámetro de la solicitud HTTP entrante al <code>name</code>atributo de la instancia del modelo. Cuando llamamos al método, se insertará un registro en la base de datos. Las marcas de tiempo y se establecerán automáticamente cuando se llame al método, por lo que no es necesario establecerlas manualmente.<code>App\\Models\\Flight</code><code>save</code><code>created_at</code><code>updated_at</code><code>save</code></p>\n  <p></p>\n  <h3>Actualizaciones</h3>\n  <p>El <code>save</code>método también se puede utilizar para actualizar modelos que ya existen en la base de datos. Para actualizar un modelo, debe recuperarlo, establecer los atributos que desee actualizar y luego llamar al <code>save</code>método. Nuevamente, la <code>updated_at</code>marca de tiempo se actualizará automáticamente, por lo que no es necesario establecer manualmente su valor:</p>\n  <pre><code>$flight = App\\Models\\Flight::find(1);\n\n$flight-&gt;name = 'New Flight Name';\n\n$flight-&gt;save();</code></pre>\n  <h4>Actualizaciones masivas</h4>\n  <p>Las actualizaciones también se pueden realizar en cualquier número de modelos que coincidan con una consulta determinada. En este ejemplo, todos los vuelos que están <code>active</code>y tienen una <code>destination</code>de <code>San Diego</code>se marcarán como retrasados:</p>\n  <pre><code>App\\Models\\Flight::where('active', 1)\n          -&gt;where('destination', 'San Diego')\n          -&gt;update(['delayed' =&gt; 1]);</code></pre>\n  <p>El <code>update</code>método espera una matriz de pares de columnas y valores que representan las columnas que deben actualizarse.</p>\n  <blockquote>\n    <div><div></div><p class=\"content\">Al emitir una actualización masiva a través elocuente, la <code>saving</code>, <code>saved</code>, <code>updating</code>, y <code>updated</code>eventos modelo no será despedido por los modelos actualizados. Esto se debe a que los modelos nunca se recuperan realmente cuando se realiza una actualización masiva.</p></div>\n  </blockquote>\n  <h4>Examinar los cambios de atributos</h4>\n  <p>Elocuente ofrece las <code>isDirty</code>, <code>isClean</code>y <code>wasChanged</code>los métodos para examinar el estado interno de su modelo y determinar cómo sus atributos han cambiado desde que se cargaron inicialmente.</p>\n  <p>The <code>isDirty</code> method determines if any attributes have been changed since the model was loaded. You may pass a specific attribute name to determine if a particular attribute is dirty. The <code>isClean</code> method is the opposite of <code>isDirty</code> and also accepts an optional attribute argument:</p>\n  <pre><code>$user = User::create([\n    'first_name' =&gt; 'Taylor',\n    'last_name' =&gt; 'Otwell',\n    'title' =&gt; 'Developer',\n]);\n\n$user-&gt;title = 'Painter';\n\n$user-&gt;isDirty(); // true\n$user-&gt;isDirty('title'); // true\n$user-&gt;isDirty('first_name'); // false\n\n$user-&gt;isClean(); // false\n$user-&gt;isClean('title'); // false\n$user-&gt;isClean('first_name'); // true\n\n$user-&gt;save();\n\n$user-&gt;isDirty(); // false\n$user-&gt;isClean(); // true</code></pre>\n  <p>The <code>wasChanged</code> method determines if any attributes were changed when the model was last saved within the current request cycle. You may also pass an attribute name to see if a particular attribute was changed:</p>\n  <pre><code>$user = User::create([\n    'first_name' =&gt; 'Taylor',\n    'last_name' =&gt; 'Otwell',\n    'title' =&gt; 'Developer',\n]);\n\n$user-&gt;title = 'Painter';\n$user-&gt;save();\n\n$user-&gt;wasChanged(); // true\n$user-&gt;wasChanged('title'); // true\n$user-&gt;wasChanged('first_name'); // false</code></pre>\n  <p>The <code>getOriginal</code> method returns an array containing the original attributes of the model regardless of any changes since the model was loaded. You may pass a specific attribute name to get the original value of a particular attribute:</p>\n  <pre><code>$user = User::find(1);\n\n$user-&gt;name; // John\n$user-&gt;email; // john@example.com\n\n$user-&gt;name = \"Jack\";\n$user-&gt;name; // Jack\n\n$user-&gt;getOriginal('name'); // John\n$user-&gt;getOriginal(); // Array of original attributes...</code></pre>\n  <p></p>\n  <h3>Mass Assignment</h3>\n  <p>También puede usar el <code>create</code>método para guardar un nuevo modelo en una sola línea. La instancia de modelo insertada le será devuelta desde el método. Sin embargo, antes de hacerlo, deberá especificar un atributo <code>fillable</code>o <code>guarded</code>en el modelo, ya que todos los modelos Eloquent protegen contra la asignación masiva de forma predeterminada.</p>\n  <p>Una vulnerabilidad de asignación masiva ocurre cuando un usuario pasa un parámetro HTTP inesperado a través de una solicitud, y ese parámetro cambia una columna en su base de datos que no esperaba. Por ejemplo, un usuario malintencionado puede enviar un <code>is_admin</code>parámetro a través de una solicitud HTTP, que luego se pasa al <code>create</code>método de su modelo , lo que permite al usuario escalar a un administrador.</p>\n  <p>Por lo tanto, para comenzar, debe definir qué atributos del modelo desea asignar en masa. Puede hacer esto usando la <code>$fillable</code>propiedad en el modelo. Por ejemplo, hagamos que el <code>name</code>atributo de nuestro <code>Flight</code>modelo sea asignable en masa:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    /**\n     * The attributes that are mass assignable.\n     *\n     * @var array\n     */\n    protected $fillable = ['name'];\n}</code></pre>\n  <p>Una vez que hemos hecho que los atributos sean asignables en masa, podemos usar el <code>create</code>método para insertar un nuevo registro en la base de datos. El <code>create</code>método devuelve la instancia del modelo guardada:</p>\n  <pre><code>$flight = App\\Models\\Flight::create(['name' =&gt; 'Flight 10']);</code></pre>\n  <p>Si ya tiene una instancia de modelo, puede usar el <code>fill</code>método para completarla con una matriz de atributos:</p>\n  <pre><code>$flight-&gt;fill(['name' =&gt; 'Flight 22']);</code></pre>\n  <h4>Permitir la asignación masiva</h4>\n  <p>Si desea que todos los atributos sean asignables en masa, puede definir la <code>$guarded</code>propiedad como una matriz vacía:</p>\n  <pre><code>/**\n * The attributes that aren't mass assignable.\n *\n * @var array\n */\nprotected $guarded = [];</code></pre>\n  <p></p>\n  <h3>Otros métodos de creación</h3>\n  <h4><code>firstOrCreate</code>/ <code>firstOrNew</code></h4>\n  <p>Hay otros dos métodos que puede utilizar para crear modelos mediante la asignación masiva de atributos: <code>firstOrCreate</code>y <code>firstOrNew</code>. El <code>firstOrCreate</code>método intentará localizar un registro de la base de datos utilizando los pares de columna / valor dados. Si el modelo no se encuentra en la base de datos, se insertará un registro con los atributos del primer parámetro, junto con los del segundo parámetro opcional.</p>\n  <p>El <code>firstOrNew</code>método, como <code>firstOrCreate</code>intentará localizar un registro en la base de datos que coincida con los atributos dados. Sin embargo, si no se encuentra un modelo, se devolverá una nueva instancia de modelo. Tenga en cuenta que el modelo devuelto por <code>firstOrNew</code>aún no se ha conservado en la base de datos. Deberá llamar <code>save</code>manualmente para conservarlo:</p>\n  <pre><code>// Retrieve flight by name, or create it if it doesn't exist...\n$flight = App\\Models\\Flight::firstOrCreate(['name' =&gt; 'Flight 10']);\n\n// Retrieve flight by name, or create it with the name, delayed, and arrival_time attributes...\n$flight = App\\Models\\Flight::firstOrCreate(\n    ['name' =&gt; 'Flight 10'],\n    ['delayed' =&gt; 1, 'arrival_time' =&gt; '11:30']\n);\n\n// Retrieve by name, or instantiate...\n$flight = App\\Models\\Flight::firstOrNew(['name' =&gt; 'Flight 10']);\n\n// Retrieve by name, or instantiate with the name, delayed, and arrival_time attributes...\n$flight = App\\Models\\Flight::firstOrNew(\n    ['name' =&gt; 'Flight 10'],\n    ['delayed' =&gt; 1, 'arrival_time' =&gt; '11:30']\n);</code></pre>\n  <h4><code>updateOrCreate</code></h4>\n  <p>También puede encontrarse con situaciones en las que desee actualizar un modelo existente o crear un modelo nuevo si no existe ninguno. Laravel proporciona un <code>updateOrCreate</code>método para hacer esto en un solo paso. Al igual que el <code>firstOrCreate</code>método, <code>updateOrCreate</code>persiste el modelo, por lo que no es necesario llamar :<code>save()</code></p>\n  <pre><code>// If there's a flight from Oakland to San Diego, set the price to $99.\n// If no matching model exists, create one.\n$flight = App\\Models\\Flight::updateOrCreate(\n    ['departure' =&gt; 'Oakland', 'destination' =&gt; 'San Diego'],\n    ['price' =&gt; 99, 'discounted' =&gt; 1]\n);</code></pre>\n  <p></p>\n  <h2>Eliminar modelos</h2>\n  <p>Para eliminar un modelo, llame al <code>delete</code>método en una instancia de modelo:</p>\n  <pre><code>$flight = App\\Models\\Flight::find(1);\n\n$flight-&gt;delete();</code></pre>\n  <h4>Eliminar un modelo existente por clave</h4>\n  <p>En el ejemplo anterior, recuperamos el modelo de la base de datos antes de llamar al <code>delete</code>método. Sin embargo, si conoce la clave principal del modelo, puede eliminar el modelo sin recuperarlo explícitamente llamando al <code>destroy</code>método. Además de una única clave primaria como argumento, el <code>destroy</code>método aceptará múltiples claves primarias, una matriz de claves primarias o una colección de claves primarias:</p>\n  <pre><code>App\\Models\\Flight::destroy(1);\n\nApp\\Models\\Flight::destroy(1, 2, 3);\n\nApp\\Models\\Flight::destroy([1, 2, 3]);\n\nApp\\Models\\Flight::destroy(collect([1, 2, 3]));</code></pre>\n  <blockquote>\n    <div><div></div><p class=\"content\">El <code>destroy</code>método carga cada modelo individualmente y llama al <code>delete</code>método en ellos para que se activen los eventos <code>deleting</code>y <code>deleted</code>.</p></div>\n  </blockquote>\n  <h4>Eliminar modelos por consulta</h4>\n  <p>También puede ejecutar una declaración de eliminación en un conjunto de modelos. En este ejemplo, eliminaremos todos los vuelos marcados como inactivos. Al igual que las actualizaciones masivas, las eliminaciones masivas no activarán ningún evento de modelo para los modelos que se eliminan:</p>\n  <pre><code>$deletedRows = App\\Models\\Flight::where('active', 0)-&gt;delete();</code></pre>\n  <blockquote>\n    <div><div></div><p class=\"content\">Al ejecutar una declaración de eliminación masiva a través de Eloquent, los eventos de modelo <code>deleting</code>y <code>deleted</code>no se activarán para los modelos eliminados. Esto se debe a que los modelos nunca se recuperan realmente al ejecutar la instrucción de eliminación.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Eliminación suave</h3>\n  <p>Además de eliminar registros de su base de datos, Eloquent también puede \"eliminar suavemente\" modelos. Cuando los modelos se eliminan temporalmente, en realidad no se eliminan de su base de datos. En su lugar, <code>deleted_at</code>se establece un atributo en el modelo y se inserta en la base de datos. Si un modelo tiene un <code>deleted_at</code>valor no nulo , el modelo se ha eliminado temporalmente. Para habilitar eliminaciones suaves para un modelo, use el rasgo en el modelo:<code>Illuminate\\Database\\Eloquent\\SoftDeletes</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\n\nclass Flight extends Model\n{\n    use SoftDeletes;\n}</code></pre>\n  <blockquote>\n    <div><div></div><p class=\"content\">El <code>SoftDeletes</code>rasgo emitirá automáticamente el <code>deleted_at</code>atributo a una instancia <code>DateTime</code>/ <code>Carbon</code>por ti.</p></div>\n  </blockquote>\n  <p>También debe agregar la <code>deleted_at</code>columna a la tabla de su base de datos. El constructor de esquemas de Laravel contiene un método auxiliar para crear esta columna:</p>\n  <pre><code>public function up()\n{\n    Schema::table('flights', function (Blueprint $table) {\n        $table-&gt;softDeletes();\n    });\n}\n\npublic function down()\n{\n    Schema::table('flights', function (Blueprint $table) {\n        $table-&gt;dropSoftDeletes();\n    });\n}</code></pre>\n  <p>Ahora, cuando llame al <code>delete</code>método en el modelo, la <code>deleted_at</code>columna se establecerá en la fecha y hora actuales. Y, al consultar un modelo que utiliza eliminaciones suaves, los modelos eliminados temporalmente se excluirán automáticamente de todos los resultados de la consulta.</p>\n  <p>Para determinar si una instancia de modelo determinada se ha eliminado temporalmente, utilice el <code>trashed</code>método:</p>\n  <pre><code>if ($flight-&gt;trashed()) {\n    //\n}</code></pre>\n  <p></p>\n  <h3>Consultar modelos eliminados temporalmente</h3>\n  <h4>Incluyendo modelos con eliminación suave</h4>\n  <p>Como se indicó anteriormente, los modelos eliminados temporalmente se excluirán automáticamente de los resultados de la consulta. Sin embargo, puede forzar que los modelos eliminados temporalmente aparezcan en un conjunto de resultados utilizando el <code>withTrashed</code>método de la consulta:</p>\n  <pre><code>$flights = App\\Models\\Flight::withTrashed()\n                -&gt;where('account_id', 1)\n                -&gt;get();</code></pre>\n  <p>El <code>withTrashed</code>método también se puede utilizar en una consulta de relación :</p>\n  <pre><code>$flight-&gt;history()-&gt;withTrashed()-&gt;get();</code></pre>\n  <h4>Recuperar solo modelos eliminados temporalmente</h4>\n  <p>El <code>onlyTrashed</code>método recuperará <strong>solo</strong> modelos eliminados temporalmente:</p>\n  <pre><code>$flights = App\\Models\\Flight::onlyTrashed()\n                -&gt;where('airline_id', 1)\n                -&gt;get();</code></pre>\n  <h4>Restauración de modelos eliminados temporalmente</h4>\n  <p>A veces, es posible que desee \"eliminar\" un modelo eliminado temporalmente. Para restaurar un modelo eliminado temporalmente a un estado activo, use el <code>restore</code>método en una instancia de modelo:</p>\n  <pre><code>$flight-&gt;restore();</code></pre>\n  <p>También puede utilizar el <code>restore</code>método en una consulta para restaurar rápidamente varios modelos. Nuevamente, al igual que otras operaciones \"masivas\", esto no activará ningún evento de modelo para los modelos que se restauran:</p>\n  <pre><code>App\\Models\\Flight::withTrashed()\n        -&gt;where('airline_id', 1)\n        -&gt;restore();</code></pre>\n  <p>Al igual que el <code>withTrashed</code>método, el <code>restore</code>método también se puede utilizar en relaciones :</p>\n  <pre><code>$flight-&gt;history()-&gt;restore();</code></pre>\n  <h4>Eliminar modelos de forma permanente</h4>\n  <p>A veces, es posible que necesite eliminar realmente un modelo de su base de datos. Para eliminar permanentemente un modelo eliminado temporalmente de la base de datos, use el <code>forceDelete</code>método:</p>\n  <pre><code>// Force deleting a single model instance...\n$flight-&gt;forceDelete();\n\n// Force deleting all related models...\n$flight-&gt;history()-&gt;forceDelete();</code></pre>\n  <p></p>\n  <h2>Replicar modelos</h2>\n  <p>Puede crear una copia sin guardar de una instancia de modelo utilizando el <code>replicate</code>método. Esto es particularmente útil cuando tiene instancias de modelo que comparten muchos de los mismos atributos:</p>\n  <pre><code>$shipping = App\\Models\\Address::create([\n    'type' =&gt; 'shipping',\n    'line_1' =&gt; '123 Example Street',\n    'city' =&gt; 'Victorville',\n    'state' =&gt; 'CA',\n    'postcode' =&gt; '90001',\n]);\n\n$billing = $shipping-&gt;replicate()-&gt;fill([\n    'type' =&gt; 'billing'\n]);\n\n$billing-&gt;save();</code></pre>\n  <p></p>\n  <h2>Ámbitos de consulta</h2>\n  <p></p>\n  <h3>Ámbitos globales</h3>\n  <p>Los alcances globales le permiten agregar restricciones a todas las consultas para un modelo determinado. La propia funcionalidad de eliminación suave de Laravel utiliza ámbitos globales para extraer únicamente modelos \"no eliminados\" de la base de datos. Escribir sus propios alcances globales puede proporcionar una manera conveniente y fácil de asegurarse de que cada consulta para un modelo dado reciba ciertas restricciones.</p>\n  <h4>Escribir alcances globales</h4>\n  <p>Escribir un alcance global es simple. Defina una clase que implemente la interfaz. Esta interfaz requiere que se implemente un método: . El método puede agregar restricciones a la consulta según sea necesario:<code>Illuminate\\Database\\Eloquent\\Scope</code><code>apply</code><code>apply</code><code>where</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Scopes;\n\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\Scope;\n\nclass AgeScope implements Scope\n{\n    /**\n     * Apply the scope to a given Eloquent query builder.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Builder  $builder\n     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\n     * @return void\n     */\n    public function apply(Builder $builder, Model $model)\n    {\n        $builder-&gt;where('age', '&gt;', 200);\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p class=\"content\">Si su alcance global está agregando columnas a la cláusula de selección de la consulta, debe usar el <code>addSelect</code>método en lugar de <code>select</code>. Esto evitará el reemplazo involuntario de la cláusula select existente de la consulta.</p></div>\n  </blockquote>\n  <h4>Aplicar alcances globales</h4>\n  <p>Para asignar un alcance global a un modelo, debe anular el <code>booted</code>método de un modelo dado y usar el <code>addGlobalScope</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse App\\Scopes\\AgeScope;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The \"booted\" method of the model.\n     *\n     * @return void\n     */\n    protected static function booted()\n    {\n        static::addGlobalScope(new AgeScope);\n    }\n}</code></pre>\n  <p>Después de agregar el alcance, una consulta producirá el siguiente SQL:<code>User::all()</code></p>\n  <pre><code>select * from `users` where `age` &gt; 200</code></pre>\n  <h4>Ámbitos globales anónimos</h4>\n  <p>Eloquent también le permite definir alcances globales usando Closures, lo cual es particularmente útil para alcances simples que no justifican una clase separada:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The \"booted\" method of the model.\n     *\n     * @return void\n     */\n    protected static function booted()\n    {\n        static::addGlobalScope('age', function (Builder $builder) {\n            $builder-&gt;where('age', '&gt;', 200);\n        });\n    }\n}</code></pre>\n  <h4>Eliminar ámbitos globales</h4>\n  <p>Si desea eliminar un alcance global para una consulta determinada, puede usar el <code>withoutGlobalScope</code>método. El método acepta el nombre de clase del ámbito global como único argumento:</p>\n  <pre><code>User::withoutGlobalScope(AgeScope::class)-&gt;get();</code></pre>\n  <p>O, si definió el alcance global mediante un cierre:</p>\n  <pre><code>User::withoutGlobalScope('age')-&gt;get();</code></pre>\n  <p>Si desea eliminar varios o incluso todos los ámbitos globales, puede usar el <code>withoutGlobalScopes</code>método:</p>\n  <pre><code>// Remove all of the global scopes...\nUser::withoutGlobalScopes()-&gt;get();\n\n// Remove some of the global scopes...\nUser::withoutGlobalScopes([\n    FirstScope::class, SecondScope::class\n])-&gt;get();</code></pre>\n  <p></p>\n  <h3>Ámbitos locales</h3>\n  <p>Los ámbitos locales le permiten definir conjuntos comunes de restricciones que puede reutilizar fácilmente en toda su aplicación. Por ejemplo, es posible que deba recuperar con frecuencia todos los usuarios que se consideran \"populares\". Para definir un alcance, anteponga un método de modelo Eloquent <code>scope</code>.</p>\n  <p>Los ámbitos siempre deben devolver una instancia del generador de consultas:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Scope a query to only include popular users.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Builder  $query\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\n     */\n    public function scopePopular($query)\n    {\n        return $query-&gt;where('votes', '&gt;', 100);\n    }\n\n    /**\n     * Scope a query to only include active users.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Builder  $query\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\n     */\n    public function scopeActive($query)\n    {\n        return $query-&gt;where('active', 1);\n    }\n}</code></pre>\n  <h4>Utilizando un alcance local</h4>\n  <p>Una vez que se ha definido el alcance, puede llamar a los métodos de alcance al consultar el modelo. Sin embargo, no debe incluir el <code>scope</code>prefijo al llamar al método. Incluso puede encadenar llamadas a varios ámbitos, por ejemplo:</p>\n  <pre><code>$users = App\\Models\\User::popular()-&gt;active()-&gt;orderBy('created_at')-&gt;get();</code></pre>\n  <p>La combinación de múltiples alcances del modelo Eloquent a través de un <code>or</code>operador de consulta puede requerir el uso de devoluciones de llamada de cierre:</p>\n  <pre><code>$users = App\\Models\\User::popular()-&gt;orWhere(function (Builder $query) {\n    $query-&gt;active();\n})-&gt;get();</code></pre>\n  <p>Sin embargo, dado que esto puede ser engorroso, Laravel proporciona un <code>orWhere</code>método de \"orden superior\" que le permite encadenar con fluidez estos ámbitos sin el uso de cierres:</p>\n  <pre><code>$users = App\\Models\\User::popular()-&gt;orWhere-&gt;active()-&gt;get();</code></pre>\n  <h4>Ámbitos dinámicos</h4>\n  <p>A veces, es posible que desee definir un ámbito que acepte parámetros. Para comenzar, simplemente agregue sus parámetros adicionales a su alcance. Los parámetros de alcance deben definirse después del <code>$query</code>parámetro:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Scope a query to only include users of a given type.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Builder  $query\n     * @param  mixed  $type\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\n     */\n    public function scopeOfType($query, $type)\n    {\n        return $query-&gt;where('type', $type);\n    }\n}</code></pre>\n  <p>Ahora, puede pasar los parámetros al llamar al alcance:</p>\n  <pre><code>$users = App\\Models\\User::ofType('admin')-&gt;get();</code></pre>\n  <p></p>\n  <h2>Comparación de modelos</h2>\n  <p>A veces es posible que deba determinar si dos modelos son \"iguales\". El <code>is</code>método se puede utilizar para verificar rápidamente que dos modelos tienen la misma clave principal, tabla y conexión de base de datos:</p>\n  <pre><code>if ($post-&gt;is($anotherPost)) {\n    //\n}</code></pre>\n  <p></p>\n  <h2>Eventos</h2>\n  <p>Modelos elocuentes disparan varios eventos, lo que le permite enganchar en los siguientes puntos en el ciclo de vida de un modelo: <code>retrieved</code>, <code>creating</code>, <code>created</code>, <code>updating</code>, <code>updated</code>, <code>saving</code>, <code>saved</code>, <code>deleting</code>, <code>deleted</code>, <code>restoring</code>, <code>restored</code>. Los eventos le permiten ejecutar código fácilmente cada vez que se guarda o actualiza una clase de modelo específica en la base de datos. Cada evento recibe la instancia del modelo a través de su constructor.</p>\n  <p>El <code>retrieved</code>evento se activará cuando se recupere un modelo existente de la base de datos. Cuando se guarda un nuevo modelo por primera vez, los eventos <code>creating</code>y <code>created</code>se activarán. Los eventos <code>updating</code>/ <code>updated</code>se activarán cuando se modifique un modelo existente y <code>save</code>se llame al método. Los eventos <code>saving</code>/ <code>saved</code>se activarán cuando se cree o actualice un modelo.</p>\n  <blockquote>\n    <div><div></div><p class=\"content\">Al emitir una actualización de masa o de eliminación a través elocuente, la <code>saved</code>, <code>updated</code>, <code>deleting</code>, y <code>deleted</code>eventos modelo no será despedido por los modelos afectados. Esto se debe a que los modelos nunca se recuperan realmente cuando se realiza una actualización o eliminación masiva.</p></div>\n  </blockquote>\n  <p>Para comenzar, defina una <code>$dispatchesEvents</code>propiedad en su modelo Eloquent que mapee varios puntos del ciclo de vida del modelo Eloquent a sus propias clases de eventos :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse App\\Events\\UserDeleted;\nuse App\\Events\\UserSaved;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable\n{\n    use Notifiable;\n\n    /**\n     * The event map for the model.\n     *\n     * @var array\n     */\n    protected $dispatchesEvents = [\n        'saved' =&gt; UserSaved::class,\n        'deleted' =&gt; UserDeleted::class,\n    ];\n}</code></pre>\n  <p>Después de definir y mapear sus eventos Eloquent, puede usar detectores de eventos para manejar los eventos.</p>\n  <p></p>\n  <h3>Usando cierres</h3>\n  <p>En lugar de utilizar clases de eventos personalizadas, puede registrar cierres que se ejecutan cuando se activan varios eventos de modelo. Por lo general, debe registrar estos cierres en el <code>booted</code>método de su modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The \"booted\" method of the model.\n     *\n     * @return void\n     */\n    protected static function booted()\n    {\n        static::created(function ($user) {\n            //\n        });\n    }\n}</code></pre>\n  <p>Si es necesario, puede utilizar detectores de eventos anónimos que se pueden poner en cola al registrar eventos modelo. Esto le indicará a Laravel que ejecute el detector de eventos del modelo usando la cola :</p>\n  <pre><code>use function Illuminate\\Events\\queueable;\n\nstatic::created(queueable(function ($user) {\n    //\n}));</code></pre>\n  <p></p>\n  <h3>Observadores</h3>\n  <h4>Definición de observadores</h4>\n  <p>Si está escuchando muchos eventos en un modelo dado, puede usar observadores para agrupar a todos sus oyentes en una sola clase. Las clases de observadores tienen nombres de métodos que reflejan los eventos de Eloquent que deseas escuchar. Cada uno de estos métodos recibe el modelo como único argumento. El comando Artisan es la forma más sencilla de crear una nueva clase de observador:<code>make:observer</code></p>\n  <pre><code>php artisan make:observer UserObserver --model=User</code></pre>\n  <p>Este comando colocará al nuevo observador en su directorio. Si este directorio no existe, Artisan lo creará por usted. Su nuevo observador se verá así:<code>App/Observers</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Observers;\n\nuse App\\Models\\User;\n\nclass UserObserver\n{\n    /**\n     * Handle the User \"created\" event.\n     *\n     * @param  \\App\\Models\\User  $user\n     * @return void\n     */\n    public function created(User $user)\n    {\n        //\n    }\n\n    /**\n     * Handle the User \"updated\" event.\n     *\n     * @param  \\App\\Models\\User  $user\n     * @return void\n     */\n    public function updated(User $user)\n    {\n        //\n    }\n\n    /**\n     * Handle the User \"deleted\" event.\n     *\n     * @param  \\App\\Models\\User  $user\n     * @return void\n     */\n    public function deleted(User $user)\n    {\n        //\n    }\n\n    /**\n     * Handle the User \"forceDeleted\" event.\n     *\n     * @param  \\App\\Models\\User  $user\n     * @return void\n     */\n    public function forceDeleted(User $user)\n    {\n        //\n    }\n}</code></pre>\n  <p>Para registrar un observador, use el <code>observe</code>método en el modelo que desea observar. Puede registrar observadores en el <code>boot</code>método de uno de sus proveedores de servicios. En este ejemplo, registraremos al observador en <code>AppServiceProvider</code>:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse App\\Observers\\UserObserver;\nuse App\\Models\\User;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        User::observe(UserObserver::class);\n    }\n}</code></pre>\n  <p></p>\n  <h3>Silenciar eventos</h3>\n  <p>Ocasionalmente, es posible que desee \"silenciar\" temporalmente todos los eventos activados por un modelo. Puede lograr esto usando el <code>withoutEvents</code>método. El <code>withoutEvents</code>método acepta un cierre como único argumento. Cualquier código ejecutado dentro de este cierre no activará eventos de modelo. Por ejemplo, lo siguiente buscará y eliminará una instancia sin activar ningún evento de modelo. Cualquier valor devuelto por el Closure dado será devuelto por el método:<code>App\\Models\\User</code><code>withoutEvents</code></p>\n  <pre><code>use App\\Models\\User;\n\n$user = User::withoutEvents(function () use () {\n    User::findOrFail(1)-&gt;delete();\n\n    return User::find(2);\n});</code></pre>\n  <h4>Guardar un solo modelo sin eventos</h4>\n  <p>A veces, es posible que desee \"guardar\" un modelo determinado sin generar ningún evento. Puede lograr esto usando el <code>saveQuietly</code>método:</p>\n  <pre><code>$user = User::findOrFail(1);\n\n$user-&gt;name = 'Victoria Faith';\n\n$user-&gt;saveQuietly();</code></pre>\n</section>"
      },
      {
        "titulo": "8.2 Relaciones",
        "contenido": "<section>\n  <h1>Eloquent: Relaciones</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Definición de relaciones\n      <ul>\n        <li>Doce y cincuenta y nueve de la noche</li>\n        <li>Uno a muchos</li>\n        <li>Uno a muchos (inverso)</li>\n        <li>Muchos a muchos</li>\n        <li>Definición de modelos personalizados de tablas intermedias</li>\n        <li>Tiene uno a través</li>\n        <li>Tiene muchos a través</li>\n      </ul></li>\n    <li>Relaciones polimórficas\n      <ul>\n        <li>Doce y cincuenta y nueve de la noche</li>\n        <li>Uno a muchos</li>\n        <li>Muchos a muchos</li>\n        <li>Tipos polimórficos personalizados</li>\n      </ul></li>\n    <li>Relaciones dinámicas</li>\n    <li>Consultar relaciones\n      <ul>\n        <li>Métodos de relación vs. Propiedades dinámicas</li>\n        <li>Consultar la existencia de la relación</li>\n        <li>Consulta de ausencia de relación</li>\n        <li>Consultar relaciones polimórficas</li>\n        <li>Contando modelos relacionados</li>\n        <li>Contando modelos relacionados en relaciones polimórficas</li>\n      </ul></li>\n    <li>Carga ansiosa\n      <ul>\n        <li>Restringir cargas impacientes</li>\n        <li>Carga impaciente perezosa</li>\n      </ul></li>\n    <li>Insertar y actualizar modelos relacionados\n      <ul>\n        <li>El <code>save</code>método</li>\n        <li>El <code>create</code>método</li>\n        <li>Pertenece a las relaciones</li>\n        <li>Muchas a muchas relaciones</li>\n      </ul></li>\n    <li>Tocar las marcas de tiempo de los padres</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Las tablas de la base de datos suelen estar relacionadas entre sí. Por ejemplo, una publicación de blog puede tener muchos comentarios o un pedido puede estar relacionado con el usuario que lo realizó. Eloquent facilita la gestión y el trabajo con estas relaciones, y admite varios tipos diferentes de relaciones:</p>\n  <div>\n    <ul>\n      <li>Doce y cincuenta y nueve de la noche</li>\n      <li>Uno a muchos</li>\n      <li>Muchos a muchos</li>\n      <li>Tiene uno a través</li>\n      <li>Tiene muchos a través</li>\n      <li>Uno a uno (polimórfico)</li>\n      <li>Uno a muchos (polimórfico)</li>\n      <li>Muchos a muchos (polimórfico)</li>\n    </ul>\n  </div>\n  <p></p>\n  <h2>Definición de relaciones</h2>\n  <p>Las relaciones elocuentes se definen como métodos en sus clases modelo elocuentes. Dado que, al igual que los propios modelos de Eloquent, las relaciones también sirven como poderosos constructores de consultas , definir las relaciones como métodos proporciona poderosas capacidades de encadenamiento y consulta de métodos. Por ejemplo, podemos encadenar restricciones adicionales en esta <code>posts</code>relación:</p>\n  <pre><code>$user-&gt;posts()-&gt;where('active', 1)-&gt;get();</code></pre>\n  <p>Pero, antes de sumergirnos demasiado en el uso de las relaciones, aprendamos a definir cada tipo.</p>\n  <blockquote>\n    <div><div></div><p> Los nombres de las relaciones no pueden colisionar con los nombres de los atributos, ya que eso podría llevar a que su modelo no sepa cuál resolver.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Doce y cincuenta y nueve de la noche</h3>\n  <p>Una relación uno a uno es una relación muy básica. Por ejemplo, un <code>User</code>modelo puede estar asociado con uno <code>Phone</code>. Para definir esta relación, colocamos un <code>phone</code>método en el <code>User</code>modelo. El <code>phone</code>método debe llamar al <code>hasOne</code>método y devolver su resultado:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Get the phone record associated with the user.\n     */\n    public function phone()\n    {\n        return $this-&gt;hasOne('App\\Models\\Phone');\n    }\n}</code></pre>\n  <p>El primer argumento que se pasa al <code>hasOne</code>método es el nombre del modelo relacionado. Una vez definida la relación, podemos recuperar el registro relacionado usando las propiedades dinámicas de Eloquent. Las propiedades dinámicas le permiten acceder a métodos de relación como si fueran propiedades definidas en el modelo:</p>\n  <pre><code>$phone = User::find(1)-&gt;phone;</code></pre>\n  <p>Eloquent determina la clave externa de la relación en función del nombre del modelo. En este caso, <code>Phone</code>se asume automáticamente que el modelo tiene una <code>user_id</code>clave externa. Si desea anular esta convención, puede pasar un segundo argumento al <code>hasOne</code>método:</p>\n  <pre><code>return $this-&gt;hasOne('App\\Models\\Phone', 'foreign_key');</code></pre>\n  <p>Además, Eloquent asume que la clave externa debe tener un valor que coincida con la columna <code>id</code>(o personalizada <code>$primaryKey</code>) del padre. En otras palabras, Eloquent buscará el valor de la <code>id</code>columna del usuario en la <code>user_id</code>columna del <code>Phone</code>registro. Si desea que la relación use un valor diferente a <code>id</code>, puede pasar un tercer argumento al <code>hasOne</code>método que especifica su clave personalizada:</p>\n  <pre><code>return $this-&gt;hasOne('App\\Models\\Phone', 'foreign_key', 'local_key');</code></pre>\n  <h4>Definiendo lo inverso de la relación</h4>\n  <p>Entonces, podemos acceder al <code>Phone</code>modelo desde nuestro <code>User</code>. Ahora, definamos una relación en el <code>Phone</code>modelo que nos permitirá acceder al <code>User</code>propietario del teléfono. Podemos definir la inversa de una <code>hasOne</code>relación usando el <code>belongsTo</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Phone extends Model\n{\n    /**\n     * Get the user that owns the phone.\n     */\n    public function user()\n    {\n        return $this-&gt;belongsTo('App\\Models\\User');\n    }\n}</code></pre>\n  <p>En el ejemplo anterior, Eloquent intentará hacer coincidir el <code>user_id</code>del <code>Phone</code>modelo con <code>id</code>el del <code>User</code>modelo. Eloquent determina el nombre de clave externa predeterminado examinando el nombre del método de relación y añadiendo el sufijo al nombre del método <code>_id</code>. Sin embargo, si la clave externa en el <code>Phone</code>modelo no lo es <code>user_id</code>, puede pasar un nombre de clave personalizada como segundo argumento del <code>belongsTo</code>método:</p>\n  <pre><code>/**\n * Get the user that owns the phone.\n */\npublic function user()\n{\n    return $this-&gt;belongsTo('App\\Models\\User', 'foreign_key');\n}</code></pre>\n  <p>Si su modelo principal no lo utiliza <code>id</code>como clave principal, o si desea unir el modelo secundario a una columna diferente, puede pasar un tercer argumento al <code>belongsTo</code>método que especifica la clave personalizada de su tabla principal:</p>\n  <pre><code>/**\n * Get the user that owns the phone.\n */\npublic function user()\n{\n    return $this-&gt;belongsTo('App\\Models\\User', 'foreign_key', 'owner_key');\n}</code></pre>\n  <p></p>\n  <h3>Uno a muchos</h3>\n  <p>Una relación de uno a muchos se utiliza para definir relaciones en las que un solo modelo posee cualquier cantidad de otros modelos. Por ejemplo, una publicación de blog puede tener un número infinito de comentarios. Como todas las demás relaciones de Eloquent, las relaciones de uno a muchos se definen colocando una función en su modelo de Eloquent:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Post extends Model\n{\n    /**\n     * Get the comments for the blog post.\n     */\n    public function comments()\n    {\n        return $this-&gt;hasMany('App\\Models\\Comment');\n    }\n}</code></pre>\n  <p>Remember, Eloquent will automatically determine the proper foreign key column on the <code>Comment</code> model. By convention, Eloquent will take the \"snake case\" name of the owning model and suffix it with <code>_id</code>. So, for this example, Eloquent will assume the foreign key on the <code>Comment</code> model is <code>post_id</code>.</p>\n  <p>Once the relationship has been defined, we can access the collection of comments by accessing the <code>comments</code> property. Remember, since Eloquent provides \"dynamic properties\", we can access relationship methods as if they were defined as properties on the model:</p>\n  <pre><code>$comments = App\\Models\\Post::find(1)-&gt;comments;\n\nforeach ($comments as $comment) {\n    //\n}</code></pre>\n  <p>Since all relationships also serve as query builders, you can add further constraints to which comments are retrieved by calling the <code>comments</code> method and continuing to chain conditions onto the query:</p>\n  <pre><code>$comment = App\\Models\\Post::find(1)-&gt;comments()-&gt;where('title', 'foo')-&gt;first();</code></pre>\n  <p>Al igual que el <code>hasOne</code>método, también puede anular las claves externas y locales pasando argumentos adicionales al <code>hasMany</code>método:</p>\n  <pre><code>return $this-&gt;hasMany('App\\Models\\Comment', 'foreign_key');\n\nreturn $this-&gt;hasMany('App\\Models\\Comment', 'foreign_key', 'local_key');</code></pre>\n  <p></p>\n  <h3>Uno a muchos (inverso)</h3>\n  <p>Ahora que podemos acceder a todos los comentarios de una publicación, definamos una relación para permitir que un comentario acceda a su publicación principal. Para definir la inversa de una <code>hasMany</code>relación, defina una función de relación en el modelo hijo que llama al <code>belongsTo</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Comment extends Model\n{\n    /**\n     * Get the post that owns the comment.\n     */\n    public function post()\n    {\n        return $this-&gt;belongsTo('App\\Models\\Post');\n    }\n}</code></pre>\n  <p>Una vez definida la relación, podemos recuperar el <code>Post</code>modelo de a <code>Comment</code>accediendo a la <code>post</code>\"propiedad dinámica\":</p>\n  <pre><code>$comment = App\\Models\\Comment::find(1);\n\necho $comment-&gt;post-&gt;title;</code></pre>\n  <p>En el ejemplo anterior, Eloquent intentará hacer coincidir el <code>post_id</code>del <code>Comment</code>modelo con <code>id</code>el del <code>Post</code>modelo. Eloquent determina el nombre de la clave externa predeterminada examinando el nombre del método de relación y agregando como sufijo el nombre del método <code>_</code>seguido del nombre de la columna de la clave principal. Sin embargo, si la clave externa en el <code>Comment</code>modelo no lo es <code>post_id</code>, puede pasar un nombre de clave personalizada como segundo argumento del <code>belongsTo</code>método:</p>\n  <pre><code>/**\n * Get the post that owns the comment.\n */\npublic function post()\n{\n    return $this-&gt;belongsTo('App\\Models\\Post', 'foreign_key');\n}</code></pre>\n  <p>Si su modelo principal no lo utiliza <code>id</code>como clave principal, o si desea unir el modelo secundario a una columna diferente, puede pasar un tercer argumento al <code>belongsTo</code>método que especifica la clave personalizada de su tabla principal:</p>\n  <pre><code>/**\n * Get the post that owns the comment.\n */\npublic function post()\n{\n    return $this-&gt;belongsTo('App\\Models\\Post', 'foreign_key', 'owner_key');\n}</code></pre>\n  <p></p>\n  <h3>Muchos a muchos</h3>\n  <p>Many-to-many relations are slightly more complicated than <code>hasOne</code> and <code>hasMany</code> relationships. An example of such a relationship is a user with many roles, where the roles are also shared by other users. For example, many users may have the role of \"Admin\".</p>\n  <h4>Table Structure</h4>\n  <p>To define this relationship, three database tables are needed: <code>users</code>, <code>roles</code>, and <code>role_user</code>. The <code>role_user</code> table is derived from the alphabetical order of the related model names, and contains the <code>user_id</code> and <code>role_id</code> columns:</p>\n  <pre><code>users\n    id - integer\n    name - string\n\nroles\n    id - integer\n    name - string\n\nrole_user\n    user_id - integer\n    role_id - integer</code></pre>\n  <h4>Model Structure</h4>\n  <p>Many-to-many relationships are defined by writing a method that returns the result of the <code>belongsToMany</code> method. For example, let's define the <code>roles</code> method on our <code>User</code> model:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The roles that belong to the user.\n     */\n    public function roles()\n    {\n        return $this-&gt;belongsToMany('App\\Models\\Role');\n    }\n}</code></pre>\n  <p>Una vez definida la relación, puede acceder a los roles del usuario utilizando la <code>roles</code>propiedad dinámica:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nforeach ($user-&gt;roles as $role) {\n    //\n}</code></pre>\n  <p>Como todos los demás tipos de relaciones, puede llamar al <code>roles</code>método para continuar encadenando restricciones de consulta a la relación:</p>\n  <pre><code>$roles = App\\Models\\User::find(1)-&gt;roles()-&gt;orderBy('name')-&gt;get();</code></pre>\n  <p>Como se mencionó anteriormente, para determinar el nombre de la tabla de unión de la relación, Eloquent unirá los dos nombres de modelos relacionados en orden alfabético. Sin embargo, puede anular esta convención. Puede hacerlo pasando un segundo argumento al <code>belongsToMany</code>método:</p>\n  <pre><code>return $this-&gt;belongsToMany('App\\Models\\Role', 'role_user');</code></pre>\n  <p>Además de personalizar el nombre de la tabla de unión, también puede personalizar los nombres de columna de las claves de la tabla pasando argumentos adicionales al <code>belongsToMany</code>método. El tercer argumento es el nombre de la clave externa del modelo en el que está definiendo la relación, mientras que el cuarto argumento es el nombre de la clave externa del modelo al que se está uniendo:</p>\n  <pre><code>return $this-&gt;belongsToMany('App\\Models\\Role', 'role_user', 'user_id', 'role_id');</code></pre>\n  <h4>Definiendo lo inverso de la relación</h4>\n  <p>Para definir la inversa de una relación de varios a varios, realiza otra llamada a <code>belongsToMany</code>en su modelo relacionado. Para continuar con nuestro ejemplo de roles de usuario, definamos el <code>users</code>método en el <code>Role</code>modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Role extends Model\n{\n    /**\n     * The users that belong to the role.\n     */\n    public function users()\n    {\n        return $this-&gt;belongsToMany('App\\Models\\User');\n    }\n}</code></pre>\n  <p>As you can see, the relationship is defined exactly the same as its <code>User</code> counterpart, with the exception of referencing the <code>App\\Models\\User</code> model. Since we're reusing the <code>belongsToMany</code> method, all of the usual table and key customization options are available when defining the inverse of many-to-many relationships.</p>\n  <h4>Retrieving Intermediate Table Columns</h4>\n  <p>As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our <code>User</code> object has many <code>Role</code> objects that it is related to. After accessing this relationship, we may access the intermediate table using the <code>pivot</code> attribute on the models:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nforeach ($user-&gt;roles as $role) {\n    echo $role-&gt;pivot-&gt;created_at;\n}</code></pre>\n  <p>Notice that each <code>Role</code> model we retrieve is automatically assigned a <code>pivot</code> attribute. This attribute contains a model representing the intermediate table, and may be used like any other Eloquent model.</p>\n  <p>By default, only the model keys will be present on the <code>pivot</code> object. If your pivot table contains extra attributes, you must specify them when defining the relationship:</p>\n  <pre><code>return $this-&gt;belongsToMany('App\\Models\\Role')-&gt;withPivot('column1', 'column2');</code></pre>\n  <p>If you want your pivot table to have automatically maintained <code>created_at</code> and <code>updated_at</code> timestamps, use the <code>withTimestamps</code> method on the relationship definition:</p>\n  <pre><code>return $this-&gt;belongsToMany('App\\Models\\Role')-&gt;withTimestamps();</code></pre>\n  <h4>Customizing The <code>pivot</code> Attribute Name</h4>\n  <p>As noted earlier, attributes from the intermediate table may be accessed on models using the <code>pivot</code> attribute. However, you are free to customize the name of this attribute to better reflect its purpose within your application.</p>\n  <p>For example, if your application contains users that may subscribe to podcasts, you probably have a many-to-many relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table accessor to <code>subscription</code> instead of <code>pivot</code>. This can be done using the <code>as</code> method when defining the relationship:</p>\n  <pre><code>return $this-&gt;belongsToMany('App\\Models\\Podcast')\n                -&gt;as('subscription')\n                -&gt;withTimestamps();</code></pre>\n  <p>Once this is done, you may access the intermediate table data using the customized name:</p>\n  <pre><code>$users = User::with('podcasts')-&gt;get();\n\nforeach ($users-&gt;flatMap-&gt;podcasts as $podcast) {\n    echo $podcast-&gt;subscription-&gt;created_at;\n}</code></pre>\n  <h4>Filtering Relationships Via Intermediate Table Columns</h4>\n  <p>También puede filtrar los resultados devueltos por <code>belongsToMany</code>el uso de la <code>wherePivot</code>, <code>wherePivotIn</code>y <code>wherePivotNotIn</code>métodos en la definición de la relación:</p>\n  <pre><code>return $this-&gt;belongsToMany('App\\Models\\Role')-&gt;wherePivot('approved', 1);\n\nreturn $this-&gt;belongsToMany('App\\Models\\Role')-&gt;wherePivotIn('priority', [1, 2]);\n\nreturn $this-&gt;belongsToMany('App\\Models\\Role')-&gt;wherePivotNotIn('priority', [1, 2]);</code></pre>\n  <p></p>\n  <h3>Definición de modelos personalizados de tablas intermedias</h3>\n  <p>Si desea definir un modelo personalizado para representar la tabla intermedia de su relación, puede llamar al <code>using</code>método al definir la relación. Los modelos dinámicos personalizados de muchos a muchos deberían ampliar la clase, mientras que los modelos dinámicos polimórficos personalizados de varios a varios deberían ampliar la clase. Por ejemplo, podemos definir un que utiliza un modelo de pivote personalizado :<code>Illuminate\\Database\\Eloquent\\Relations\\Pivot</code><code>Illuminate\\Database\\Eloquent\\Relations\\MorphPivot</code><code>Role</code><code>RoleUser</code></p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Role extends Model\n{\n    /**\n     * The users that belong to the role.\n     */\n    public function users()\n    {\n        return $this-&gt;belongsToMany('App\\Models\\User')-&gt;using('App\\Models\\RoleUser');\n    }\n}</code></pre>\n  <p>Al definir el <code>RoleUser</code>modelo, ampliaremos la <code>Pivot</code>clase:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Relations\\Pivot;\n\nclass RoleUser extends Pivot\n{\n    //\n}</code></pre>\n  <p>Puede combinar <code>using</code>y <code>withPivot</code>para recuperar columnas de la tabla intermedia. Por ejemplo, puede recuperar las columnas <code>created_by</code>y <code>updated_by</code>de la <code>RoleUser</code>tabla dinámica pasando los nombres de las columnas al <code>withPivot</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Role extends Model\n{\n    /**\n     * The users that belong to the role.\n     */\n    public function users()\n    {\n        return $this-&gt;belongsToMany('App\\Models\\User')\n                        -&gt;using('App\\Models\\RoleUser')\n                        -&gt;withPivot([\n                            'created_by',\n                            'updated_by',\n                        ]);\n    }\n}</code></pre>\n  <blockquote>\n    <p><strong>Nota: Es</strong> posible que los modelos Pivot no utilicen el <code>SoftDeletes</code>rasgo. Si necesita eliminar temporalmente los registros dinámicos, considere convertir su modelo dinámico en un modelo Eloquent real.</p>\n  </blockquote>\n  <h4>Modelos de pivote personalizados e ID en aumento</h4>\n  <p>Si ha definido una relación de muchos a muchos que utiliza un modelo de pivote personalizado y ese modelo de pivote tiene una clave principal que se incrementa automáticamente, debe asegurarse de que su clase de modelo de pivote personalizado defina una <code>incrementing</code>propiedad establecida en <code>true</code>.</p>\n  <pre><code>/**\n * Indicates if the IDs are auto-incrementing.\n *\n * @var bool\n */\npublic $incrementing = true;</code></pre>\n  <p></p>\n  <h3>Tiene uno a través</h3>\n  <p>La relación \"tiene uno a través\" vincula los modelos a través de una única relación intermedia.</p>\n  <p>Por ejemplo, en una aplicación de taller de reparación de vehículos, cada uno <code>Mechanic</code>puede tener uno <code>Car</code>y cada uno <code>Car</code>puede tener uno <code>Owner</code>. Si bien el <code>Mechanic</code>y el <code>Owner</code>no tienen conexión directa, el <code>Mechanic</code>puede acceder a <code>Owner</code> <em>través</em> del <code>Car</code>mismo. Veamos las tablas necesarias para definir esta relación:</p>\n  <pre><code>mechanics\n    id - integer\n    name - string\n\ncars\n    id - integer\n    model - string\n    mechanic_id - integer\n\nowners\n    id - integer\n    name - string\n    car_id - integer</code></pre>\n  <p>Ahora que hemos examinado la estructura de la tabla para la relación, definamos la relación en el <code>Mechanic</code>modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Mechanic extends Model\n{\n    /**\n     * Get the car's owner.\n     */\n    public function carOwner()\n    {\n        return $this-&gt;hasOneThrough('App\\Models\\Owner', 'App\\Models\\Car');\n    }\n}</code></pre>\n  <p>El primer argumento que se pasa al <code>hasOneThrough</code>método es el nombre del modelo final al que deseamos acceder, mientras que el segundo argumento es el nombre del modelo intermedio.</p>\n  <p>Se utilizarán las convenciones típicas de claves foráneas de Eloquent al realizar las consultas de la relación. Si desea personalizar las claves de la relación, puede pasarlas como tercer y cuarto argumento al <code>hasOneThrough</code>método. El tercer argumento es el nombre de la clave externa en el modelo intermedio. El cuarto argumento es el nombre de la clave externa en el modelo final. El quinto argumento es la clave local, mientras que el sexto argumento es la clave local del modelo intermedio:</p>\n  <pre><code>class Mechanic extends Model\n{\n    /**\n     * Get the car's owner.\n     */\n    public function carOwner()\n    {\n        return $this-&gt;hasOneThrough(\n            'App\\Models\\Owner',\n            'App\\Models\\Car',\n            'mechanic_id', // Foreign key on cars table...\n            'car_id', // Foreign key on owners table...\n            'id', // Local key on mechanics table...\n            'id' // Local key on cars table...\n        );\n    }\n}</code></pre>\n  <p></p>\n  <h3>Tiene muchos a través</h3>\n  <p>La relación \"tiene-muchos-a través\" proporciona un atajo conveniente para acceder a relaciones distantes a través de una relación intermedia. Por ejemplo, un <code>Country</code>modelo puede tener muchos <code>Post</code>modelos a través de un <code>User</code>modelo intermedio . En este ejemplo, podría recopilar fácilmente todas las publicaciones de blog de un país determinado. Veamos las tablas necesarias para definir esta relación:</p>\n  <pre><code>countries\n    id - integer\n    name - string\n\nusers\n    id - integer\n    country_id - integer\n    name - string\n\nposts\n    id - integer\n    user_id - integer\n    title - string</code></pre>\n  <p>Aunque <code>posts</code>no contiene una <code>country_id</code>columna, la <code>hasManyThrough</code>relación proporciona acceso a las publicaciones de un país a través de . Para realizar esta consulta, Eloquent inspecciona el en la tabla intermedia . Después de encontrar los ID de usuario coincidentes, se utilizan para consultar la tabla.<code>$country-&gt;posts</code><code>country_id</code><code>users</code><code>posts</code></p>\n  <p>Ahora que hemos examinado la estructura de la tabla para la relación, definámosla en el <code>Country</code>modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Country extends Model\n{\n    /**\n     * Get all of the posts for the country.\n     */\n    public function posts()\n    {\n        return $this-&gt;hasManyThrough('App\\Models\\Post', 'App\\Models\\User');\n    }\n}</code></pre>\n  <p>The first argument passed to the <code>hasManyThrough</code> method is the name of the final model we wish to access, while the second argument is the name of the intermediate model.</p>\n  <p>Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the <code>hasManyThrough</code> method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model:</p>\n  <pre><code>class Country extends Model\n{\n    public function posts()\n    {\n        return $this-&gt;hasManyThrough(\n            'App\\Models\\Post',\n            'App\\Models\\User',\n            'country_id', // Foreign key on users table...\n            'user_id', // Foreign key on posts table...\n            'id', // Local key on countries table...\n            'id' // Local key on users table...\n        );\n    }\n}</code></pre>\n  <p></p>\n  <h2>Polymorphic Relationships</h2>\n  <p>A polymorphic relationship allows the target model to belong to more than one type of model using a single association.</p>\n  <p></p>\n  <h3>One To One (Polymorphic)</h3>\n  <h4>Table Structure</h4>\n  <p>A one-to-one polymorphic relation is similar to a simple one-to-one relation; however, the target model can belong to more than one type of model on a single association. For example, a blog <code>Post</code> and a <code>User</code> may share a polymorphic relation to an <code>Image</code> model. Using a one-to-one polymorphic relation allows you to have a single list of unique images that are used for both blog posts and user accounts. First, let's examine the table structure:</p>\n  <pre><code>posts\n    id - integer\n    name - string\n\nusers\n    id - integer\n    name - string\n\nimages\n    id - integer\n    url - string\n    imageable_id - integer\n    imageable_type - string</code></pre>\n  <p>Tome nota de las columnas <code>imageable_id</code>y <code>imageable_type</code>de la <code>images</code>tabla. La <code>imageable_id</code>columna contendrá el valor de ID de la publicación o usuario, mientras que la <code>imageable_type</code>columna contendrá el nombre de la clase del modelo principal. La <code>imageable_type</code>columna se utiliza por elocuente para determinar qué \"tipo\" de modelo padre a retorno cuando se accede a la <code>imageable</code>relación.</p>\n  <h4>Estructura del modelo</h4>\n  <p>A continuación, examinemos las definiciones del modelo necesarias para construir esta relación:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Image extends Model\n{\n    /**\n     * Get the owning imageable model.\n     */\n    public function imageable()\n    {\n        return $this-&gt;morphTo();\n    }\n}\n\nclass Post extends Model\n{\n    /**\n     * Get the post's image.\n     */\n    public function image()\n    {\n        return $this-&gt;morphOne('App\\Models\\Image', 'imageable');\n    }\n}\n\nclass User extends Model\n{\n    /**\n     * Get the user's image.\n     */\n    public function image()\n    {\n        return $this-&gt;morphOne('App\\Models\\Image', 'imageable');\n    }\n}</code></pre>\n  <h4>Recuperando la relación</h4>\n  <p>Una vez que la tabla y los modelos de su base de datos estén definidos, puede acceder a las relaciones a través de sus modelos. Por ejemplo, para recuperar la imagen de una publicación, podemos usar la <code>image</code>propiedad dinámica:</p>\n  <pre><code>$post = App\\Models\\Post::find(1);\n\n$image = $post-&gt;image;</code></pre>\n  <p>También puede recuperar el padre del modelo polimórfico accediendo al nombre del método que realiza la llamada a <code>morphTo</code>. En nuestro caso, ese es el <code>imageable</code>método del <code>Image</code>modelo. Entonces, accederemos a ese método como una propiedad dinámica:</p>\n  <pre><code>$image = App\\Models\\Image::find(1);\n\n$imageable = $image-&gt;imageable;</code></pre>\n  <p>La <code>imageable</code>relación del <code>Image</code>modelo devolverá una instancia <code>Post</code>o <code>User</code>, según el tipo de modelo que posea la imagen. Si necesita especificar columnas personalizadas <code>type</code>y <code>id</code>para la <code>morphTo</code>relación, asegúrese siempre de pasar el nombre de la relación (que debe coincidir exactamente con el nombre del método) como primer parámetro:</p>\n  <pre><code>/**\n * Get the model that the image belongs to.\n */\npublic function imageable()\n{\n    return $this-&gt;morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');\n}</code></pre>\n  <p></p>\n  <h3>Uno a muchos (polimórfico)</h3>\n  <h4>Estructura de la tabla</h4>\n  <p>A one-to-many polymorphic relation is similar to a simple one-to-many relation; however, the target model can belong to more than one type of model on a single association. For example, imagine users of your application can \"comment\" on both posts and videos. Using polymorphic relationships, you may use a single <code>comments</code> table for both of these scenarios. First, let's examine the table structure required to build this relationship:</p>\n  <pre><code>posts\n    id - integer\n    title - string\n    body - text\n\nvideos\n    id - integer\n    title - string\n    url - string\n\ncomments\n    id - integer\n    body - text\n    commentable_id - integer\n    commentable_type - string</code></pre>\n  <h4>Model Structure</h4>\n  <p>Next, let's examine the model definitions needed to build this relationship:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Comment extends Model\n{\n    /**\n     * Get the owning commentable model.\n     */\n    public function commentable()\n    {\n        return $this-&gt;morphTo();\n    }\n}\n\nclass Post extends Model\n{\n    /**\n     * Get all of the post's comments.\n     */\n    public function comments()\n    {\n        return $this-&gt;morphMany('App\\Models\\Comment', 'commentable');\n    }\n}\n\nclass Video extends Model\n{\n    /**\n     * Get all of the video's comments.\n     */\n    public function comments()\n    {\n        return $this-&gt;morphMany('App\\Models\\Comment', 'commentable');\n    }\n}</code></pre>\n  <h4>Retrieving The Relationship</h4>\n  <p>Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the comments for a post, we can use the <code>comments</code> dynamic property:</p>\n  <pre><code>$post = App\\Models\\Post::find(1);\n\nforeach ($post-&gt;comments as $comment) {\n    //\n}</code></pre>\n  <p>You may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to <code>morphTo</code>. In our case, that is the <code>commentable</code> method on the <code>Comment</code> model. So, we will access that method as a dynamic property:</p>\n  <pre><code>$comment = App\\Models\\Comment::find(1);\n\n$commentable = $comment-&gt;commentable;</code></pre>\n  <p>The <code>commentable</code> relation on the <code>Comment</code> model will return either a <code>Post</code> or <code>Video</code> instance, depending on which type of model owns the comment.</p>\n  <p></p>\n  <h3>Many To Many (Polymorphic)</h3>\n  <h4>Table Structure</h4>\n  <p>Las relaciones polimórficas de muchos a muchos son un poco más complicadas que las relaciones <code>morphOne</code>y <code>morphMany</code>. Por ejemplo, un blog <code>Post</code>y un <code>Video</code>modelo podrían compartir una relación polimórfica con un <code>Tag</code>modelo. El uso de una relación polimórfica de muchos a muchos le permite tener una sola lista de etiquetas únicas que se comparten entre publicaciones de blog y videos. Primero, examinemos la estructura de la tabla:</p>\n  <pre><code>posts\n    id - integer\n    name - string\n\nvideos\n    id - integer\n    name - string\n\ntags\n    id - integer\n    name - string\n\ntaggables\n    tag_id - integer\n    taggable_id - integer\n    taggable_type - string</code></pre>\n  <h4>Estructura del modelo</h4>\n  <p>A continuación, estamos listos para definir las relaciones en el modelo. Los modelos <code>Post</code>y <code>Video</code>tendrán un <code>tags</code>método que llama al <code>morphToMany</code>método en la clase base Eloquent:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Post extends Model\n{\n    /**\n     * Get all of the tags for the post.\n     */\n    public function tags()\n    {\n        return $this-&gt;morphToMany('App\\Models\\Tag', 'taggable');\n    }\n}</code></pre>\n  <h4>Definiendo lo inverso de la relación</h4>\n  <p>A continuación, en el <code>Tag</code>modelo, debe definir un método para cada uno de sus modelos relacionados. Entonces, para este ejemplo, definiremos un <code>posts</code>método y un <code>videos</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Tag extends Model\n{\n    /**\n     * Get all of the posts that are assigned this tag.\n     */\n    public function posts()\n    {\n        return $this-&gt;morphedByMany('App\\Models\\Post', 'taggable');\n    }\n\n    /**\n     * Get all of the videos that are assigned this tag.\n     */\n    public function videos()\n    {\n        return $this-&gt;morphedByMany('App\\Models\\Video', 'taggable');\n    }\n}</code></pre>\n  <h4>Recuperando la relación</h4>\n  <p>Una vez que la tabla y los modelos de su base de datos estén definidos, puede acceder a las relaciones a través de sus modelos. Por ejemplo, para acceder a todas las etiquetas de una publicación, puede usar la <code>tags</code>propiedad dinámica:</p>\n  <pre><code>$post = App\\Models\\Post::find(1);\n\nforeach ($post-&gt;tags as $tag) {\n    //\n}</code></pre>\n  <p>También puede recuperar el propietario de una relación polimórfica del modelo polimórfico accediendo al nombre del método que realiza la llamada a <code>morphedByMany</code>. En nuestro caso, esos son los métodos <code>posts</code>o <code>videos</code>en el <code>Tag</code>modelo. Entonces, accederá a esos métodos como propiedades dinámicas:</p>\n  <pre><code>$tag = App\\Models\\Tag::find(1);\n\nforeach ($tag-&gt;videos as $video) {\n    //\n}</code></pre>\n  <p></p>\n  <h3>Tipos polimórficos personalizados</h3>\n  <p>By default, Laravel will use the fully qualified class name to store the type of the related model. For instance, given the one-to-many example above where a <code>Comment</code> may belong to a <code>Post</code> or a <code>Video</code>, the default <code>commentable_type</code> would be either <code>App\\Models\\Post</code> or <code>App\\Models\\Video</code>, respectively. However, you may wish to decouple your database from your application's internal structure. In that case, you may define a \"morph map\" to instruct Eloquent to use a custom name for each model instead of the class name:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\nRelation::morphMap([\n    'posts' =&gt; 'App\\Models\\Post',\n    'videos' =&gt; 'App\\Models\\Video',\n]);</code></pre>\n  <p>You may register the <code>morphMap</code> in the <code>boot</code> function of your <code>AppServiceProvider</code> or create a separate service provider if you wish.</p>\n  <blockquote>\n    <div><div></div><p> When adding a \"morph map\" to your existing application, every morphable <code>*_type</code> column value in your database that still contains a fully-qualified class will need to be converted to its \"map\" name.</p></div>\n  </blockquote>\n  <p>You may determine the morph alias of a given model at runtime using the <code>getMorphClass</code> method. Conversely, you may determine the fully-qualified class name associated with a morph alias using the <code>Relation::getMorphedModel</code> method:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\n$alias = $post-&gt;getMorphClass();\n\n$class = Relation::getMorphedModel($alias);</code></pre>\n  <p></p>\n  <h3>Dynamic Relationships</h3>\n  <p>You may use the <code>resolveRelationUsing</code> method to define relations between Eloquent models at runtime. While not typically recommended for normal application development, this may occasionally be useful when developing Laravel packages:</p>\n  <pre><code>use App\\Models\\Order;\nuse App\\Models\\Customer;\n\nOrder::resolveRelationUsing('customer', function ($orderModel) {\n    return $orderModel-&gt;belongsTo(Customer::class, 'customer_id');\n});</code></pre>\n  <blockquote>\n    <div><div></div><p> When defining dynamic relationships, always provide explicit key name arguments to the Eloquent relationship methods.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Querying Relations</h2>\n  <p>Dado que todos los tipos de relaciones elocuentes se definen a través de métodos, puede llamar a esos métodos para obtener una instancia de la relación sin ejecutar realmente las consultas de relación. Además, todos los tipos de relaciones de Eloquent también sirven como constructores de consultas , lo que le permite continuar encadenando restricciones en la consulta de relación antes de ejecutar finalmente el SQL en su base de datos.</p>\n  <p>Por ejemplo, imagine un sistema de blogs en el que un <code>User</code>modelo tiene muchos <code>Post</code>modelos asociados :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Get all of the posts for the user.\n     */\n    public function posts()\n    {\n        return $this-&gt;hasMany('App\\Models\\Post');\n    }\n}</code></pre>\n  <p>Puede consultar la <code>posts</code>relación y agregar restricciones adicionales a la relación de esta manera:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;posts()-&gt;where('active', 1)-&gt;get();</code></pre>\n  <p>Puede utilizar cualquiera de los métodos del generador de consultas en la relación, así que asegúrese de explorar la documentación del generador de consultas para conocer todos los métodos que están disponibles para usted.</p>\n  <h4>Encadenamiento de <code>orWhere</code>cláusulas después de las relaciones</h4>\n  <p>Como se demostró en el ejemplo anterior, puede agregar restricciones adicionales a las relaciones cuando las consulte. Sin embargo, tenga cuidado al encadenar <code>orWhere</code>cláusulas en una relación, ya que las <code>orWhere</code>cláusulas se agruparán lógicamente al mismo nivel que la restricción de relación:</p>\n  <pre><code>$user-&gt;posts()\n        -&gt;where('active', 1)\n        -&gt;orWhere('votes', '&gt;=', 100)\n        -&gt;get();\n\n// select * from posts\n// where user_id = ? and active = 1 or votes &gt;= 100</code></pre>\n  <p>En la mayoría de las situaciones, es probable que desee utilizar grupos de restricciones para agrupar lógicamente las verificaciones condicionales entre paréntesis:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n$user-&gt;posts()\n        -&gt;where(function (Builder $query) {\n            return $query-&gt;where('active', 1)\n                         -&gt;orWhere('votes', '&gt;=', 100);\n        })\n        -&gt;get();\n\n// select * from posts\n// where user_id = ? and (active = 1 or votes &gt;= 100)</code></pre>\n  <p></p>\n  <h3>Métodos de relación vs. Propiedades dinámicas</h3>\n  <p>If you do not need to add additional constraints to an Eloquent relationship query, you may access the relationship as if it were a property. For example, continuing to use our <code>User</code> and <code>Post</code> example models, we may access all of a user's posts like so:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nforeach ($user-&gt;posts as $post) {\n    //\n}</code></pre>\n  <p>Dynamic properties are \"lazy loading\", meaning they will only load their relationship data when you actually access them. Because of this, developers often use eager loading to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relations.</p>\n  <p></p>\n  <h3>Querying Relationship Existence</h3>\n  <p>When accessing the records for a model, you may wish to limit your results based on the existence of a relationship. For example, imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the relationship to the <code>has</code> and <code>orHas</code> methods:</p>\n  <pre><code>// Retrieve all posts that have at least one comment...\n$posts = App\\Models\\Post::has('comments')-&gt;get();</code></pre>\n  <p>You may also specify an operator and count to further customize the query:</p>\n  <pre><code>// Retrieve all posts that have three or more comments...\n$posts = App\\Models\\Post::has('comments', '&gt;=', 3)-&gt;get();</code></pre>\n  <p>Nested <code>has</code> statements may also be constructed using \"dot\" notation. For example, you may retrieve all posts that have at least one comment and vote:</p>\n  <pre><code>// Retrieve posts that have at least one comment with votes...\n$posts = App\\Models\\Post::has('comments.votes')-&gt;get();</code></pre>\n  <p>If you need even more power, you may use the <code>whereHas</code> and <code>orWhereHas</code> methods to put \"where\" conditions on your <code>has</code> queries. These methods allow you to add customized constraints to a relationship constraint, such as checking the content of a comment:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n// Retrieve posts with at least one comment containing words like foo%...\n$posts = App\\Models\\Post::whereHas('comments', function (Builder $query) {\n    $query-&gt;where('content', 'like', 'foo%');\n})-&gt;get();\n\n// Retrieve posts with at least ten comments containing words like foo%...\n$posts = App\\Models\\Post::whereHas('comments', function (Builder $query) {\n    $query-&gt;where('content', 'like', 'foo%');\n}, '&gt;=', 10)-&gt;get();</code></pre>\n  <p></p>\n  <h3>Querying Relationship Absence</h3>\n  <p>When accessing the records for a model, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that <strong>don't</strong> have any comments. To do so, you may pass the name of the relationship to the <code>doesntHave</code> and <code>orDoesntHave</code> methods:</p>\n  <pre><code>$posts = App\\Models\\Post::doesntHave('comments')-&gt;get();</code></pre>\n  <p>If you need even more power, you may use the <code>whereDoesntHave</code> and <code>orWhereDoesntHave</code> methods to put \"where\" conditions on your <code>doesntHave</code> queries. These methods allows you to add customized constraints to a relationship constraint, such as checking the content of a comment:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n$posts = App\\Models\\Post::whereDoesntHave('comments', function (Builder $query) {\n    $query-&gt;where('content', 'like', 'foo%');\n})-&gt;get();</code></pre>\n  <p>Puede utilizar la notación de \"puntos\" para ejecutar una consulta en una relación anidada. Por ejemplo, la siguiente consulta recuperará todas las publicaciones que no tienen comentarios y las publicaciones que tienen comentarios de autores que no están prohibidos:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n$posts = App\\Models\\Post::whereDoesntHave('comments.author', function (Builder $query) {\n    $query-&gt;where('banned', 0);\n})-&gt;get();</code></pre>\n  <p></p>\n  <h3>Consultar relaciones polimórficas</h3>\n  <p>Para consultar la existencia de <code>MorphTo</code>relaciones, puede utilizar el <code>whereHasMorph</code>método y sus métodos correspondientes:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n// Retrieve comments associated to posts or videos with a title like foo%...\n$comments = App\\Models\\Comment::whereHasMorph(\n    'commentable',\n    ['App\\Models\\Post', 'App\\Models\\Video'],\n    function (Builder $query) {\n        $query-&gt;where('title', 'like', 'foo%');\n    }\n)-&gt;get();\n\n// Retrieve comments associated to posts with a title not like foo%...\n$comments = App\\Models\\Comment::whereDoesntHaveMorph(\n    'commentable',\n    'App\\Models\\Post',\n    function (Builder $query) {\n        $query-&gt;where('title', 'like', 'foo%');\n    }\n)-&gt;get();</code></pre>\n  <p>Puede usar el <code>$type</code>parámetro para agregar diferentes restricciones según el modelo relacionado:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n$comments = App\\Models\\Comment::whereHasMorph(\n    'commentable',\n    ['App\\Models\\Post', 'App\\Models\\Video'],\n    function (Builder $query, $type) {\n        $query-&gt;where('title', 'like', 'foo%');\n\n        if ($type === 'App\\Models\\Post') {\n            $query-&gt;orWhere('content', 'like', 'foo%');\n        }\n    }\n)-&gt;get();</code></pre>\n  <p>En lugar de pasar una serie de posibles modelos polimórficos, puede proporcionar <code>*</code>como comodín y dejar que Laravel recupere todos los posibles tipos polimórficos de la base de datos. Laravel ejecutará una consulta adicional para realizar esta operación:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n$comments = App\\Models\\Comment::whereHasMorph('commentable', '*', function (Builder $query) {\n    $query-&gt;where('title', 'like', 'foo%');\n})-&gt;get();</code></pre>\n  <p></p>\n  <h3>Contando modelos relacionados</h3>\n  <p>If you want to count the number of results from a relationship without actually loading them you may use the <code>withCount</code> method, which will place a <code>{relation}_count</code> column on your resulting models. For example:</p>\n  <pre><code>$posts = App\\Models\\Post::withCount('comments')-&gt;get();\n\nforeach ($posts as $post) {\n    echo $post-&gt;comments_count;\n}</code></pre>\n  <p>You may add the \"counts\" for multiple relations as well as add constraints to the queries:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n$posts = App\\Models\\Post::withCount(['votes', 'comments' =&gt; function (Builder $query) {\n    $query-&gt;where('content', 'like', 'foo%');\n}])-&gt;get();\n\necho $posts[0]-&gt;votes_count;\necho $posts[0]-&gt;comments_count;</code></pre>\n  <p>You may also alias the relationship count result, allowing multiple counts on the same relationship:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Builder;\n\n$posts = App\\Models\\Post::withCount([\n    'comments',\n    'comments as pending_comments_count' =&gt; function (Builder $query) {\n        $query-&gt;where('approved', false);\n    },\n])-&gt;get();\n\necho $posts[0]-&gt;comments_count;\n\necho $posts[0]-&gt;pending_comments_count;</code></pre>\n  <p>If you're combining <code>withCount</code> with a <code>select</code> statement, ensure that you call <code>withCount</code> after the <code>select</code> method:</p>\n  <pre><code>$posts = App\\Models\\Post::select(['title', 'body'])-&gt;withCount('comments')-&gt;get();\n\necho $posts[0]-&gt;title;\necho $posts[0]-&gt;body;\necho $posts[0]-&gt;comments_count;</code></pre>\n  <p>In addition, using the <code>loadCount</code> method, you may load a relationship count after the parent model has already been retrieved:</p>\n  <pre><code>$book = App\\Models\\Book::first();\n\n$book-&gt;loadCount('genres');</code></pre>\n  <p>If you need to set additional query constraints on the eager loading query, you may pass an array keyed by the relationships you wish to load. The array values should be <code>Closure</code> instances which receive the query builder instance:</p>\n  <pre><code>$book-&gt;loadCount(['reviews' =&gt; function ($query) {\n    $query-&gt;where('rating', 5);\n}])</code></pre>\n  <p></p>\n  <h3>Counting Related Models On Polymorphic Relationships</h3>\n  <p>If you would like to eager load a <code>morphTo</code> relationship, as well as nested relationship counts on the various entities that may be returned by that relationship, you may use the <code>with</code> method in combination with the <code>morphTo</code> relationship's <code>morphWithCount</code> method.</p>\n  <p>In this example, let's assume <code>Photo</code> and <code>Post</code> models may create <code>ActivityFeed</code> models. Additionally, let's assume that <code>Photo</code> models are associated with <code>Tag</code> models, and <code>Post</code> models are associated with <code>Comment</code> models.</p>\n  <p>Usando estas definiciones y relaciones de modelos, podemos recuperar <code>ActivityFeed</code>instancias de <code>parentable</code>modelos y cargar ansiosamente todos los modelos y sus respectivos recuentos de relaciones anidadas:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n\n$activities = ActivityFeed::query()\n    -&gt;with(['parentable' =&gt; function (MorphTo $morphTo) {\n        $morphTo-&gt;morphWithCount([\n            Photo::class =&gt; ['tags'],\n            Post::class =&gt; ['comments'],\n        ]);\n    }])-&gt;get();</code></pre>\n  <p>Además, puede utilizar el <code>loadMorphCount</code>método para cargar ansiosamente todos los recuentos de relaciones anidadas en las diversas entidades de la relación polimórfica si los <code>ActivityFeed</code>modelos ya se han recuperado:</p>\n  <pre><code>$activities = ActivityFeed::with('parentable')\n    -&gt;get()\n    -&gt;loadMorphCount('parentable', [\n        Photo::class =&gt; ['tags'],\n        Post::class =&gt; ['comments'],\n    ]);</code></pre>\n  <p></p>\n  <h2>Carga ansiosa</h2>\n  <p>Al acceder a las relaciones de Eloquent como propiedades, los datos de la relación se \"cargan de forma diferida\". Esto significa que los datos de la relación no se cargan realmente hasta que accede por primera vez a la propiedad. Sin embargo, Eloquent puede \"cargar ansiosamente\" las relaciones al momento de consultar el modelo principal. La carga ansiosa alivia el problema de las consultas N + 1. Para ilustrar el problema de la consulta N + 1, considere un <code>Book</code>modelo relacionado con <code>Author</code>:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Book extends Model\n{\n    /**\n     * Get the author that wrote the book.\n     */\n    public function author()\n    {\n        return $this-&gt;belongsTo('App\\Models\\Author');\n    }\n}</code></pre>\n  <p>Ahora, recuperemos todos los libros y sus autores:</p>\n  <pre><code>$books = App\\Models\\Book::all();\n\nforeach ($books as $book) {\n    echo $book-&gt;author-&gt;name;\n}</code></pre>\n  <p>Este ciclo ejecutará 1 consulta para recuperar todos los libros de la mesa, luego otra consulta para cada libro para recuperar el autor. Entonces, si tenemos 25 libros, el código anterior ejecutaría 26 consultas: 1 para el libro original y 25 consultas adicionales para recuperar el autor de cada libro.</p>\n  <p>Thankfully, we can use eager loading to reduce this operation to just 2 queries. When querying, you may specify which relationships should be eager loaded using the <code>with</code> method:</p>\n  <pre><code>$books = App\\Models\\Book::with('author')-&gt;get();\n\nforeach ($books as $book) {\n    echo $book-&gt;author-&gt;name;\n}</code></pre>\n  <p>For this operation, only two queries will be executed:</p>\n  <pre><code>select * from books\n\nselect * from authors where id in (1, 2, 3, 4, 5, ...)</code></pre>\n  <h4>Eager Loading Multiple Relationships</h4>\n  <p>Sometimes you may need to eager load several different relationships in a single operation. To do so, just pass additional arguments to the <code>with</code> method:</p>\n  <pre><code>$books = App\\Models\\Book::with(['author', 'publisher'])-&gt;get();</code></pre>\n  <h4>Nested Eager Loading</h4>\n  <p>To eager load nested relationships, you may use \"dot\" syntax. For example, let's eager load all of the book's authors and all of the author's personal contacts in one Eloquent statement:</p>\n  <pre><code>$books = App\\Models\\Book::with('author.contacts')-&gt;get();</code></pre>\n  <h4>Nested Eager Loading <code>morphTo</code> Relationships</h4>\n  <p>If you would like to eager load a <code>morphTo</code> relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the <code>with</code> method in combination with the <code>morphTo</code> relationship's <code>morphWith</code> method. To help illustrate this method, let's consider the following model:</p>\n  <pre><code>&lt;?php\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass ActivityFeed extends Model\n{\n    /**\n     * Get the parent of the activity feed record.\n     */\n    public function parentable()\n    {\n        return $this-&gt;morphTo();\n    }\n}</code></pre>\n  <p>In this example, let's assume <code>Event</code>, <code>Photo</code>, and <code>Post</code> models may create <code>ActivityFeed</code> models. Additionally, let's assume that <code>Event</code> models belong to a <code>Calendar</code> model, <code>Photo</code> models are associated with <code>Tag</code> models, and <code>Post</code> models belong to an <code>Author</code> model.</p>\n  <p>Using these model definitions and relationships, we may retrieve <code>ActivityFeed</code> model instances and eager load all <code>parentable</code> models and their respective nested relationships:</p>\n  <pre><code>use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n\n$activities = ActivityFeed::query()\n    -&gt;with(['parentable' =&gt; function (MorphTo $morphTo) {\n        $morphTo-&gt;morphWith([\n            Event::class =&gt; ['calendar'],\n            Photo::class =&gt; ['tags'],\n            Post::class =&gt; ['author'],\n        ]);\n    }])-&gt;get();</code></pre>\n  <h4>Carga ansiosa de columnas específicas</h4>\n  <p>Es posible que no siempre necesite todas las columnas de las relaciones que está recuperando. Por esta razón, Eloquent te permite especificar qué columnas de la relación te gustaría recuperar:</p>\n  <pre><code>$books = App\\Models\\Book::with('author:id,name')-&gt;get();</code></pre>\n  <blockquote>\n    <div><div></div><p>Al utilizar esta función, siempre debe incluir la <code>id</code>columna y cualquier columna de clave externa relevante en la lista de columnas que desea recuperar.</p></div>\n  </blockquote>\n  <h4>Carga ansiosa por defecto</h4>\n  <p>A veces, es posible que desee cargar siempre algunas relaciones al recuperar un modelo. Para lograr esto, puede definir una <code>$with</code>propiedad en el modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Book extends Model\n{\n    /**\n     * The relationships that should always be loaded.\n     *\n     * @var array\n     */\n    protected $with = ['author'];\n\n    /**\n     * Get the author that wrote the book.\n     */\n    public function author()\n    {\n        return $this-&gt;belongsTo('App\\Models\\Author');\n    }\n}</code></pre>\n  <p>Si desea eliminar un elemento de la <code>$with</code>propiedad para una sola consulta, puede usar el <code>without</code>método:</p>\n  <pre><code>$books = App\\Models\\Book::without('author')-&gt;get();</code></pre>\n  <p></p>\n  <h3>Restringir cargas impacientes</h3>\n  <p>Sometimes you may wish to eager load a relationship, but also specify additional query conditions for the eager loading query. Here's an example:</p>\n  <pre><code>$users = App\\Models\\User::with(['posts' =&gt; function ($query) {\n    $query-&gt;where('title', 'like', '%first%');\n}])-&gt;get();</code></pre>\n  <p>In this example, Eloquent will only eager load posts where the post's <code>title</code> column contains the word <code>first</code>. You may call other query builder methods to further customize the eager loading operation:</p>\n  <pre><code>$users = App\\Models\\User::with(['posts' =&gt; function ($query) {\n    $query-&gt;orderBy('created_at', 'desc');\n}])-&gt;get();</code></pre>\n  <blockquote>\n    <div><div></div><p> The <code>limit</code> and <code>take</code> query builder methods may not be used when constraining eager loads.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Lazy Eager Loading</h3>\n  <p>Sometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models:</p>\n  <pre><code>$books = App\\Models\\Book::all();\n\nif ($someCondition) {\n    $books-&gt;load('author', 'publisher');\n}</code></pre>\n  <p>Si necesita establecer restricciones de consulta adicionales en la consulta de carga ansiosa, puede pasar una matriz codificada por las relaciones que desea cargar. Los valores de la matriz deben ser <code>Closure</code>instancias que reciban la instancia de consulta:</p>\n  <pre><code>$author-&gt;load(['books' =&gt; function ($query) {\n    $query-&gt;orderBy('published_date', 'asc');\n}]);</code></pre>\n  <p>Para cargar una relación solo cuando aún no se ha cargado, use el <code>loadMissing</code>método:</p>\n  <pre><code>public function format(Book $book)\n{\n    $book-&gt;loadMissing('author');\n\n    return [\n        'name' =&gt; $book-&gt;name,\n        'author' =&gt; $book-&gt;author-&gt;name,\n    ];\n}</code></pre>\n  <h4>Carga ansiosa perezosa anidada y <code>morphTo</code></h4>\n  <p>Si desea cargar ansiosamente una <code>morphTo</code>relación, así como relaciones anidadas en las diversas entidades que pueden ser devueltas por esa relación, puede usar el <code>loadMorph</code>método.</p>\n  <p>Este método acepta el nombre de la <code>morphTo</code>relación como su primer argumento y una matriz de pares modelo / relación como su segundo argumento. Para ayudar a ilustrar este método, consideremos el siguiente modelo:</p>\n  <pre><code>&lt;?php\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass ActivityFeed extends Model\n{\n    /**\n     * Get the parent of the activity feed record.\n     */\n    public function parentable()\n    {\n        return $this-&gt;morphTo();\n    }\n}</code></pre>\n  <p>En este ejemplo, vamos a suponer <code>Event</code>, <code>Photo</code>y <code>Post</code>modelos pueden crear <code>ActivityFeed</code>modelos. Además, supongamos que los <code>Event</code>modelos pertenecen a un <code>Calendar</code>modelo, los <code>Photo</code>modelos están asociados con <code>Tag</code>modelos y los <code>Post</code>modelos pertenecen a un <code>Author</code>modelo.</p>\n  <p>Usando estas definiciones y relaciones de modelos, podemos recuperar <code>ActivityFeed</code>instancias de <code>parentable</code>modelos y cargar ansiosamente todos los modelos y sus respectivas relaciones anidadas:</p>\n  <pre><code>$activities = ActivityFeed::with('parentable')\n    -&gt;get()\n    -&gt;loadMorph('parentable', [\n        Event::class =&gt; ['calendar'],\n        Photo::class =&gt; ['tags'],\n        Post::class =&gt; ['author'],\n    ]);</code></pre>\n  <p></p>\n  <h2>Insertar y actualizar modelos relacionados</h2>\n  <p></p>\n  <h3>El método de guardar</h3>\n  <p>Eloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to insert a new <code>Comment</code> for a <code>Post</code> model. Instead of manually setting the <code>post_id</code> attribute on the <code>Comment</code>, you may insert the <code>Comment</code> directly from the relationship's <code>save</code> method:</p>\n  <pre><code>$comment = new App\\Models\\Comment(['message' =&gt; 'A new comment.']);\n\n$post = App\\Models\\Post::find(1);\n\n$post-&gt;comments()-&gt;save($comment);</code></pre>\n  <p>Notice that we did not access the <code>comments</code> relationship as a dynamic property. Instead, we called the <code>comments</code> method to obtain an instance of the relationship. The <code>save</code> method will automatically add the appropriate <code>post_id</code> value to the new <code>Comment</code> model.</p>\n  <p>If you need to save multiple related models, you may use the <code>saveMany</code> method:</p>\n  <pre><code>$post = App\\Models\\Post::find(1);\n\n$post-&gt;comments()-&gt;saveMany([\n    new App\\Models\\Comment(['message' =&gt; 'A new comment.']),\n    new App\\Models\\Comment(['message' =&gt; 'Another comment.']),\n]);</code></pre>\n  <p>The <code>save</code> and <code>saveMany</code> methods will not add the new models to any in-memory relationships that are already loaded onto the parent model. If you plan on accessing the relationship after using the <code>save</code> or <code>saveMany</code> methods, you may wish to use the <code>refresh</code> method to reload the model and its relationships:</p>\n  <pre><code>$post-&gt;comments()-&gt;save($comment);\n\n$post-&gt;refresh();\n\n// All comments, including the newly saved comment...\n$post-&gt;comments;</code></pre>\n  <p></p>\n  <h4>Recursively Saving Models &amp; Relationships</h4>\n  <p>If you would like to <code>save</code> your model and all of its associated relationships, you may use the <code>push</code> method:</p>\n  <pre><code>$post = App\\Models\\Post::find(1);\n\n$post-&gt;comments[0]-&gt;message = 'Message';\n$post-&gt;comments[0]-&gt;author-&gt;name = 'Author Name';\n\n$post-&gt;push();</code></pre>\n  <p></p>\n  <h3>The Create Method</h3>\n  <p>Además de los métodos <code>save</code>y <code>saveMany</code>, también puede utilizar el <code>create</code>método, que acepta una matriz de atributos, crea un modelo y lo inserta en la base de datos. Nuevamente, la diferencia entre <code>save</code>y <code>create</code>es que <code>save</code>acepta una instancia de modelo Eloquent completa mientras que <code>create</code>acepta un PHP simple <code>array</code>:</p>\n  <pre><code>$post = App\\Models\\Post::find(1);\n\n$comment = $post-&gt;comments()-&gt;create([\n    'message' =&gt; 'A new comment.',\n]);</code></pre>\n  <blockquote>\n    <div><div></div><p>Antes de utilizar el <code>create</code>método, asegúrese de revisar la documentación sobre la asignación masiva de atributos .</p></div>\n  </blockquote>\n  <p>Puede utilizar el <code>createMany</code>método para crear varios modelos relacionados:</p>\n  <pre><code>$post = App\\Models\\Post::find(1);\n\n$post-&gt;comments()-&gt;createMany([\n    [\n        'message' =&gt; 'A new comment.',\n    ],\n    [\n        'message' =&gt; 'Another new comment.',\n    ],\n]);</code></pre>\n  <p>También puede utilizar los <code>findOrNew</code>, <code>firstOrNew</code>, <code>firstOrCreate</code>y <code>updateOrCreate</code>métodos para crear y actualizar los modelos de relaciones .</p>\n  <p></p>\n  <h3>Pertenece a las relaciones</h3>\n  <p>Al actualizar una <code>belongsTo</code>relación, puede utilizar el <code>associate</code>método. Este método establecerá la clave externa en el modelo secundario:</p>\n  <pre><code>$account = App\\Models\\Account::find(10);\n\n$user-&gt;account()-&gt;associate($account);\n\n$user-&gt;save();</code></pre>\n  <p>Al eliminar una <code>belongsTo</code>relación, puede utilizar el <code>dissociate</code>método. Este método establecerá la clave externa de la relación en <code>null</code>:</p>\n  <pre><code>$user-&gt;account()-&gt;dissociate();\n\n$user-&gt;save();</code></pre>\n  <p></p>\n  <h4>Modelos predeterminados</h4>\n  <p>Los <code>belongsTo</code>, <code>hasOne</code>, <code>hasOneThrough</code>, y <code>morphOne</code>relaciones permiten definir un modelo predeterminado que será devuelto si la relación es dada <code>null</code>. Este patrón a menudo se denomina patrón de objeto nulo y puede ayudar a eliminar las verificaciones condicionales en su código. En el siguiente ejemplo, la <code>user</code>relación devolverá un modelo vacío si no se adjunta a la publicación:<code>App\\Models\\User</code><code>user</code></p>\n  <pre><code>/**\n * Get the author of the post.\n */\npublic function user()\n{\n    return $this-&gt;belongsTo('App\\Models\\User')-&gt;withDefault();\n}</code></pre>\n  <p>Para completar el modelo predeterminado con atributos, puede pasar una matriz o un cierre al <code>withDefault</code>método:</p>\n  <pre><code>/**\n * Get the author of the post.\n */\npublic function user()\n{\n    return $this-&gt;belongsTo('App\\Models\\User')-&gt;withDefault([\n        'name' =&gt; 'Guest Author',\n    ]);\n}\n\n/**\n * Get the author of the post.\n */\npublic function user()\n{\n    return $this-&gt;belongsTo('App\\Models\\User')-&gt;withDefault(function ($user, $post) {\n        $user-&gt;name = 'Guest Author';\n    });\n}</code></pre>\n  <p></p>\n  <h3>Muchas a muchas relaciones</h3>\n  <h4>Adjuntar / Desmontar</h4>\n  <p>Eloquent también proporciona algunos métodos auxiliares adicionales para que el trabajo con modelos relacionados sea más conveniente. Por ejemplo, imaginemos que un usuario puede tener muchos roles y un rol puede tener muchos usuarios. Para adjuntar un rol a un usuario insertando un registro en la tabla intermedia que une los modelos, use el <code>attach</code>método:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;roles()-&gt;attach($roleId);</code></pre>\n  <p>Al adjuntar una relación a un modelo, también puede pasar una matriz de datos adicionales para insertarlos en la tabla intermedia:</p>\n  <pre><code>$user-&gt;roles()-&gt;attach($roleId, ['expires' =&gt; $expires]);</code></pre>\n  <p>A veces, puede ser necesario eliminar un rol de un usuario. Para eliminar un registro de relación de varios a varios, utilice el <code>detach</code>método. El <code>detach</code>método eliminará el registro apropiado de la tabla intermedia; sin embargo, ambos modelos permanecerán en la base de datos:</p>\n  <pre><code>// Detach a single role from the user...\n$user-&gt;roles()-&gt;detach($roleId);\n\n// Detach all roles from the user...\n$user-&gt;roles()-&gt;detach();</code></pre>\n  <p>Para mayor comodidad, <code>attach</code>y <code>detach</code>también acepte matrices de ID como entrada:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;roles()-&gt;detach([1, 2, 3]);\n\n$user-&gt;roles()-&gt;attach([\n    1 =&gt; ['expires' =&gt; $expires],\n    2 =&gt; ['expires' =&gt; $expires],\n]);</code></pre>\n  <h4>Asociaciones de sincronización</h4>\n  <p>También puede utilizar el <code>sync</code>método para construir asociaciones de varios a varios. El <code>sync</code>método acepta una matriz de ID para colocar en la tabla intermedia. Cualquier ID que no esté en la matriz dada se eliminará de la tabla intermedia. Entonces, después de que se complete esta operación, solo los ID en la matriz dada existirán en la tabla intermedia:</p>\n  <pre><code>$user-&gt;roles()-&gt;sync([1, 2, 3]);</code></pre>\n  <p>También puede pasar valores de tabla intermedios adicionales con los ID:</p>\n  <pre><code>$user-&gt;roles()-&gt;sync([1 =&gt; ['expires' =&gt; true], 2, 3]);</code></pre>\n  <p>Si no desea desvincular las ID existentes, puede utilizar el <code>syncWithoutDetaching</code>método:</p>\n  <pre><code>$user-&gt;roles()-&gt;syncWithoutDetaching([1, 2, 3]);</code></pre>\n  <h4>Alternar asociaciones</h4>\n  <p>La relación de muchos a muchos también proporciona un <code>toggle</code>método que \"alterna\" el estado de adjunto de los ID dados. Si la identificación proporcionada está actualmente adjunta, se desvinculará. Asimismo, si actualmente se encuentra desvinculado, se adjuntará:</p>\n  <pre><code>$user-&gt;roles()-&gt;toggle([1, 2, 3]);</code></pre>\n  <h4>Guardar datos adicionales en una tabla dinámica</h4>\n  <p>Cuando se trabaja con una relación de muchos a muchos, el <code>save</code>método acepta una matriz de atributos de tabla intermedia adicionales como segundo argumento:</p>\n  <pre><code>App\\Models\\User::find(1)-&gt;roles()-&gt;save($role, ['expires' =&gt; $expires]);</code></pre>\n  <h4>Actualizar un registro en una tabla dinámica</h4>\n  <p>Si necesita actualizar una fila existente en su tabla dinámica, puede usar el <code>updateExistingPivot</code>método. Este método acepta la clave externa del registro dinámico y una matriz de atributos para actualizar:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;roles()-&gt;updateExistingPivot($roleId, $attributes);</code></pre>\n  <p></p>\n  <h2>Tocar las marcas de tiempo de los padres</h2>\n  <p>Cuando un modelo <code>belongsTo</code>u <code>belongsToMany</code>otro modelo, como uno <code>Comment</code>que pertenece a un <code>Post</code>, a veces es útil actualizar la marca de tiempo del padre cuando se actualiza el modelo hijo. Por ejemplo, cuando <code>Comment</code>se actualiza un modelo, es posible que desee \"tocar\" automáticamente la <code>updated_at</code>marca de tiempo del propietario <code>Post</code>. Eloquent te lo pone fácil. Simplemente agregue una <code>touches</code>propiedad que contenga los nombres de las relaciones al modelo secundario:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Comment extends Model\n{\n    /**\n     * All of the relationships to be touched.\n     *\n     * @var array\n     */\n    protected $touches = ['post'];\n\n    /**\n     * Get the post that the comment belongs to.\n     */\n    public function post()\n    {\n        return $this-&gt;belongsTo('App\\Models\\Post');\n    }\n}</code></pre>\n  <p>Ahora, cuando actualice a <code>Comment</code>, la propiedad <code>Post</code>también tendrá su <code>updated_at</code>columna actualizada, lo que hace que sea más conveniente saber cuándo invalidar un caché del <code>Post</code>modelo:</p>\n  <pre><code>$comment = App\\Models\\Comment::find(1);\n\n$comment-&gt;text = 'Edit to this comment!';\n\n$comment-&gt;save();</code></pre>\n</section>"
      },
      {
        "titulo": "8.3 Colecciones",
        "contenido": "<section>\n  <h1>Eloquent: Colecciones</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Métodos disponibles</li>\n    <li>Colecciones personalizadas</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Todos los conjuntos de resultados múltiples devueltos por Eloquent son instancias del objeto, incluidos los resultados recuperados a través del método o accedidos a través de una relación. El objeto de colección Eloquent amplía la colección base de Laravel , por lo que naturalmente hereda docenas de métodos utilizados para trabajar con fluidez con la matriz subyacente de modelos Eloquent.<code>Illuminate\\Database\\Eloquent\\Collection</code><code>get</code></p>\n  <p>Todas las colecciones también sirven como iteradores, lo que le permite recorrerlas como si fueran simples matrices PHP:</p>\n  <pre><code>$users = App\\Models\\User::where('active', 1)-&gt;get();\n\nforeach ($users as $user) {\n    echo $user-&gt;name;\n}</code></pre>\n  <p>Sin embargo, las colecciones son mucho más poderosas que las matrices y exponen una variedad de operaciones de mapa / reducción que se pueden encadenar mediante una interfaz intuitiva. Por ejemplo, eliminemos todos los modelos inactivos y recopilemos el nombre de cada usuario restante:</p>\n  <pre><code>$users = App\\Models\\User::all();\n\n$names = $users-&gt;reject(function ($user) {\n    return $user-&gt;active === false;\n})\n-&gt;map(function ($user) {\n    return $user-&gt;name;\n});</code></pre>\n  <blockquote>\n    <div><div></div><p>Aunque la mayoría de métodos de recolección Elocuentes devuelven una nueva instancia de una colección elocuente, la <code>pluck</code>, <code>keys</code>, <code>zip</code>, <code>collapse</code>, <code>flatten</code>y <code>flip</code>métodos devuelven un colección base instancia. Asimismo, si una <code>map</code>operación devuelve una colección que no contiene ningún modelo Eloquent, se convertirá automáticamente en una colección base.</p></div>\n  </blockquote>\n  <p></p>\n  <h2>Métodos disponibles</h2>\n  <p>Todas las colecciones de Eloquent amplían el objeto de colección base de Laravel ; por lo tanto, heredan todos los métodos poderosos proporcionados por la clase de colección base.</p>\n  <p>Además, la clase proporciona un superconjunto de métodos para ayudar a administrar sus colecciones de modelos. La mayoría de los métodos devuelven instancias; sin embargo, algunos métodos devuelven una instancia base .<code>Illuminate\\Database\\Eloquent\\Collection</code><code>Illuminate\\Database\\Eloquent\\Collection</code><code>Illuminate\\Support\\Collection</code></p>\n  <style>\n    #collection-method-list > p {\n        column-count: 1; -moz-column-count: 1; -webkit-column-count: 1;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    #collection-method-list a {\n        display: block;\n    }\n</style>\n  <div>\n    <p>contiene\n      diff\n      excepto\n      encontrar\n      Fresco\n      intersecarse\n      carga\n      loadMissing\n      modelKeys\n      Hacer visible\n      makeHidden\n      solamente\n      para consultar\n      único</p>\n  </div>\n  <p></p>\n  <h4><code>contains($key, $operator = null, $value = null)</code></h4>\n  <p>El <code>contains</code>método se puede utilizar para determinar si la colección contiene una instancia de modelo determinada. Este método acepta una clave principal o una instancia de modelo:</p>\n  <pre><code>$users-&gt;contains(1);\n\n$users-&gt;contains(User::find(1));</code></pre>\n  <p></p>\n  <h4><code>diff($items)</code></h4>\n  <p>El <code>diff</code>método devuelve todos los modelos que no están presentes en la colección dada:</p>\n  <pre><code>use App\\Models\\User;\n\n$users = $users-&gt;diff(User::whereIn('id', [1, 2, 3])-&gt;get());</code></pre>\n  <p></p>\n  <h4><code>except($keys)</code></h4>\n  <p>El <code>except</code>método devuelve todos los modelos que no tienen las claves primarias dadas:</p>\n  <pre><code>$users = $users-&gt;except([1, 2, 3]);</code></pre>\n  <p></p>\n  <h4><code>find($key)</code></h4>\n  <p>El <code>find</code>método encuentra un modelo que tiene una clave primaria determinada. Si <code>$key</code>es una instancia de modelo, <code>find</code>intentará devolver un modelo que coincida con la clave principal. Si <code>$key</code>es una matriz de claves, <code>find</code>devolverá todos los modelos que coincidan con el <code>$keys</code>uso :<code>whereIn()</code></p>\n  <pre><code>$users = User::all();\n\n$user = $users-&gt;find(1);</code></pre>\n  <p></p>\n  <h4><code>fresh($with = [])</code></h4>\n  <p>El <code>fresh</code>método recupera una instancia nueva de cada modelo de la colección de la base de datos. Además, cualquier relación especificada se cargará con entusiasmo:</p>\n  <pre><code>$users = $users-&gt;fresh();\n\n$users = $users-&gt;fresh('comments');</code></pre>\n  <p></p>\n  <h4><code>intersect($items)</code></h4>\n  <p>El <code>intersect</code>método devuelve todos los modelos que también están presentes en la colección dada:</p>\n  <pre><code>use App\\Models\\User;\n\n$users = $users-&gt;intersect(User::whereIn('id', [1, 2, 3])-&gt;get());</code></pre>\n  <p></p>\n  <h4><code>load($relations)</code></h4>\n  <p>El <code>load</code>método ansioso carga las relaciones dadas para todos los modelos de la colección:</p>\n  <pre><code>$users-&gt;load('comments', 'posts');\n\n$users-&gt;load('comments.author');</code></pre>\n  <p></p>\n  <h4><code>loadMissing($relations)</code></h4>\n  <p>El <code>loadMissing</code>método ansioso carga las relaciones dadas para todos los modelos de la colección si las relaciones aún no están cargadas:</p>\n  <pre><code>$users-&gt;loadMissing('comments', 'posts');\n\n$users-&gt;loadMissing('comments.author');</code></pre>\n  <p></p>\n  <h4><code>modelKeys()</code></h4>\n  <p>El <code>modelKeys</code>método devuelve las claves primarias para todos los modelos de la colección:</p>\n  <pre><code>$users-&gt;modelKeys();\n\n// [1, 2, 3, 4, 5]</code></pre>\n  <p></p>\n  <h4><code>makeVisible($attributes)</code></h4>\n  <p>El <code>makeVisible</code>método hace visibles los atributos que normalmente están \"ocultos\" en cada modelo de la colección:</p>\n  <pre><code>$users = $users-&gt;makeVisible(['address', 'phone_number']);</code></pre>\n  <p></p>\n  <h4><code>makeHidden($attributes)</code></h4>\n  <p>El <code>makeHidden</code>método oculta atributos que normalmente son \"visibles\" en cada modelo de la colección:</p>\n  <pre><code>$users = $users-&gt;makeHidden(['address', 'phone_number']);</code></pre>\n  <p></p>\n  <h4><code>only($keys)</code></h4>\n  <p>El <code>only</code>método devuelve todos los modelos que tienen las claves primarias dadas:</p>\n  <pre><code>$users = $users-&gt;only([1, 2, 3]);</code></pre>\n  <p></p>\n  <h4><code>toQuery()</code></h4>\n  <p>El <code>toQuery</code>método devuelve una instancia del generador de consultas Eloquent que contiene una <code>whereIn</code>restricción en las claves primarias del modelo de colección:</p>\n  <pre><code>$users = App\\Models\\User::where('status', 'VIP')-&gt;get();\n\n$users-&gt;toQuery()-&gt;update([\n    'status' =&gt; 'Administrator',\n]);</code></pre>\n  <p></p>\n  <h4><code>unique($key = null, $strict = false)</code></h4>\n  <p>El <code>unique</code>método devuelve todos los modelos únicos de la colección. Se eliminan todos los modelos del mismo tipo con la misma clave principal que otro modelo de la colección.</p>\n  <pre><code>$users = $users-&gt;unique();</code></pre>\n  <p></p>\n  <h2>Colecciones personalizadas</h2>\n  <p>Si necesita utilizar un <code>Collection</code>objeto personalizado con sus propios métodos de extensión, puede anular el <code>newCollection</code>método en su modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse App\\Support\\CustomCollection;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Create a new Eloquent Collection instance.\n     *\n     * @param  array  $models\n     * @return \\Illuminate\\Database\\Eloquent\\Collection\n     */\n    public function newCollection(array $models = [])\n    {\n        return new CustomCollection($models);\n    }\n}</code></pre>\n  <p>Una vez que haya definido un <code>newCollection</code>método, recibirá una instancia de su colección personalizada cada vez que Eloquent devuelva una <code>Collection</code>instancia de ese modelo. Si desea utilizar una colección personalizada para cada modelo en su aplicación, debe anular el <code>newCollection</code>método en una clase de modelo base que se extiende a todos sus modelos.</p>\n</section>"
      },
      {
        "titulo": "8.4 Mutadores",
        "contenido": "<section>\n  <h1>Eloquent: Mutadores</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Accesores y mutadores\n      <ul>\n        <li>Definición de un accesor</li>\n        <li>Definición de un mutador</li>\n      </ul></li>\n    <li>Mutadores de fecha</li>\n    <li>Casting de atributos\n      <ul>\n        <li>Casts personalizados</li>\n        <li>Casting de matrices y JSON</li>\n        <li>Casting de fecha</li>\n        <li>Conversión de tiempo de consulta</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Los accesores y mutadores le permiten formatear los valores de los atributos de Eloquent cuando los recupera o los configura en instancias de modelo. Por ejemplo, es posible que desee utilizar el cifrador de Laravel para cifrar un valor mientras está almacenado en la base de datos, y luego descifrar automáticamente el atributo cuando accede a él en un modelo Eloquent.</p>\n  <p>Además de los accesores y mutadores personalizados, Eloquent también puede enviar automáticamente campos de fecha a instancias de Carbon o incluso enviar campos de texto a JSON .</p>\n  <p></p>\n  <h2>Accesores y mutadores</h2>\n  <p></p>\n  <h3>Definición de un accesor</h3>\n  <p>Para definir un descriptor de acceso, cree un <code>getFooAttribute</code>método en su modelo donde <code>Foo</code>esté el nombre en mayúsculas y minúsculas de la columna a la que desea acceder. En este ejemplo, definiremos un descriptor de acceso para el <code>first_name</code>atributo. Eloquent llamará automáticamente al descriptor de acceso cuando intente recuperar el valor del <code>first_name</code>atributo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Get the user's first name.\n     *\n     * @param  string  $value\n     * @return string\n     */\n    public function getFirstNameAttribute($value)\n    {\n        return ucfirst($value);\n    }\n}</code></pre>\n  <p>Como puede ver, el valor original de la columna se pasa al descriptor de acceso, lo que le permite manipular y devolver el valor. Para acceder al valor del descriptor de acceso, puede acceder al <code>first_name</code>atributo en una instancia de modelo:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$firstName = $user-&gt;first_name;</code></pre>\n  <p>También puede utilizar descriptores de acceso para devolver nuevos valores calculados a partir de atributos existentes:</p>\n  <pre><code>/**\n * Get the user's full name.\n *\n * @return string\n */\npublic function getFullNameAttribute()\n{\n    return \"{$this-&gt;first_name} {$this-&gt;last_name}\";\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Si desea que estos valores calculados se agreguen a las representaciones de matriz / JSON de su modelo, deberá agregarlos .</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Definición de un mutador</h3>\n  <p>Para definir un mutador, defina un <code>setFooAttribute</code>método en su modelo donde <code>Foo</code>está el nombre en mayúsculas y minúsculas \"studly\" de la columna a la que desea acceder. Entonces, nuevamente, definamos un mutador para el <code>first_name</code>atributo. Este mutador se llamará automáticamente cuando intentemos establecer el valor del <code>first_name</code>atributo en el modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Set the user's first name.\n     *\n     * @param  string  $value\n     * @return void\n     */\n    public function setFirstNameAttribute($value)\n    {\n        $this-&gt;attributes['first_name'] = strtolower($value);\n    }\n}</code></pre>\n  <p>El mutador recibirá el valor que se establece en el atributo, lo que le permitirá manipular el valor y establecer el valor manipulado en la <code>$attributes</code>propiedad interna del modelo Eloquent . Entonces, por ejemplo, si intentamos establecer el <code>first_name</code>atributo en <code>Sally</code>:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;first_name = 'Sally';</code></pre>\n  <p>En este ejemplo, la <code>setFirstNameAttribute</code>función se llamará con el valor <code>Sally</code>. El mutador luego aplicará la <code>strtolower</code>función al nombre y establecerá su valor resultante en la <code>$attributes</code>matriz interna .</p>\n  <p></p>\n  <h2>Mutadores de fecha</h2>\n  <p>De forma predeterminada, Eloquent convertirá las columnas <code>created_at</code>y <code>updated_at</code>en instancias de Carbon , lo que amplía la <code>DateTime</code>clase PHP y proporciona una variedad de métodos útiles. Puede agregar atributos de fecha adicionales configurando la <code>$dates</code>propiedad de su modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The attributes that should be mutated to dates.\n     *\n     * @var array\n     */\n    protected $dates = [\n        'seen_at',\n    ];\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Puede deshabilitar el valor predeterminado <code>created_at</code>y las <code>updated_at</code>marcas de tiempo configurando la <code>$timestamps</code>propiedad pública de su modelo en <code>false</code>.</p></div>\n  </blockquote>\n  <p>Cuando una columna se considera una fecha, puede establecer su valor en una marca de tiempo UNIX, una cadena de fecha ( ), una cadena de fecha y hora o una instancia / . El valor de la fecha se convertirá y almacenará correctamente en su base de datos:<code>Y-m-d</code><code>DateTime</code><code>Carbon</code></p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;deleted_at = now();\n\n$user-&gt;save();</code></pre>\n  <p>Como se señaló anteriormente, al recuperar atributos que se enumeran en su <code>$dates</code>propiedad, se convertirán automáticamente en instancias de Carbon , lo que le permitirá utilizar cualquiera de los métodos de Carbon en sus atributos:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nreturn $user-&gt;deleted_at-&gt;getTimestamp();</code></pre>\n  <h4>Formatos de fecha</h4>\n  <p>De forma predeterminada, las marcas de tiempo tienen el formato <code>'Y-m-d H:i:s'</code>. Si necesita personalizar el formato de la marca de tiempo, establezca la <code>$dateFormat</code>propiedad en su modelo. Esta propiedad determina cómo se almacenan los atributos de fecha en la base de datos:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Flight extends Model\n{\n    /**\n     * The storage format of the model's date columns.\n     *\n     * @var string\n     */\n    protected $dateFormat = 'U';\n}</code></pre>\n  <p></p>\n  <h2>Casting de atributos</h2>\n  <p>La <code>$casts</code>propiedad de su modelo proporciona un método conveniente para convertir atributos en tipos de datos comunes. La <code>$casts</code>propiedad debe ser una matriz donde la clave es el nombre del atributo que se está lanzando y el valor es el tipo al que desea convertir la columna. Los tipos elenco soportados son: <code>integer</code>, <code>real</code>, <code>float</code>, <code>double</code>, , , , , , , , , y . Al enviar a , debe definir el número de dígitos ( ).<code>decimal:&lt;digits&gt;</code><code>string</code><code>boolean</code><code>object</code><code>array</code><code>collection</code><code>date</code><code>datetime</code><code>timestamp</code><code>decimal</code><code>decimal:2</code></p>\n  <p>Para demostrar la conversión de atributos, enviemos el <code>is_admin</code>atributo, que se almacena en nuestra base de datos como un número entero ( <code>0</code>o <code>1</code>) a un valor booleano:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The attributes that should be cast.\n     *\n     * @var array\n     */\n    protected $casts = [\n        'is_admin' =&gt; 'boolean',\n    ];\n}</code></pre>\n  <p>Ahora, el <code>is_admin</code>atributo siempre se convertirá en un booleano cuando acceda a él, incluso si el valor subyacente se almacena en la base de datos como un número entero:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nif ($user-&gt;is_admin) {\n    //\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Los atributos que lo sean <code>null</code>no se emitirán. Además, nunca debes definir un elenco (o un atributo) que tenga el mismo nombre que una relación.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Casts personalizados</h3>\n  <p>Laravel tiene una variedad de tipos de elenco útiles incorporados; sin embargo, es posible que ocasionalmente deba definir sus propios tipos de elenco. Puede lograr esto definiendo una clase que implemente la <code>CastsAttributes</code>interfaz.</p>\n  <p>Las clases que implementan esta interfaz deben definir un método <code>get</code>y <code>set</code>. El <code>get</code>método es responsable de transformar un valor sin procesar de la base de datos en un valor de conversión, mientras que el <code>set</code>método debe transformar un valor de conversión en un valor sin procesar que se pueda almacenar en la base de datos. Como ejemplo, volveremos a implementar el <code>json</code>tipo de conversión integrado como un tipo de conversión personalizado:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Casts;\n\nuse Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\n\nclass Json implements CastsAttributes\n{\n    /**\n     * Cast the given value.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\n     * @param  string  $key\n     * @param  mixed  $value\n     * @param  array  $attributes\n     * @return array\n     */\n    public function get($model, $key, $value, $attributes)\n    {\n        return json_decode($value, true);\n    }\n\n    /**\n     * Prepare the given value for storage.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\n     * @param  string  $key\n     * @param  array  $value\n     * @param  array  $attributes\n     * @return string\n     */\n    public function set($model, $key, $value, $attributes)\n    {\n        return json_encode($value);\n    }\n}</code></pre>\n  <p>Una vez que haya definido un tipo de molde personalizado, puede adjuntarlo a un atributo de modelo usando su nombre de clase:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse App\\Casts\\Json;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The attributes that should be cast.\n     *\n     * @var array\n     */\n    protected $casts = [\n        'options' =&gt; Json::class,\n    ];\n}</code></pre>\n  <h4>Conversión de objetos de valor</h4>\n  <p>No estás limitado a lanzar valores a tipos primitivos. También puede transmitir valores a objetos. Definir conversiones personalizadas que transmiten valores a objetos es muy similar a convertir a tipos primitivos; sin embargo, el <code>set</code>método debe devolver una matriz de pares clave / valor que se utilizará para establecer valores almacenables sin procesar en el modelo.</p>\n  <p>Como ejemplo, definiremos una clase de conversión personalizada que convierte múltiples valores de modelo en un <code>Address</code>objeto de valor único . Asumiremos que el <code>Address</code>valor tiene dos propiedades públicas: <code>lineOne</code>y <code>lineTwo</code>:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Casts;\n\nuse App\\Models\\Address as AddressModel;\nuse Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\nuse InvalidArgumentException;\n\nclass Address implements CastsAttributes\n{\n    /**\n     * Cast the given value.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\n     * @param  string  $key\n     * @param  mixed  $value\n     * @param  array  $attributes\n     * @return \\App\\Models\\Address\n     */\n    public function get($model, $key, $value, $attributes)\n    {\n        return new AddressModel(\n            $attributes['address_line_one'],\n            $attributes['address_line_two']\n        );\n    }\n\n    /**\n     * Prepare the given value for storage.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\n     * @param  string  $key\n     * @param  \\App\\Models\\Address  $value\n     * @param  array  $attributes\n     * @return array\n     */\n    public function set($model, $key, $value, $attributes)\n    {\n        if (! $value instanceof AddressModel) {\n            throw new InvalidArgumentException('The given value is not an Address instance.');\n        }\n\n        return [\n            'address_line_one' =&gt; $value-&gt;lineOne,\n            'address_line_two' =&gt; $value-&gt;lineTwo,\n        ];\n    }\n}</code></pre>\n  <p>Al convertir a objetos de valor, cualquier cambio realizado en el objeto de valor se sincronizará automáticamente con el modelo antes de que se guarde el modelo:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;address-&gt;lineOne = 'Updated Address Value';\n\n$user-&gt;save();</code></pre>\n  <blockquote>\n    <div><div></div><p>Si planea serializar sus modelos Eloquent que contienen objetos de valor en JSON o matrices, debe implementar las interfaces y en el objeto de valor.<code>Illuminate\\Contracts\\Support\\Arrayable</code><code>JsonSerializable</code></p></div>\n  </blockquote>\n  <h4>Casting entrante</h4>\n  <p>De vez en cuando, es posible que deba escribir una conversión personalizada que solo transforme los valores que se establecen en el modelo y no realiza ninguna operación cuando se recuperan atributos del modelo. Un ejemplo clásico de un elenco solo entrante es un elenco \"hash\". Las conversiones personalizadas solo entrantes deben implementar la <code>CastsInboundAttributes</code>interfaz, que solo requiere <code>set</code>que se defina un método.</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Casts;\n\nuse Illuminate\\Contracts\\Database\\Eloquent\\CastsInboundAttributes;\n\nclass Hash implements CastsInboundAttributes\n{\n    /**\n     * The hashing algorithm.\n     *\n     * @var string\n     */\n    protected $algorithm;\n\n    /**\n     * Create a new cast class instance.\n     *\n     * @param  string|null  $algorithm\n     * @return void\n     */\n    public function __construct($algorithm = null)\n    {\n        $this-&gt;algorithm = $algorithm;\n    }\n\n    /**\n     * Prepare the given value for storage.\n     *\n     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\n     * @param  string  $key\n     * @param  array  $value\n     * @param  array  $attributes\n     * @return string\n     */\n    public function set($model, $key, $value, $attributes)\n    {\n        return is_null($this-&gt;algorithm)\n                    ? bcrypt($value)\n                    : hash($this-&gt;algorithm, $value);\n    }\n}</code></pre>\n  <h4>Parámetros de fundición</h4>\n  <p>Cuando se adjunta una conversión personalizada a un modelo, los parámetros de conversión se pueden especificar separándolos del nombre de la clase mediante un <code>:</code>carácter y delimitando varios parámetros por comas. Los parámetros se pasarán al constructor de la clase de conversión:</p>\n  <pre><code>/**\n * The attributes that should be cast.\n *\n * @var array\n */\nprotected $casts = [\n    'secret' =&gt; Hash::class.':sha256',\n];</code></pre>\n  <h4>Castables</h4>\n  <p>En lugar de adjuntar la conversión personalizada a su modelo, alternativamente puede adjuntar una clase que implemente la interfaz:<code>Illuminate\\Contracts\\Database\\Eloquent\\Castable</code></p>\n  <pre><code>protected $casts = [\n    'address' =&gt; \\App\\Models\\Address::class,\n];</code></pre>\n  <p>Los objetos que implementan la <code>Castable</code>interfaz deben definir un <code>castUsing</code>método que devuelva el nombre de clase de la clase de lanzador personalizado que es responsable de la transmisión hacia y desde la <code>Castable</code>clase:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Contracts\\Database\\Eloquent\\Castable;\nuse App\\Casts\\Address as AddressCast;\n\nclass Address implements Castable\n{\n    /**\n     * Get the name of the caster class to use when casting from / to this cast target.\n     *\n     * @return string\n     */\n    public static function castUsing()\n    {\n        return AddressCast::class;\n    }\n}</code></pre>\n  <p>Al usar <code>Castable</code>clases, aún puede proporcionar argumentos en la <code>$casts</code>definición. Los argumentos se pasarán directamente a la clase caster:</p>\n  <pre><code>protected $casts = [\n    'address' =&gt; \\App\\Models\\Address::class.':argument',\n];</code></pre>\n  <p></p>\n  <h3>Casting de matrices y JSON</h3>\n  <p>El <code>array</code>tipo de conversión es particularmente útil cuando se trabaja con columnas que se almacenan como JSON serializado. Por ejemplo, si su base de datos tiene un tipo de campo <code>JSON</code>o <code>TEXT</code>que contiene JSON serializado, agregar la <code>array</code>conversión a ese atributo deserializará automáticamente el atributo a una matriz PHP cuando acceda a él en su modelo Eloquent:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The attributes that should be cast.\n     *\n     * @var array\n     */\n    protected $casts = [\n        'options' =&gt; 'array',\n    ];\n}</code></pre>\n  <p>Una vez que se define el reparto, puede acceder al <code>options</code>atributo y se deserializará automáticamente desde JSON en una matriz PHP. Cuando establece el valor del <code>options</code>atributo, la matriz dada se serializará automáticamente nuevamente en JSON para su almacenamiento:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$options = $user-&gt;options;\n\n$options['key'] = 'value';\n\n$user-&gt;options = $options;\n\n$user-&gt;save();</code></pre>\n  <p>Para actualizar un solo campo de un atributo JSON con una sintaxis más concisa, puede usar el operador:<code>-&gt;</code></p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\n$user-&gt;update(['options-&gt;key' =&gt; 'value']);</code></pre>\n  <p></p>\n  <h3>Casting de fecha</h3>\n  <p>Al usar el tipo de conversión <code>date</code>o <code>datetime</code>, puede especificar el formato de la fecha. Este formato se utilizará cuando el modelo se serialice en una matriz o JSON :</p>\n  <pre><code>/**\n * The attributes that should be cast.\n *\n * @var array\n */\nprotected $casts = [\n    'created_at' =&gt; 'datetime:Y-m-d',\n];</code></pre>\n  <p></p>\n  <h3>Conversión de tiempo de consulta</h3>\n  <p>A veces, es posible que deba aplicar conversiones mientras ejecuta una consulta, como cuando selecciona un valor sin procesar de una tabla. Por ejemplo, considere la siguiente consulta:</p>\n  <pre><code>use App\\Models\\Post;\nuse App\\Models\\User;\n\n$users = User::select([\n    'users.*',\n    'last_posted_at' =&gt; Post::selectRaw('MAX(created_at)')\n            -&gt;whereColumn('user_id', 'users.id')\n])-&gt;get();</code></pre>\n  <p>El <code>last_posted_at</code>atributo de los resultados de esta consulta será una cadena sin formato. Sería conveniente si pudiéramos aplicar una <code>date</code>conversión a este atributo al ejecutar la consulta. Para lograr esto, podemos usar el <code>withCasts</code>método:</p>\n  <pre><code>$users = User::select([\n    'users.*',\n    'last_posted_at' =&gt; Post::selectRaw('MAX(created_at)')\n            -&gt;whereColumn('user_id', 'users.id')\n])-&gt;withCasts([\n    'last_posted_at' =&gt; 'datetime'\n])-&gt;get();</code></pre>\n</section>"
      },
      {
        "titulo": "8.5 Recursos de API",
        "contenido": "<section>\n  <h1>Eloquent: Recursos de API</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Generando recursos</li>\n    <li>Resumen del concepto\n      <ul>\n        <li>Colecciones de recursos</li>\n      </ul></li>\n    <li>Recursos de escritura\n      <ul>\n        <li>Envoltura de datos</li>\n        <li>Paginación</li>\n        <li>Atributos condicionales</li>\n        <li>Relaciones condicionales</li>\n        <li>Agregar metadatos</li>\n      </ul></li>\n    <li>Respuestas de recursos</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Al crear una API, es posible que necesite una capa de transformación que se encuentre entre sus modelos Eloquent y las respuestas JSON que realmente se devuelven a los usuarios de su aplicación. Las clases de recursos de Laravel le permiten transformar de manera expresiva y sencilla sus modelos y colecciones de modelos en JSON.</p>\n  <p></p>\n  <h2>Generando recursos</h2>\n  <p>Para generar una clase de recurso, puede usar el comando Artisan. De forma predeterminada, los recursos se colocarán en el directorio de su aplicación. Los recursos amplían la clase:<code>make:resource</code><code>app/Http/Resources</code><code>Illuminate\\Http\\Resources\\Json\\JsonResource</code></p>\n  <pre><code>php artisan make:resource User</code></pre>\n  <h4>Colecciones de recursos</h4>\n  <p>Además de generar recursos que transforman modelos individuales, puede generar recursos que son responsables de transformar colecciones de modelos. Esto permite que su respuesta incluya enlaces y otra metainformación que sea relevante para una colección completa de un recurso determinado.</p>\n  <p>Para crear una colección de recursos, debe usar la <code>--collection</code>marca al crear el recurso. O, incluir la palabra <code>Collection</code>en el nombre del recurso le indicará a Laravel que debe crear un recurso de colección. Los recursos de la colección amplían la clase:<code>Illuminate\\Http\\Resources\\Json\\ResourceCollection</code></p>\n  <pre><code>php artisan make:resource Users --collection\n\nphp artisan make:resource UserCollection</code></pre>\n  <p></p>\n  <h2>Resumen del concepto</h2>\n  <blockquote>\n    <div><div></div><p>Esta es una descripción general de alto nivel de recursos y colecciones de recursos. Le recomendamos que lea las otras secciones de esta documentación para obtener una comprensión más profunda de la personalización y el poder que le ofrecen los recursos.</p></div>\n  </blockquote>\n  <p>Antes de sumergirnos en todas las opciones disponibles para usted al escribir recursos, primero echemos un vistazo de alto nivel a cómo se usan los recursos dentro de Laravel. Una clase de recurso representa un modelo único que debe transformarse en una estructura JSON. Por ejemplo, aquí hay una <code>User</code>clase de recurso simple :</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\n\nclass User extends JsonResource\n{\n    /**\n     * Transform the resource into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return [\n            'id' =&gt; $this-&gt;id,\n            'name' =&gt; $this-&gt;name,\n            'email' =&gt; $this-&gt;email,\n            'created_at' =&gt; $this-&gt;created_at,\n            'updated_at' =&gt; $this-&gt;updated_at,\n        ];\n    }\n}</code></pre>\n  <p>Cada clase de recurso define un <code>toArray</code>método que devuelve la matriz de atributos que deben convertirse a JSON al enviar la respuesta. Observe que podemos acceder a las propiedades del modelo directamente desde la <code>$this</code>variable. Esto se debe a que una clase de recurso transferirá automáticamente el acceso a las propiedades y métodos al modelo subyacente para un acceso conveniente. Una vez que se define el recurso, se puede devolver desde una ruta o controlador:</p>\n  <pre><code>use App\\Http\\Resources\\User as UserResource;\nuse App\\Models\\User;\n\nRoute::get('/user', function () {\n    return new UserResource(User::find(1));\n});</code></pre>\n  <p></p>\n  <h3>Colecciones de recursos</h3>\n  <p>Si devuelve una colección de recursos o una respuesta paginada, puede usar el <code>collection</code>método al crear la instancia de recurso en su ruta o controlador:</p>\n  <pre><code>use App\\Http\\Resources\\User as UserResource;\nuse App\\Models\\User;\n\nRoute::get('/user', function () {\n    return UserResource::collection(User::all());\n});</code></pre>\n  <p>Tenga en cuenta que esto no permite ninguna adición de metadatos que puedan necesitar ser devueltos con la colección. Si desea personalizar la respuesta de la colección de recursos, puede crear un recurso dedicado para representar la colección:</p>\n  <pre><code>php artisan make:resource UserCollection</code></pre>\n  <p>Una vez que se haya generado la clase de colección de recursos, puede definir fácilmente cualquier metadato que deba incluirse con la respuesta:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\ResourceCollection;\n\nclass UserCollection extends ResourceCollection\n{\n    /**\n     * Transform the resource collection into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return [\n            'data' =&gt; $this-&gt;collection,\n            'links' =&gt; [\n                'self' =&gt; 'link-value',\n            ],\n        ];\n    }\n}</code></pre>\n  <p>Después de definir su colección de recursos, se puede devolver desde una ruta o controlador:</p>\n  <pre><code>use App\\Http\\Resources\\UserCollection;\nuse App\\Models\\User;\n\nRoute::get('/users', function () {\n    return new UserCollection(User::all());\n});</code></pre>\n  <h4>Conservación de claves de colección</h4>\n  <p>Al devolver una colección de recursos de una ruta, Laravel restablece las claves de la colección para que estén en orden numérico simple. Sin embargo, puede agregar una <code>preserveKeys</code>propiedad a su clase de recurso que indique si las claves de colección deben conservarse:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\n\nclass User extends JsonResource\n{\n    /**\n     * Indicates if the resource's collection keys should be preserved.\n     *\n     * @var bool\n     */\n    public $preserveKeys = true;\n}</code></pre>\n  <p>Cuando la <code>preserveKeys</code>propiedad se establece en <code>true</code>, las claves de colección se conservarán:</p>\n  <pre><code>use App\\Http\\Resources\\User as UserResource;\nuse App\\Models\\User;\n\nRoute::get('/user', function () {\n    return UserResource::collection(User::all()-&gt;keyBy-&gt;id);\n});</code></pre>\n  <h4>Personalización de la clase de recurso subyacente</h4>\n  <p>Por lo general, la propiedad de una colección de recursos se completa automáticamente con el resultado de asignar cada elemento de la colección a su clase de recurso singular. Se supone que la clase de recurso singular es el nombre de clase de la colección sin la cadena final .<code>$this-&gt;collection</code><code>Collection</code></p>\n  <p>Por ejemplo, <code>UserCollection</code>intentará mapear las instancias de usuario dadas en el <code>User</code>recurso. Para personalizar este comportamiento, puede anular la <code>$collects</code>propiedad de su colección de recursos:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\ResourceCollection;\n\nclass UserCollection extends ResourceCollection\n{\n    /**\n     * The resource that this resource collects.\n     *\n     * @var string\n     */\n    public $collects = 'App\\Http\\Resources\\Member';\n}</code></pre>\n  <p></p>\n  <h2>Recursos de escritura</h2>\n  <blockquote>\n    <div><div></div><p>Si no ha leído la descripción general del concepto , le recomendamos que lo haga antes de continuar con esta documentación.</p></div>\n  </blockquote>\n  <p>En esencia, los recursos son simples. Solo necesitan transformar un modelo dado en una matriz. Por lo tanto, cada recurso contiene un <code>toArray</code>método que traduce los atributos de su modelo en una matriz compatible con API que se puede devolver a sus usuarios:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\n\nclass User extends JsonResource\n{\n    /**\n     * Transform the resource into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return [\n            'id' =&gt; $this-&gt;id,\n            'name' =&gt; $this-&gt;name,\n            'email' =&gt; $this-&gt;email,\n            'created_at' =&gt; $this-&gt;created_at,\n            'updated_at' =&gt; $this-&gt;updated_at,\n        ];\n    }\n}</code></pre>\n  <p>Una vez que se ha definido un recurso, se puede devolver directamente desde una ruta o controlador:</p>\n  <pre><code>use App\\Http\\Resources\\User as UserResource;\nuse App\\Models\\User;\n\nRoute::get('/user', function () {\n    return new UserResource(User::find(1));\n});</code></pre>\n  <h4>Relaciones</h4>\n  <p>Si desea incluir recursos relacionados en su respuesta, puede agregarlos a la matriz devuelta por su <code>toArray</code>método. En este ejemplo, usaremos el método <code>Post</code>del recurso <code>collection</code>para agregar las publicaciones del blog del usuario a la respuesta del recurso:</p>\n  <pre><code>/**\n * Transform the resource into an array.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @return array\n */\npublic function toArray($request)\n{\n    return [\n        'id' =&gt; $this-&gt;id,\n        'name' =&gt; $this-&gt;name,\n        'email' =&gt; $this-&gt;email,\n        'posts' =&gt; PostResource::collection($this-&gt;posts),\n        'created_at' =&gt; $this-&gt;created_at,\n        'updated_at' =&gt; $this-&gt;updated_at,\n    ];\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Si desea incluir relaciones solo cuando ya se hayan cargado, consulte la documentación sobre relaciones condicionales .</p></div>\n  </blockquote>\n  <h4>Colecciones de recursos</h4>\n  <p>Mientras que los recursos traducen un solo modelo en una matriz, las colecciones de recursos traducen una colección de modelos en una matriz. No es absolutamente necesario definir una clase de colección de recursos para cada uno de sus tipos de modelo, ya que todos los recursos proporcionan un <code>collection</code>método para generar una colección de recursos \"ad-hoc\" sobre la marcha:</p>\n  <pre><code>use App\\Http\\Resources\\User as UserResource;\nuse App\\Models\\User;\n\nRoute::get('/user', function () {\n    return UserResource::collection(User::all());\n});</code></pre>\n  <p>Sin embargo, si necesita personalizar los metadatos devueltos con la colección, será necesario definir una colección de recursos:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\ResourceCollection;\n\nclass UserCollection extends ResourceCollection\n{\n    /**\n     * Transform the resource collection into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return [\n            'data' =&gt; $this-&gt;collection,\n            'links' =&gt; [\n                'self' =&gt; 'link-value',\n            ],\n        ];\n    }\n}</code></pre>\n  <p>Al igual que los recursos singulares, las colecciones de recursos pueden devolverse directamente desde rutas o controladores:</p>\n  <pre><code>use App\\Http\\Resources\\UserCollection;\nuse App\\Models\\User;\n\nRoute::get('/users', function () {\n    return new UserCollection(User::all());\n});</code></pre>\n  <p></p>\n  <h3>Envoltura de datos</h3>\n  <p>De forma predeterminada, su recurso más externo está envuelto en una <code>data</code>clave cuando la respuesta del recurso se convierte a JSON. Entonces, por ejemplo, una respuesta típica de recopilación de recursos se ve así:</p>\n  <pre><code>{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"Eladio Schroeder Sr.\",\n            \"email\": \"therese28@example.com\",\n        },\n        {\n            \"id\": 2,\n            \"name\": \"Liliana Mayert\",\n            \"email\": \"evandervort@example.com\",\n        }\n    ]\n}</code></pre>\n  <p>Si desea utilizar una clave personalizada en lugar de <code>data</code>, puede definir un <code>$wrap</code>atributo en la clase de recurso:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\n\nclass User extends JsonResource\n{\n    /**\n     * The \"data\" wrapper that should be applied.\n     *\n     * @var string\n     */\n    public static $wrap = 'user';\n}</code></pre>\n  <p>Si desea deshabilitar la envoltura del recurso más externo, puede usar el <code>withoutWrapping</code>método en la clase de recurso base. Por lo general, debe llamar a este método desde su <code>AppServiceProvider</code>u otro proveedor de servicios que se carga en cada solicitud a su aplicación:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        JsonResource::withoutWrapping();\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>El <code>withoutWrapping</code>método solo afecta la respuesta más externa y no eliminará las <code>data</code>claves que agregue manualmente a sus propias colecciones de recursos.</p></div>\n  </blockquote>\n  <h3>Envolviendo recursos anidados</h3>\n  <p>Tiene total libertad para determinar cómo se envuelven las relaciones de sus recursos. Si desea que todas las colecciones de recursos estén envueltas en una <code>data</code>clave, independientemente de su anidación, debe definir una clase de colección de recursos para cada recurso y devolver la colección dentro de una <code>data</code>clave.</p>\n  <p>Quizás se esté preguntando si esto hará que su recurso más externo esté envuelto en dos <code>data</code>claves. No se preocupe, Laravel nunca permitirá que sus recursos se doblen accidentalmente, por lo que no tiene que preocuparse por el nivel de anidamiento de la colección de recursos que está transformando:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\ResourceCollection;\n\nclass CommentsCollection extends ResourceCollection\n{\n    /**\n     * Transform the resource collection into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return ['data' =&gt; $this-&gt;collection];\n    }\n}</code></pre>\n  <h3>Envoltura de datos y paginación</h3>\n  <p>Al devolver colecciones paginadas en una respuesta de recurso, Laravel envolverá los datos de su recurso en una <code>data</code>clave incluso si <code>withoutWrapping</code>se ha llamado al método. Esto se debe a que las respuestas paginadas siempre contienen <code>meta</code>y <code>links</code>claves con información sobre el estado del paginador:</p>\n  <pre><code>{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"Eladio Schroeder Sr.\",\n            \"email\": \"therese28@example.com\",\n        },\n        {\n            \"id\": 2,\n            \"name\": \"Liliana Mayert\",\n            \"email\": \"evandervort@example.com\",\n        }\n    ],\n    \"links\":{\n        \"first\": \"http://example.com/pagination?page=1\",\n        \"last\": \"http://example.com/pagination?page=1\",\n        \"prev\": null,\n        \"next\": null\n    },\n    \"meta\":{\n        \"current_page\": 1,\n        \"from\": 1,\n        \"last_page\": 1,\n        \"path\": \"http://example.com/pagination\",\n        \"per_page\": 15,\n        \"to\": 10,\n        \"total\": 10\n    }\n}</code></pre>\n  <p></p>\n  <h3>Paginación</h3>\n  <p>Siempre puede pasar una instancia de paginador al <code>collection</code>método de un recurso o a una colección de recursos personalizada:</p>\n  <pre><code>use App\\Http\\Resources\\UserCollection;\nuse App\\Models\\User;\n\nRoute::get('/users', function () {\n    return new UserCollection(User::paginate());\n});</code></pre>\n  <p>Las respuestas paginadas siempre contienen <code>meta</code>y <code>links</code>claves con información sobre el estado del paginador:</p>\n  <pre><code>{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"Eladio Schroeder Sr.\",\n            \"email\": \"therese28@example.com\",\n        },\n        {\n            \"id\": 2,\n            \"name\": \"Liliana Mayert\",\n            \"email\": \"evandervort@example.com\",\n        }\n    ],\n    \"links\":{\n        \"first\": \"http://example.com/pagination?page=1\",\n        \"last\": \"http://example.com/pagination?page=1\",\n        \"prev\": null,\n        \"next\": null\n    },\n    \"meta\":{\n        \"current_page\": 1,\n        \"from\": 1,\n        \"last_page\": 1,\n        \"path\": \"http://example.com/pagination\",\n        \"per_page\": 15,\n        \"to\": 10,\n        \"total\": 10\n    }\n}</code></pre>\n  <p></p>\n  <h3>Atributos condicionales</h3>\n  <p>A veces, es posible que desee incluir solo un atributo en una respuesta de recurso si se cumple una condición determinada. Por ejemplo, es posible que desee incluir solo un valor si el usuario actual es un \"administrador\". Laravel proporciona una variedad de métodos de ayuda para ayudarlo en esta situación. El <code>when</code>método puede usarse para agregar condicionalmente un atributo a una respuesta de recurso:</p>\n  <pre><code>/**\n * Transform the resource into an array.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @return array\n */\npublic function toArray($request)\n{\n    return [\n        'id' =&gt; $this-&gt;id,\n        'name' =&gt; $this-&gt;name,\n        'email' =&gt; $this-&gt;email,\n        'secret' =&gt; $this-&gt;when(Auth::user()-&gt;isAdmin(), 'secret-value'),\n        'created_at' =&gt; $this-&gt;created_at,\n        'updated_at' =&gt; $this-&gt;updated_at,\n    ];\n}</code></pre>\n  <p>En este ejemplo, la <code>secret</code>clave solo se devolverá en la respuesta de recurso final si el <code>isAdmin</code>método del usuario autenticado regresa <code>true</code>. Si el método regresa <code>false</code>, la <code>secret</code>clave se eliminará de la respuesta del recurso por completo antes de que se envíe de vuelta al cliente. El <code>when</code>método le permite definir expresivamente sus recursos sin recurrir a declaraciones condicionales al construir la matriz.</p>\n  <p>El <code>when</code>método también acepta un cierre como segundo argumento, lo que le permite calcular el valor resultante solo si la condición dada es <code>true</code>:</p>\n  <pre><code>'secret' =&gt; $this-&gt;when(Auth::user()-&gt;isAdmin(), function () {\n    return 'secret-value';\n}),</code></pre>\n  <h4>Fusionar atributos condicionales</h4>\n  <p>A veces, puede tener varios atributos que solo deberían incluirse en la respuesta del recurso según la misma condición. En este caso, puede usar el <code>mergeWhen</code>método para incluir los atributos en la respuesta solo cuando la condición dada es <code>true</code>:</p>\n  <pre><code>/**\n * Transform the resource into an array.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @return array\n */\npublic function toArray($request)\n{\n    return [\n        'id' =&gt; $this-&gt;id,\n        'name' =&gt; $this-&gt;name,\n        'email' =&gt; $this-&gt;email,\n        $this-&gt;mergeWhen(Auth::user()-&gt;isAdmin(), [\n            'first-secret' =&gt; 'value',\n            'second-secret' =&gt; 'value',\n        ]),\n        'created_at' =&gt; $this-&gt;created_at,\n        'updated_at' =&gt; $this-&gt;updated_at,\n    ];\n}</code></pre>\n  <p>Nuevamente, si la condición dada es <code>false</code>, estos atributos se eliminarán de la respuesta del recurso por completo antes de que se envíe al cliente.</p>\n  <blockquote>\n    <div><div></div><p>El <code>mergeWhen</code>método no debe usarse dentro de matrices que mezclan cadenas y teclas numéricas. Además, no debe usarse dentro de arreglos con teclas numéricas que no estén ordenadas secuencialmente.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Relaciones condicionales</h3>\n  <p>Además de cargar atributos de forma condicional, puede incluir relaciones de forma condicional en sus respuestas de recursos en función de si la relación ya se ha cargado en el modelo. Esto permite que su controlador decida qué relaciones deben cargarse en el modelo y su recurso puede incluirlas fácilmente solo cuando realmente se hayan cargado.</p>\n  <p>En última instancia, esto hace que sea más fácil evitar problemas de consultas \"N + 1\" dentro de sus recursos. El <code>whenLoaded</code>método se puede utilizar para cargar condicionalmente una relación. Para evitar la carga innecesaria de relaciones, este método acepta el nombre de la relación en lugar de la relación en sí:</p>\n  <pre><code>/**\n * Transform the resource into an array.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @return array\n */\npublic function toArray($request)\n{\n    return [\n        'id' =&gt; $this-&gt;id,\n        'name' =&gt; $this-&gt;name,\n        'email' =&gt; $this-&gt;email,\n        'posts' =&gt; PostResource::collection($this-&gt;whenLoaded('posts')),\n        'created_at' =&gt; $this-&gt;created_at,\n        'updated_at' =&gt; $this-&gt;updated_at,\n    ];\n}</code></pre>\n  <p>En este ejemplo, si la relación no se ha cargado, la <code>posts</code>clave se eliminará de la respuesta del recurso por completo antes de enviarse al cliente.</p>\n  <h4>Información de pivote condicional</h4>\n  <p>Además de incluir condicionalmente información de relación en sus respuestas de recursos, puede incluir condicionalmente datos de las tablas intermedias de relaciones de muchos a muchos utilizando el <code>whenPivotLoaded</code>método. El <code>whenPivotLoaded</code>método acepta el nombre de la tabla dinámica como primer argumento. El segundo argumento debe ser un cierre que defina el valor que se devolverá si la información dinámica está disponible en el modelo:</p>\n  <pre><code>/**\n * Transform the resource into an array.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @return array\n */\npublic function toArray($request)\n{\n    return [\n        'id' =&gt; $this-&gt;id,\n        'name' =&gt; $this-&gt;name,\n        'expires_at' =&gt; $this-&gt;whenPivotLoaded('role_user', function () {\n            return $this-&gt;pivot-&gt;expires_at;\n        }),\n    ];\n}</code></pre>\n  <p>Si su tabla intermedia usa un descriptor de acceso diferente a <code>pivot</code>, puede usar el <code>whenPivotLoadedAs</code>método:</p>\n  <pre><code>/**\n * Transform the resource into an array.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @return array\n */\npublic function toArray($request)\n{\n    return [\n        'id' =&gt; $this-&gt;id,\n        'name' =&gt; $this-&gt;name,\n        'expires_at' =&gt; $this-&gt;whenPivotLoadedAs('subscription', 'role_user', function () {\n            return $this-&gt;subscription-&gt;expires_at;\n        }),\n    ];\n}</code></pre>\n  <p></p>\n  <h3>Agregar metadatos</h3>\n  <p>Algunos estándares de la API JSON requieren la adición de metadatos a sus respuestas de recursos y colecciones de recursos. Esto a menudo incluye cosas como <code>links</code>el recurso o recursos relacionados, o metadatos sobre el recurso en sí. Si necesita devolver metadatos adicionales sobre un recurso, inclúyalos en su <code>toArray</code>método. Por ejemplo, puede incluir <code>link</code>información al transformar una colección de recursos:</p>\n  <pre><code>/**\n * Transform the resource into an array.\n *\n * @param  \\Illuminate\\Http\\Request  $request\n * @return array\n */\npublic function toArray($request)\n{\n    return [\n        'data' =&gt; $this-&gt;collection,\n        'links' =&gt; [\n            'self' =&gt; 'link-value',\n        ],\n    ];\n}</code></pre>\n  <p>Al devolver metadatos adicionales de sus recursos, nunca tendrá que preocuparse por anular accidentalmente las claves <code>links</code>o <code>meta</code>que Laravel agrega automáticamente al devolver respuestas paginadas. Cualquier adicional <code>links</code>que defina se fusionará con los enlaces proporcionados por el paginador.</p>\n  <h4>Metadatos de nivel superior</h4>\n  <p>A veces, es posible que desee incluir solo ciertos metadatos con una respuesta de recurso si el recurso es el recurso más externo que se devuelve. Normalmente, esto incluye metainformación sobre la respuesta en su conjunto. Para definir estos metadatos, agregue un <code>with</code>método a su clase de recursos. Este método debe devolver una matriz de metadatos que se incluirán con la respuesta del recurso solo cuando el recurso es el recurso más externo que se representa:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\ResourceCollection;\n\nclass UserCollection extends ResourceCollection\n{\n    /**\n     * Transform the resource collection into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return parent::toArray($request);\n    }\n\n    /**\n     * Get additional data that should be returned with the resource array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function with($request)\n    {\n        return [\n            'meta' =&gt; [\n                'key' =&gt; 'value',\n            ],\n        ];\n    }\n}</code></pre>\n  <h4>Agregar metadatos al construir recursos</h4>\n  <p>También puede agregar datos de nivel superior al construir instancias de recursos en su ruta o controlador. El <code>additional</code>método, que está disponible en todos los recursos, acepta una matriz de datos que se deben agregar a la respuesta del recurso:</p>\n  <pre><code>return (new UserCollection(User::all()-&gt;load('roles')))\n                -&gt;additional(['meta' =&gt; [\n                    'key' =&gt; 'value',\n                ]]);</code></pre>\n  <p></p>\n  <h2>Respuestas de recursos</h2>\n  <p>Como ya ha leído, los recursos pueden devolverse directamente desde rutas y controladores:</p>\n  <pre><code>use App\\Http\\Resources\\User as UserResource;\nuse App\\Models\\User;\n\nRoute::get('/user', function () {\n    return new UserResource(User::find(1));\n});</code></pre>\n  <p>Sin embargo, a veces es posible que deba personalizar la respuesta HTTP saliente antes de enviarla al cliente. Hay dos maneras de lograr esto. Primero, puede encadenar el <code>response</code>método al recurso. Este método devolverá una instancia, lo que le permitirá un control total de los encabezados de la respuesta:<code>Illuminate\\Http\\JsonResponse</code></p>\n  <pre><code>use App\\Http\\Resources\\User as UserResource;\nuse App\\Models\\User;\n\nRoute::get('/user', function () {\n    return (new UserResource(User::find(1)))\n                -&gt;response()\n                -&gt;header('X-Value', 'True');\n});</code></pre>\n  <p>Alternativamente, puede definir un <code>withResponse</code>método dentro del propio recurso. Este método se llamará cuando el recurso se devuelva como el recurso más externo en una respuesta:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\n\nclass User extends JsonResource\n{\n    /**\n     * Transform the resource into an array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return [\n            'id' =&gt; $this-&gt;id,\n        ];\n    }\n\n    /**\n     * Customize the outgoing response for the resource.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Illuminate\\Http\\Response  $response\n     * @return void\n     */\n    public function withResponse($request, $response)\n    {\n        $response-&gt;header('X-Value', 'True');\n    }\n}</code></pre>\n</section>"
      },
      {
        "titulo": "8.6 Publicación por entregas",
        "contenido": "<section>\n  <h1>Eloquent: serialización</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Serializar modelos y colecciones\n      <ul>\n        <li>Serializar en matrices</li>\n        <li>Serializando a JSON</li>\n      </ul></li>\n    <li>Ocultar atributos de JSON</li>\n    <li>Agregar valores a JSON</li>\n    <li>Serialización de fecha</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Al crear API JSON, a menudo necesitará convertir sus modelos y relaciones en matrices o JSON. Eloquent incluye métodos convenientes para realizar estas conversiones, así como para controlar qué atributos se incluyen en sus serializaciones.</p>\n  <p></p>\n  <h2>Serializar modelos y colecciones</h2>\n  <p></p>\n  <h3>Serializar en matrices</h3>\n  <p>Para convertir un modelo y sus relaciones cargadas en una matriz, debe usar el <code>toArray</code>método. Este método es recursivo, por lo que todos los atributos y todas las relaciones (incluidas las relaciones de relaciones) se convertirán en matrices:</p>\n  <pre><code>$user = App\\Models\\User::with('roles')-&gt;first();\n\nreturn $user-&gt;toArray();</code></pre>\n  <p>Para convertir solo los atributos de un modelo en una matriz, use el <code>attributesToArray</code>método:</p>\n  <pre><code>$user = App\\Models\\User::first();\n\nreturn $user-&gt;attributesToArray();</code></pre>\n  <p>También puede convertir colecciones completas de modelos en matrices:</p>\n  <pre><code>$users = App\\Models\\User::all();\n\nreturn $users-&gt;toArray();</code></pre>\n  <p></p>\n  <h3>Serializando a JSON</h3>\n  <p>Para convertir un modelo a JSON, debe usar el <code>toJson</code>método. Por ejemplo <code>toArray</code>, el <code>toJson</code>método es recursivo, por lo que todos los atributos y relaciones se convertirán a JSON. También puede especificar opciones de codificación JSON compatibles con PHP :</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nreturn $user-&gt;toJson();\n\nreturn $user-&gt;toJson(JSON_PRETTY_PRINT);</code></pre>\n  <p>Alternativamente, puede convertir un modelo o colección a una cadena, que llamará automáticamente al <code>toJson</code>método en el modelo o colección:</p>\n  <pre><code>$user = App\\Models\\User::find(1);\n\nreturn (string) $user;</code></pre>\n  <p>Dado que los modelos y las colecciones se convierten a JSON cuando se convierten en una cadena, puede devolver objetos Eloquent directamente desde las rutas o controladores de su aplicación:</p>\n  <pre><code>Route::get('users', function () {\n    return App\\Models\\User::all();\n});</code></pre>\n  <h4>Relaciones</h4>\n  <p>Cuando un modelo Eloquent se convierte a JSON, sus relaciones cargadas se incluirán automáticamente como atributos en el objeto JSON. Además, aunque los métodos de relación de Eloquent se definen utilizando \"caso de camello\", el atributo JSON de una relación será \"caso de serpiente\".</p>\n  <p></p>\n  <h2>Ocultar atributos de JSON</h2>\n  <p>A veces, es posible que desee limitar los atributos, como las contraseñas, que se incluyen en la matriz de su modelo o la representación JSON. Para hacerlo, agregue una <code>$hidden</code>propiedad a su modelo:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The attributes that should be hidden for arrays.\n     *\n     * @var array\n     */\n    protected $hidden = ['password'];\n}</code></pre>\n  <blockquote>\n    <div><div></div><p> Cuando oculte relaciones, use el nombre del método de la relación.</p></div>\n  </blockquote>\n  <p>Alternativamente, puede usar la <code>visible</code>propiedad para definir una lista blanca de atributos que deben incluirse en la matriz de su modelo y la representación JSON. Todos los demás atributos se ocultarán cuando el modelo se convierta en una matriz o JSON:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The attributes that should be visible in arrays.\n     *\n     * @var array\n     */\n    protected $visible = ['first_name', 'last_name'];\n}</code></pre>\n  <h4>Modificar temporalmente la visibilidad de los atributos</h4>\n  <p>Si desea que algunos atributos normalmente ocultos sean visibles en una instancia de modelo determinada, puede utilizar el <code>makeVisible</code>método. El <code>makeVisible</code>método devuelve la instancia del modelo para un encadenamiento conveniente del método:</p>\n  <pre><code>return $user-&gt;makeVisible('attribute')-&gt;toArray();</code></pre>\n  <p>Del mismo modo, si desea ocultar algunos atributos normalmente visibles en una instancia de modelo determinada, puede utilizar el <code>makeHidden</code>método.</p>\n  <pre><code>return $user-&gt;makeHidden('attribute')-&gt;toArray();</code></pre>\n  <p></p>\n  <h2>Agregar valores a JSON</h2>\n  <p>Ocasionalmente, al convertir modelos en una matriz o JSON, es posible que desee agregar atributos que no tienen una columna correspondiente en su base de datos. Para hacerlo, primero defina un descriptor de acceso para el valor:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Get the administrator flag for the user.\n     *\n     * @return bool\n     */\n    public function getIsAdminAttribute()\n    {\n        return $this-&gt;attributes['admin'] === 'yes';\n    }\n}</code></pre>\n  <p>Después de crear el descriptor de acceso, agregue el nombre del atributo a la <code>appends</code>propiedad en el modelo. Tenga en cuenta que normalmente se hace referencia a los nombres de los atributos en \"caso de serpiente\", aunque el descriptor de acceso se define mediante \"caso de camello\":</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The accessors to append to the model's array form.\n     *\n     * @var array\n     */\n    protected $appends = ['is_admin'];\n}</code></pre>\n  <p>Una vez que el atributo se ha agregado a la <code>appends</code>lista, se incluirá tanto en la matriz del modelo como en las representaciones JSON. Los atributos de la <code>appends</code>matriz también respetarán la configuración de <code>visible</code>y <code>hidden</code>configurada en el modelo.</p>\n  <h4>Agregar en tiempo de ejecución</h4>\n  <p>Puede indicarle a una única instancia de modelo que agregue atributos mediante el <code>append</code>método. O puede usar el <code>setAppends</code>método para anular toda la matriz de propiedades agregadas para una instancia de modelo determinada:</p>\n  <pre><code>return $user-&gt;append('is_admin')-&gt;toArray();\n\nreturn $user-&gt;setAppends(['is_admin'])-&gt;toArray();</code></pre>\n  <p></p>\n  <h2>Serialización de fecha</h2>\n  <h4>Personalización del formato de fecha predeterminado</h4>\n  <p>Puede personalizar el formato de serialización predeterminado anulando el <code>serializeDate</code>método:</p>\n  <pre><code>/**\n * Prepare a date for array / JSON serialization.\n *\n * @param  \\DateTimeInterface  $date\n * @return string\n */\nprotected function serializeDate(DateTimeInterface $date)\n{\n    return $date-&gt;format('Y-m-d');\n}</code></pre>\n  <h4>Personalización del formato de fecha por atributo</h4>\n  <p>Puede personalizar el formato de serialización de los atributos de fecha individuales de Eloquent especificando el formato de fecha en la declaración del reparto :</p>\n  <pre><code>protected $casts = [\n    'birthday' =&gt; 'date:Y-m-d',\n    'joined_at' =&gt; 'datetime:Y-m-d H:00',\n];</code></pre>\n</section>"
      }
    ]
  },
  {
    "titulo": "Testing",
    "subtitulo": "",
    "items": [
      {
        "titulo": "9.1 Empezando",
        "contenido": "<section>\n  <h1>Prueba: Primeros pasos</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Ambiente</li>\n    <li>Creación y ejecución de pruebas\n      <ul>\n        <li>Corredor de pruebas artesanal</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel se construye teniendo en cuenta las pruebas. De hecho, el soporte para realizar pruebas con PHPUnit está incluido y ya está configurado un archivo para su aplicación. El marco también se envía con métodos de ayuda convenientes que le permiten probar expresivamente sus aplicaciones.<code>phpunit.xml</code></p>\n  <p>De forma predeterminada, el <code>tests</code>directorio de su aplicación contiene dos directorios: <code>Feature</code>y <code>Unit</code>. Las pruebas unitarias son pruebas que se centran en una parte muy pequeña y aislada de su código. De hecho, la mayoría de las pruebas unitarias probablemente se centren en un solo método. Las pruebas de funciones pueden probar una parte más grande de su código, incluida la forma en que varios objetos interactúan entre sí o incluso una solicitud HTTP completa a un punto final JSON.</p>\n  <p>Se proporciona un archivo en los directorios de prueba y . Después de instalar una nueva aplicación Laravel, ejecútela en la línea de comandos para ejecutar sus pruebas.<code>ExampleTest.php</code><code>Feature</code><code>Unit</code><code>vendor/bin/phpunit</code></p>\n  <p></p>\n  <h2>Ambiente</h2>\n  <p>Al ejecutar las pruebas a través de , Laravel establecerá automáticamente el entorno de configuración debido a las variables de entorno definidas en el archivo. Laravel también configura automáticamente la sesión y el caché para el controlador durante la prueba, lo que significa que no se conservarán los datos de la sesión o del caché durante la prueba.<code>vendor/bin/phpunit</code><code>testing</code><code>phpunit.xml</code><code>array</code></p>\n  <p>Puede definir otros valores de configuración del entorno de prueba según sea necesario. Las <code>testing</code>variables de entorno se pueden configurar en el archivo, ¡pero asegúrese de borrar su caché de configuración usando el comando Artisan antes de ejecutar sus pruebas!<code>phpunit.xml</code><code>config:clear</code></p>\n  <p>Además, puede crear un archivo en la raíz de su proyecto. Este archivo anulará el archivo al ejecutar pruebas PHPUnit o ejecutar comandos Artisan con la opción.<code>.env.testing</code><code>.env</code><code>--env=testing</code></p>\n  <p></p>\n  <h2>Creación y ejecución de pruebas</h2>\n  <p>Para crear un nuevo caso de prueba, use el comando Artisan:<code>make:test</code></p>\n  <pre><code>// Create a test in the Feature directory...\nphp artisan make:test UserTest\n\n// Create a test in the Unit directory...\nphp artisan make:test UserTest --unit</code></pre>\n  <blockquote>\n    <div><div></div><p>Los stubs de prueba se pueden personalizar mediante la publicación de stub</p></div>\n  </blockquote>\n  <p>Una vez que se ha generado la prueba, puede definir métodos de prueba como lo haría normalmente con PHPUnit. Para ejecutar sus pruebas, ejecute el comando <code>phpunit</code>o <code>artisan test</code>desde su terminal:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Unit;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass ExampleTest extends TestCase\n{\n    /**\n     * A basic test example.\n     *\n     * @return void\n     */\n    public function testBasicTest()\n    {\n        $this-&gt;assertTrue(true);\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Si define sus propios métodos <code>setUp</code>/ <code>tearDown</code>dentro de una clase de prueba, asegúrese de llamar a los métodos / respectivos en la clase principal.<code>parent::setUp()</code><code>parent::tearDown()</code></p></div>\n  </blockquote>\n  <p></p>\n  <h3>Corredor de pruebas artesanal</h3>\n  <p>Además del <code>phpunit</code>comando, puede usar el <code>test</code>comando Artisan para ejecutar sus pruebas. El ejecutor de pruebas de Artisan proporciona informes de prueba detallados para facilitar el desarrollo y la depuración:</p>\n  <pre><code>php artisan test</code></pre>\n  <p>Cualquier argumento que pueda pasarse al <code>phpunit</code>comando también puede pasarse al <code>test</code>comando Artisan :</p>\n  <pre><code>php artisan test --group=feature --stop-on-failure</code></pre>\n</section>"
      },
      {
        "titulo": "9.2 Pruebas HTTP",
        "contenido": "<section>\n  <h1>Pruebas HTTP</h1>\n  <ul>\n    <li>Introducción\n      <ul>\n        <li>Personalización de encabezados de solicitud</li>\n        <li>Galletas</li>\n        <li>Respuestas de depuración</li>\n      </ul></li>\n    <li>Sesión / Autenticación</li>\n    <li>Prueba de las API JSON</li>\n    <li>Prueba de cargas de archivos</li>\n    <li>Prueba de vistas</li>\n    <li>Afirmaciones disponibles\n      <ul>\n        <li>Afirmaciones de respuesta</li>\n        <li>Afirmaciones de autenticación</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel proporciona una API muy fluida para realizar solicitudes HTTP a su aplicación y examinar la salida. Por ejemplo, eche un vistazo a la prueba de características que se define a continuación:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Feature;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse Illuminate\\Foundation\\Testing\\WithoutMiddleware;\nuse Tests\\TestCase;\n\nclass ExampleTest extends TestCase\n{\n    /**\n     * A basic test example.\n     *\n     * @return void\n     */\n    public function testBasicTest()\n    {\n        $response = $this-&gt;get('/');\n\n        $response-&gt;assertStatus(200);\n    }\n}</code></pre>\n  <p>El <code>get</code>método realiza una <code>GET</code>solicitud en la aplicación, mientras que el <code>assertStatus</code>método afirma que la respuesta devuelta debe tener el código de estado HTTP dado. Además de esta simple afirmación, Laravel también contiene una variedad de afirmaciones para inspeccionar los encabezados de respuesta, el contenido, la estructura JSON y más.</p>\n  <p></p>\n  <h3>Personalización de encabezados de solicitud</h3>\n  <p>Puede utilizar el <code>withHeaders</code>método para personalizar los encabezados de la solicitud antes de enviarla a la aplicación. Esto le permite agregar cualquier encabezado personalizado que le gustaría a la solicitud:</p>\n  <pre><code>&lt;?php\n\nclass ExampleTest extends TestCase\n{\n    /**\n     * A basic functional test example.\n     *\n     * @return void\n     */\n    public function testBasicExample()\n    {\n        $response = $this-&gt;withHeaders([\n            'X-Header' =&gt; 'Value',\n        ])-&gt;json('POST', '/user', ['name' =&gt; 'Sally']);\n\n        $response\n            -&gt;assertStatus(201)\n            -&gt;assertJson([\n                'created' =&gt; true,\n            ]);\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p> El middleware CSRF se desactiva automáticamente al ejecutar pruebas.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Galletas</h3>\n  <p>Puede usar los métodos <code>withCookie</code>o <code>withCookies</code>para establecer valores de cookies antes de realizar una solicitud. El <code>withCookie</code>método acepta un nombre y un valor de cookie como sus dos argumentos, mientras que el <code>withCookies</code>método acepta una matriz de pares de nombre / valor:</p>\n  <pre><code>&lt;?php\n\nclass ExampleTest extends TestCase\n{\n    public function testCookies()\n    {\n        $response = $this-&gt;withCookie('color', 'blue')-&gt;get('/');\n\n        $response = $this-&gt;withCookies([\n            'color' =&gt; 'blue',\n            'name' =&gt; 'Taylor',\n        ])-&gt;get('/');\n    }\n}</code></pre>\n  <p></p>\n  <h3>Respuestas de depuración</h3>\n  <p>Después de hacer una solicitud de prueba para su aplicación, el <code>dump</code>, <code>dumpHeaders</code>y <code>dumpSession</code>métodos se pueden utilizar para examinar y depurar los contenidos de respuesta:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Feature;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse Illuminate\\Foundation\\Testing\\WithoutMiddleware;\nuse Tests\\TestCase;\n\nclass ExampleTest extends TestCase\n{\n    /**\n     * A basic test example.\n     *\n     * @return void\n     */\n    public function testBasicTest()\n    {\n        $response = $this-&gt;get('/');\n\n        $response-&gt;dumpHeaders();\n\n        $response-&gt;dumpSession();\n\n        $response-&gt;dump();\n    }\n}</code></pre>\n  <p></p>\n  <h2>Sesión / Autenticación</h2>\n  <p>Laravel proporciona varios ayudantes para trabajar con la sesión durante las pruebas HTTP. Primero, puede configurar los datos de la sesión en una matriz dada usando el <code>withSession</code>método. Esto es útil para cargar la sesión con datos antes de enviar una solicitud a su aplicación:</p>\n  <pre><code>&lt;?php\n\nclass ExampleTest extends TestCase\n{\n    public function testApplication()\n    {\n        $response = $this-&gt;withSession(['foo' =&gt; 'bar'])\n                         -&gt;get('/');\n    }\n}</code></pre>\n  <p>Un uso común de la sesión es mantener el estado del usuario autenticado. El <code>actingAs</code>método auxiliar proporciona una forma sencilla de autenticar a un usuario determinado como usuario actual. Por ejemplo, podemos usar una fábrica de modelos para generar y autenticar a un usuario:</p>\n  <pre><code>&lt;?php\n\nuse App\\Models\\User;\n\nclass ExampleTest extends TestCase\n{\n    public function testApplication()\n    {\n        $user = User::factory()-&gt;create();\n\n        $response = $this-&gt;actingAs($user)\n                         -&gt;withSession(['foo' =&gt; 'bar'])\n                         -&gt;get('/');\n    }\n}</code></pre>\n  <p>También puede especificar qué guardia debe usarse para autenticar al usuario dado pasando el nombre de guardia como segundo argumento del <code>actingAs</code>método:</p>\n  <pre><code>$this-&gt;actingAs($user, 'api')</code></pre>\n  <p></p>\n  <h2>Prueba de las API JSON</h2>\n  <p>Laravel también proporciona varios ayudantes para probar las API JSON y sus respuestas. Por ejemplo, el <code>json</code>, <code>getJson</code>, <code>postJson</code>, <code>putJson</code>, <code>patchJson</code>, <code>deleteJson</code>, y <code>optionsJson</code>métodos se pueden utilizar para emitir solicitudes JSON con diversos verbos HTTP. También puede pasar fácilmente datos y encabezados a estos métodos. Para comenzar, escribamos una prueba para realizar una <code>POST</code>solicitud <code>/user</code>y afirmar que se devolvieron los datos esperados:</p>\n  <pre><code>&lt;?php\n\nclass ExampleTest extends TestCase\n{\n    /**\n     * A basic functional test example.\n     *\n     * @return void\n     */\n    public function testBasicExample()\n    {\n        $response = $this-&gt;postJson('/user', ['name' =&gt; 'Sally']);\n\n        $response\n            -&gt;assertStatus(201)\n            -&gt;assertJson([\n                'created' =&gt; true,\n            ]);\n    }\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>El <code>assertJson</code>método convierte la respuesta en una matriz y se utiliza para verificar que la matriz dada existe dentro de la respuesta JSON devuelta por la aplicación. Por lo tanto, si hay otras propiedades en la respuesta JSON, esta prueba se aprobará siempre que el fragmento dado esté presente.<code>PHPUnit::assertArraySubset</code></p></div>\n  </blockquote>\n  <p>Además, se puede acceder a los datos de respuesta JSON como variables de matriz en la respuesta:</p>\n  <pre><code>$this-&gt;assertTrue($response['created']);</code></pre>\n  <p></p>\n  <h3>Verificación de una coincidencia JSON exacta</h3>\n  <p>Si desea verificar que la matriz dada es una coincidencia <strong>exacta</strong> para el JSON devuelto por la aplicación, debe usar el <code>assertExactJson</code>método:</p>\n  <pre><code>&lt;?php\n\nclass ExampleTest extends TestCase\n{\n    /**\n     * A basic functional test example.\n     *\n     * @return void\n     */\n    public function testBasicExample()\n    {\n        $response = $this-&gt;json('POST', '/user', ['name' =&gt; 'Sally']);\n\n        $response\n            -&gt;assertStatus(201)\n            -&gt;assertExactJson([\n                'created' =&gt; true,\n            ]);\n    }\n}</code></pre>\n  <p></p>\n  <h3>Verificación de rutas JSON</h3>\n  <p>Si desea verificar que la respuesta JSON contiene algunos datos dados en una ruta específica, debe usar el <code>assertJsonPath</code>método:</p>\n  <pre><code>&lt;?php\n\nclass ExampleTest extends TestCase\n{\n    /**\n     * A basic functional test example.\n     *\n     * @return void\n     */\n    public function testBasicExample()\n    {\n        $response = $this-&gt;json('POST', '/user', ['name' =&gt; 'Sally']);\n\n        $response\n            -&gt;assertStatus(201)\n            -&gt;assertJsonPath('team.owner.name', 'foo')\n    }\n}</code></pre>\n  <p></p>\n  <h2>Prueba de cargas de archivos</h2>\n  <p>La clase proporciona un método que puede usarse para generar archivos o imágenes ficticios para realizar pruebas. Esto, combinado con el método de la fachada, simplifica enormemente la prueba de carga de archivos. Por ejemplo, puede combinar estas dos funciones para probar fácilmente un formulario de carga de avatar:<code>Illuminate\\Http\\UploadedFile</code><code>fake</code><code>Storage</code><code>fake</code></p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Feature;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse Illuminate\\Foundation\\Testing\\WithoutMiddleware;\nuse Illuminate\\Http\\UploadedFile;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Tests\\TestCase;\n\nclass ExampleTest extends TestCase\n{\n    public function testAvatarUpload()\n    {\n        Storage::fake('avatars');\n\n        $file = UploadedFile::fake()-&gt;image('avatar.jpg');\n\n        $response = $this-&gt;json('POST', '/avatar', [\n            'avatar' =&gt; $file,\n        ]);\n\n        // Assert the file was stored...\n        Storage::disk('avatars')-&gt;assertExists($file-&gt;hashName());\n\n        // Assert a file does not exist...\n        Storage::disk('avatars')-&gt;assertMissing('missing.jpg');\n    }\n}</code></pre>\n  <h4>Personalización de archivos falsos</h4>\n  <p>Al crear archivos usando el <code>fake</code>método, puede especificar el ancho, alto y tamaño de la imagen para probar mejor sus reglas de validación:</p>\n  <pre><code>UploadedFile::fake()-&gt;image('avatar.jpg', $width, $height)-&gt;size(100);</code></pre>\n  <p>Además de crear imágenes, puede crear archivos de cualquier otro tipo utilizando el <code>create</code>método:</p>\n  <pre><code>UploadedFile::fake()-&gt;create('document.pdf', $sizeInKilobytes);</code></pre>\n  <p>Si es necesario, puede pasar un <code>$mimeType</code>argumento al método para definir explícitamente el tipo MIME que debe devolver el archivo:</p>\n  <pre><code>UploadedFile::fake()-&gt;create('document.pdf', $sizeInKilobytes, 'application/pdf');</code></pre>\n  <p></p>\n  <h2>Prueba de vistas</h2>\n  <p>Laravel le permite representar una vista de forma aislada sin realizar una solicitud HTTP simulada a la aplicación. Para lograr esto, puede usar el <code>view</code>método dentro de su prueba. El <code>view</code>método acepta el nombre de la vista y una matriz opcional de datos. El método devuelve una instancia de , que ofrece varios métodos para hacer afirmaciones de manera conveniente sobre el contenido de la vista:<code>Illuminate\\Testing\\TestView</code></p>\n  <pre><code>public function testWelcomeView()\n{\n    $view = $this-&gt;view('welcome', ['name' =&gt; 'Taylor']);\n\n    $view-&gt;assertSee('Taylor');\n}</code></pre>\n  <p>El <code>TestView</code>objeto proporciona los siguientes métodos de aserción: <code>assertSee</code>, <code>assertSeeInOrder</code>, <code>assertSeeText</code>, <code>assertSeeTextInOrder</code>, <code>assertDontSee</code>, y <code>assertDontSeeText</code>.</p>\n  <p>Si es necesario, puede obtener el contenido de la vista renderizada sin procesar al convertir la <code>TestView</code>instancia en una cadena:</p>\n  <pre><code>$contents = (string) $this-&gt;view('welcome');</code></pre>\n  <h4>Compartir errores</h4>\n  <p>Algunas vistas pueden depender de errores compartidos en la bolsa de errores global proporcionada por Laravel. Para hidratar la bolsa de error con mensajes de error, puede utilizar el <code>withViewErrors</code>método:</p>\n  <pre><code>$view = $this-&gt;withViewErrors([\n    'name' =&gt; ['Please provide a valid name.']\n])-&gt;view('form');\n\n$view-&gt;assertSee('Please provide a valid name.');</code></pre>\n  <h4>Representación de la hoja sin procesar</h4>\n  <p>Si es necesario, puede utilizar el <code>blade</code>método para evaluar y renderizar una cadena Blade sin procesar. Como el <code>view</code>método, el <code>blade</code>método devuelve una instancia de :<code>Illuminate\\Testing\\TestView</code></p>\n  <pre><code>$view = $this-&gt;blade(\n    '&lt;x-component :name=\"$name\" /&gt;',\n    ['name' =&gt; 'Taylor']\n);\n\n$view-&gt;assertSee('Taylor');</code></pre>\n  <p></p>\n  <h2>Afirmaciones disponibles</h2>\n  <p></p>\n  <h3>Afirmaciones de respuesta</h3>\n  <p>Laravel proporciona una variedad de métodos de afirmación personalizados para sus pruebas de funciones PHPUnit . Estas afirmaciones pueden ser accedidos en la respuesta que se devuelve desde los <code>json</code>, <code>get</code>, <code>post</code>, <code>put</code>, y <code>delete</code>métodos de ensayo:</p>\n  <style>\n    .collection-method-list > p {\n        column-count: 2; -moz-column-count: 2; -webkit-column-count: 2;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    .collection-method-list a {\n        display: block;\n    }\n</style>\n  <div>\n    <p>afirmarCookie\n      assertCookieExpired\n      asertCookieNotExpired\n      afirmarCookieMissing\n      aseverarCreado\n      AsertDontSee\n      asertDontSeeText\n      asertExactJson\n      aseverar Prohibido\n      assertHeader\n      assertHeaderMissing\n      asertJson\n      asertJsonCount\n      asertJsonFragment\n      asertJsonMissing\n      asertJsonMissingExact\n      asertJsonMissingValidationErrors\n      asertJsonPath\n      asertJsonStructure\n      asertJsonValidationErrors\n      asertLocation\n      assertNoContent\n      asertNotFound\n      afirmarOk\n      assertPlainCookie\n      asertRedirect\n      aseverarVer\n      asertSeeInOrder\n      asertSeeText\n      asertSeeTextInOrder\n      AsertSessionHas\n      asertSessionHasInput\n      asertSessionHasAll\n      asertSessionHasErrors\n      asertSessionHasErrorsIn\n      asertSessionHasNoErrors\n      asertSessionDoesntHaveErrors\n      asertSessionMissing\n      asertStatus\n      afirmar con éxito\n      aseverar no autorizado\n      assertViewHas\n      asertViewHasAll\n      assertViewIs\n      assertViewMissing</p>\n  </div>\n  <p></p>\n  <h4>afirmarCookie</h4>\n  <p>Afirma que la respuesta contiene la cookie dada:</p>\n  <pre><code>$response-&gt;assertCookie($cookieName, $value = null);</code></pre>\n  <p></p>\n  <h4>assertCookieExpired</h4>\n  <p>Afirma que la respuesta contiene la cookie dada y está vencida:</p>\n  <pre><code>$response-&gt;assertCookieExpired($cookieName);</code></pre>\n  <p></p>\n  <h4>asertCookieNotExpired</h4>\n  <p>Afirme que la respuesta contiene la cookie dada y que no está vencida:</p>\n  <pre><code>$response-&gt;assertCookieNotExpired($cookieName);</code></pre>\n  <p></p>\n  <h4>afirmarCookieMissing</h4>\n  <p>Afirme que la respuesta no contiene la cookie dada:</p>\n  <pre><code>$response-&gt;assertCookieMissing($cookieName);</code></pre>\n  <p></p>\n  <h4>aseverarCreado</h4>\n  <p>Afirme que la respuesta tiene un código de estado 201:</p>\n  <pre><code>$response-&gt;assertCreated();</code></pre>\n  <p></p>\n  <h4>AsertDontSee</h4>\n  <p>Afirme que la cadena dada no está contenida en la respuesta. Esta afirmación escapará automáticamente de la cadena dada a menos que pase un segundo argumento de <code>false</code>:</p>\n  <pre><code>$response-&gt;assertDontSee($value, $escaped = true);</code></pre>\n  <p></p>\n  <h4>asertDontSeeText</h4>\n  <p>Afirme que la cadena dada no está incluida en el texto de respuesta. Esta afirmación escapará automáticamente de la cadena dada a menos que pase un segundo argumento de <code>false</code>:</p>\n  <pre><code>$response-&gt;assertDontSeeText($value, $escaped = true);</code></pre>\n  <p></p>\n  <h4>asertExactJson</h4>\n  <p>Afirma que la respuesta contiene una coincidencia exacta de los datos JSON dados:</p>\n  <pre><code>$response-&gt;assertExactJson(array $data);</code></pre>\n  <p></p>\n  <h4>aseverar Prohibido</h4>\n  <p>Afirme que la respuesta tiene un código de estado prohibido (403):</p>\n  <pre><code>$response-&gt;assertForbidden();</code></pre>\n  <p></p>\n  <h4>assertHeader</h4>\n  <p>Afirma que el encabezado dado está presente en la respuesta:</p>\n  <pre><code>$response-&gt;assertHeader($headerName, $value = null);</code></pre>\n  <p></p>\n  <h4>assertHeaderMissing</h4>\n  <p>Afirma que el encabezado dado no está presente en la respuesta:</p>\n  <pre><code>$response-&gt;assertHeaderMissing($headerName);</code></pre>\n  <p></p>\n  <h4>asertJson</h4>\n  <p>Afirma que la respuesta contiene los datos JSON dados:</p>\n  <pre><code>$response-&gt;assertJson(array $data, $strict = false);</code></pre>\n  <p></p>\n  <h4>asertJsonCount</h4>\n  <p>Afirma que la respuesta JSON tiene una matriz con el número esperado de elementos en la clave dada:</p>\n  <pre><code>$response-&gt;assertJsonCount($count, $key = null);</code></pre>\n  <p></p>\n  <h4>asertJsonFragment</h4>\n  <p>Afirma que la respuesta contiene el fragmento JSON dado:</p>\n  <pre><code>$response-&gt;assertJsonFragment(array $data);</code></pre>\n  <p></p>\n  <h4>asertJsonMissing</h4>\n  <p>Afirma que la respuesta no contiene el fragmento JSON dado:</p>\n  <pre><code>$response-&gt;assertJsonMissing(array $data);</code></pre>\n  <p></p>\n  <h4>asertJsonMissingExact</h4>\n  <p>Afirma que la respuesta no contiene el fragmento JSON exacto:</p>\n  <pre><code>$response-&gt;assertJsonMissingExact(array $data);</code></pre>\n  <p></p>\n  <h4>asertJsonMissingValidationErrors</h4>\n  <p>Afirme que la respuesta no tiene errores de validación JSON para las claves dadas:</p>\n  <pre><code>$response-&gt;assertJsonMissingValidationErrors($keys);</code></pre>\n  <p></p>\n  <h4>asertJsonPath</h4>\n  <p>Afirma que la respuesta contiene los datos proporcionados en la ruta especificada:</p>\n  <pre><code>$response-&gt;assertJsonPath($path, array $data, $strict = false);</code></pre>\n  <p></p>\n  <h4>asertJsonStructure</h4>\n  <p>Afirma que la respuesta tiene una estructura JSON determinada:</p>\n  <pre><code>$response-&gt;assertJsonStructure(array $structure);</code></pre>\n  <p></p>\n  <h4>asertJsonValidationErrors</h4>\n  <p>Afirme que la respuesta tiene los errores de validación JSON dados:</p>\n  <pre><code>$response-&gt;assertJsonValidationErrors(array $data);</code></pre>\n  <p></p>\n  <h4>asertLocation</h4>\n  <p>Afirma que la respuesta tiene el valor URI dado en el <code>Location</code>encabezado:</p>\n  <pre><code>$response-&gt;assertLocation($uri);</code></pre>\n  <p></p>\n  <h4>assertNoContent</h4>\n  <p>Afirme que la respuesta tiene el código de estado dado y no tiene contenido.</p>\n  <pre><code>$response-&gt;assertNoContent($status = 204);</code></pre>\n  <p></p>\n  <h4>asertNotFound</h4>\n  <p>Afirma que la respuesta tiene un código de estado no encontrado:</p>\n  <pre><code>$response-&gt;assertNotFound();</code></pre>\n  <p></p>\n  <h4>afirmarOk</h4>\n  <p>Afirma que la respuesta tiene un código de estado 200:</p>\n  <pre><code>$response-&gt;assertOk();</code></pre>\n  <p></p>\n  <h4>assertPlainCookie</h4>\n  <p>Afirme que la respuesta contiene la cookie dada (sin cifrar):</p>\n  <pre><code>$response-&gt;assertPlainCookie($cookieName, $value = null);</code></pre>\n  <p></p>\n  <h4>asertRedirect</h4>\n  <p>Afirme que la respuesta es una redirección a un URI determinado:</p>\n  <pre><code>$response-&gt;assertRedirect($uri);</code></pre>\n  <p></p>\n  <h4>aseverarVer</h4>\n  <p>Afirma que la cadena dada está incluida en la respuesta. Esta afirmación escapará automáticamente de la cadena dada a menos que pase un segundo argumento de <code>false</code>:</p>\n  <pre><code>$response-&gt;assertSee($value, $escaped = true);</code></pre>\n  <p></p>\n  <h4>asertSeeInOrder</h4>\n  <p>Afirme que las cadenas dadas están contenidas en orden dentro de la respuesta. Esta afirmación escapará automáticamente de las cadenas dadas a menos que pase un segundo argumento de <code>false</code>:</p>\n  <pre><code>$response-&gt;assertSeeInOrder(array $values, $escaped = true);</code></pre>\n  <p></p>\n  <h4>asertSeeText</h4>\n  <p>Afirma que la cadena dada está contenida en el texto de respuesta. Esta afirmación escapará automáticamente de la cadena dada a menos que pase un segundo argumento de <code>false</code>:</p>\n  <pre><code>$response-&gt;assertSeeText($value, $escaped = true);</code></pre>\n  <p></p>\n  <h4>asertSeeTextInOrder</h4>\n  <p>Afirme que las cadenas dadas están contenidas en orden dentro del texto de respuesta. Esta afirmación escapará automáticamente de las cadenas dadas a menos que pase un segundo argumento de <code>false</code>:</p>\n  <pre><code>$response-&gt;assertSeeTextInOrder(array $values, $escaped = true);</code></pre>\n  <p></p>\n  <h4>AsertSessionHas</h4>\n  <p>Afirmar que la sesión contiene el dato dado:</p>\n  <pre><code>$response-&gt;assertSessionHas($key, $value = null);</code></pre>\n  <p></p>\n  <h4>asertSessionHasInput</h4>\n  <p>Afirme que la sesión tiene un valor dado en la matriz de entrada flasheada:</p>\n  <pre><code>$response-&gt;assertSessionHasInput($key, $value = null);</code></pre>\n  <p></p>\n  <h4>asertSessionHasAll</h4>\n  <p>Afirmar que la sesión tiene una lista determinada de valores:</p>\n  <pre><code>$response-&gt;assertSessionHasAll(array $data);</code></pre>\n  <p></p>\n  <h4>asertSessionHasErrors</h4>\n  <p>Afirme que la sesión contiene un error para el dado <code>$keys</code>. Si <code>$keys</code>es una matriz asociativa, afirme que la sesión contiene un mensaje de error específico (valor) para cada campo (clave):</p>\n  <pre><code>$response-&gt;assertSessionHasErrors(array $keys, $format = null, $errorBag = 'default');</code></pre>\n  <p></p>\n  <h4>asertSessionHasErrorsIn</h4>\n  <p>Afirme que la sesión contiene un error para lo dado <code>$keys</code>, dentro de una bolsa de errores específica. Si <code>$keys</code>es una matriz asociativa, afirme que la sesión contiene un mensaje de error específico (valor) para cada campo (clave), dentro de la bolsa de errores:</p>\n  <pre><code>$response-&gt;assertSessionHasErrorsIn($errorBag, $keys = [], $format = null);</code></pre>\n  <p></p>\n  <h4>asertSessionHasNoErrors</h4>\n  <p>Afirme que la sesión no tiene errores:</p>\n  <pre><code>$response-&gt;assertSessionHasNoErrors();</code></pre>\n  <p></p>\n  <h4>asertSessionDoesntHaveErrors</h4>\n  <p>Afirme que la sesión no tiene errores para las claves dadas:</p>\n  <pre><code>$response-&gt;assertSessionDoesntHaveErrors($keys = [], $format = null, $errorBag = 'default');</code></pre>\n  <p></p>\n  <h4>asertSessionMissing</h4>\n  <p>Afirme que la sesión no contiene la clave dada:</p>\n  <pre><code>$response-&gt;assertSessionMissing($key);</code></pre>\n  <p></p>\n  <h4>asertStatus</h4>\n  <p>Afirma que la respuesta tiene un código determinado:</p>\n  <pre><code>$response-&gt;assertStatus($code);</code></pre>\n  <p></p>\n  <h4>afirmar con éxito</h4>\n  <p>Afirmar que la respuesta tiene un código de estado correcto (&gt; = 200 y &lt;300):</p>\n  <pre><code>$response-&gt;assertSuccessful();</code></pre>\n  <p></p>\n  <h4>aseverar no autorizado</h4>\n  <p>Afirme que la respuesta tiene un código de estado no autorizado (401):</p>\n  <pre><code>$response-&gt;assertUnauthorized();</code></pre>\n  <p></p>\n  <h4>assertViewHas</h4>\n  <p>Afirmar que a la vista de respuesta se le dio un dato:</p>\n  <pre><code>$response-&gt;assertViewHas($key, $value = null);</code></pre>\n  <p>Además, se puede acceder a los datos de la vista como variables de matriz en la respuesta:</p>\n  <pre><code>$this-&gt;assertEquals('Taylor', $response['name']);</code></pre>\n  <p></p>\n  <h4>asertViewHasAll</h4>\n  <p>Afirme que la vista de respuesta tiene una lista de datos determinada:</p>\n  <pre><code>$response-&gt;assertViewHasAll(array $data);</code></pre>\n  <p></p>\n  <h4>assertViewIs</h4>\n  <p>Afirmar que la ruta devolvió la vista dada:</p>\n  <pre><code>$response-&gt;assertViewIs($value);</code></pre>\n  <p></p>\n  <h4>assertViewMissing</h4>\n  <p>Afirme que a la vista de respuesta le falta una parte de los datos vinculados:</p>\n  <pre><code>$response-&gt;assertViewMissing($key);</code></pre>\n  <p></p>\n  <h3>Afirmaciones de autenticación</h3>\n  <p>Laravel también proporciona una variedad de afirmaciones relacionadas con la autenticación para las pruebas de funciones de PHPUnit :</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Método</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$this-&gt;assertAuthenticated($guard = null);</code></td>\n      <td>Afirme que el usuario está autenticado.</td>\n    </tr>\n    <tr>\n      <td><code>$this-&gt;assertGuest($guard = null);</code></td>\n      <td>Afirme que el usuario no está autenticado.</td>\n    </tr>\n    <tr>\n      <td><code>$this-&gt;assertAuthenticatedAs($user, $guard = null);</code></td>\n      <td>Afirmar que el usuario dado está autenticado.</td>\n    </tr>\n    <tr>\n      <td><code>$this-&gt;assertCredentials(array $credentials, $guard = null);</code></td>\n      <td>Asegúrate de que las credenciales proporcionadas son válidas.</td>\n    </tr>\n    <tr>\n      <td><code>$this-&gt;assertInvalidCredentials(array $credentials, $guard = null);</code></td>\n      <td>Confirme que las credenciales proporcionadas no son válidas.</td>\n    </tr>\n    </tbody>\n  </table>\n</section>"
      },
      {
        "titulo": "9.3 Pruebas en consola",
        "contenido": "<section>\n  <h1>Pruebas de consola</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Esperando entrada / salida</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Además de simplificar las pruebas HTTP, Laravel proporciona una API simple para probar aplicaciones de consola que solicitan la entrada del usuario.</p>\n  <p></p>\n  <h2>Esperando entrada / salida</h2>\n  <p>Laravel te permite \"simular\" fácilmente la entrada del usuario para los comandos de tu consola usando el <code>expectsQuestion</code>método. Además, puede especificar el código de salida y el texto que espera que genere el comando de la consola mediante los métodos <code>assertExitCode</code>y <code>expectsOutput</code>. Por ejemplo, considere el siguiente comando de consola:</p>\n  <pre><code>Artisan::command('question', function () {\n    $name = $this-&gt;ask('What is your name?');\n\n    $language = $this-&gt;choice('Which language do you program in?', [\n        'PHP',\n        'Ruby',\n        'Python',\n    ]);\n\n    $this-&gt;line('Your name is '.$name.' and you program in '.$language.'.');\n});</code></pre>\n  <p>Usted puede probar este comando con la siguiente prueba que utiliza los <code>expectsQuestion</code>, <code>expectsOutput</code>, y <code>assertExitCode</code>métodos:</p>\n  <pre><code>/**\n * Test a console command.\n *\n * @return void\n */\npublic function testConsoleCommand()\n{\n    $this-&gt;artisan('question')\n         -&gt;expectsQuestion('What is your name?', 'Taylor Otwell')\n         -&gt;expectsQuestion('Which language do you program in?', 'PHP')\n         -&gt;expectsOutput('Your name is Taylor Otwell and you program in PHP.')\n         -&gt;assertExitCode(0);\n}</code></pre>\n  <p>Al escribir un comando que espera una confirmación en forma de respuesta \"sí\" o \"no\", puede utilizar el <code>expectsConfirmation</code>método:</p>\n  <pre><code>$this-&gt;artisan('module:import')\n    -&gt;expectsConfirmation('Do you really wish to run this command?', 'no')\n    -&gt;assertExitCode(1);</code></pre>\n</section>"
      },
      {
        "titulo": "9.4 Pruebas del navegador",
        "contenido": "<section>\n  <h1>Anochecer de Laravel</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Instalación\n      <ul>\n        <li>Administrar instalaciones de ChromeDriver</li>\n        <li>Usar otros navegadores</li>\n      </ul></li>\n    <li>Empezando\n      <ul>\n        <li>Generación de pruebas</li>\n        <li>Ejecución de pruebas</li>\n        <li>Manejo del medio ambiente</li>\n        <li>Crear navegadores</li>\n        <li>Macros del navegador</li>\n        <li>Autenticación</li>\n        <li>Migraciones de bases de datos</li>\n        <li>Galletas</li>\n        <li>Tomando una captura de pantalla</li>\n        <li>Almacenamiento de la salida de la consola en el disco</li>\n        <li>Almacenamiento de la fuente de la página en el disco</li>\n      </ul></li>\n    <li>Interactuar con elementos\n      <ul>\n        <li>Selectores de anochecer</li>\n        <li>Hacer clic en enlaces</li>\n        <li>Texto, valores y atributos</li>\n        <li>Usar formularios</li>\n        <li>Adjuntar archivos</li>\n        <li>Usando el teclado</li>\n        <li>Usando el mouse</li>\n        <li>Diálogos de JavaScript</li>\n        <li>Selectores de alcance</li>\n        <li>Esperando elementos</li>\n        <li>Desplazamiento de un elemento a la vista</li>\n        <li>Hacer afirmaciones de Vue</li>\n      </ul></li>\n    <li>Afirmaciones disponibles</li>\n    <li>Páginas\n      <ul>\n        <li>Generando páginas</li>\n        <li>Configurar páginas</li>\n        <li>Navegación a páginas</li>\n        <li>Selectores de taquigrafía</li>\n        <li>Métodos de página</li>\n      </ul></li>\n    <li>Componentes\n      <ul>\n        <li>Generación de componentes</li>\n        <li>Usando componentes</li>\n      </ul></li>\n    <li>Integración continua\n      <ul>\n        <li>CircleCI</li>\n        <li>Codificación</li>\n        <li>Heroku CI</li>\n        <li>Travis CI</li>\n        <li>Acciones de GitHub</li>\n      </ul></li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel Dusk proporciona una API de prueba y automatización de navegador expresiva y fácil de usar. De forma predeterminada, Dusk no requiere que instales JDK o Selenium en tu máquina. En cambio, Dusk utiliza una instalación independiente de ChromeDriver . Sin embargo, puede utilizar cualquier otro controlador compatible con Selenium que desee.</p>\n  <p></p>\n  <h2>Instalación</h2>\n  <p>Para comenzar, debe agregar la dependencia de Composer a su proyecto:<code>laravel/dusk</code></p>\n  <pre><code>composer require --dev laravel/dusk</code></pre>\n  <blockquote>\n    <div><div></div><p>Si está registrando manualmente el proveedor de servicios de Dusk, <strong>nunca</strong> debe registrarlo en su entorno de producción, ya que hacerlo podría llevar a usuarios arbitrarios a poder autenticarse con su aplicación.</p></div>\n  </blockquote>\n  <p>Después de instalar el paquete Dusk, ejecute el comando Artisan:<code>dusk:install</code></p>\n  <pre><code>php artisan dusk:install</code></pre>\n  <p>Se <code>Browser</code>creará un directorio dentro de su <code>tests</code>directorio y contendrá una prueba de ejemplo. A continuación, configure la <code>APP_URL</code>variable de entorno en su <code>.env</code>archivo. Este valor debe coincidir con la URL que usa para acceder a su aplicación en un navegador.</p>\n  <p>Para ejecutar sus pruebas, use el <code>dusk</code>comando Artisan. El <code>dusk</code>comando acepta cualquier argumento que también sea aceptado por el <code>phpunit</code>comando:</p>\n  <pre><code>php artisan dusk</code></pre>\n  <p>Si tuvo fallas en las pruebas la última vez que ejecutó el <code>dusk</code>comando, puede ahorrar tiempo si vuelve a ejecutar las pruebas que fallaron primero con el comando:<code>dusk:fails</code></p>\n  <pre><code>php artisan dusk:fails</code></pre>\n  <p></p>\n  <h3>Administrar instalaciones de ChromeDriver</h3>\n  <p>Si desea instalar una versión diferente de ChromeDriver a la que se incluye con Laravel Dusk, puede usar el comando:<code>dusk:chrome-driver</code></p>\n  <pre><code># Install the latest version of ChromeDriver for your OS...\nphp artisan dusk:chrome-driver\n\n# Install a given version of ChromeDriver for your OS...\nphp artisan dusk:chrome-driver 74\n\n# Install a given version of ChromeDriver for all supported OSs...\nphp artisan dusk:chrome-driver --all</code></pre>\n  <blockquote>\n    <div><div></div><p>Dusk requiere que los <code>chromedriver</code>binarios sean ejecutables. Si usted está teniendo problemas para ejecutar la oscuridad, debe asegurarse de los binarios son ejecutables mediante el siguiente comando: .<code>chmod -R 0755 vendor/laravel/dusk/bin/</code></p></div>\n  </blockquote>\n  <p></p>\n  <h3>Usar otros navegadores</h3>\n  <p>De forma predeterminada, Dusk usa Google Chrome y una instalación independiente de ChromeDriver para ejecutar las pruebas de su navegador. Sin embargo, puede iniciar su propio servidor Selenium y ejecutar sus pruebas en cualquier navegador que desee.</p>\n  <p>Para comenzar, abra su archivo, que es el caso de prueba base de Dusk para su aplicación. Dentro de este archivo, puede eliminar la llamada al método. Esto evitará que Dusk inicie automáticamente ChromeDriver:<code>tests/DuskTestCase.php</code><code>startChromeDriver</code></p>\n  <pre><code>/**\n * Prepare for Dusk test execution.\n *\n * @beforeClass\n * @return void\n */\npublic static function prepare()\n{\n    // static::startChromeDriver();\n}</code></pre>\n  <p>A continuación, puede modificar el <code>driver</code>método para conectarse a la URL y al puerto de su elección. Además, puede modificar las \"capacidades deseadas\" que deben pasarse al WebDriver:</p>\n  <pre><code>/**\n * Create the RemoteWebDriver instance.\n *\n * @return \\Facebook\\WebDriver\\Remote\\RemoteWebDriver\n */\nprotected function driver()\n{\n    return RemoteWebDriver::create(\n        'http://localhost:4444/wd/hub', DesiredCapabilities::phantomjs()\n    );\n}</code></pre>\n  <p></p>\n  <h2>Empezando</h2>\n  <p></p>\n  <h3>Generación de pruebas</h3>\n  <p>Para generar una prueba de Crepúsculo, use el comando Artisan. La prueba generada se colocará en el directorio:<code>dusk:make</code><code>tests/Browser</code></p>\n  <pre><code>php artisan dusk:make LoginTest</code></pre>\n  <p></p>\n  <h3>Ejecución de pruebas</h3>\n  <p>Para ejecutar las pruebas de su navegador, use el <code>dusk</code>comando Artisan:</p>\n  <pre><code>php artisan dusk</code></pre>\n  <p>Si tuvo fallas en las pruebas la última vez que ejecutó el <code>dusk</code>comando, puede ahorrar tiempo si vuelve a ejecutar las pruebas que fallaron primero con el comando:<code>dusk:fails</code></p>\n  <pre><code>php artisan dusk:fails</code></pre>\n  <p>El <code>dusk</code>comando acepta cualquier argumento que normalmente es aceptado por el ejecutor de pruebas PHPUnit, lo que le permite ejecutar las pruebas solo para un grupo determinado , etc.</p>\n  <pre><code>php artisan dusk --group=foo</code></pre>\n  <h4>Iniciar ChromeDriver manualmente</h4>\n  <p>De forma predeterminada, Dusk intentará iniciar ChromeDriver automáticamente. Si esto no funciona para su sistema en particular, puede iniciar ChromeDriver manualmente antes de ejecutar el <code>dusk</code>comando. Si elige iniciar ChromeDriver manualmente, debe comentar la siguiente línea de su archivo:<code>tests/DuskTestCase.php</code></p>\n  <pre><code>/**\n * Prepare for Dusk test execution.\n *\n * @beforeClass\n * @return void\n */\npublic static function prepare()\n{\n    // static::startChromeDriver();\n}</code></pre>\n  <p>Además, si inicia ChromeDriver en un puerto que no sea 9515, debe modificar el <code>driver</code>método de la misma clase:</p>\n  <pre><code>/**\n * Create the RemoteWebDriver instance.\n *\n * @return \\Facebook\\WebDriver\\Remote\\RemoteWebDriver\n */\nprotected function driver()\n{\n    return RemoteWebDriver::create(\n        'http://localhost:9515', DesiredCapabilities::chrome()\n    );\n}</code></pre>\n  <p></p>\n  <h3>Environment Handling</h3>\n  <p>To force Dusk to use its own environment file when running tests, create a <code>.env.dusk.{environment}</code> file in the root of your project. For example, if you will be initiating the <code>dusk</code> command from your <code>local</code> environment, you should create a <code>.env.dusk.local</code> file.</p>\n  <p>When running tests, Dusk will back-up your <code>.env</code> file and rename your Dusk environment to <code>.env</code>. Once the tests have completed, your <code>.env</code> file will be restored.</p>\n  <p></p>\n  <h3>Creating Browsers</h3>\n  <p>To get started, let's write a test that verifies we can log into our application. After generating a test, we can modify it to navigate to the login page, enter some credentials, and click the \"Login\" button. To create a browser instance, call the <code>browse</code> method:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Browser;\n\nuse App\\Models\\User;\nuse Illuminate\\Foundation\\Testing\\DatabaseMigrations;\nuse Laravel\\Dusk\\Chrome;\nuse Tests\\DuskTestCase;\n\nclass ExampleTest extends DuskTestCase\n{\n    use DatabaseMigrations;\n\n    /**\n     * A basic browser test example.\n     *\n     * @return void\n     */\n    public function testBasicExample()\n    {\n        $user = factory(User::class)-&gt;create([\n            'email' =&gt; 'taylor@laravel.com',\n        ]);\n\n        $this-&gt;browse(function ($browser) use ($user) {\n            $browser-&gt;visit('/login')\n                    -&gt;type('email', $user-&gt;email)\n                    -&gt;type('password', 'password')\n                    -&gt;press('Login')\n                    -&gt;assertPathIs('/home');\n        });\n    }\n}</code></pre>\n  <p>As you can see in the example above, the <code>browse</code> method accepts a callback. A browser instance will automatically be passed to this callback by Dusk and is the main object used to interact with and make assertions against your application.</p>\n  <h4>Creating Multiple Browsers</h4>\n  <p>Sometimes you may need multiple browsers in order to properly carry out a test. For example, multiple browsers may be needed to test a chat screen that interacts with websockets. To create multiple browsers, \"ask\" for more than one browser in the signature of the callback given to the <code>browse</code> method:</p>\n  <pre><code>$this-&gt;browse(function ($first, $second) {\n    $first-&gt;loginAs(User::find(1))\n          -&gt;visit('/home')\n          -&gt;waitForText('Message');\n\n    $second-&gt;loginAs(User::find(2))\n           -&gt;visit('/home')\n           -&gt;waitForText('Message')\n           -&gt;type('message', 'Hey Taylor')\n           -&gt;press('Send');\n\n    $first-&gt;waitForText('Hey Taylor')\n          -&gt;assertSee('Jeffrey Way');\n});</code></pre>\n  <h4>Resizing Browser Windows</h4>\n  <p>You may use the <code>resize</code> method to adjust the size of the browser window:</p>\n  <pre><code>$browser-&gt;resize(1920, 1080);</code></pre>\n  <p>The <code>maximize</code> method may be used to maximize the browser window:</p>\n  <pre><code>$browser-&gt;maximize();</code></pre>\n  <p>The <code>fitContent</code> method will resize the browser window to match the size of the content:</p>\n  <pre><code>$browser-&gt;fitContent();</code></pre>\n  <p>When a test fails, Dusk will automatically resize the browser to fit the content prior to taking a screenshot. You may disable this feature by calling the <code>disableFitOnFailure</code> method within your test:</p>\n  <pre><code>$browser-&gt;disableFitOnFailure();</code></pre>\n  <p>You may use the <code>move</code> method to move the browser window to a different position on your screen:</p>\n  <pre><code>$browser-&gt;move(100, 100);</code></pre>\n  <p></p>\n  <h3>Browser Macros</h3>\n  <p>If you would like to define a custom browser method that you can re-use in a variety of your tests, you may use the <code>macro</code> method on the <code>Browser</code> class. Typically, you should call this method from a service provider's <code>boot</code> method:</p>\n  <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse Laravel\\Dusk\\Browser;\n\nclass DuskServiceProvider extends ServiceProvider\n{\n    /**\n     * Register the Dusk's browser macros.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        Browser::macro('scrollToElement', function ($element = null) {\n            $this-&gt;script(\"$('html, body').animate({ scrollTop: $('$element').offset().top }, 0);\");\n\n            return $this;\n        });\n    }\n}</code></pre>\n  <p>La <code>macro</code>función acepta un nombre como primer argumento y un cierre como segundo. El cierre de la macro se ejecutará cuando se llame a la macro como método en una <code>Browser</code>implementación:</p>\n  <pre><code>$this-&gt;browse(function ($browser) use ($user) {\n    $browser-&gt;visit('/pay')\n            -&gt;scrollToElement('#credit-card-details')\n            -&gt;assertSee('Enter Credit Card Details');\n});</code></pre>\n  <p></p>\n  <h3>Autenticación</h3>\n  <p>A menudo, probará páginas que requieren autenticación. Puede utilizar el <code>loginAs</code>método de Dusk para evitar interactuar con la pantalla de inicio de sesión durante cada prueba. El <code>loginAs</code>método acepta una ID de usuario o una instancia de modelo de usuario:</p>\n  <pre><code>$this-&gt;browse(function ($first, $second) {\n    $first-&gt;loginAs(User::find(1))\n          -&gt;visit('/home');\n});</code></pre>\n  <blockquote>\n    <div><div></div><p>Después de usar el <code>loginAs</code>método, la sesión de usuario se mantendrá para todas las pruebas dentro del archivo.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Migraciones de bases de datos</h3>\n  <p>Cuando su prueba requiere migraciones, como en el ejemplo de autenticación anterior, nunca debe usar el <code>RefreshDatabase</code>rasgo. El <code>RefreshDatabase</code>rasgo aprovecha las transacciones de la base de datos que no serán aplicables a las solicitudes HTTP. En su lugar, use el <code>DatabaseMigrations</code>rasgo:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Browser;\n\nuse App\\Models\\User;\nuse Illuminate\\Foundation\\Testing\\DatabaseMigrations;\nuse Laravel\\Dusk\\Chrome;\nuse Tests\\DuskTestCase;\n\nclass ExampleTest extends DuskTestCase\n{\n    use DatabaseMigrations;\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Es posible que las bases de datos en memoria de SQLite no se utilicen al ejecutar pruebas Dusk. Dado que el navegador se ejecuta dentro de su propio proceso, no podrá acceder a las bases de datos en memoria de otros procesos.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Galletas</h3>\n  <p>Puede utilizar el <code>cookie</code>método para obtener o establecer el valor de una cookie cifrada:</p>\n  <pre><code>$browser-&gt;cookie('name');\n\n$browser-&gt;cookie('name', 'Taylor');</code></pre>\n  <p>Puede utilizar el <code>plainCookie</code>método para obtener o establecer el valor de una cookie no cifrada:</p>\n  <pre><code>$browser-&gt;plainCookie('name');\n\n$browser-&gt;plainCookie('name', 'Taylor');</code></pre>\n  <p>Puede utilizar el <code>deleteCookie</code>método para eliminar la cookie dada:</p>\n  <pre><code>$browser-&gt;deleteCookie('name');</code></pre>\n  <p></p>\n  <h3>Tomando una captura de pantalla</h3>\n  <p>Puede usar el <code>screenshot</code>método para tomar una captura de pantalla y almacenarla con el nombre de archivo dado. Todas las capturas de pantalla se almacenarán dentro del directorio:<code>tests/Browser/screenshots</code></p>\n  <pre><code>$browser-&gt;screenshot('filename');</code></pre>\n  <p></p>\n  <h3>Almacenamiento de la salida de la consola en el disco</h3>\n  <p>Puede usar el <code>storeConsoleLog</code>método para escribir la salida de la consola en el disco con el nombre de archivo dado. La salida de la consola se almacenará dentro del directorio:<code>tests/Browser/console</code></p>\n  <pre><code>$browser-&gt;storeConsoleLog('filename');</code></pre>\n  <p></p>\n  <h3>Almacenamiento de la fuente de la página en el disco</h3>\n  <p>Puede usar el <code>storeSource</code>método para escribir la fuente actual de la página en el disco con el nombre de archivo dado. La fuente de la página se almacenará dentro del directorio:<code>tests/Browser/source</code></p>\n  <pre><code>$browser-&gt;storeSource('filename');</code></pre>\n  <p></p>\n  <h2>Interactuar con elementos</h2>\n  <p></p>\n  <h3>Selectores de anochecer</h3>\n  <p>Elegir buenos selectores de CSS para interactuar con elementos es una de las partes más difíciles de escribir pruebas Dusk. Con el tiempo, los cambios en la interfaz pueden hacer que los selectores CSS como los siguientes rompan sus pruebas:</p>\n  <pre><code>// HTML...\n\n&lt;button&gt;Login&lt;/button&gt;\n\n// Test...\n\n$browser-&gt;click('.login-page .container div &gt; button');</code></pre>\n  <p>Los selectores de anochecer le permiten concentrarse en escribir pruebas efectivas en lugar de recordar los selectores de CSS. Para definir un selector, agregue un <code>dusk</code>atributo a su elemento HTML. Luego, anteponga el selector con <code>@</code>para manipular el elemento adjunto dentro de una prueba Dusk:</p>\n  <pre><code>// HTML...\n\n&lt;button dusk=\"login-button\"&gt;Login&lt;/button&gt;\n\n// Test...\n\n$browser-&gt;click('@login-button');</code></pre>\n  <p></p>\n  <h3>Hacer clic en enlaces</h3>\n  <p>Para hacer clic en un enlace, puede utilizar el <code>clickLink</code>método en la instancia del navegador. El <code>clickLink</code>método hará clic en el enlace que tiene el texto de visualización dado:</p>\n  <pre><code>$browser-&gt;clickLink($linkText);</code></pre>\n  <p>Puede usar el <code>seeLink</code>método para determinar si un enlace que tiene el texto de visualización dado es visible en la página:</p>\n  <pre><code>if ($browser-&gt;seeLink($linkText)) {\n    // ...\n}</code></pre>\n  <blockquote>\n    <div><div></div><p>Estos métodos interactúan con jQuery. Si jQuery no está disponible en la página, Dusk lo inyectará automáticamente en la página para que esté disponible durante la prueba.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Texto, valores y atributos</h3>\n  <h4>Recuperar y configurar valores</h4>\n  <p>Dusk proporciona varios métodos para interactuar con el texto de visualización actual, el valor y los atributos de los elementos de la página. Por ejemplo, para obtener el \"valor\" de un elemento que coincide con un selector dado, use el <code>value</code>método:</p>\n  <pre><code>// Retrieve the value...\n$value = $browser-&gt;value('selector');\n\n// Set the value...\n$browser-&gt;value('selector', 'value');</code></pre>\n  <p>Puede usar el <code>inputValue</code>método para obtener el \"valor\" de un elemento de entrada que tiene un nombre de campo determinado:</p>\n  <pre><code>// Retrieve the value of an input element...\n$inputValue = $browser-&gt;inputValue('field');</code></pre>\n  <h4>Recuperando texto</h4>\n  <p>El <code>text</code>método se puede utilizar para recuperar el texto de visualización de un elemento que coincide con el selector dado:</p>\n  <pre><code>$text = $browser-&gt;text('selector');</code></pre>\n  <h4>Recuperando atributos</h4>\n  <p>Finalmente, el <code>attribute</code>método puede usarse para recuperar un atributo de un elemento que coincida con el selector dado:</p>\n  <pre><code>$attribute = $browser-&gt;attribute('selector', 'value');</code></pre>\n  <p></p>\n  <h3>Usar formularios</h3>\n  <h4>Escribir valores</h4>\n  <p>Dusk proporciona una variedad de métodos para interactuar con formularios y elementos de entrada. Primero, echemos un vistazo a un ejemplo de cómo escribir texto en un campo de entrada:</p>\n  <pre><code>$browser-&gt;type('email', 'taylor@laravel.com');</code></pre>\n  <p>Tenga en cuenta que, aunque el método acepta uno si es necesario, no estamos obligados a pasar un selector de CSS al <code>type</code>método. Si no se proporciona un selector de CSS, Dusk buscará un campo de entrada con el <code>name</code>atributo dado . Finalmente, Dusk intentará encontrar un <code>textarea</code>con el <code>name</code>atributo dado .</p>\n  <p>Para agregar texto a un campo sin borrar su contenido, puede usar el <code>append</code>método:</p>\n  <pre><code>$browser-&gt;type('tags', 'foo')\n        -&gt;append('tags', ', bar, baz');</code></pre>\n  <p>Puede borrar el valor de una entrada usando el <code>clear</code>método:</p>\n  <pre><code>$browser-&gt;clear('email');</code></pre>\n  <p>Puedes indicarle a Dusk que escriba lentamente usando el <code>typeSlowly</code>método. De forma predeterminada, Dusk hará una pausa de 100 milisegundos entre pulsaciones de tecla. Para personalizar la cantidad de tiempo entre las pulsaciones de teclas, puede pasar la cantidad apropiada de milisegundos como segundo argumento del método:</p>\n  <pre><code>$browser-&gt;typeSlowly('mobile', '+1 (202) 555-5555');\n\n$browser-&gt;typeSlowly('mobile', '+1 (202) 555-5555', 300);</code></pre>\n  <p>Puede usar el <code>appendSlowly</code>método para agregar texto lentamente:</p>\n  <pre><code>$browser-&gt;type('tags', 'foo')\n        -&gt;appendSlowly('tags', ', bar, baz');</code></pre>\n  <h4>Listas deplegables</h4>\n  <p>Para seleccionar un valor en un cuadro de selección desplegable, puede utilizar el <code>select</code>método. Al igual que el <code>type</code>método, el <code>select</code>método no requiere un selector CSS completo. Al pasar un valor al <code>select</code>método, debe pasar el valor de la opción subyacente en lugar del texto de visualización:</p>\n  <pre><code>$browser-&gt;select('size', 'Large');</code></pre>\n  <p>Puede seleccionar una opción aleatoria omitiendo el segundo parámetro:</p>\n  <pre><code>$browser-&gt;select('size');</code></pre>\n  <h4>Casillas de verificación</h4>\n  <p>Para \"marcar\" un campo de casilla de verificación, puede utilizar el <code>check</code>método. Como muchos otros métodos relacionados con la entrada, no se requiere un selector completo de CSS. Si no se puede encontrar una coincidencia exacta del selector, Dusk buscará una casilla de verificación con un <code>name</code>atributo coincidente :</p>\n  <pre><code>$browser-&gt;check('terms');\n\n$browser-&gt;uncheck('terms');</code></pre>\n  <h4>Botones de radio</h4>\n  <p>To \"select\" a radio button option, you may use the <code>radio</code> method. Like many other input related methods, a full CSS selector is not required. If an exact selector match can't be found, Dusk will search for a radio with matching <code>name</code> and <code>value</code> attributes:</p>\n  <pre><code>$browser-&gt;radio('version', 'php7');</code></pre>\n  <p></p>\n  <h3>Attaching Files</h3>\n  <p>The <code>attach</code> method may be used to attach a file to a <code>file</code> input element. Like many other input related methods, a full CSS selector is not required. If an exact selector match can't be found, Dusk will search for a file input with matching <code>name</code> attribute:</p>\n  <pre><code>$browser-&gt;attach('photo', __DIR__.'/photos/me.png');</code></pre>\n  <blockquote>\n    <div><div></div><p> The attach function requires the <code>Zip</code> PHP extension to be installed and enabled on your server.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Using The Keyboard</h3>\n  <p>The <code>keys</code> method allows you to provide more complex input sequences to a given element than normally allowed by the <code>type</code> method. For example, you may hold modifier keys entering values. In this example, the <code>shift</code> key will be held while <code>taylor</code> is entered into the element matching the given selector. After <code>taylor</code> is typed, <code>otwell</code> will be typed without any modifier keys:</p>\n  <pre><code>$browser-&gt;keys('selector', ['{shift}', 'taylor'], 'otwell');</code></pre>\n  <p>You may even send a \"hot key\" to the primary CSS selector that contains your application:</p>\n  <pre><code>$browser-&gt;keys('.app', ['{command}', 'j']);</code></pre>\n  <blockquote>\n    <div><div></div><p> All modifier keys are wrapped in <code>{}</code> characters, and match the constants defined in the <code>Facebook\\WebDriver\\WebDriverKeys</code> class, which can be found on GitHub.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Using The Mouse</h3>\n  <h4>Clicking On Elements</h4>\n  <p>The <code>click</code> method may be used to \"click\" on an element matching the given selector:</p>\n  <pre><code>$browser-&gt;click('.selector');</code></pre>\n  <p>The <code>clickAtXPath</code> method may be used to \"click\" on an element matching the given XPath expression:</p>\n  <pre><code>$browser-&gt;clickAtXPath('//div[@class = \"selector\"]');</code></pre>\n  <p>The <code>clickAtPoint</code> method may be used to \"click\" on the topmost element at a given pair of coordinates relative to the viewable area of the browser:</p>\n  <pre><code>$browser-&gt;clickAtPoint(0, 0);</code></pre>\n  <p>The <code>doubleClick</code> method may be used to simulate the double \"click\" of a mouse:</p>\n  <pre><code>$browser-&gt;doubleClick();</code></pre>\n  <p>The <code>rightClick</code> method may be used to simulate the right \"click\" of a mouse:</p>\n  <pre><code>$browser-&gt;rightClick();\n\n$browser-&gt;rightClick('.selector');</code></pre>\n  <p>The <code>clickAndHold</code> method may be used to simulate a mouse button being clicked and held down. A subsequent call to the <code>releaseMouse</code> method will undo this behavior and release the mouse button:</p>\n  <pre><code>$browser-&gt;clickAndHold()\n        -&gt;pause(1000)\n        -&gt;releaseMouse();</code></pre>\n  <h4>Mouseover</h4>\n  <p>The <code>mouseover</code> method may be used when you need to move the mouse over an element matching the given selector:</p>\n  <pre><code>$browser-&gt;mouseover('.selector');</code></pre>\n  <h4>Drag &amp; Drop</h4>\n  <p>The <code>drag</code> method may be used to drag an element matching the given selector to another element:</p>\n  <pre><code>$browser-&gt;drag('.from-selector', '.to-selector');</code></pre>\n  <p>Or, you may drag an element in a single direction:</p>\n  <pre><code>$browser-&gt;dragLeft('.selector', 10);\n$browser-&gt;dragRight('.selector', 10);\n$browser-&gt;dragUp('.selector', 10);\n$browser-&gt;dragDown('.selector', 10);</code></pre>\n  <p>Finally, you may drag an element by a given offset:</p>\n  <pre><code>$browser-&gt;dragOffset('.selector', 10, 10);</code></pre>\n  <p></p>\n  <h3>JavaScript Dialogs</h3>\n  <p>Dusk provides various methods to interact with JavaScript Dialogs:</p>\n  <pre><code>// Wait for a dialog to appear:\n$browser-&gt;waitForDialog($seconds = null);\n\n// Assert that a dialog has been displayed and that its message matches the given value:\n$browser-&gt;assertDialogOpened('value');\n\n// Type the given value in an open JavaScript prompt dialog:\n$browser-&gt;typeInDialog('Hello World');</code></pre>\n  <p>To close an opened JavaScript Dialog, clicking the OK button:</p>\n  <pre><code>$browser-&gt;acceptDialog();</code></pre>\n  <p>To close an opened JavaScript Dialog, clicking the Cancel button (for a confirmation dialog only):</p>\n  <pre><code>$browser-&gt;dismissDialog();</code></pre>\n  <p></p>\n  <h3>Scoping Selectors</h3>\n  <p>Sometimes you may wish to perform several operations while scoping all of the operations within a given selector. For example, you may wish to assert that some text exists only within a table and then click a button within that table. You may use the <code>with</code> method to accomplish this. All operations performed within the callback given to the <code>with</code> method will be scoped to the original selector:</p>\n  <pre><code>$browser-&gt;with('.table', function ($table) {\n    $table-&gt;assertSee('Hello World')\n          -&gt;clickLink('Delete');\n});</code></pre>\n  <p>You may occasionally need to execute assertions outside of the current scope. You may use the <code>elsewhere</code> method to accomplish this:</p>\n  <pre><code> $browser-&gt;with('.table', function ($table) {\n    // Current scope is `body .table`...\n    $browser-&gt;elsewhere('.page-title', function ($title) {\n        // Current scope is `body .page-title`...\n        $title-&gt;assertSee('Hello World');\n    });\n });</code></pre>\n  <p></p>\n  <h3>Waiting For Elements</h3>\n  <p>When testing applications that use JavaScript extensively, it often becomes necessary to \"wait\" for certain elements or data to be available before proceeding with a test. Dusk makes this a cinch. Using a variety of methods, you may wait for elements to be visible on the page or even wait until a given JavaScript expression evaluates to <code>true</code>.</p>\n  <h4>Waiting</h4>\n  <p>If you need to pause the test for a given number of milliseconds, use the <code>pause</code> method:</p>\n  <pre><code>$browser-&gt;pause(1000);</code></pre>\n  <h4>Waiting For Selectors</h4>\n  <p>The <code>waitFor</code> method may be used to pause the execution of the test until the element matching the given CSS selector is displayed on the page. By default, this will pause the test for a maximum of five seconds before throwing an exception. If necessary, you may pass a custom timeout threshold as the second argument to the method:</p>\n  <pre><code>// Wait a maximum of five seconds for the selector...\n$browser-&gt;waitFor('.selector');\n\n// Wait a maximum of one second for the selector...\n$browser-&gt;waitFor('.selector', 1);</code></pre>\n  <p>You may also wait until the given selector is missing from the page:</p>\n  <pre><code>$browser-&gt;waitUntilMissing('.selector');\n\n$browser-&gt;waitUntilMissing('.selector', 1);</code></pre>\n  <h4>Scoping Selectors When Available</h4>\n  <p>Occasionally, you may wish to wait for a given selector and then interact with the element matching the selector. For example, you may wish to wait until a modal window is available and then press the \"OK\" button within the modal. The <code>whenAvailable</code> method may be used in this case. All element operations performed within the given callback will be scoped to the original selector:</p>\n  <pre><code>$browser-&gt;whenAvailable('.modal', function ($modal) {\n    $modal-&gt;assertSee('Hello World')\n          -&gt;press('OK');\n});</code></pre>\n  <h4>Waiting For Text</h4>\n  <p>The <code>waitForText</code> method may be used to wait until the given text is displayed on the page:</p>\n  <pre><code>// Wait a maximum of five seconds for the text...\n$browser-&gt;waitForText('Hello World');\n\n// Wait a maximum of one second for the text...\n$browser-&gt;waitForText('Hello World', 1);</code></pre>\n  <p>You may use the <code>waitUntilMissingText</code> method to wait until the displayed text has been removed from the page:</p>\n  <pre><code>// Wait a maximum of five seconds for the text to be removed...\n$browser-&gt;waitUntilMissingText('Hello World');\n\n// Wait a maximum of one second for the text to be removed...\n$browser-&gt;waitUntilMissingText('Hello World', 1);</code></pre>\n  <h4>Waiting For Links</h4>\n  <p>The <code>waitForLink</code> method may be used to wait until the given link text is displayed on the page:</p>\n  <pre><code>// Wait a maximum of five seconds for the link...\n$browser-&gt;waitForLink('Create');\n\n// Wait a maximum of one second for the link...\n$browser-&gt;waitForLink('Create', 1);</code></pre>\n  <h4>Esperando en la ubicación de la página</h4>\n  <p>Al realizar una aserción de ruta como , la aserción puede fallar si se actualiza de forma asincrónica. Puede usar el método para esperar a que la ubicación tenga un valor dado:<code>$browser-&gt;assertPathIs('/home')</code><code>window.location.pathname</code><code>waitForLocation</code></p>\n  <pre><code>$browser-&gt;waitForLocation('/secret');</code></pre>\n  <p>También puede esperar la ubicación de una ruta con nombre:</p>\n  <pre><code>$browser-&gt;waitForRoute($routeName, $parameters);</code></pre>\n  <h4>Esperando recargas de página</h4>\n  <p>Si necesita hacer afirmaciones después de que se haya vuelto a cargar una página, use el <code>waitForReload</code>método:</p>\n  <pre><code>$browser-&gt;click('.some-action')\n        -&gt;waitForReload()\n        -&gt;assertSee('something');</code></pre>\n  <h4>Esperando expresiones de JavaScript</h4>\n  <p>A veces, es posible que desee pausar la ejecución de una prueba hasta que una expresión de JavaScript determinada se evalúe como <code>true</code>. Puede lograr esto fácilmente usando el <code>waitUntil</code>método. Al pasar una expresión a este método, no es necesario que incluya la <code>return</code>palabra clave o un punto y coma final:</p>\n  <pre><code>// Wait a maximum of five seconds for the expression to be true...\n$browser-&gt;waitUntil('App.dataLoaded');\n\n$browser-&gt;waitUntil('App.data.servers.length &gt; 0');\n\n// Wait a maximum of one second for the expression to be true...\n$browser-&gt;waitUntil('App.data.servers.length &gt; 0', 1);</code></pre>\n  <h4>Esperando Expresiones Vue</h4>\n  <p>Se pueden usar los siguientes métodos para esperar hasta que un atributo de componente de Vue determinado tenga un valor determinado:</p>\n  <pre><code>// Wait until the component attribute contains the given value...\n$browser-&gt;waitUntilVue('user.name', 'Taylor', '@user');\n\n// Wait until the component attribute doesn't contain the given value...\n$browser-&gt;waitUntilVueIsNot('user.name', null, '@user');</code></pre>\n  <h4>Esperando con una devolución de llamada</h4>\n  <p>Muchos de los métodos de \"espera\" de Dusk se basan en el <code>waitUsing</code>método subyacente . Puede usar este método directamente para esperar a que regrese una devolución de llamada determinada <code>true</code>. El <code>waitUsing</code>método acepta el número máximo de segundos de espera, el intervalo en el que se debe evaluar el cierre, el cierre y un mensaje de error opcional:</p>\n  <pre><code>$browser-&gt;waitUsing(10, 1, function () use ($something) {\n    return $something-&gt;isReady();\n}, \"Something wasn't ready in time.\");</code></pre>\n  <p></p>\n  <h3>Desplazamiento de un elemento a la vista</h3>\n  <p>A veces, es posible que no pueda hacer clic en un elemento porque está fuera del área visible del navegador. El <code>scrollIntoView</code>método desplazará la ventana del navegador hasta que el elemento en el selector dado esté dentro de la vista:</p>\n  <pre><code>$browser-&gt;scrollIntoView('selector')\n        -&gt;click('selector');</code></pre>\n  <p></p>\n  <h3>Hacer afirmaciones de Vue</h3>\n  <p>Dusk incluso le permite hacer afirmaciones sobre el estado de los datos de los componentes de Vue . Por ejemplo, imagine que su aplicación contiene el siguiente componente de Vue:</p>\n  <pre><code>// HTML...\n\n&lt;profile dusk=\"profile-component\"&gt;&lt;/profile&gt;\n\n// Component Definition...\n\nVue.component('profile', {\n    template: '&lt;div&gt;{{ user.name }}&lt;/div&gt;',\n\n    data: function () {\n        return {\n            user: {\n                name: 'Taylor'\n            }\n        };\n    }\n});</code></pre>\n  <p>Puede afirmar sobre el estado del componente Vue así:</p>\n  <pre><code>/**\n * A basic Vue test example.\n *\n * @return void\n */\npublic function testVue()\n{\n    $this-&gt;browse(function (Browser $browser) {\n        $browser-&gt;visit('/')\n                -&gt;assertVue('user.name', 'Taylor', '@profile-component');\n    });\n}</code></pre>\n  <p></p>\n  <h2>Afirmaciones disponibles</h2>\n  <p>Dusk proporciona una variedad de afirmaciones que puede hacer en contra de su solicitud. Todas las afirmaciones disponibles se documentan en la siguiente lista:</p>\n  <style>\n    .collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    .collection-method-list a {\n        display: block;\n    }\n</style>\n  <div>\n    <p>assertTitle\n      assertTitleContains\n      asertUrlIs\n      assertSchemeIs\n      assertSchemeIsNot\n      asertHostIs\n      asertHostIsNot\n      AsertPortIs\n      assertPortIsNot\n      assertPathBeginsWith\n      AsertPathIs\n      assertPathIsNot\n      asertRouteIs\n      asertQueryStringHas\n      asertQueryStringMissing\n      assertFragmentIs\n      assertFragmentBeginsWith\n      assertFragmentIsNot\n      assertHasCookie\n      assertHasPlainCookie\n      afirmarCookieMissing\n      assertPlainCookieMissing\n      asertCookieValue\n      assertPlainCookieValue\n      aseverarVer\n      AsertDontSee\n      afirmarSeeIn\n      assertDontSeeIn\n      assertSourceHas\n      assertSourceMissing\n      assertSeeLink\n      assertDontSeeLink\n      assertInputValue\n      assertInputValueIsNot\n      assertChecked\n      assertNotChecked\n      assertRadioSelected\n      assertRadioNotSelected\n      assertSelected\n      assertNotSelected\n      assertSelectHasOptions\n      assertSelectMissingOption\n      assertSelectMissingOptions\n      assertSelectHasOption\n      assertValue\n      assertAttribute\n      assertAriaAttribute\n      assertDataAttribute\n      assertVisible\n      assertPresent\n      assertMissing\n      assertDialogOpened\n      assertEnabled\n      assertDisabled\n      assertButtonEnabled\n      assertButtonDisabled\n      assertFocused\n      assertNotFocused\n      assertAuthenticated\n      assertGuest\n      assertAuthenticatedAs\n      assertVue\n      assertVueIsNot\n      assertVueContains\n      assertVueDoesNotContain</p>\n  </div>\n  <p></p>\n  <h4>assertTitle</h4>\n  <p>Assert that the page title matches the given text:</p>\n  <pre><code>$browser-&gt;assertTitle($title);</code></pre>\n  <p></p>\n  <h4>assertTitleContains</h4>\n  <p>Assert that the page title contains the given text:</p>\n  <pre><code>$browser-&gt;assertTitleContains($title);</code></pre>\n  <p></p>\n  <h4>assertUrlIs</h4>\n  <p>Afirma que la URL actual (sin la cadena de consulta) coincide con la cadena dada:</p>\n  <pre><code>$browser-&gt;assertUrlIs($url);</code></pre>\n  <p></p>\n  <h4>assertSchemeIs</h4>\n  <p>Afirmar que el esquema de URL actual coincide con el esquema dado:</p>\n  <pre><code>$browser-&gt;assertSchemeIs($scheme);</code></pre>\n  <p></p>\n  <h4>assertSchemeIsNot</h4>\n  <p>Afirme que el esquema de URL actual no coincide con el esquema dado:</p>\n  <pre><code>$browser-&gt;assertSchemeIsNot($scheme);</code></pre>\n  <p></p>\n  <h4>asertHostIs</h4>\n  <p>Confirme que el host de la URL actual coincide con el host dado:</p>\n  <pre><code>$browser-&gt;assertHostIs($host);</code></pre>\n  <p></p>\n  <h4>asertHostIsNot</h4>\n  <p>Afirme que el host de la URL actual no coincide con el host dado:</p>\n  <pre><code>$browser-&gt;assertHostIsNot($host);</code></pre>\n  <p></p>\n  <h4>AsertPortIs</h4>\n  <p>Confirme que el puerto URL actual coincide con el puerto dado:</p>\n  <pre><code>$browser-&gt;assertPortIs($port);</code></pre>\n  <p></p>\n  <h4>assertPortIsNot</h4>\n  <p>Afirme que el puerto URL actual no coincide con el puerto dado:</p>\n  <pre><code>$browser-&gt;assertPortIsNot($port);</code></pre>\n  <p></p>\n  <h4>assertPathBeginsWith</h4>\n  <p>Afirme que la ruta URL actual comienza con la ruta dada:</p>\n  <pre><code>$browser-&gt;assertPathBeginsWith($path);</code></pre>\n  <p></p>\n  <h4>AsertPathIs</h4>\n  <p>Afirme que la ruta actual coincide con la ruta dada:</p>\n  <pre><code>$browser-&gt;assertPathIs('/home');</code></pre>\n  <p></p>\n  <h4>assertPathIsNot</h4>\n  <p>Afirme que la ruta actual no coincide con la ruta dada:</p>\n  <pre><code>$browser-&gt;assertPathIsNot('/home');</code></pre>\n  <p></p>\n  <h4>asertRouteIs</h4>\n  <p>Afirmar que la URL actual coincide con la URL de la ruta con nombre dada:</p>\n  <pre><code>$browser-&gt;assertRouteIs($name, $parameters);</code></pre>\n  <p></p>\n  <h4>asertQueryStringHas</h4>\n  <p>Afirmar que el parámetro de cadena de consulta dado está presente:</p>\n  <pre><code>$browser-&gt;assertQueryStringHas($name);</code></pre>\n  <p>Afirmar que el parámetro de cadena de consulta dado está presente y tiene un valor dado:</p>\n  <pre><code>$browser-&gt;assertQueryStringHas($name, $value);</code></pre>\n  <p></p>\n  <h4>asertQueryStringMissing</h4>\n  <p>Afirmar que falta el parámetro de cadena de consulta proporcionado:</p>\n  <pre><code>$browser-&gt;assertQueryStringMissing($name);</code></pre>\n  <p></p>\n  <h4>assertFragmentIs</h4>\n  <p>Afirma que el fragmento actual coincide con el fragmento dado:</p>\n  <pre><code>$browser-&gt;assertFragmentIs('anchor');</code></pre>\n  <p></p>\n  <h4>assertFragmentBeginsWith</h4>\n  <p>Afirme que el fragmento actual comienza con el fragmento dado:</p>\n  <pre><code>$browser-&gt;assertFragmentBeginsWith('anchor');</code></pre>\n  <p></p>\n  <h4>assertFragmentIsNot</h4>\n  <p>Afirme que el fragmento actual no coincide con el fragmento dado:</p>\n  <pre><code>$browser-&gt;assertFragmentIsNot('anchor');</code></pre>\n  <p></p>\n  <h4>assertHasCookie</h4>\n  <p>Confirme que la cookie cifrada proporcionada está presente:</p>\n  <pre><code>$browser-&gt;assertHasCookie($name);</code></pre>\n  <p></p>\n  <h4>assertHasPlainCookie</h4>\n  <p>Confirme que la cookie no encriptada dada está presente:</p>\n  <pre><code>$browser-&gt;assertHasPlainCookie($name);</code></pre>\n  <p></p>\n  <h4>afirmarCookieMissing</h4>\n  <p>Confirme que la cookie cifrada proporcionada no está presente:</p>\n  <pre><code>$browser-&gt;assertCookieMissing($name);</code></pre>\n  <p></p>\n  <h4>assertPlainCookieMissing</h4>\n  <p>Confirme que la cookie no cifrada proporcionada no está presente:</p>\n  <pre><code>$browser-&gt;assertPlainCookieMissing($name);</code></pre>\n  <p></p>\n  <h4>asertCookieValue</h4>\n  <p>Afirmar que una cookie cifrada tiene un valor determinado:</p>\n  <pre><code>$browser-&gt;assertCookieValue($name, $value);</code></pre>\n  <p></p>\n  <h4>assertPlainCookieValue</h4>\n  <p>Afirmar que una cookie no cifrada tiene un valor determinado:</p>\n  <pre><code>$browser-&gt;assertPlainCookieValue($name, $value);</code></pre>\n  <p></p>\n  <h4>aseverarVer</h4>\n  <p>Afirmar que el texto dado está presente en la página:</p>\n  <pre><code>$browser-&gt;assertSee($text);</code></pre>\n  <p></p>\n  <h4>AsertDontSee</h4>\n  <p>Afirme que el texto dado no está presente en la página:</p>\n  <pre><code>$browser-&gt;assertDontSee($text);</code></pre>\n  <p></p>\n  <h4>afirmarSeeIn</h4>\n  <p>Afirmar que el texto dado está presente dentro del selector:</p>\n  <pre><code>$browser-&gt;assertSeeIn($selector, $text);</code></pre>\n  <p></p>\n  <h4>AsertDontSeeIn</h4>\n  <p>Afirma que el texto dado no está presente en el selector:</p>\n  <pre><code>$browser-&gt;assertDontSeeIn($selector, $text);</code></pre>\n  <p></p>\n  <h4>asertSourceHas</h4>\n  <p>Afirme que el código fuente dado está presente en la página:</p>\n  <pre><code>$browser-&gt;assertSourceHas($code);</code></pre>\n  <p></p>\n  <h4>asertSourceMissing</h4>\n  <p>Afirme que el código fuente proporcionado no está presente en la página:</p>\n  <pre><code>$browser-&gt;assertSourceMissing($code);</code></pre>\n  <p></p>\n  <h4>asertSeeLink</h4>\n  <p>Afirme que el enlace dado está presente en la página:</p>\n  <pre><code>$browser-&gt;assertSeeLink($linkText);</code></pre>\n  <p></p>\n  <h4>asertDontSeeLink</h4>\n  <p>Afirma que el enlace proporcionado no está presente en la página:</p>\n  <pre><code>$browser-&gt;assertDontSeeLink($linkText);</code></pre>\n  <p></p>\n  <h4>asertInputValue</h4>\n  <p>Asegrese que el campo de entrada dado tiene el valor dado:</p>\n  <pre><code>$browser-&gt;assertInputValue($field, $value);</code></pre>\n  <p></p>\n  <h4>assertInputValueIsNot</h4>\n  <p>Afirmar que el campo de entrada dado no tiene el valor dado:</p>\n  <pre><code>$browser-&gt;assertInputValueIsNot($field, $value);</code></pre>\n  <p></p>\n  <h4>aseverar</h4>\n  <p>Confirme que la casilla de verificación dada está marcada:</p>\n  <pre><code>$browser-&gt;assertChecked($field);</code></pre>\n  <p></p>\n  <h4>asertNotChecked</h4>\n  <p>Afirmar que la casilla de verificación dada no está marcada:</p>\n  <pre><code>$browser-&gt;assertNotChecked($field);</code></pre>\n  <p></p>\n  <h4>assertRadioSelected</h4>\n  <p>Confirme que el campo de radio dado está seleccionado:</p>\n  <pre><code>$browser-&gt;assertRadioSelected($field, $value);</code></pre>\n  <p></p>\n  <h4>asertRadioNotSelected</h4>\n  <p>Afirmar que el campo de radio dado no está seleccionado:</p>\n  <pre><code>$browser-&gt;assertRadioNotSelected($field, $value);</code></pre>\n  <p></p>\n  <h4>aseverarSeleccionado</h4>\n  <p>Afirmar que el menú desplegable dado tiene el valor dado seleccionado:</p>\n  <pre><code>$browser-&gt;assertSelected($field, $value);</code></pre>\n  <p></p>\n  <h4>assertNotSelected</h4>\n  <p>Afirme que el menú desplegable proporcionado no tiene el valor dado seleccionado:</p>\n  <pre><code>$browser-&gt;assertNotSelected($field, $value);</code></pre>\n  <p></p>\n  <h4>asertSelectHasOptions</h4>\n  <p>Afirmar que la matriz de valores dada está disponible para ser seleccionada:</p>\n  <pre><code>$browser-&gt;assertSelectHasOptions($field, $values);</code></pre>\n  <p></p>\n  <h4>asertSelectMissingOption</h4>\n  <p>Afirmar que el valor dado no está disponible para ser seleccionado:</p>\n  <pre><code>$browser-&gt;assertSelectMissingOption($field, $value);</code></pre>\n  <p></p>\n  <h4>asertSelectMissingOptions</h4>\n  <p>Afirmar que la matriz de valores dada no está disponible para ser seleccionada:</p>\n  <pre><code>$browser-&gt;assertSelectMissingOptions($field, $values);</code></pre>\n  <p></p>\n  <h4>asertSelectHasOption</h4>\n  <p>Afirmar que el valor dado está disponible para ser seleccionado en el campo dado:</p>\n  <pre><code>$browser-&gt;assertSelectHasOption($field, $value);</code></pre>\n  <p></p>\n  <h4>asertValue</h4>\n  <p>Afirma que el elemento que coincide con el selector dado tiene el valor dado:</p>\n  <pre><code>$browser-&gt;assertValue($selector, $value);</code></pre>\n  <p></p>\n  <h4>assertAttribute</h4>\n  <p>Afirmar que el elemento que coincide con el selector dado tiene el valor dado en el atributo proporcionado:</p>\n  <pre><code>$browser-&gt;assertAttribute($selector, $attribute, $value);</code></pre>\n  <p></p>\n  <h4>asertAriaAttribute</h4>\n  <p>Afirma que el elemento que coincide con el selector dado tiene el valor dado en el atributo aria proporcionado:</p>\n  <pre><code>$browser-&gt;assertAriaAttribute($selector, $attribute, $value);</code></pre>\n  <p>Por ejemplo, dado el marcado , puede afirmar contra el atributo de esta manera:<code>&lt;button aria-label=\"Add\"&gt;&lt;/button&gt;</code><code>aria-label</code></p>\n  <pre><code>$browser-&gt;assertAriaAttribute('button', 'label', 'Add')</code></pre>\n  <p></p>\n  <h4>asertDataAttribute</h4>\n  <p>Afirmar que el elemento que coincide con el selector dado tiene el valor dado en el atributo de datos proporcionado:</p>\n  <pre><code>$browser-&gt;assertDataAttribute($selector, $attribute, $value);</code></pre>\n  <p>Por ejemplo, dado el marcado , puede afirmar contra el atributo de esta manera:<code>&lt;tr id=\"row-1\" data-content=\"attendees\"&gt;&lt;/tr&gt;</code><code>data-label</code></p>\n  <pre><code>$browser-&gt;assertDataAttribute('#row-1', 'content', 'attendees')</code></pre>\n  <p></p>\n  <h4>asertVisible</h4>\n  <p>Afirma que el elemento que coincide con el selector dado es visible:</p>\n  <pre><code>$browser-&gt;assertVisible($selector);</code></pre>\n  <p></p>\n  <h4>afirmarPresente</h4>\n  <p>Afirmar que el elemento que coincide con el selector dado está presente:</p>\n  <pre><code>$browser-&gt;assertPresent($selector);</code></pre>\n  <p></p>\n  <h4>aseverar</h4>\n  <p>Afirma que el elemento que coincide con el selector dado no es visible:</p>\n  <pre><code>$browser-&gt;assertMissing($selector);</code></pre>\n  <p></p>\n  <h4>assertDialogOpened</h4>\n  <p>Confirme que se ha abierto un cuadro de diálogo de JavaScript con el mensaje dado:</p>\n  <pre><code>$browser-&gt;assertDialogOpened($message);</code></pre>\n  <p></p>\n  <h4>asertEnabled</h4>\n  <p>Confirme que el campo dado está habilitado:</p>\n  <pre><code>$browser-&gt;assertEnabled($field);</code></pre>\n  <p></p>\n  <h4>AsertDisabled</h4>\n  <p>Afirma que el campo dado está deshabilitado:</p>\n  <pre><code>$browser-&gt;assertDisabled($field);</code></pre>\n  <p></p>\n  <h4>assertButtonEnabled</h4>\n  <p>Afirma que el botón dado está habilitado:</p>\n  <pre><code>$browser-&gt;assertButtonEnabled($button);</code></pre>\n  <p></p>\n  <h4>assertButtonDisabled</h4>\n  <p>Afirma que el botón dado está deshabilitado:</p>\n  <pre><code>$browser-&gt;assertButtonDisabled($button);</code></pre>\n  <p></p>\n  <h4>aseverarFocused</h4>\n  <p>Afirmar que el campo dado está enfocado:</p>\n  <pre><code>$browser-&gt;assertFocused($field);</code></pre>\n  <p></p>\n  <h4>afirmarNotFocused</h4>\n  <p>Afirmar que el campo dado no está enfocado:</p>\n  <pre><code>$browser-&gt;assertNotFocused($field);</code></pre>\n  <p></p>\n  <h4>afirmarAuthenticated</h4>\n  <p>Afirmar que el usuario está autenticado:</p>\n  <pre><code>$browser-&gt;assertAuthenticated();</code></pre>\n  <p></p>\n  <h4>AsertGuest</h4>\n  <p>Afirmar que el usuario no está autenticado:</p>\n  <pre><code>$browser-&gt;assertGuest();</code></pre>\n  <p></p>\n  <h4>assertAuthenticatedAs</h4>\n  <p>Afirmar que el usuario está autenticado como el usuario dado:</p>\n  <pre><code>$browser-&gt;assertAuthenticatedAs($user);</code></pre>\n  <p></p>\n  <h4>asertVue</h4>\n  <p>Afirmar que una propiedad de datos del componente de Vue determinada coincide con el valor dado:</p>\n  <pre><code>$browser-&gt;assertVue($property, $value, $componentSelector = null);</code></pre>\n  <p></p>\n  <h4>asertVueIsNot</h4>\n  <p>Afirme que una propiedad de datos del componente Vue dada no coincide con el valor dado:</p>\n  <pre><code>$browser-&gt;assertVueIsNot($property, $value, $componentSelector = null);</code></pre>\n  <p></p>\n  <h4>asertVueContains</h4>\n  <p>Afirmar que una propiedad de datos de un componente de Vue dada es una matriz y contiene el valor dado:</p>\n  <pre><code>$browser-&gt;assertVueContains($property, $value, $componentSelector = null);</code></pre>\n  <p></p>\n  <h4>asertVueDoesNotContain</h4>\n  <p>Afirme que una propiedad de datos de componente de Vue dada es una matriz y no contiene el valor dado:</p>\n  <pre><code>$browser-&gt;assertVueDoesNotContain($property, $value, $componentSelector = null);</code></pre>\n  <p></p>\n  <h2>Páginas</h2>\n  <p>A veces, las pruebas requieren que se realicen varias acciones complicadas en secuencia. Esto puede hacer que sus pruebas sean más difíciles de leer y comprender. Las páginas le permiten definir acciones expresivas que luego se pueden realizar en una página determinada utilizando un único método. Las páginas también le permiten definir accesos directos a selectores comunes para su aplicación o una sola página.</p>\n  <p></p>\n  <h3>Generando páginas</h3>\n  <p>Para generar un objeto de página, use el comando Artisan. Todos los objetos de la página se colocarán en el directorio:<code>dusk:page</code><code>tests/Browser/Pages</code></p>\n  <pre><code>php artisan dusk:page Login</code></pre>\n  <p></p>\n  <h3>Configurar páginas</h3>\n  <p>Por defecto, las páginas tienen tres métodos: <code>url</code>, <code>assert</code>, y <code>elements</code>. Discutiremos los métodos <code>url</code>y <code>assert</code>ahora. El <code>elements</code>método se discutirá con más detalle a continuación .</p>\n  <h4>El <code>url</code>método</h4>\n  <p>El <code>url</code>método debe devolver la ruta de la URL que representa la página. Dusk usará esta URL cuando navegue a la página en el navegador:</p>\n  <pre><code>/**\n * Get the URL for the page.\n *\n * @return string\n */\npublic function url()\n{\n    return '/login';\n}</code></pre>\n  <h4>El <code>assert</code>método</h4>\n  <p>El <code>assert</code>método puede hacer las afirmaciones necesarias para verificar que el navegador se encuentra realmente en la página dada. No es necesario completar este método; sin embargo, puede hacer estas afirmaciones si lo desea. Estas afirmaciones se ejecutarán automáticamente al navegar a la página:</p>\n  <pre><code>/**\n * Assert that the browser is on the page.\n *\n * @return void\n */\npublic function assert(Browser $browser)\n{\n    $browser-&gt;assertPathIs($this-&gt;url());\n}</code></pre>\n  <p></p>\n  <h3>Navegación a páginas</h3>\n  <p>Una vez que se ha configurado una página, puede navegar a ella usando el <code>visit</code>método:</p>\n  <pre><code>use Tests\\Browser\\Pages\\Login;\n\n$browser-&gt;visit(new Login);</code></pre>\n  <p>Puede usar el <code>visitRoute</code>método para navegar a una ruta con nombre:</p>\n  <pre><code>$browser-&gt;visitRoute('login');</code></pre>\n  <p>Puede navegar \"atrás\" y \"adelante\" utilizando los métodos <code>back</code>y <code>forward</code>:</p>\n  <pre><code>$browser-&gt;back();\n\n$browser-&gt;forward();</code></pre>\n  <p>You may use the <code>refresh</code> method to refresh the page:</p>\n  <pre><code>$browser-&gt;refresh();</code></pre>\n  <p>Sometimes you may already be on a given page and need to \"load\" the page's selectors and methods into the current test context. This is common when pressing a button and being redirected to a given page without explicitly navigating to it. In this situation, you may use the <code>on</code> method to load the page:</p>\n  <pre><code>use Tests\\Browser\\Pages\\CreatePlaylist;\n\n$browser-&gt;visit('/dashboard')\n        -&gt;clickLink('Create Playlist')\n        -&gt;on(new CreatePlaylist)\n        -&gt;assertSee('@create');</code></pre>\n  <p></p>\n  <h3>Shorthand Selectors</h3>\n  <p>The <code>elements</code> method of pages allows you to define quick, easy-to-remember shortcuts for any CSS selector on your page. For example, let's define a shortcut for the \"email\" input field of the application's login page:</p>\n  <pre><code>/**\n * Get the element shortcuts for the page.\n *\n * @return array\n */\npublic function elements()\n{\n    return [\n        '@email' =&gt; 'input[name=email]',\n    ];\n}</code></pre>\n  <p>Now, you may use this shorthand selector anywhere you would use a full CSS selector:</p>\n  <pre><code>$browser-&gt;type('@email', 'taylor@laravel.com');</code></pre>\n  <h4>Global Shorthand Selectors</h4>\n  <p>Después de instalar Dusk, <code>Page</code>se colocará una clase base en su directorio. Esta clase contiene un método que se puede utilizar para definir selectores de taquigrafía globales que deberían estar disponibles en todas las páginas de su aplicación:<code>tests/Browser/Pages</code><code>siteElements</code></p>\n  <pre><code>/**\n * Get the global element shortcuts for the site.\n *\n * @return array\n */\npublic static function siteElements()\n{\n    return [\n        '@element' =&gt; '#selector',\n    ];\n}</code></pre>\n  <p></p>\n  <h3>Métodos de página</h3>\n  <p>Además de los métodos predeterminados definidos en las páginas, puede definir métodos adicionales que se pueden utilizar a lo largo de sus pruebas. Por ejemplo, imaginemos que estamos creando una aplicación de gestión de música. Una acción común para una página de la aplicación podría ser crear una lista de reproducción. En lugar de volver a escribir la lógica para crear una lista de reproducción en cada prueba, puede definir un <code>createPlaylist</code>método en una clase de página:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Browser\\Pages;\n\nuse Laravel\\Dusk\\Browser;\n\nclass Dashboard extends Page\n{\n    // Other page methods...\n\n    /**\n     * Create a new playlist.\n     *\n     * @param  \\Laravel\\Dusk\\Browser  $browser\n     * @param  string  $name\n     * @return void\n     */\n    public function createPlaylist(Browser $browser, $name)\n    {\n        $browser-&gt;type('name', $name)\n                -&gt;check('share')\n                -&gt;press('Create Playlist');\n    }\n}</code></pre>\n  <p>Una vez que se ha definido el método, puede utilizarlo en cualquier prueba que utilice la página. La instancia del navegador se pasará automáticamente al método de la página:</p>\n  <pre><code>use Tests\\Browser\\Pages\\Dashboard;\n\n$browser-&gt;visit(new Dashboard)\n        -&gt;createPlaylist('My Playlist')\n        -&gt;assertSee('My Playlist');</code></pre>\n  <p></p>\n  <h2>Componentes</h2>\n  <p>Los componentes son similares a los \"objetos de página\" de Dusk, pero están pensados \u200B\u200Bpara piezas de IU y funcionalidad que se reutilizan en toda la aplicación, como una barra de navegación o una ventana de notificación. Como tal, los componentes no están vinculados a URL específicas.</p>\n  <p></p>\n  <h3>Generación de componentes</h3>\n  <p>Para generar un componente, use el comando Artisan. Los nuevos componentes se colocan en el directorio:<code>dusk:component</code><code>tests/Browser/Components</code></p>\n  <pre><code>php artisan dusk:component DatePicker</code></pre>\n  <p>Como se muestra arriba, un \"selector de fecha\" es un ejemplo de un componente que puede existir en su aplicación en una variedad de páginas. Puede resultar engorroso escribir manualmente la lógica de automatización del navegador para seleccionar una fecha en docenas de pruebas en todo el conjunto de pruebas. En cambio, podemos definir un componente Dusk para representar el selector de fecha, lo que nos permite encapsular esa lógica dentro del componente:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Browser\\Components;\n\nuse Laravel\\Dusk\\Browser;\nuse Laravel\\Dusk\\Component as BaseComponent;\n\nclass DatePicker extends BaseComponent\n{\n    /**\n     * Get the root selector for the component.\n     *\n     * @return string\n     */\n    public function selector()\n    {\n        return '.date-picker';\n    }\n\n    /**\n     * Assert that the browser page contains the component.\n     *\n     * @param  Browser  $browser\n     * @return void\n     */\n    public function assert(Browser $browser)\n    {\n        $browser-&gt;assertVisible($this-&gt;selector());\n    }\n\n    /**\n     * Get the element shortcuts for the component.\n     *\n     * @return array\n     */\n    public function elements()\n    {\n        return [\n            '@date-field' =&gt; 'input.datepicker-input',\n            '@year-list' =&gt; 'div &gt; div.datepicker-years',\n            '@month-list' =&gt; 'div &gt; div.datepicker-months',\n            '@day-list' =&gt; 'div &gt; div.datepicker-days',\n        ];\n    }\n\n    /**\n     * Select the given date.\n     *\n     * @param  \\Laravel\\Dusk\\Browser  $browser\n     * @param  int  $year\n     * @param  int  $month\n     * @param  int  $day\n     * @return void\n     */\n    public function selectDate($browser, $year, $month, $day)\n    {\n        $browser-&gt;click('@date-field')\n                -&gt;within('@year-list', function ($browser) use ($year) {\n                    $browser-&gt;click($year);\n                })\n                -&gt;within('@month-list', function ($browser) use ($month) {\n                    $browser-&gt;click($month);\n                })\n                -&gt;within('@day-list', function ($browser) use ($day) {\n                    $browser-&gt;click($day);\n                });\n    }\n}</code></pre>\n  <p></p>\n  <h3>Usando componentes</h3>\n  <p>Una vez que se ha definido el componente, podemos seleccionar fácilmente una fecha dentro del selector de fechas de cualquier prueba. Y, si cambia la lógica necesaria para seleccionar una fecha, solo necesitamos actualizar el componente:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Browser;\n\nuse Illuminate\\Foundation\\Testing\\DatabaseMigrations;\nuse Laravel\\Dusk\\Browser;\nuse Tests\\Browser\\Components\\DatePicker;\nuse Tests\\DuskTestCase;\n\nclass ExampleTest extends DuskTestCase\n{\n    /**\n     * A basic component test example.\n     *\n     * @return void\n     */\n    public function testBasicExample()\n    {\n        $this-&gt;browse(function (Browser $browser) {\n            $browser-&gt;visit('/')\n                    -&gt;within(new DatePicker, function ($browser) {\n                        $browser-&gt;selectDate(2019, 1, 30);\n                    })\n                    -&gt;assertSee('January');\n        });\n    }\n}</code></pre>\n  <p></p>\n  <h2>Integración continua</h2>\n  <blockquote>\n    <div><div></div><p>Antes de agregar un archivo de configuración de integración continua, asegúrese de que su archivo contenga una entrada con un valor de .<code>.env.testing</code><code>APP_URL</code><code>http://127.0.0.1:8000</code></p></div>\n  </blockquote>\n  <p></p>\n  <h3>CircleCI</h3>\n  <p>Si está utilizando CircleCI para ejecutar sus pruebas Dusk, puede utilizar este archivo de configuración como punto de partida. Al igual que TravisCI, usaremos el <code>php artisan serve</code>comando para iniciar el servidor web integrado de PHP:</p>\n  <pre><code>version: 2\njobs:\n    build:\n        steps:\n            - run: sudo apt-get install -y libsqlite3-dev\n            - run: cp .env.testing .env\n            - run: composer install -n --ignore-platform-reqs\n            - run: php artisan key:generate\n            - run: php artisan dusk:chrome-driver\n            - run: npm install\n            - run: npm run production\n            - run: vendor/bin/phpunit\n\n            - run:\n                name: Start Chrome Driver\n                command: ./vendor/laravel/dusk/bin/chromedriver-linux\n                background: true\n\n            - run:\n                name: Run Laravel Server\n                command: php artisan serve\n                background: true\n\n            - run:\n                name: Run Laravel Dusk Tests\n                command: php artisan dusk\n\n            - store_artifacts:\n                path: tests/Browser/screenshots\n\n            - store_artifacts:\n                path: tests/Browser/console\n\n            - store_artifacts:\n                path: storage/logs</code></pre>\n  <p></p>\n  <h3>Codificación</h3>\n  <p>Para ejecutar pruebas de Dusk en Codeship , agregue los siguientes comandos a su proyecto de Codeship. Estos comandos son solo un punto de partida y puede agregar comandos adicionales según sea necesario:</p>\n  <pre><code>phpenv local 7.2\ncp .env.testing .env\nmkdir -p ./bootstrap/cache\ncomposer install --no-interaction --prefer-dist\nphp artisan key:generate\nphp artisan dusk:chrome-driver\nnohup bash -c \"php artisan serve 2&gt;&amp;1 &amp;\" &amp;&amp; sleep 5\nphp artisan dusk</code></pre>\n  <p></p>\n  <h3>Heroku CI</h3>\n  <p>Para ejecutar pruebas de Dusk en Heroku CI , agregue el siguiente paquete de compilación y scripts de Google Chrome a su archivo Heroku :<code>app.json</code></p>\n  <pre><code>{\n  \"environments\": {\n    \"test\": {\n      \"buildpacks\": [\n        { \"url\": \"heroku/php\" },\n        { \"url\": \"https://github.com/heroku/heroku-buildpack-google-chrome\" }\n      ],\n      \"scripts\": {\n        \"test-setup\": \"cp .env.testing .env\",\n        \"test\": \"nohup bash -c './vendor/laravel/dusk/bin/chromedriver-linux &gt; /dev/null 2&gt;&amp;1 &amp;' &amp;&amp; nohup bash -c 'php artisan serve &gt; /dev/null 2&gt;&amp;1 &amp;' &amp;&amp; php artisan dusk\"\n      }\n    }\n  }\n}</code></pre>\n  <p></p>\n  <h3>Travis CI</h3>\n  <p>Para ejecutar sus pruebas Dusk en Travis CI , use la siguiente configuración. Dado que Travis CI no es un entorno gráfico, tendremos que realizar algunos pasos adicionales para iniciar un navegador Chrome. Además, usaremos para iniciar el servidor web integrado de PHP:<code>.travis.yml</code><code>php artisan serve</code></p>\n  <pre><code>language: php\n\nphp:\n  - 7.3\n\naddons:\n  chrome: stable\n\ninstall:\n  - cp .env.testing .env\n  - travis_retry composer install --no-interaction --prefer-dist --no-suggest\n  - php artisan key:generate\n  - php artisan dusk:chrome-driver\n\nbefore_script:\n  - google-chrome-stable --headless --disable-gpu --remote-debugging-port=9222 http://localhost &amp;\n  - php artisan serve &amp;\n\nscript:\n  - php artisan dusk</code></pre>\n  <p></p>\n  <h3>Acciones de GitHub</h3>\n  <p>Si está utilizando acciones de Github para ejecutar sus pruebas de Dusk, puede utilizar este archivo de configuración como punto de partida. Al igual que TravisCI, usaremos el <code>php artisan serve</code>comando para iniciar el servidor web integrado de PHP:</p>\n  <pre><code>name: CI\non: [push]\njobs:\n\n  dusk-php:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Prepare The Environment\n        run: cp .env.example .env\n      - name: Create Database\n        run: |\n          sudo systemctl start mysql\n          mysql --user=\"root\" --password=\"root\" -e \"CREATE DATABASE 'my-database' character set UTF8mb4 collate utf8mb4_bin;\"\n      - name: Install Composer Dependencies\n        run: composer install --no-progress --no-suggest --prefer-dist --optimize-autoloader\n      - name: Generate Application Key\n        run: php artisan key:generate\n      - name: Upgrade Chrome Driver\n        run: php artisan dusk:chrome-driver `/opt/google/chrome/chrome --version | cut -d \" \" -f3 | cut -d \".\" -f1`\n      - name: Start Chrome Driver\n        run: ./vendor/laravel/dusk/bin/chromedriver-linux &amp;\n      - name: Run Laravel Server\n        run: php artisan serve &amp;\n      - name: Run Dusk Tests\n        env:\n          APP_URL: \"http://127.0.0.1:8000\"\n        run: php artisan dusk</code></pre>\n</section>"
      },
      {
        "titulo": "9.5 Base de datos",
        "contenido": "<section>\n  <h1>Prueba de base de datos</h1>\n  <ul>\n    <li>Introducción</li>\n    <li>Restablecimiento de la base de datos después de cada prueba</li>\n    <li>Creación de fábricas</li>\n    <li>Escritura Factories\n      <ul>\n        <li>Estados de fábrica</li>\n        <li>Devoluciones de llamada de fábrica</li>\n      </ul></li>\n    <li>Usando Factories\n      <ul>\n        <li>Creando modelos</li>\n        <li>Modelos persistentes</li>\n        <li>Secuencias</li>\n      </ul></li>\n    <li>Relaciones de fábrica\n      <ul>\n        <li>Relaciones dentro de definiciones</li>\n        <li>Tiene muchas relaciones</li>\n        <li>Pertenece a las relaciones</li>\n        <li>Muchas a muchas relaciones</li>\n        <li>Relaciones polimórficas</li>\n      </ul></li>\n    <li>Usando semillas</li>\n    <li>Afirmaciones disponibles</li>\n  </ul>\n  <p></p>\n  <h2>Introducción</h2>\n  <p>Laravel proporciona una variedad de herramientas útiles para facilitar la prueba de sus aplicaciones basadas en bases de datos. Primero, puede usar el <code>assertDatabaseHas</code>ayudante para afirmar que existen datos en la base de datos que coinciden con un conjunto de criterios dado. Por ejemplo, si desea verificar que hay un registro en la <code>users</code>tabla con el <code>email</code>valor de , puede hacer lo siguiente:<code>sally@example.com</code></p>\n  <pre><code>public function testDatabase()\n{\n    // Make call to application...\n\n    $this-&gt;assertDatabaseHas('users', [\n        'email' =&gt; 'sally@example.com',\n    ]);\n}</code></pre>\n  <p>También puede utilizar el <code>assertDatabaseMissing</code>asistente para afirmar que los datos no existen en la base de datos.</p>\n  <p>El <code>assertDatabaseHas</code>método y otros ayudantes similares son por conveniencia. Puede utilizar cualquiera de los métodos de afirmación integrados de PHPUnit para complementar sus pruebas de funciones.</p>\n  <p></p>\n  <h2>Restablecimiento de la base de datos después de cada prueba</h2>\n  <p>A menudo, es útil restablecer su base de datos después de cada prueba para que los datos de una prueba anterior no interfieran con las pruebas posteriores. El <code>RefreshDatabase</code>rasgo adopta el enfoque más óptimo para migrar su base de datos de prueba dependiendo de si está utilizando una base de datos en memoria o una base de datos tradicional. Use el rasgo en su clase de prueba y todo se manejará por usted:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Feature;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse Illuminate\\Foundation\\Testing\\WithoutMiddleware;\nuse Tests\\TestCase;\n\nclass ExampleTest extends TestCase\n{\n    use RefreshDatabase;\n\n    /**\n     * A basic functional test example.\n     *\n     * @return void\n     */\n    public function testBasicExample()\n    {\n        $response = $this-&gt;get('/');\n\n        // ...\n    }\n}</code></pre>\n  <p></p>\n  <h2>Creación de fábricas</h2>\n  <p>Al realizar la prueba, es posible que deba insertar algunos registros en su base de datos antes de ejecutar su prueba. En lugar de especificar manualmente el valor de cada columna cuando crea estos datos de prueba, Laravel le permite definir un conjunto predeterminado de atributos para cada uno de sus modelos Eloquent usando fábricas de modelos.</p>\n  <p>Para crear una fábrica, use el comando Artisan :<code>make:factory</code> </p>\n  <pre><code>php artisan make:factory PostFactory</code></pre>\n  <p>La nueva fábrica se colocará en su directorio.<code>database/factories</code></p>\n  <p>La <code>--model</code>opción se puede utilizar para indicar el nombre del modelo creado por la fábrica. Esta opción rellenará previamente el archivo de fábrica generado con el modelo dado:</p>\n  <pre><code>php artisan make:factory PostFactory --model=Post</code></pre>\n  <p></p>\n  <h2>Escritura Factories</h2>\n  <p>Para comenzar, eche un vistazo al archivo en su aplicación. De fábrica, este archivo contiene la siguiente definición de fábrica:<code>database/factories/UserFactory.php</code></p>\n  <pre><code>namespace Database\\Factories;\n\nuse App\\Models\\User;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\nuse Illuminate\\Support\\Str;\n\nclass UserFactory extends Factory\n{\n    /**\n     * The name of the factory's corresponding model.\n     *\n     * @var string\n     */\n    protected $model = User::class;\n\n    /**\n     * Define the model's default state.\n     *\n     * @return array\n     */\n    public function definition()\n    {\n        return [\n            'name' =&gt; $this-&gt;faker-&gt;name,\n            'email' =&gt; $this-&gt;faker-&gt;unique()-&gt;safeEmail,\n            'email_verified_at' =&gt; now(),\n            'password' =&gt; '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password\n            'remember_token' =&gt; Str::random(10),\n        ];\n    }\n}</code></pre>\n  <p>Como puede ver, en su forma más básica, las fábricas son clases que extienden la clase de fábrica base de Laravel y definen una <code>model</code>propiedad y un <code>definition</code>método. El <code>definition</code>método devuelve el conjunto predeterminado de valores de atributos que deben aplicarse al crear un modelo utilizando la fábrica.</p>\n  <p>A través de la <code>faker</code>propiedad, las fábricas tienen acceso a la biblioteca PHP de Faker , que le permite generar convenientemente varios tipos de datos aleatorios para realizar pruebas.</p>\n  <blockquote>\n    <div><div></div><p>Puede establecer la configuración regional de Faker agregando una <code>faker_locale</code>opción a su archivo de configuración.<code>config/app.php</code></p></div>\n  </blockquote>\n  <p></p>\n  <h3>Estados de fábrica</h3>\n  <p>Los métodos de manipulación de estados le permiten definir modificaciones discretas que se pueden aplicar a sus fábricas de modelos en cualquier combinación. Por ejemplo, su <code>User</code>modelo puede tener un <code>suspended</code>estado que modifique uno de sus valores de atributo predeterminados. Puede definir sus transformaciones de estado utilizando el <code>state</code>método de la fábrica base . Puede nombrar su método estatal como desee. Después de todo, es solo un método PHP típico:</p>\n  <pre><code>/**\n * Indicate that the user is suspended.\n *\n * @return \\Illuminate\\Database\\Eloquent\\Factories\\Factory\n */\npublic function suspended()\n{\n    return $this-&gt;state([\n        'account_status' =&gt; 'suspended',\n    ]);\n}</code></pre>\n  <p>Si su transformación de estado requiere acceso a los otros atributos definidos por la fábrica, puede pasar una devolución de llamada al <code>state</code>método. La devolución de llamada recibirá la matriz de atributos en bruto definidos para la fábrica:</p>\n  <pre><code>/**\n * Indicate that the user is suspended.\n *\n * @return \\Illuminate\\Database\\Eloquent\\Factories\\Factory\n */\npublic function suspended()\n{\n    return $this-&gt;state(function (array $attributes) {\n        return [\n            'account_status' =&gt; 'suspended',\n        ];\n    });\n}</code></pre>\n  <p></p>\n  <h3>Devoluciones de llamada de fábrica</h3>\n  <p>Devoluciones de llamada de fábrica se registran utilizando el <code>afterMaking</code>y <code>afterCreating</code>métodos y le permiten realizar tareas adicionales después de hacer o crear un modelo. Debe registrar estas devoluciones de llamada definiendo un <code>configure</code>método en la clase de fábrica. Laravel llamará automáticamente a este método cuando se cree una instancia de la fábrica:</p>\n  <pre><code>namespace Database\\Factories;\n\nuse App\\Models\\User;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\nuse Illuminate\\Support\\Str;\n\nclass UserFactory extends Factory\n{\n    /**\n     * The name of the factory's corresponding model.\n     *\n     * @var string\n     */\n    protected $model = User::class;\n\n    /**\n     * Configure the model factory.\n     *\n     * @return $this\n     */\n    public function configure()\n    {\n        return $this-&gt;afterMaking(function (User $user) {\n            //\n        })-&gt;afterCreating(function (User $user) {\n            //\n        });\n    }\n\n    // ...\n}</code></pre>\n  <p></p>\n  <h2>Usando Factories</h2>\n  <p></p>\n  <h3>Creando modelos</h3>\n  <p>Una vez que haya definido sus fábricas, puede utilizar el <code>factory</code>método estático proporcionado por el rasgo en sus modelos Eloquent para crear una instancia de fábrica para ese modelo:<code>Illuminate\\Database\\Eloquent\\Factories\\HasFactory</code></p>\n  <pre><code>namespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    use HasFactory;\n}</code></pre>\n  <p>Echemos un vistazo a algunos ejemplos de creación de modelos. Primero, usaremos el <code>make</code>método para crear modelos sin persistirlos en la base de datos:</p>\n  <pre><code>use App\\Models\\User;\n\npublic function testDatabase()\n{\n    $user = User::factory()-&gt;make();\n\n    // Use model in tests...\n}</code></pre>\n  <p>Puede crear una colección de muchos modelos usando el <code>count</code>método:</p>\n  <pre><code>// Create three App\\Models\\User instances...\n$users = User::factory()-&gt;count(3)-&gt;make();</code></pre>\n  <p>El método <code>HasFactory</code>del rasgo <code>factory</code>utilizará convenciones para determinar la fábrica adecuada para el modelo. Específicamente, el método buscará una fábrica en el espacio de nombres que tenga un nombre de clase que coincida con el nombre del modelo y tenga el sufijo . Si estas convenciones no se aplican a su aplicación o fábrica en particular, puede sobrescribir el método en su modelo para devolver una instancia de la fábrica correspondiente del modelo directamente:<code>Database\\Factories</code><code>Factory</code><code>newFactory</code></p>\n  <pre><code>/**\n * Create a new factory instance for the model.\n *\n * @return \\Illuminate\\Database\\Eloquent\\Factories\\Factory\n */\nprotected static function newFactory()\n{\n    return \\Database\\Factories\\Administration\\FlightFactory::new();\n}</code></pre>\n  <h4>Estados solicitantes</h4>\n  <p>You may also apply any of your states to the models. If you would like to apply multiple state transformations to the models, you may simply call state methods directly:</p>\n  <pre><code>$users = User::factory()-&gt;count(5)-&gt;suspended()-&gt;make();</code></pre>\n  <h4>Overriding Attributes</h4>\n  <p>If you would like to override some of the default values of your models, you may pass an array of values to the <code>make</code> method. Only the specified values will be replaced while the rest of the values remain set to their default values as specified by the factory:</p>\n  <pre><code>$user = User::factory()-&gt;make([\n    'name' =&gt; 'Abigail Otwell',\n]);</code></pre>\n  <p>Alternatively, the <code>state</code> method may be called directly on the factory instance to perform an inline state transformation:</p>\n  <pre><code>$user = User::factory()-&gt;state([\n    'name' =&gt; 'Abigail Otwell',\n])-&gt;make();</code></pre>\n  <blockquote>\n    <div><div></div><p> Mass assignment protection is automatically disabled when creating models using factories.</p></div>\n  </blockquote>\n  <p></p>\n  <h3>Persisting Models</h3>\n  <p>El <code>create</code>método crea instancias de modelo y las persiste en la base de datos utilizando el <code>save</code>método de Eloquent :</p>\n  <pre><code>use App\\Models\\User;\n\npublic function testDatabase()\n{\n    // Create a single App\\Models\\User instance...\n    $user = User::factory()-&gt;create();\n\n    // Create three App\\Models\\User instances...\n    $users = User::factory()-&gt;count(3)-&gt;create();\n\n    // Use model in tests...\n}</code></pre>\n  <p>Puede anular atributos en el modelo pasando una matriz de atributos al <code>create</code>método:</p>\n  <pre><code>$user = User::factory()-&gt;create([\n    'name' =&gt; 'Abigail',\n]);</code></pre>\n  <p></p>\n  <h3>Secuencias</h3>\n  <p>A veces, es posible que desee alternar el valor de un atributo de modelo dado para cada modelo creado. Puede lograr esto definiendo una transformación de estado como una <code>Sequence</code>instancia. Por ejemplo, es posible que deseemos alternar el valor de una <code>admin</code>columna en un <code>User</code>modelo entre <code>Y</code>y <code>N</code>para cada usuario creado:</p>\n  <pre><code>use App\\Models\\User;\nuse Illuminate\\Database\\Eloquent\\Factories\\Sequence;\n\n$users = User::factory()\n                -&gt;count(10)\n                -&gt;state(new Sequence(\n                    ['admin' =&gt; 'Y'],\n                    ['admin' =&gt; 'N'],\n                ))\n                -&gt;create();</code></pre>\n  <p>En este ejemplo, se crearán cinco usuarios con un <code>admin</code>valor de <code>Y</code>y se crearán cinco usuarios con un <code>admin</code>valor de <code>N</code>.</p>\n  <p></p>\n  <h2>Relaciones de fábrica</h2>\n  <p></p>\n  <h3>Relaciones dentro de definiciones</h3>\n  <p>Puede adjuntar relaciones a modelos en sus definiciones de fábrica. Por ejemplo, si desea crear una nueva <code>User</code>instancia al crear una <code>Post</code>, puede hacer lo siguiente:</p>\n  <pre><code>use App\\Models\\User;\n\n/**\n * Define the model's default state.\n *\n * @return array\n */\npublic function definition()\n{\n    return [\n        'user_id' =&gt; User::factory(),\n        'title' =&gt; $this-&gt;faker-&gt;title,\n        'content' =&gt; $this-&gt;faker-&gt;paragraph,\n    ];\n}</code></pre>\n  <p>Si las columnas de la relación dependen de la fábrica que la define, puede proporcionar una devolución de llamada que acepte la matriz de atributos evaluados:</p>\n  <pre><code>/**\n * Define the model's default state.\n *\n * @return array\n */\npublic function definition()\n{\n    return [\n        'user_id' =&gt; User::factory(),\n        'user_type' =&gt; function (array $attributes) {\n            return User::find($attributes['user_id'])-&gt;type;\n        },\n        'title' =&gt; $this-&gt;faker-&gt;title,\n        'content' =&gt; $this-&gt;faker-&gt;paragraph,\n    ];\n}</code></pre>\n  <p></p>\n  <h3>Tiene muchas relaciones</h3>\n  <p>A continuación, exploremos la construcción de relaciones de modelo Eloquent utilizando los fluidos métodos de fábrica de Laravel. Primero, supongamos que nuestra aplicación tiene un <code>User</code>modelo y un <code>Post</code>modelo. Además, supongamos que el <code>User</code>modelo define una <code>hasMany</code>relación con <code>Post</code>. Podemos crear un usuario que tenga tres publicaciones utilizando el <code>has</code>método proporcionado por la fábrica. El <code>has</code>método acepta una instancia de fábrica:</p>\n  <pre><code>use App\\Models\\Post;\nuse App\\Models\\User;\n\n$users = User::factory()\n            -&gt;has(Post::factory()-&gt;count(3))\n            -&gt;create();</code></pre>\n  <p>Por convención, al pasar un <code>Post</code>modelo al <code>has</code>método, Laravel asumirá que el <code>User</code>modelo debe tener un <code>posts</code>método que defina la relación. Si es necesario, puede especificar explícitamente el nombre de la relación que le gustaría manipular:</p>\n  <pre><code>$users = User::factory()\n            -&gt;has(Post::factory()-&gt;count(3), 'posts')\n            -&gt;create();</code></pre>\n  <p>Por supuesto, puede realizar manipulaciones de estado en los modelos relacionados. Además, puede aprobar una transformación de estado basada en el cierre si su cambio de estado requiere acceso al modelo principal:</p>\n  <pre><code>$users = User::factory()\n            -&gt;has(\n                Post::factory()\n                        -&gt;count(3)\n                        -&gt;state(function (array $attributes, User $user) {\n                            return ['user_type' =&gt; $user-&gt;type];\n                        })\n            )\n            -&gt;create();</code></pre>\n  <h4>Usando métodos mágicos</h4>\n  <p>Por conveniencia, puede utilizar los métodos mágicos de relación de la fábrica para definir relaciones. Por ejemplo, el siguiente ejemplo utilizará la convención para determinar que los modelos relacionados deben crearse mediante un <code>posts</code>método de relación en el <code>User</code>modelo:</p>\n  <pre><code>$users = User::factory()\n            -&gt;hasPosts(3)\n            -&gt;create();</code></pre>\n  <p>Cuando utilice métodos mágicos para crear relaciones de fábrica, puede pasar una serie de atributos para anular en los modelos relacionados:</p>\n  <pre><code>$users = User::factory()\n            -&gt;hasPosts(3, [\n                'published' =&gt; false,\n            ])\n            -&gt;create();</code></pre>\n  <p>Puede proporcionar una transformación de estado basada en el cierre si su cambio de estado requiere acceso al modelo principal:</p>\n  <pre><code>$users = User::factory()\n            -&gt;hasPosts(3, function (array $attributes, User $user) {\n                return ['user_type' =&gt; $user-&gt;type];\n            })\n            -&gt;create();</code></pre>\n  <p></p>\n  <h3>Pertenece a las relaciones</h3>\n  <p>Ahora que hemos explorado cómo construir \"tiene muchas\" relaciones utilizando fábricas, exploremos la relación inversa. El <code>for</code>método se puede utilizar para definir el modelo al que pertenecen los modelos creados en fábrica. Por ejemplo, podemos crear tres <code>Post</code>instancias de modelo que pertenezcan a un solo usuario:</p>\n  <pre><code>use App\\Models\\Post;\nuse App\\Models\\User;\n\n$posts = Post::factory()\n            -&gt;count(3)\n            -&gt;for(User::factory()-&gt;state([\n                'name' =&gt; 'Jessica Archer',\n            ]))\n            -&gt;create();</code></pre>\n  <h4>Usando métodos mágicos</h4>\n  <p>Por conveniencia, puede utilizar los métodos mágicos de relación de la fábrica para definir las relaciones \"pertenece a\". Por ejemplo, el siguiente ejemplo usará la convención para determinar que las tres publicaciones deben pertenecer a la <code>user</code>relación en el <code>Post</code>modelo:</p>\n  <pre><code>$posts = Post::factory()\n            -&gt;count(3)\n            -&gt;forUser([\n                'name' =&gt; 'Jessica Archer',\n            ])\n            -&gt;create();</code></pre>\n  <p></p>\n  <h3>Muchas a muchas relaciones</h3>\n  <p>Como ocurre con muchas relaciones , las relaciones \"de muchos a muchos\" se pueden crear utilizando el <code>has</code>método:</p>\n  <pre><code>use App\\Models\\Role;\nuse App\\Models\\User;\n\n$users = User::factory()\n            -&gt;has(Role::factory()-&gt;count(3))\n            -&gt;create();</code></pre>\n  <h4>Atributos de la tabla dinámica</h4>\n  <p>Si necesita definir atributos que deben establecerse en la tabla dinámica / intermedia que vincula los modelos, puede usar el <code>hasAttached</code>método. Este método acepta una matriz de valores y nombres de atributos de tabla dinámica como segundo argumento:</p>\n  <pre><code>use App\\Models\\Role;\nuse App\\Models\\User;\n\n$users = User::factory()\n            -&gt;hasAttached(\n                Role::factory()-&gt;count(3),\n                ['active' =&gt; true]\n            )\n            -&gt;create();</code></pre>\n  <p>Puede proporcionar una transformación de estado basada en el cierre si su cambio de estado requiere acceso al modelo relacionado:</p>\n  <pre><code>$users = User::factory()\n            -&gt;hasAttached(\n                Role::factory()\n                    -&gt;count(3)\n                    -&gt;state(function (array $attributes, User $user) {\n                        return ['name' =&gt; $user-&gt;name.' Role'];\n                    }),\n                ['active' =&gt; true]\n            )\n            -&gt;create();</code></pre>\n  <h4>Usando métodos mágicos</h4>\n  <p>Por conveniencia, puede utilizar los métodos de relación mágica de la fábrica para definir relaciones de muchos a muchos. Por ejemplo, el siguiente ejemplo utilizará la convención para determinar que los modelos relacionados deben crearse mediante un <code>roles</code>método de relación en el <code>User</code>modelo:</p>\n  <pre><code>$users = User::factory()\n            -&gt;hasRoles(1, [\n                'name' =&gt; 'Editor'\n            ])\n            -&gt;create();</code></pre>\n  <p></p>\n  <h3>Relaciones polimórficas</h3>\n  <p>También se pueden crear relaciones polimórficas utilizando fábricas. Las relaciones polimórficas \"morph many\" se crean de la misma manera que las relaciones típicas \"has many\". Por ejemplo, si un <code>Post</code>modelo tiene una <code>morphMany</code>relación con un <code>Comment</code>modelo:</p>\n  <pre><code>use App\\Models\\Post;\n\n$post = Post::factory()-&gt;hasComments(3)-&gt;create();</code></pre>\n  <h4>Transformar a las relaciones</h4>\n  <p>Los métodos mágicos no pueden usarse para crear <code>morphTo</code>relaciones. En cambio, el <code>for</code>método debe usarse directamente y el nombre de la relación debe proporcionarse explícitamente. Por ejemplo, imagine que el <code>Comment</code>modelo tiene un <code>commentable</code>método que define una <code>morphTo</code>relación. En esta situación, podemos crear tres comentarios que pertenezcan a una sola publicación usando el <code>for</code>método directamente:</p>\n  <pre><code>$comments = Comment::factory()-&gt;count(3)-&gt;for(\n    Post::factory(), 'commentable'\n)-&gt;create();</code></pre>\n  <h4>Relaciones polimórficas de muchos a muchos</h4>\n  <p>Las relaciones polimórficas \"de muchos a muchos\" se pueden crear al igual que las relaciones no polimórficas de \"muchos a muchos\":</p>\n  <pre><code>use App\\Models\\Tag;\nuse App\\Models\\Video;\n\n$users = Video::factory()\n            -&gt;hasAttached(\n                Tag::factory()-&gt;count(3),\n                ['public' =&gt; true]\n            )\n            -&gt;create();</code></pre>\n  <p>Por supuesto, el <code>has</code>método mágico también se puede utilizar para crear relaciones polimórficas \"de muchos a muchos\":</p>\n  <pre><code>$users = Video::factory()\n            -&gt;hasTags(3, ['public' =&gt; true])\n            -&gt;create();</code></pre>\n  <p></p>\n  <h2>Usando semillas</h2>\n  <p>Si desea utilizar sembradoras de bases de datos para completar su base de datos durante una prueba de características, puede utilizar el <code>seed</code>método. De forma predeterminada, el <code>seed</code>método devolverá el <code>DatabaseSeeder</code>, que debería ejecutar todas sus otras sembradoras. Alternativamente, pasa un nombre de clase de sembrador específico al <code>seed</code>método:</p>\n  <pre><code>&lt;?php\n\nnamespace Tests\\Feature;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse Illuminate\\Foundation\\Testing\\WithoutMiddleware;\nuse OrderStatusSeeder;\nuse Tests\\TestCase;\n\nclass ExampleTest extends TestCase\n{\n    use RefreshDatabase;\n\n    /**\n     * Test creating a new order.\n     *\n     * @return void\n     */\n    public function testCreatingANewOrder()\n    {\n        // Run the DatabaseSeeder...\n        $this-&gt;seed();\n\n        // Run a single seeder...\n        $this-&gt;seed(OrderStatusSeeder::class);\n\n        // ...\n    }\n}</code></pre>\n  <p></p>\n  <h2>Afirmaciones disponibles</h2>\n  <p>Laravel proporciona varias afirmaciones de base de datos para sus pruebas de funciones PHPUnit :</p>\n  <table>\n    <thead>\n    <tr>\n      <th>Método</th>\n      <th>Descripción</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>$this-&gt;assertDatabaseCount($table, int $count);</code></td>\n      <td>Afirme que una tabla en la base de datos contiene la cantidad dada de entradas.</td>\n    </tr>\n    <tr>\n      <td><code>$this-&gt;assertDatabaseHas($table, array $data);</code></td>\n      <td>Afirme que una tabla de la base de datos contiene los datos proporcionados.</td>\n    </tr>\n    <tr>\n      <td><code>$this-&gt;assertDatabaseMissing($table, array $data);</code></td>\n      <td>Afirme que una tabla de la base de datos no contiene los datos proporcionados.</td>\n    </tr>\n    <tr>\n      <td><code>$this-&gt;assertDeleted($table, array $data);</code></td>\n      <td>Afirmar que el registro dado ha sido eliminado.</td>\n    </tr>\n    <tr>\n      <td><code>$this-&gt;assertSoftDeleted($table, array $data);</code></td>\n      <td>Afirmar que el registro dado se ha eliminado temporalmente.</td>\n    </tr>\n    </tbody>\n  </table>\n  <p>Por conveniencia, puede pasar un modelo a los ayudantes <code>assertDeleted</code>y <code>assertSoftDeleted</code>para afirmar que el registro fue eliminado o eliminado temporalmente, respectivamente, de la base de datos según la clave principal del modelo.</p>\n  <p>Por ejemplo, si está utilizando una fábrica de modelos en su prueba, puede pasar este modelo a uno de estos ayudantes para probar que su aplicación eliminó correctamente el registro de la base de datos:</p>\n  <pre><code>public function testDatabase()\n{\n    $user = User::factory()-&gt;create();\n\n    // Make call to application...\n\n    $this-&gt;assertDeleted($user);\n}</code></pre>\n</section>"
      }
    ]
  },
  {
    "titulo": "",
    "subtitulo": "",
    "items": [
      {
        "titulo": "",
        "contenido": ""
      }
    ]
  }
]